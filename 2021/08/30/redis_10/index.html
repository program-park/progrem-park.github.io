<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Redis 配置文件详解 | 程序园</title><meta name="keywords" content="Redis"><meta name="author" content="一位木带感情的码农"><meta name="copyright" content="一位木带感情的码农"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文是对 Redis 配置文件的详细解析。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 配置文件详解">
<meta property="og:url" content="https://program-park.github.io/2021/08/30/redis_10/index.html">
<meta property="og:site_name" content="程序园">
<meta property="og:description" content="本文是对 Redis 配置文件的详细解析。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://program-park.github.io/img/redis/1.png">
<meta property="article:published_time" content="2021-08-30T04:35:35.000Z">
<meta property="article:modified_time" content="2022-09-06T07:30:32.465Z">
<meta property="article:author" content="一位木带感情的码农">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://program-park.github.io/img/redis/1.png"><link rel="shortcut icon" href="/img/favicon_logo/favicon.png"><link rel="canonical" href="https://program-park.github.io/2021/08/30/redis_10/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: 一位木带感情的码农","link":"链接: ","source":"来源: 程序园","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 配置文件详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-06 15:30:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatat_img.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/redis/1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">程序园</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis 配置文件详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-30T04:35:35.000Z" title="发表于 2021-08-30 12:35:35">2021-08-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-06T07:30:32.465Z" title="更新于 2022-09-06 15:30:32">2022-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 配置文件详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li>单位：配置文件对<code>unit</code>单位大小写不敏感<br>
<img src="https://img-blog.csdnimg.cn/43d6fc9032d243b3b878460892528e7b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>可以包含多个配置文件<br>
<img src="https://img-blog.csdnimg.cn/dd15fd9bc267449f90cb3644b5c1b89b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h1 id="NETWORK（网络）">#### NETWORK（网络）####</h1>
<ul>
<li>
<p>绑定的IP，默认只接受本机的访问请求，生产环境要写应用服务器的地址<br>
<img src="https://img-blog.csdnimg.cn/e2656ba059fe4988b6df791b0e5ef083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li>
<p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应<br>
<img src="https://img-blog.csdnimg.cn/e4c561d709314eb582e56c87411fadd9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li>
<p>端口号默认6379<br>
<img src="https://img-blog.csdnimg.cn/46c7026667be4f4ab2314cca8069ced5.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>设置 tcp 的 backlog</p>
<ul>
<li>backlog 其实是一个连接队列，backlog<code>队列总和=未完成三次握手队列 + 已经完成三次握手队列</code></li>
<li>在高并发环境下需要一个高 backlog 值来避免慢客户端连接问题</li>
<li>注意 Linux 内核会将这个值减小到<code>/proc/sys/net/core/somaxconn的值（128）</code>，所以需要确认增大<code>/proc/sys/net/core/somaxconn</code>和<code>/proc/sys/net/ipv4/tcp_max_syn_backlog（128）</code>两个值来达到想要的效果</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f83982fefa7f490fa8f714ecde1d5547.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能，即永不关闭<br>
<img src="https://img-blog.csdnimg.cn/ac454671f546446ba1fbfa7baca7ab1a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li>
<p>对访问客户端的一种心跳检测，每隔 n 秒检测一次</p>
<ul>
<li>单位为秒，如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60</li>
<li>使用keepalive有两个好处：
<ul>
<li>检测挂掉的对端</li>
<li>降低中间设备出问题而导致网络看似连接却已经与对端端口的问题</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/b3ab2bc70ee04e48889b348c0c7a3ce7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="GENERAL（通用）">#### GENERAL（通用）####</h1>
<ul>
<li>
<p>以守护进程方式运行，默认是 no<br>
<img src="https://img-blog.csdnimg.cn/dfdee24af96d4d79bda181db6e1ef83e.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>存放pid文件的位置，每个实例会产生一个不同的pid文件<br>
<img src="https://img-blog.csdnimg.cn/c2415dd32af54068a9e0f61d99e3f4b8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li>
<p>指定日志记录级别，Redis总共支持四个级别：</p>
<ul>
<li><code>debug</code>（很多信息，方便开发、测试）、</li>
<li><code>verbose</code>（许多有用的信息，但是没有debug级别信息多）、</li>
<li><code>notice</code>（默认，适当的日志级别，适合生产环境）、</li>
<li><code>warning</code>（只有非常重要的信息）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f749df74f74a437193522617dca26a25.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备，后台运行的 redis 标准输出是<code>/dev/null</code><br>
<img src="https://img-blog.csdnimg.cn/e40c49c3eded4f98aacfde1fbbacad9f.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>Syslog 相关配置<br>
<img src="https://img-blog.csdnimg.cn/7a8bf395a8a040798abc8067f7545031.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>设定库的数量默认 16，默认数据库为 0，可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库 id<br>
<img src="https://img-blog.csdnimg.cn/41cbcf55f1664c75b6fbe2f70bc538fa.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="SNAPSHOTTING（快照）">#### SNAPSHOTTING（快照）####</h1>
<ul>
<li>
<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb.aof</p>
<ul>
<li>redis是内存数据库，没有持久化，那么断电后数据就会丢失</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/559b916cba5e4b468621f0b689298c12.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li>
<p>当<code>RDB</code>持久化出现错误后，是否依然进行继续进行工作</p>
<ul>
<li>可以通过 info 中的<code>rdb_last_bgsave_status</code>了解<code>RDB</code>持久化是否有错误</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/12af0c428a674ebf86e0a713e1a1529a.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>使用压缩<code>RDB</code>文件，<code>RDB</code>文件压缩使用 LZF 压缩算法<br>
<img src="https://img-blog.csdnimg.cn/12d65d8f1568440ba360881ac5c21d61.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>保存<code>RDB</code>文件时，进行错误的检查校验</p>
<ul>
<li>从 rdb 格式的第五个版本开始，在 rdb 文件的末尾会带上<code>CRC64</code>的校验和。这跟有利于文件的容错性，但是在保存 rdb 文件的时候，会有大概 10% 的性能损耗，所以如果追求高性能，可以关闭该配置</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/4ff5a087978e41c9912b242bcf2b70ea.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p><code>RDB</code>文件的名称<br>
<img src="https://img-blog.csdnimg.cn/fd2092314c874f028a60741da80a1860.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>数据目录，数据库的写入会在这个目录</p>
<ul>
<li>rdb、aof文件也会写在这个目录</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f23fabed8ccb49089376fa1517992f20.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="REPLICATION（主从复制）">#### REPLICATION（主从复制）####</h1>
<ul>
<li>
<p>复制选项，slave复制对应的master<br>
<img src="https://img-blog.csdnimg.cn/c7000199e1604f31a2cc260ee7b29698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li>
<p>如果 master 设置了 requirepass ，那么 slave 要连上 master ，需要有 master 的密码</p>
<ul>
<li>masterauth 就是用来配置master的密码，这样可以在连上 master 后进行认证</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/48c21ad36f654b2ca6b8d80a21387d3c.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：</p>
<ul>
<li>如果<code>replica-serve-stale-data</code>设置为<code>yes</code>(默认设置)，从库会继续响应客户端的请求</li>
<li>如果<code>replica-serve-stale-data</code>设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误<code>SYNC with master in progress</code><br>
<img src="https://img-blog.csdnimg.cn/010958124b824b29a1362c5ba18ad308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>
<p>作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）<img src="https://img-blog.csdnimg.cn/c478f1abe4ea4bc99325d47db4b6fddc.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>是否使用 socket 方式复制数据</p>
<ul>
<li>目前 redis 复制提供两种方式，disk 和 socket</li>
<li>如果新的 slave 连上来或者重连的 slave 无法部分同步，就会执行全量同步，master 会生成 rdb 文件</li>
<li>disk 方式是 master 创建一个新的进程把 rdb 文件保存到磁盘，再把磁盘上的 rdb 文件传递给 slave</li>
<li>socket 是 master 创建一个新的进程，直接把 rdb 文件以 socket 的方式发给 slave</li>
<li>disk 方式的时候，当一个 rdb 保存的过程中，多个 slave 都能共享这个 rdb 文件</li>
<li>socket 的方式就的一个个 slave 顺序复制。在磁盘速度缓慢，网速快的情况下推荐用 socket 方式</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/d35a3a3345034810b38a39ac3a3980a5.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>diskless复制的延迟时间，防止设置为0</p>
<ul>
<li>一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输</li>
<li>所以最好等待一段时间，等更多的slave连上来</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/3e4ef4a9fc924c79bbcdad4a54f4b8df.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>slave根据指定的时间间隔向服务器发送ping请求</p>
<ul>
<li>时间间隔可以通过<code>repl_ping_slave_period</code>来设置，默认 10 秒</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/fcf717e6a9764f459491f84cfcf905dd.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>复制连接超时时间</p>
<ul>
<li>master 和 slave 都有超时时间的设置。master 检测到 slave 上次发送的时间超过<code>repl-timeout</code>，即认为 slave 离线，清除该 slave 信息。</li>
<li>slave 检测到上次和 master 交互的时间超过<code>repl-timeout</code>，则认为 master 离线。</li>
<li>需要注意的是<code>repl-timeout</code>需要设置一个比<code>repl-ping-slave-period</code>更大的值，不然会经常检测到超时。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c87978b01e6447fe86a34791362b547b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>是否禁止复制tcp链接的tcp</p>
<ul>
<li>nodelay 参数，可传递 yes 或者 no（默认是no，即使用tcp nodelay）</li>
<li>如果 master 设置了 yes 来禁止<code>tcp nodelay</code>设置，在把数据复制给 slave 的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。</li>
<li>默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择 yes</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/6b542adaac324b5eb3eab8710a51b850.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>复制缓冲区大小</p>
<ul>
<li>这是一个环形复制缓冲区，用来保存最新复制的命令</li>
<li>这样在 slave 离线的时候，不需要完全复制 master 的数据</li>
<li>如果可以执行部分同步，只需要把缓冲区的部分数据复制给 slave，就能恢复正常复制状态</li>
<li>缓冲区的大小越大，slave 离线的时间可以更长，复制缓冲区只有在有 slave 连接的时候才分配内存</li>
<li>没有 slave 的一段时间，内存会被释放出来，默认 1m</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/e30795f5ecfd4406b5b305578650ae63.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>master 没有 slave 一段时间会释放复制缓冲区的内存</p>
<ul>
<li><code>repl-backlog-ttl</code>用来设置该时间长度，单位为秒</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/a796eccfb9d1405189fbf37ffac05c0a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>当master不可用，Sentinel会根据slave的优先级选举一个master</p>
<ul>
<li>最低的优先级的slave，当选master。而配置成0，永远不会被选举</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/da03b6d4eb4c4bc5ad68faaacbaa51fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>redis 提供了可以让 master 停止写入的方式</p>
<ul>
<li>如果配置了<code>min-slaves-to-write</code>，健康的 slave 的个数小于 N，mater 就禁止写入</li>
<li>master 最少得有多少个健康的 slave 存活才能执行写命令</li>
<li>这个配置虽然不能保证 N 个 slave 都一定能接收到 master 的写操作，但是能避免没有足够健康的 slave 的时候，master 不能写入来避免数据丢失</li>
<li>设置为 0 是关闭该功能</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/bc92c34a7dd64c13accf80283e34bdfc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>延迟小于<code>min-slaves-max-lag</code>秒的 slave 才认为是健康的 slave<br>
<img src="https://img-blog.csdnimg.cn/03526168fc4a4d10b932db3d74fbcd7d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>设置1或另一个设置为0禁用这个特性<br>
<img src="https://img-blog.csdnimg.cn/91207b6d7a1e47bc9d5f8024bed61485.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="SECURITY（安全）">#### SECURITY（安全）####</h1>
<ul>
<li>
<p><code>requirepass</code>配置可以让用户使用 AUTH 命令来认证密码，才能使用其他命令</p>
<ul>
<li>这让 redis 可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证</li>
<li>使用<code>requirepass</code>的时候需要注意，因为 redis 太快了，每秒可以认证 15w 次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码</li>
<li>注意只有密码没有用户名</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/82ed1cb37007432d841d764e317f9714.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>把危险的命令给修改成其他名称</p>
<ul>
<li>比如<code>CONFIG</code>命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/5b4d31a319874fe4b40220104d5a4dd5.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>设置成一个空的值，可以禁止一个命令<br>
<img src="https://img-blog.csdnimg.cn/22ff50f560314e26a7b1193db1856b75.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="CLIENTS（进程限制相关）">#### CLIENTS（进程限制相关）####</h1>
<ul>
<li>
<p>设置能连上redis的最大客户端连接数量。默认是10000个客户端连接</p>
<ul>
<li>由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32</li>
<li>如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f247b272da7f42768612f7e560bfde24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>redis 配置的最大内存容量。当内存满了，需要配合<code>maxmemory-policy</code>策略进行处理</p>
<ul>
<li>注意 slave 的输出缓冲区是不计算在<code>maxmemory</code>内的</li>
<li>所以为了防止主机内存使用完，建议设置的<code>maxmemory</code>需要更小一些</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/66edcb20db19415e8032938a9a54ad31.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>内存容量超过<code>maxmemory</code>后的处理策略</p>
<ul>
<li>volatile-lru：利用 LRU 算法移除设置过过期时间的 key</li>
<li>volatile-random：随机移除设置过过期时间的 key</li>
<li>volatile-ttl：移除即将过期的 key，根据最近过期时间来删除（辅以 TTL ）</li>
<li>allkeys-lru：利用LRU算法移除任何 key</li>
<li>allkeys-random：随机移除任何 key</li>
<li>noeviction：不移除任何 key，只是返回一个写错误</li>
<li>上面的这些驱逐策略，如果 redis 没有合适的 key 驱逐，对于写命令，还是会返回错误</li>
<li>redis 将不再接收写请求，只接收 get 请求</li>
<li>写命令包括：<code>set</code> <code>setnx</code> <code>setex</code> <code>append</code> <code>incr</code> <code>decr</code> <code>rpush</code> <code>lpush</code> <code>rpushx</code> <code>lpushx</code> <code>linsert</code> <code>lset</code> <code>rpoplpush</code> <code>sadd</code> <code>sinter</code> <code>sinterstore</code> <code>sunion</code> <code>sunionstore</code> <code>sdiff</code> <code>sdiffstore</code> <code>zadd</code> <code>zincrby</code> <code>zunionstore</code> <code>zinterstore</code> <code>hset</code> <code>hsetnx</code> <code>hmset</code> <code>hincrby</code> <code>incrby</code> <code>decrby</code> <code>getset</code> <code>mset</code> <code>msetnx</code> <code>exec</code> <code>sort</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c4f7018b96994c648297ad47b15ca6a7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>lru 检测的样本数</p>
<ul>
<li>使用 lru 或者 ttl 淘汰算法，从需要淘汰的列表中随机选择 sample 个 key，选出闲置时间最长的 key 移除</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/a292051cbe6241718dd8140b166e6f30.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="APPEND-ONLY-MODE（持久化方式）">#### APPEND ONLY MODE（持久化方式）####</h1>
<ul>
<li>
<p>默认 redis 使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了</p>
<ul>
<li>但是 redis 如果中途宕机，会导致可能有几分钟的数据丢失，根据 save 来策略进行持久化，<code>Append Only File</code>是另一种持久化方式，可以提供更好的持久化特性</li>
<li>Redis 会把每次写入的数据在接收后都写入 <code>appendonly.aof </code>文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略<code>RDB</code>文件</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/48d5154ab1434edbbdd3751ef56813eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>aof 文件名<br>
<img src="https://img-blog.csdnimg.cn/3ef5525d3421466b9e3811382680fcbd.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>aof 持久化策略的配置</p>
<ul>
<li>no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快</li>
<li>always 表示每次写入都执行 fsync，以保证数据同步到磁盘</li>
<li>everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/fd9f60ded03243a38c2409045bd3e5c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>在 aof 重写或者写入 rdb 文件的时候，会执行大量 IO</p>
<ul>
<li>此时对于 everysec 和 always 的 aof 模式来说，执行 fsync 会造成阻塞过长时间，<code>no-appendfsync-on-rewrite</code>字段设置为默认设置为 no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题</li>
<li>如果对延迟要求很高的应用，这个字段可以设置为 yes，，设置为 ye s表示 rewrite 期间对新写操作不 fsync，暂时存在内存中,不会造成阻塞的问题（因为没有磁盘竞争），等 rewrite 完成后再写入，这个时候 redis 会丢失数据</li>
<li>Linux 的默认 fsync 策略是 30 秒。可能丢失 30 秒数据</li>
<li>因此，如果应用系统无法忍受延迟，而可以容忍少量的数据丢失，则设置为 yes</li>
<li>如果应用系统无法忍受数据丢失，则设置为 no</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/94af5050d4b14ec88b7c5b5d297d9420.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>aof 自动重写配置</p>
<ul>
<li>当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写</li>
<li>即当 aof 文件增长到一定大小的时候Redis能够调用 bgrewriteaof 对日志文件进行重写</li>
<li>当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍（设置为 100 ）时，自动启动新的日志重写过程</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/478bfeb443fb4b21bd2f62538af771ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写<br>
<img src="https://img-blog.csdnimg.cn/05315adedea3415fa20bf0ef744f2166.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
<li>
<p>aof 文件可能在尾部是不完整的，当 redis 启动的时候，aof 文件的数据被载入内存</p>
<ul>
<li>重启可能发生在 redis 所在的主机操作系统宕机后，尤其在 ext4 文件系统没有加上<code>data=ordered</code>选项（ redis 宕机或者异常终止不会造成尾部不完整现象。）出现这种现象</li>
<li>可以选择让 redis 退出，或者导入尽可能多的数据</li>
<li>如果选择的是 yes，当截断的 aof 文件被导入的时候，会自动发布一个 log 给客户端然后 load</li>
<li>如果是 no，用户必须手动<code>redis-check-aof</code>修复 AOF 文件才可以</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/cd8705e10c5544328a2a56e32c6b463c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="LUA-SCRIPTING（LUA脚本）">#### LUA SCRIPTING（LUA脚本）####</h1>
<ul>
<li>
<p>如果达到最大时间限制（毫秒），redis 会记个 log，然后返回 error</p>
<ul>
<li>当一个脚本超过了最大时限。只有<code>SCRIPT KILL和SHUTDOWN NOSAVE</code>可以用</li>
<li>第一个可以杀没有调 write 命令的东西。要是已经调用了 write，只能用第二个命令杀</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f5443f87cacc438791aa6d5bcf160603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="REDIS-CLUSTER（集群相关）">#### REDIS CLUSTER（集群相关）####</h1>
<ul>
<li>
<p>集群开关，默认是不开启集群模式<br>
<img src="https://img-blog.csdnimg.cn/31f912e96dbf4bbf90c5e6460b57e0ad.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息</p>
<ul>
<li>这个文件并不需要手动配置，这个配置文件有 Redis 生成并更新，每个 Redis 集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/64f08d975ab6494f82d35125d68a232c.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>节点互连超时的阀值。集群节点超时毫秒数<br>
<img src="https://img-blog.csdnimg.cn/bcbd203397c84326aa5f56f28cf24a08.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>在进行故障转移的时候，全部 slave 都会请求申请为 master ，但是有些 slave 可能与 master 断开连接一段时间了，导致数据过于陈旧，这样的 slave 不应该被提升为 master</p>
<ul>
<li>该参数就是用来判断 slave 节点与 master 断线的时间是否过长</li>
<li>判断方法：
<ul>
<li>比较 slave 断开连接的时间和<code>(node-timeout * slave-validity-factor) + repl-ping-slave-period</code></li>
<li>如果节点超时时间为三十秒, 并且<code>slave-validity-factor</code>为 10 ,假设默认的<code>repl-ping-slave-period</code>是 10 秒，即如果超过 310 秒 slave 将不会尝试进行故障转移</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/ae7ac278dc8046c0ab44d6e9771c7b91.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>master 的 slave 数量大于该值，slave 才能迁移到其他孤立master上</p>
<ul>
<li>如这个参数若被设为 2，那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/651dc63f91ee4e2da2726af5f170102a.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置<br>
<img src="https://img-blog.csdnimg.cn/700e164f8f054a9087988767abf0e896.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="SLOW-LOG（慢查询日志）">#### SLOW LOG（慢查询日志）####</h1>
<ul>
<li>
<p>slog log 是用来记录 redis 运行中执行比较慢的命令耗时</p>
<ul>
<li>当命令的执行超过了指定时间，就记录在 slow log 中，slog log 保存在内存中，所以没有 IO 操作</li>
<li>执行时间比<code>slowlog-log-slower-than</code>大的请求记录到 slowlog 里面，单位是微秒，所以 1000000 就是 1 秒</li>
<li>注意，负数时间会禁用慢查询日志，而 0 则会强制记录所有命令</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/dafaeb3ccc714e109429b47f7647b138.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉</p>
<ul>
<li>这个长度没有限制，只要有足够的内存就行</li>
<li>你可以通过 <code>SLOWLOG RESET</code> 来释放内存</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/29bd2b1f9cc54d2583452d991bed6b4a.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="LATENCY-MONITOR（延迟监控）">#### LATENCY MONITOR（延迟监控）####</h1>
<ul>
<li>
<p>延迟监控功能是用来监控 redis 中执行比较缓慢的一些操作，用 LATENCY 打印 redis 实例在跑命令时的耗时图表</p>
<ul>
<li>只记录大于等于下边设置的值的操作，0 的话，就是关闭监视。默认延迟监控功能是关闭的</li>
<li>如果你需要打开，也可以通过<code>CONFIG SET</code>命令动态设置</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/53b22e9a3f46444d95795dd9d0675899.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="EVENT-NOTIFICATION（订阅通知）">#### EVENT NOTIFICATION（订阅通知）####</h1>
<ul>
<li>
<p>键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件</p>
<ul>
<li>因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态</li>
<li><code>notify-keyspace-events</code> 的参数可以是以下字符的任意组合</li>
<li>它指定了服务器该发送哪些类型的通知：
<ul>
<li><code>K</code> 键空间通知，所有通知以 __keyspace@__ 为前缀</li>
<li><code>E</code> 键事件通知，所有通知以 __keyevent@__ 为前缀</li>
<li><code>g</code> DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</li>
<li><code>$</code> 字符串命令的通知</li>
<li><code>l</code> 列表命令的通知</li>
<li><code>s</code> 集合命令的通知</li>
<li><code>h</code> 哈希命令的通知</li>
<li><code>z</code> 有序集合命令的通知</li>
<li><code>x</code> 过期事件：每当有过期键被删除时发送</li>
<li><code>e</code> 驱逐(evict)事件：每当有键因为 <code>maxmemory</code>政策而被删除时发送</li>
<li><code>A</code> 参数 g$lshzxe 的别名</li>
<li>输入的参数中至少要有一个 <code>K</code> 或者 <code>E</code>，否则的话，不管其余的参数是什么，都不会有任何通知被分发</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/4e5100994a8349daa3a27cde926f9974.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="ADVANCED-CONFIG（高级配置）">#### ADVANCED CONFIG（高级配置）####</h1>
<ul>
<li>
<p>数据量小于等于<code>hash-max-ziplist-entries</code>的用 ziplist ，大于<code>hash-max-ziplist-entries</code>用 hash<br>
<img src="https://img-blog.csdnimg.cn/9a6d4a795f2d43d2a1b8175452779e3a.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>value 大小小于等于<code>hash-max-ziplist-value</code>的用 ziplist，大于<code>hash-max-ziplist-value</code>用 hash<br>
<img src="https://img-blog.csdnimg.cn/18fdffa7de7742e5aa97fa05cc356498.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>数据量小于等于<code>set-max-intset-entries</code>用 iniset，大于<code>set-max-intset-entries</code>用 set<br>
<img src="https://img-blog.csdnimg.cn/ca8e9df21e92432191daea97b22047dd.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>value 大小小于等于<code>zset-max-ziplist-value</code>用 ziplist，大于<code>zset-max-ziplist-value</code>用 zset<br>
<img src="https://img-blog.csdnimg.cn/44ce0be71ac44ca09f49a92b1bd367b9.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>数据量小于等于<code>zset-max-ziplist-entries</code>用 ziplist ，大于<code>zset-max-ziplist-entries</code>用 zset<br>
<img src="https://img-blog.csdnimg.cn/e82af1b17e0f4acca739fe634a3ddc17.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>value 大小小于等于<code>hll-sparse-max-bytes</code>使用稀疏数据结构（sparse），大于<code>hll-sparse-max-bytes</code>使用稠密的数据结构（dense）</p>
<ul>
<li>一个比 16000 大的 value 是几乎没用的，建议的 value 大概为 3000</li>
<li>如果对 CPU 要求不高，对空间要求较高的，建议设置到 10000 左右</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/a2cdb029d80e4acfa36df49d4233e50e.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>Redis 将在每100毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用</p>
<ul>
<li>当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no</li>
<li>如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/098f6370919445e6a7ad34f337bf9797.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>redis 执行任务的频率为 1s 除以 hz</p>
<ul>
<li>在 aof 重写的时候，如果打开了<code>aof-rewrite-incremental-fsync</code>开关，系统会每 32MB 执行一次 fsync</li>
<li>这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/10e77ecba71e47e1aab3dfb66abd49b8.png" alt="在这里插入图片描述"></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://program-park.github.io/">一位木带感情的码农</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://program-park.github.io/2021/08/30/redis_10/">https://program-park.github.io/2021/08/30/redis_10/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归 <a href=https://program-park.github.io/>程序园</a> 所有，如有转载，请注明来自原作者。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/img/redis/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/03/redis_11/"><img class="prev-cover" src="/img/redis/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis 的持久化操作</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/23/python_13/"><img class="next-cover" src="/img/python/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python整数相除保留小数SyntaxError: from __future__ imports must occur at the beginning of the file</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/05/25/redis_1/" title="Redis 6.2.3 安装教程"><img class="cover" src="/img/redis/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-25</div><div class="title">Redis 6.2.3 安装教程</div></div></a></div><div><a href="/2021/09/03/redis_12/" title="Redis 的发布和订阅"><img class="cover" src="/img/redis/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-03</div><div class="title">Redis 的发布和订阅</div></div></a></div><div><a href="/2021/09/03/redis_11/" title="Redis 的持久化操作"><img class="cover" src="/img/redis/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-03</div><div class="title">Redis 的持久化操作</div></div></a></div><div><a href="/2021/09/06/redis_13/" title="Redis 主从复制"><img class="cover" src="/img/redis/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-06</div><div class="title">Redis 主从复制</div></div></a></div><div><a href="/2021/09/06/redis_14/" title="Redis 哨兵模式详解"><img class="cover" src="/img/redis/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-06</div><div class="title">Redis 哨兵模式详解</div></div></a></div><div><a href="/2021/05/25/redis_2/" title="redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode because"><img class="cover" src="/img/redis/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-25</div><div class="title">redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode because</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatat_img.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">一位木带感情的码农</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/program-park"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/program-park" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lkm869666@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_44758876" target="_blank" title="CSDN"><i class="fa-solid fa-c"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里是程序园，如有任何意见和疑问，请反馈到我的邮箱。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NETWORK%EF%BC%88%E7%BD%91%E7%BB%9C%EF%BC%89"><span class="toc-text">#### NETWORK（网络）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GENERAL%EF%BC%88%E9%80%9A%E7%94%A8%EF%BC%89"><span class="toc-text">#### GENERAL（通用）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SNAPSHOTTING%EF%BC%88%E5%BF%AB%E7%85%A7%EF%BC%89"><span class="toc-text">#### SNAPSHOTTING（快照）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REPLICATION%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89"><span class="toc-text">#### REPLICATION（主从复制）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SECURITY%EF%BC%88%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-text">#### SECURITY（安全）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CLIENTS%EF%BC%88%E8%BF%9B%E7%A8%8B%E9%99%90%E5%88%B6%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="toc-text">#### CLIENTS（进程限制相关）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APPEND-ONLY-MODE%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-text">#### APPEND ONLY MODE（持久化方式）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LUA-SCRIPTING%EF%BC%88LUA%E8%84%9A%E6%9C%AC%EF%BC%89"><span class="toc-text">#### LUA SCRIPTING（LUA脚本）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REDIS-CLUSTER%EF%BC%88%E9%9B%86%E7%BE%A4%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="toc-text">#### REDIS CLUSTER（集群相关）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SLOW-LOG%EF%BC%88%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-text">#### SLOW LOG（慢查询日志）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LATENCY-MONITOR%EF%BC%88%E5%BB%B6%E8%BF%9F%E7%9B%91%E6%8E%A7%EF%BC%89"><span class="toc-text">#### LATENCY MONITOR（延迟监控）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EVENT-NOTIFICATION%EF%BC%88%E8%AE%A2%E9%98%85%E9%80%9A%E7%9F%A5%EF%BC%89"><span class="toc-text">#### EVENT NOTIFICATION（订阅通知）####</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ADVANCED-CONFIG%EF%BC%88%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-text">#### ADVANCED CONFIG（高级配置）####</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/30/reptile_1/" title="Python 爬虫基础之 urllib 库的深入使用详解"><img src="/img/reptile/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 爬虫基础之 urllib 库的深入使用详解"/></a><div class="content"><a class="title" href="/2022/08/30/reptile_1/" title="Python 爬虫基础之 urllib 库的深入使用详解">Python 爬虫基础之 urllib 库的深入使用详解</a><time datetime="2022-08-30T09:15:02.000Z" title="发表于 2022-08-30 17:15:02">2022-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/linux_6/" title="Linux 防火墙常用命令总结"><img src="/img/linux/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 防火墙常用命令总结"/></a><div class="content"><a class="title" href="/2022/08/15/linux_6/" title="Linux 防火墙常用命令总结">Linux 防火墙常用命令总结</a><time datetime="2022-08-15T07:20:44.000Z" title="发表于 2022-08-15 15:20:44">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/linux_5/" title="Linux 基础命令之 tar 解压缩详解"><img src="/img/linux/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 基础命令之 tar 解压缩详解"/></a><div class="content"><a class="title" href="/2022/07/31/linux_5/" title="Linux 基础命令之 tar 解压缩详解">Linux 基础命令之 tar 解压缩详解</a><time datetime="2022-07-31T00:22:50.000Z" title="发表于 2022-07-31 08:22:50">2022-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/13/nginx_16/" title="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离"><img src="/img/nginx/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离"/></a><div class="content"><a class="title" href="/2022/07/13/nginx_16/" title="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离">Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离</a><time datetime="2022-07-13T07:33:23.000Z" title="发表于 2022-07-13 15:33:23">2022-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/04/nginx_15/" title="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究"><img src="/img/nginx/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究"/></a><div class="content"><a class="title" href="/2022/07/04/nginx_15/" title="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究">Nginx 从入门到入坟（十四）- Nginx 缓存深入研究</a><time datetime="2022-07-04T04:20:02.000Z" title="发表于 2022-07-04 12:20:02">2022-07-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/redis/1.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 一位木带感情的码农</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://program-park.github.io/2021/08/30/redis_10/'
    this.page.identifier = '/2021/08/30/redis_10/'
    this.page.title = 'Redis 配置文件详解'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>