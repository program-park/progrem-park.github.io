<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《数据结构与算法》（六）- 栈详解 | 程序园</title><meta name="keywords" content="数据结构,算法"><meta name="author" content="一位木带感情的码农"><meta name="copyright" content="一位木带感情的码农"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文是《数据结构与算法》系列，第六篇：栈。">
<meta property="og:type" content="article">
<meta property="og:title" content="《数据结构与算法》（六）- 栈详解">
<meta property="og:url" content="https://program-park.github.io/2021/10/31/algorithm_6/index.html">
<meta property="og:site_name" content="程序园">
<meta property="og:description" content="本文是《数据结构与算法》系列，第六篇：栈。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://program-park.github.io/img/algorithm/1.png">
<meta property="article:published_time" content="2021-10-31T10:28:22.000Z">
<meta property="article:modified_time" content="2022-12-05T04:36:25.091Z">
<meta property="article:author" content="一位木带感情的码农">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://program-park.github.io/img/algorithm/1.png"><link rel="shortcut icon" href="/img/favicon_logo/favicon.png"><link rel="canonical" href="https://program-park.github.io/2021/10/31/algorithm_6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: 一位木带感情的码农","link":"链接: ","source":"来源: 程序园","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《数据结构与算法》（六）- 栈详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-05 12:36:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatat_img.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">程序园</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">《数据结构与算法》（六）- 栈详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-10-31T10:28:22.000Z" title="发表于 2021-10-31 18:28:22">2021-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《数据结构与算法》（六）- 栈详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="前言">前言</h1>
<p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p>
<h1 id="1-栈的定义">1. 栈的定义</h1>
<h2 id="1-1-栈的定义">1.1 栈的定义</h2>
<p>  很多软件，比如Word、 Photoshop 等文档或图像编辑软件中，都有撤销（undo）的操作，也是用栈这种方式来实现的，当然不同的软件具体实现代码会有很大差异，不过原理其实都是一样的。</p>
<blockquote>
<p><strong>栈( stack )是限定仅在表尾进行插入和删除操作的线性表。</strong></p>
</blockquote>
<p>  我们把<font color=#6495ED><strong>允许插入和删除的一端称为栈顶（top）， 另一端称为栈底（bottom）， 不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</strong></font>。<br>
  理解栈的定义需要注意：<br>
  首先它是一个<font color=#8A2BE2><strong>线性表</strong></font>， 也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。<br>
  它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。<br>
  <font color=#6495ED><strong>栈的插入操作，叫作进栈，也称压栈、入栈。</strong></font>如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/9c937a67b9714e4e969bb7946858b4e1.png#pic_center" alt="在这里插入图片描述"><br>
  <font color=#6495ED><strong>栈的删除操作，叫作出栈，也有的叫作弹栈。</strong></font>如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/6355ec164c694d84931c523854e083c1.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-2-进栈出栈变化形式">1.2 进栈出栈变化形式</h2>
<p>  栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。<br>
  举例来说，如果我们现在是有 3 个整型数字元素 1、2、3 依次进栈，会有哪些出栈次序呢？</p>
<ul>
<li>第一种：1、2、3 进，再 3、2、1 出。这是最简单的最好理解的一种，出栈次序为 3、2、1。</li>
<li>第二种：1 进，1 出，2 进，2 出，3 进，3 出。也就是进一个就出一个，出<br>
栈次序为 1、2、3。</li>
<li>第三种：1 进，2 进，2 出，1 出，3 进，3 出。出栈次序为 2、1、3.</li>
<li>第四种：1 进，1 出，2 进，3 进，3 出，2 出。出栈次序为 1、3、2。</li>
<li>第五种：1 进，2 进，2 出，3 进，3 出，1 出。出栈次序为 2、3、1。</li>
</ul>
<p>  有没有可能是 3、1、2 这样的次序出栈呢？答案是肯定不会。因为 3 先出栈，就意味着，3 曾经进栈，既然 3 都进栈了，那也就意味着，1 和 2 已经进栈了，此时，2 一定是在 1 的上面，就是更接近栈顶，那么出栈只可能是 3、2、1，不然不满足 1、2、3 依次进栈的要求，所以此时不会发生 1 比 2 先出栈的情况。<br>
  从这个简单的例子就能看出，只是 3 个元素，就有 5 种可能的出栈次序，如果元素数量多，其实出栈的变化将会更多的。<br>
<br></p>
<h1 id="2-栈的抽象数据类型">2. 栈的抽象数据类型</h1>
<p>  对于栈来讲，理论上线性表的操作特性它都具备，可由于它的特殊性，所以针对它在操作上会有些变化。特别是插入和删除操作，我们改名为<code>push</code>和<code>pop</code>，英文直译的话是压和弹，更容易理解。你就把它当成是弹夹的子弹压入和弹出就好记忆了，我们一般叫进栈和出栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT栈(<span class="built_in">stack</span>)</span><br><span class="line">Data</span><br><span class="line">	同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">	<span class="title function_">Initstack</span><span class="params">(*S)</span>：初始化操作，建立一个空栈S。</span><br><span class="line">	<span class="title function_">DestroyStack</span><span class="params">(*S)</span>：若栈存在，则销毁它。</span><br><span class="line">	<span class="title function_">Clearstack</span><span class="params">(*S)</span>：将栈清空。</span><br><span class="line">	<span class="title function_">StackEmpty</span><span class="params">(S)</span>：若栈为空，返回<span class="literal">true</span>,否则返回<span class="literal">false</span>。</span><br><span class="line">	<span class="title function_">GetTop</span><span class="params">(S,*e)</span>：若栈存在且非空，用e返回S的栈顶元素。</span><br><span class="line">	<span class="title function_">Push</span><span class="params">(*S,e)</span>:若栈S存在，插入新元素e到栈S中并成为栈顶元素。</span><br><span class="line">	<span class="title function_">Pop</span><span class="params">(*S,*e)</span> :删除栈S中栈顶元素，并用e返回其值。</span><br><span class="line">	<span class="title function_">StackLength</span><span class="params">(S)</span> :返回栈S的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>  由于栈本身就是一个线性表，那么线性表的顺序存储和链式存储，对于栈来说，也是同样适用的。<br>
<br></p>
<h1 id="3-栈的顺序存储结构及实现">3. 栈的顺序存储结构及实现</h1>
<h2 id="3-1-栈的顺序存储结构">3.1 栈的顺序存储结构</h2>
<p>  既然栈是线性表的特例，那么<strong>栈的顺序存储</strong>其实也是线性表顺序存储的简化，我们简称为<strong>顺序栈</strong>。线性表是用数组来实现的，想想看，对于栈这种只能一头插入删除的线性表来说，用数组哪一端来作为栈顶和栈底比较好?<br>
  对，没错，下标为0的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它作栈底。<br>
  我们定义一个<code>top</code>变量来指示栈顶元素在数组中的位置，这<code>top</code>就如同中学物理学过的游标卡尺的游标，它可以来回移动，意味着栈顶的<code>top</code>可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为<code>StackSize</code>，则栈顶位置<code>top</code>必须小于<code>StackSize</code>。当栈存在一个元素时，<code>top</code>等于 0，因此通常把空栈的判定条件定为<code>top</code>等于 -1。<br>
  来看栈的结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType; <span class="comment">/* SElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> top;	<span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<p>  若现在有一个栈，<code>StackSize</code>是 5，则栈普通情况、空栈和栈满的情况示意图如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/8c0e3565e6b34eaf84d126997b2c42bc.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-2-栈的顺序存储结构——进栈操作">3.2 栈的顺序存储结构——进栈操作</h2>
<p>  出栈<code>pop</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回oK;否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack *s,SElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	*e=S-&gt;data[S-&gt;top];	<span class="comment">/* 将要删除的栈顶元素赋值给e */</span></span><br><span class="line">	S-&gt;top--;	<span class="comment">/* 栈顶指针减一 */</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  两者没有涉及到任何循环语句，因此时间复杂度均是<strong>O(1)</strong>。<br>
<br></p>
<h1 id="4-两栈共享空间">4. 两栈共享空间</h1>
<p>  其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题。不过它有一个很大的缺陷，就是必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。对于一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于两个相同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来进行操作。<br>
  打个比方，两个大学室友毕业同时到北京工作，开始时，他们觉得住了这么多年学校的集体宿舍，现在工作了一定要有自己的私密空间。于是他们都希望租房时能找到独住的一居室，可找来找去却发现，最便宜的一居室也要每月 1500 元，地段还不好，实在是承受不起，最终他俩还是合租了一套两居室， 一共2000元，各出一半，还不错。<br>
  对于两个一居室，都有独立的卫生间和厨房，是私密了，但大部分空间的利用率却不高。而两居室，两个人各有卧室，还共享了客厅、厨房和卫生间，房间的利用率就显著提高，而且租房成本也大大下降了。<br>
  同样的道理，如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这又何必呢？我们完全可以用一个数组来存储两个栈，只不过需要点小技巧。<br>
  我们的做法如下图，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为数组的末端，即下标为数组长度<code>n-1</code>处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br>
<img src="https://img-blog.csdnimg.cn/c967938416c84bc3b96d8a38a4186231.png#pic_center" alt="在这里插入图片描述"><br>
  其实关键思路是：它们是在数组的两端，向中间靠拢。<code>top1</code>和<code>top2</code>是栈 1 和栈 2 的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。.<br>
  从这里也就可以分析出来，栈 1 为空时，就是<code>top1</code>等于 -1 时；而当<code>top2</code>等于<code>n</code>时，即是栈 2 为空时，那什么时候栈满呢？<br>
  想想极端的情况，若栈 2 是空栈，栈 1 的<code>top1</code>等于<code>n-1</code>时，就是栈 1 满了。反之，当栈 1 为空栈时，<code>top2</code>等于 0 时，为栈 2 满。但更多的情况，其实就是刚才说的，两个栈见面之时，也就是两个指针之间相差 1 时，即<code>top1+1==top2</code>为栈满。<br>
  两栈共享空间的结构的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两栈共享空间结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> top1;	<span class="comment">/* 栈1栈顶指针 */</span></span><br><span class="line">	<span class="type">int</span> top2;	<span class="comment">/* 栈2栈顶指针 */</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>
<p>  对于两栈共享空间的<code>push</code>方法，我们除了要插入元素值参数外，还需要有一个判断是栈 1 还是栈 2 的栈号参数<code>stackNumber</code>。插入元素的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqDoubleStack *S,SElemType e,<span class="type">int</span> stackNumber)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;top1+<span class="number">1</span>==S-&gt;top2)	<span class="comment">/* 栈已满，不能再push新元素了 */</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (stackNumber==<span class="number">1</span>)	<span class="comment">/* 栈1有元素进栈 */</span></span><br><span class="line">		S-&gt;data[++S-&gt;top1]=e;	<span class="comment">/* 若是栈1则先top1+1后给数组元素赋值 */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)	<span class="comment">/* 栈2有元素进栈 */</span></span><br><span class="line">		S-&gt;data[--S-&gt;top2]=e;<span class="comment">/* 若是栈2则先top2-1后给数组元素赋值 */</span></span><br><span class="line">	<span class="keyword">return</span> OK:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  因为在开始时已经判断了是否有栈满的情况，所以后面的<code>top1+1</code>或<code>top2-1</code>是不担心溢出问题的。<br>
  对于两栈共享空间的<code>pop</code>方法，参数就只是判断栈 1 栈 2 的参数<code>stackNumber</code>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK;否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqDoubleStack *s,SElemType *e,<span class="type">int</span> stackNumber)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (stackNumber==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (S-&gt;top1==<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;	<span class="comment">/* 说明栈1已经是空栈，溢出 */</span></span><br><span class="line">		*e=s-&gt;data[S-&gt;top1--];	<span class="comment">/* 将栈1的栈顶元素出栈 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (S-&gt;top2==MAXSIZE)</span><br><span class="line">			<span class="keyword">return</span> ERROR:	<span class="comment">/* 说明栈2已经是空栈，溢出 */</span></span><br><span class="line">		*e=S-&gt;data[S-&gt;top2++];	<span class="comment">/* 将栈2的栈顶元素出栈 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK:</span><br></pre></td></tr></table></figure>
<p>  事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样， 你买入时，一定是有一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而溢出了。<br>
  当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不相同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂，大家要注意这个前提。<br>
<br></p>
<h1 id="5-栈的链式存储结构及实现">5. 栈的链式存储结构及实现</h1>
<h2 id="5-1-栈的链式存储结构">5.1 栈的链式存储结构</h2>
<p>  讲完了栈的顺序存储结构，我们现在来看看<font color=#6495ED>栈的链式存储结构，简称为链栈。</font><br>
  想想看，栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢？所以比较好的办法是把栈顶放在单链表的头部（如下图所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。<br>
<img src="https://img-blog.csdnimg.cn/de22bc9064da4c148c5afde1f0f0ab92.png#pic_center" alt="在这里插入图片描述"><br>
  对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是否溢出的问题。<br>
  但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是<code>top=NULL</code>的时候。<br>
  链栈的结构代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链栈结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linkstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LinkstackPtr top;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">&#125;Linkstack;</span><br></pre></td></tr></table></figure>
<p>  链栈的操作绝大部分都和单链表类似，只是在插入和删除上，特殊一些。</p>
<h2 id="5-2-栈的链式存储结构——进栈操作">5.2 栈的链式存储结构——进栈操作</h2>
<p>  对于链栈的进栈<code>push</code>操作，假设元素值为<code>e</code>的新结点是<code>s</code>，<code>top </code>为栈顶指针，如下所示：<br>
<img src="https://img-blog.csdnimg.cn/9a73255ffdc84afc91743b158db53aca.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(Linkstack *S,SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkstackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">	s-&gt;data=e;</span><br><span class="line">	s-&gt;next=S-&gt;top;	<span class="comment">/* 把当前的栈頂元素赋值给新结点的直接后继，如图中① */</span></span><br><span class="line">	S-&gt;top=s;	<span class="comment">/* 将新的结点s赋值给栈顶指针，如图中② */</span></span><br><span class="line">	S-&gt;count++:</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-栈的链式存储结构——出栈操作">5.3 栈的链式存储结构——出栈操作</h2>
<p>  至于链栈的出栈<code>pop</code>操作，也是很简单的三句操作。假设变量<code>p</code>用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放<code>p</code>即可，如下所示。<img src="https://img-blog.csdnimg.cn/2eeb04696ade4446942cc1e581124286.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK;否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStackPtr p;</span><br><span class="line">	<span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	*e=S-&gt;top-&gt;data;</span><br><span class="line">	p=S-&gt;top;	<span class="comment">/* 将栈顶结点赋值给p，如图③ */</span></span><br><span class="line">	S-&gt;top=S-&gt;top-&gt;next;	<span class="comment">/* 使得栈顶指针下移一位，指向后一结点，如图④ */</span></span><br><span class="line">	<span class="built_in">free</span>(p);	<span class="comment">/* 释放结点p */</span></span><br><span class="line">	S-&gt;count--:</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  链栈的进栈<code>push</code>和出栈<code>pop</code>操作都很简单，没有任何循环操作，时间复杂度均为<strong>O(1)</strong>。<br>
  对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。 对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，<font color=#6495ED><strong>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一一些。</strong></font><br>
<br></p>
<h1 id="6-栈的作用">6. 栈的作用</h1>
<p>  有的人可能会觉得，用数组或链表直接实现功能不就行了吗？干嘛要引入栈这样的数据结构呢？<br>
  其实这和我们明明有两只脚可以走路，干吗还要乘汽车、火车、飞机一样。理论上，陆地上的任何地方，你都是可以靠双脚走到的，可那需要多少时间和精力呢？我们更关注的是到达而不是如何去的过程。<br>
  <font color=#6495ED><strong>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。</strong></font>而像线性表顺序存储结构用到的数组，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。<br>
  所以现在的许多高级语言，比如<code>Java</code>、<code>C#</code>等都有对栈结构的封装，你可以不用关注它的实现细节，就可以直接使用<code>Stack</code>的<code>push</code>和<code>pop</code>方法，非常方便。<br>
<br></p>
<h1 id="7-栈的应用——递归">7. 栈的应用——递归</h1>
<p>  栈有一个很重要的应用：在程序设计语言中实现了递归。那么什么是递归呢？<br>
  当你往镜子前面一站，镜子里面就有一个你的像。 但你试过两面镜子起照吗？如果<code>A</code>、<code>B</code>两面镜子相互面对面放着，你往中间一站，嘿，两面镜子里都有你的千百个“化身”。为什么会有这么奇妙的现象呢？原来，<code>A</code>镜子里有<code>B</code>镜子的像，<code>B</code>镜子里也有<code>A</code>镜子的像，这样反反复复，就会产生一连串的“像中像”。这是一种递归现象。<br>
  我们先来看一个经典的递归例子：斐波那契数列（Fibonacci）。 为了说明这个数列，这位斐老还举了一个很形象的例子。</p>
<h2 id="7-1-斐波那契数列的实现">7.1 斐波那契数列的实现</h2>
<p>  说如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔都不死，那么一年以后可以繁殖多少对兔子呢？<br>
  我们拿新出生的一对小兔子分析一下：第一个月小兔子没有繁殖能力，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对……以此类推可以列出下表。</p>
<table>
	<tr align=center>
		<th>所经过的月数</th>
		<th>1</th>
		<th>2</th>
		<th>3</th>
		<th>4</th>
		<th>5</th>
		<th>6</th>
		<th>7</th>
		<th>8</th>
		<th>9</th>
		<th>10</th>
		<th>11</th>
		<th>12</th>
	</tr>
	<tr align=center>
		<td>兔子对数</td>
		<td>1</td>
		<td>1</td>
		<td>2</td>
		<td>3</td>
		<td>5</td>
		<td>8</td>
		<td>13</td>
		<td>21</td>
		<td>34</td>
		<td>55</td>
		<td>89</td>
		<td>144</td>
	</tr>
</table>
&emsp;&emsp;表中数字 1，1，2，3，5，8，13，.....… 构成了一个序列。这个数列有个十分明显的特点，那就是：前面相邻两项之和，构成了后一项，如下图所示。
<p><img src="https://img-blog.csdnimg.cn/2ddcec021101470ba8a20582898f075e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
  可以发现，编号①的一对兔子经过 6 个月就变成 8 对兔子了。如果我们用数学函数来定义就是：<br>
<img src="https://img-blog.csdnimg.cn/500e00bb37154da5a81f6881301e1e18.png#pic_center" alt="在这里插入图片描述"><br>
  先考虑一下，如果我们要实现这样的数列用常规的迭代的办法如何实现？假设我们需要打印出前 40 位的斐波那契数列数。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">40</span>];</span><br><span class="line">	a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; <span class="number">40</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i] = a[i<span class="number">-1</span>] + a[i<span class="number">-2</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  代码很简单，几乎不用做什么解释。但其实我们的代码，如果用递归来实现，还可以更简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契的递归函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fbi</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( i &lt; <span class="number">2</span> )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> Fbi(i<span class="number">-1</span>)+Fbi(i<span class="number">-2</span>);	<span class="comment">/* 这里Fbi就是函数自己，等于在调用自己 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;递归显示斐波那契数列：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Fbi(i));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  函数怎么可以自已调用自己？听起来有些难以理解，不过你可以不要把一个递归函数中调用自己的函数看作是在调用自己，而就当它是在调另-一个函数。只不过，这个函数和自己长得一样而已。<br>
  我们来模拟代码中的<code>Fbi(i)</code>函数当<code>i= 5</code>的执行过程，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/0df9a289bd2f406dbf82f31bbe8e79f7.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="7-2-递归的定义">7.2 递归的定义</h2>
<p>  在高级语言中，调用自己和其他函数并没有本质的不同。我们<font color=#6495ED><strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。</strong></font><br>
  当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，<font color=#6495ED><strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</strong></font>比如刚才的例子，总有一次递归会使得<code>i&lt;2</code>的，这样就可以执行<code>return i</code>的语句而不用继续递归了。<br>
  对比了两种实现斐波那契的代码。迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。<br>
  那么我们讲了这么多递归的内容，和栈有什么关系呢？这得从计算机系统的内部说起。<br>
  前面我们已经看到递归是如何执行它的前行和退回阶段的。递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。<br>
  这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构，因此，编译器使用栈实现递归就没什么好惊讶的了。<br>
  简单的说，就是在前行阶段，对于每一层递归， 函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。<br>
  当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。<br>
<br></p>
<h1 id="8-栈的应用——四则运算表达式求值">8. 栈的应用——四则运算表达式求值</h1>
<h2 id="8-1-后缀（逆波兰）表示法的定义">8.1 后缀（逆波兰）表示法的定义</h2>
<p>  栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求值。<br>
  我们小学学数学的时候，有一句话是老师反复强调的，“先乘除，后加减，从左算到右，先括号内后括号外”。这个大家都不陌生。我记得我小时候，天天做这种加减乘除的数学作业，很烦，于是就偷偷拿了老爸的计算器来帮着算答案，对于单纯的两个数的加减乘除，的确是省心不少，我也因此潇酒了一两年。 可后来要求要加减乘除，甚至还有带有大中小括号的四则运算，我发现老爸那个简陋的计算器不好使了。比如<code>9+(3-1)×3+10÷2</code>，这是一个非常简单的题目，心算也可以很快算出是 20。可就这么简单的题目，计算器却不能在一次输入后马上得出结果，很是不方便。<br>
  当然，后来出的计算器就高级多了，它引入了四则运算表达式的概念，也可以输入括号了，所以现在的 00 后的小朋友们，更加可以偷懒、抄近路做数学作业了。<br>
  那么在新式计算器中或者计算机中，它是如何实现的呢？如果让你用<code>C</code>语言或其他高级语言实现对数学表达式的求值，你打算如何做?<br>
  这里面的困难就在于乘除在加减的后面，却要先运算，而加入了括号后，就变得更加复杂。不知道该如何处理。<br>
  但仔细观察后发现，括号都是成对出现的，有左括号就一定会有右括号，对于多重括号，最终也是完全嵌套匹配的。这用栈结构正好合适，只有碰到左括号，就将此左括号进栈，不管表达式有多少重括号，反正遇到左括号就进栈，而后面出现右括号时，就让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈的结果。<br>
  但对于四则运算，括号也只是当中的一部分，先乘除后加减使得问题依然复杂，如何有效地处理它们呢？<br>
  20 世纪 50 年代，波兰逻辑学家 Jan tukasiewicz，当时也和我们现在一样，困惑于如何才可以搞定这个四则运算，不知道他是否也像牛顿被苹果砸到头而想到万有引力的原理，或者还是阿基米德在浴缸中洗澡时想到判断皇冠是否纯金的办法，总之他也是灵感突现，想到了<font color=#6495ED><strong>一种不需要括号的后缀表达法，我们也把它称为逆波兰（Reverse Polish Noation, RPN）表示。</strong></font>我想可能是他的名字太复杂了，所以后人只用他的国籍而不是姓名来命名，实在可惜。这也告诉我们，想要流芳百世，名字还要起得朗朗上口才行。这种后缀表示法，是表达式的一种新的显示方式，非常巧妙地解决了程序实现四则运算的难题。<br>
  我们先来看看，对于“9+(3-1)×3+10÷2&quot;，要用后缀表示法应该是什么样子。<br>
  正常数学表达式：9+(3-1)×3+10÷2<br>
  后缀表达式：9 3 1-3 * + 10 2 / +<br>
  “9 3 1-3 * + 10 2 / +”这样的表达式成为<font color=#8A2BE2><strong>后缀表达式</strong></font>，叫后缀的原因在于<font color=#6495ED><strong>所有的符号都是在要运算数字的后面出现。</strong></font>显然，这里没有了括号。对于从来没有接触过后缀表达式的人来讲，这样的表述是很难受的。不过你不喜欢，有“人”喜欢，比如我们聪明的计算机。</p>
<h2 id="8-2-后缀表达式的计算结果">8.2 后缀表达式的计算结果</h2>
<p>  为了解释后缀表达式的好处，我们先来看看，计算机如何应用后缀表达式计算出最终的结果 20 的。<br>
  后缀表达式：9 3 1-3 * + 10 2 / +<br>
  规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p>
<ol>
<li>初始化一个空栈。此栈用来对要运算的数字进出使用。</li>
<li>后缀表达式中前三个都是数字，所以 9、3、1 进栈，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/492727172cbd4bef947be82333be8b33.png" alt="在这里插入图片描述"></li>
<li>接下来是 “-”，所以将栈中的 1 出栈作为减数，3 出栈作为被减数，并运算 3-1 得到 2，再将 2 进栈。</li>
<li>接着是数字 3 进栈，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/5e00576bde134e56a5026238bab8546d.png" alt="在这里插入图片描述"></li>
<li>后面是 “*”，也就意味着栈中 3 和 2 出栈，2 与 3 相乘，得到 6，并将 6 进栈。</li>
<li>下面是 “+”，所以栈中 6 和 9 出栈，9 与 6 相加，得到 15，将 15 进栈，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/7c10d8533d354b0bb9bb8f562bb46059.png" alt="在这里插入图片描述"></li>
<li>接着是 10 与 2 两数字进栈。</li>
<li>接下来是符号 “/”，因此，栈顶的 2 与 10 出栈，10 与 2 相除，得到 5，将5 进栈，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/223c593f42c7472a9e311aaf604385dc.png" alt="在这里插入图片描述"></li>
<li>最后一个是符号 “+”，所以 15 与 5 出栈并相加，得到 20，将 20 进栈。</li>
<li>结果是 20 出栈，栈变为空，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/f4401013ca394a7e8b1f2ca92773d122.png" alt="在这里插入图片描述"></li>
</ol>
<p>  果然，后缀表达法可以很顺利解决计算的问题。那么现在应该都有同样的疑问，就是这个后缀表达式 “9 3 1-3 * + 10 2 / +” 是怎么出来的？这个问题不搞清楚，等于没有解决。所以下面，我们就来推导如何让 “9+(3-1)×3+10÷2”转化为 “9 3 1-3 * + 10 2 / +”。</p>
<h2 id="8-3-中缀表达式转后缀表达式">8.3 中缀表达式转后缀表达式</h2>
<p>  我们把平时所用的<font color=#6495ED><strong>标准四则运算表达式</strong></font>，即 “9+(3-1)×3+10÷2” 叫做中缀表达式。因为所有的运算符号都在两数字的中间，现在我们的问题就是中缀到后缀的转化。<br>
  中缀表达式 “9+(3-1)×3+10÷2&quot; 转化为后缀表达式“9 3 1-3 * + 10 2 / +”。<br>
  规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p>
<ol>
<li>
<p>初始化一空栈， 用来对符号进出栈使用。</p>
</li>
<li>
<p>第一个字符是数字 9，输出 9，后面是符号 “+”，进栈。如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/c0e16c56a68942738b49991fd70fd897.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>第三个字符是 “(&quot;，依然是符号，因其只是左括号，还未配对，故进栈。</p>
</li>
<li>
<p>第四个字符是数字 3，输出，总表达式为 9 3，接着是“-&quot;，进栈。如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/84f38f9ad4be4884a1b6fbe2fc52ec8f.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>接下来是数字 1，输出，总表达式为 9 3 1，后面是符号 “)”，此时，我们需要去匹配此前的 “(“，所以栈顶依次出栈，并输出，直到 “(” 出栈为止。此时左括号上方只有 “-”，因此输出 “-”。总的输出表达式为 9 3 1-。</p>
</li>
<li>
<p>紧接着是符号 “×”，因为此时的栈顶符号为 “+”，优先级低于 “×”，因此不能输出，“*” 进栈。接着是数字 3，输出，总的表达式为 9 3 1 - 3》如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/bb6d80002d17434da64a2351656d8a16.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>之后是符号 “+'，此时当前栈顶元素 “*” 比这个 “+” 的优先级高，因此栈中元素出栈并输出（没有比 “+” 号更低的优先级，所以全部出栈），总输出表达式为 9 3 1-3 * +。然后将当前这个符号 “+” 进栈。也就是说，前 6 张图的栈底的 “+” 是指中缀表达式中开头的 9 后面那个 “+”，而下图中左图中的栈底（也是栈顶）的 “+” 是指 “9+(3-1)×3+” 中的最后一个 “+”。</p>
</li>
<li>
<p>紧接着数字 10，输出，总表达式变为 9 3 1-3 * + 10。后是符号 “÷”，所以“/” 进栈。如下图中右图所示。<br>
<img src="https://img-blog.csdnimg.cn/1fe6230022d1458b92b3603be23a05a3.png" alt="在这里插入图片描述"></p>
</li>
<li>
<p>最后一个数字 2，输出，总的表达式为 9 3 1 - 3 * + 10 2。</p>
</li>
<li>
<p>因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为 9 3 1 - 3 * + 10 2 / +。如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/3b5700d8f4b84d81be9e94118fd95e87.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>  从刚才的推导中你会发现，要想让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就是两步：</p>
<ol>
<li>将中缀表达式转化为后缀表达式（栈用来进出运算的符号）。</li>
<li>将后缀表达式进行运算得出结果（栈用来进出运算的数字）。</li>
</ol>
<p>  整个过程，都充分利用了栈的后进先出特性来处理，理解好它其实也就理解好了栈这个数据结构。<br>
<br></p>
<h1 id="9-总结">9. 总结</h1>
<p>  栈就是特殊的线性表，只不过对插入和删除操作做了限制。<br>
  栈（stack）是限定仅在表尾进行插入和删除操作的线性表。<br>
  它可以用线性表的顺序存储结构来实现，但存在着顺序存储的一些弊端。如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>
  它也可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.progrem-park.top/">一位木带感情的码农</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.progrem-park.top/2021/10/31/algorithm_6/">https://www.progrem-park.top/2021/10/31/algorithm_6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归 <a href=https://www.progrem-park.top/>程序园</a> 所有，如有转载，请注明来自原作者。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/algorithm/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/01/algorithm_7/"><img class="prev-cover" src="/img/algorithm/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《数据结构与算法》（七）- 队列详解</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/18/algorithm_5/"><img class="next-cover" src="/img/algorithm/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《数据结构与算法》（五）- 链表详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/08/algorithm_10/" title="《数据结构与算法》（十）- 二叉树详解"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-08</div><div class="title">《数据结构与算法》（十）- 二叉树详解</div></div></a></div><div><a href="/2021/10/11/algorithm_1/" title="《数据结构与算法》（一）- 数据结构详解"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-11</div><div class="title">《数据结构与算法》（一）- 数据结构详解</div></div></a></div><div><a href="/2021/11/09/algorithm_11/" title="《数据结构与算法》（十一）- 树、森林与二叉树的转换及哈夫曼树详解"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-09</div><div class="title">《数据结构与算法》（十一）- 树、森林与二叉树的转换及哈夫曼树详解</div></div></a></div><div><a href="/2021/11/10/algorithm_12/" title="《数据结构与算法》（十二）- 图详解"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-10</div><div class="title">《数据结构与算法》（十二）- 图详解</div></div></a></div><div><a href="/2021/11/10/algorithm_13/" title="《数据结构与算法》（十三）- 图的应用：最小生成树"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-10</div><div class="title">《数据结构与算法》（十三）- 图的应用：最小生成树</div></div></a></div><div><a href="/2021/11/11/algorithm_14/" title="《数据结构与算法》（十四）- 图的应用：最短路径"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-11</div><div class="title">《数据结构与算法》（十四）- 图的应用：最短路径</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatat_img.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">一位木带感情的码农</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/program-park"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/program-park" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lkm869666@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_44758876" target="_blank" title="CSDN"><i class="fa-solid fa-c"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站正在优化中......</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 栈的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 栈的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F"><span class="toc-text">1.2 进栈出栈变化形式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 栈的抽象数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. 栈的顺序存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">3.1 栈的顺序存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-text">3.2 栈的顺序存储结构——进栈操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4"><span class="toc-text">4. 两栈共享空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. 栈的链式存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">5.1 栈的链式存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-text">5.2 栈的链式存储结构——进栈操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-text">5.3 栈的链式存储结构——出栈操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">6. 栈的作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%80%92%E5%BD%92"><span class="toc-text">7. 栈的应用——递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">7.1 斐波那契数列的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">7.2 递归的定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-text">8. 栈的应用——四则运算表达式求值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%90%8E%E7%BC%80%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">8.1 后缀（逆波兰）表示法的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C"><span class="toc-text">8.2 后缀表达式的计算结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">8.3 中缀表达式转后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%80%BB%E7%BB%93"><span class="toc-text">9. 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/30/reptile_1/" title="Python 爬虫基础之 urllib 库的深入使用详解"><img src="/img/reptile/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 爬虫基础之 urllib 库的深入使用详解"/></a><div class="content"><a class="title" href="/2022/08/30/reptile_1/" title="Python 爬虫基础之 urllib 库的深入使用详解">Python 爬虫基础之 urllib 库的深入使用详解</a><time datetime="2022-08-30T09:15:02.000Z" title="发表于 2022-08-30 17:15:02">2022-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/linux_6/" title="Linux 防火墙常用命令总结"><img src="/img/linux/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 防火墙常用命令总结"/></a><div class="content"><a class="title" href="/2022/08/15/linux_6/" title="Linux 防火墙常用命令总结">Linux 防火墙常用命令总结</a><time datetime="2022-08-15T07:20:44.000Z" title="发表于 2022-08-15 15:20:44">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/linux_5/" title="Linux 基础命令之 tar 解压缩详解"><img src="/img/linux/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 基础命令之 tar 解压缩详解"/></a><div class="content"><a class="title" href="/2022/07/31/linux_5/" title="Linux 基础命令之 tar 解压缩详解">Linux 基础命令之 tar 解压缩详解</a><time datetime="2022-07-31T00:22:50.000Z" title="发表于 2022-07-31 08:22:50">2022-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/13/nginx_16/" title="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离"><img src="/img/nginx/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离"/></a><div class="content"><a class="title" href="/2022/07/13/nginx_16/" title="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离">Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离</a><time datetime="2022-07-13T07:33:23.000Z" title="发表于 2022-07-13 15:33:23">2022-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/04/nginx_15/" title="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究"><img src="/img/nginx/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究"/></a><div class="content"><a class="title" href="/2022/07/04/nginx_15/" title="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究">Nginx 从入门到入坟（十四）- Nginx 缓存深入研究</a><time datetime="2022-07-04T04:20:02.000Z" title="发表于 2022-07-04 12:20:02">2022-07-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/9.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 一位木带感情的码农</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://program-park.github.io/2021/10/31/algorithm_6/'
    this.page.identifier = '/2021/10/31/algorithm_6/'
    this.page.title = '《数据结构与算法》（六）- 栈详解'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>