<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《数据结构与算法》（十）- 二叉树详解 | 程序园</title><meta name="keywords" content="数据结构,算法"><meta name="author" content="一位木带感情的码农"><meta name="copyright" content="一位木带感情的码农"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文是《数据结构与算法》系列，第十篇：二叉树。">
<meta property="og:type" content="article">
<meta property="og:title" content="《数据结构与算法》（十）- 二叉树详解">
<meta property="og:url" content="https://www.progrem-park.top/2021/11/08/algorithm_10/index.html">
<meta property="og:site_name" content="程序园">
<meta property="og:description" content="本文是《数据结构与算法》系列，第十篇：二叉树。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.progrem-park.top/img/algorithm/1.png">
<meta property="article:published_time" content="2021-11-08T07:41:51.000Z">
<meta property="article:modified_time" content="2022-12-05T04:36:25.047Z">
<meta property="article:author" content="一位木带感情的码农">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.progrem-park.top/img/algorithm/1.png"><link rel="shortcut icon" href="/img/favicon_logo/favicon.png"><link rel="canonical" href="https://www.progrem-park.top/2021/11/08/algorithm_10/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":350},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: 一位木带感情的码农","link":"链接: ","source":"来源: 程序园","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《数据结构与算法》（十）- 二叉树详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-05 12:36:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatat_img.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">程序园</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">《数据结构与算法》（十）- 二叉树详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-11-08T07:41:51.000Z" title="发表于 2021-11-08 15:41:51">2021-11-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《数据结构与算法》（十）- 二叉树详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="前言">前言</h1>
<p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p>
<h1 id="1-二叉树简介">1. 二叉树简介</h1>
<h2 id="1-1-二叉树的定义">1.1 二叉树的定义</h2>
<p>  现在我们来做个游戏，我在纸上已经写好了一个 100 以内的正整数数字，请大家想办法猜出我写的是哪一个？注意你们猜的数字不能超过 7 个，我的回答只会告诉你是 “大了” 或 “小了”。<br>
  这个游戏在一些电视节目中， 猜测一些商品的定价时常会使用。我看到过有些人是一点一点的数字累加的，比如 5、10、 15、 20 这样猜，这样的猜数策略太低级了，显然是没有学过数据结构和算法的人才做得出的事。<br>
  其实这是一个很经典的折半查找算法。如果我们用下图（下三层省略）的办法，就一定能在 7 次以内，猜出结果来。<br>
<img src="https://img-blog.csdnimg.cn/e6c7e4dc562246f2bfcb60d8516fd6b0.png#pic_center" alt="在这里插入图片描述"><br>
  由于是 100 以内的正整数，所以我们先猜 50（100 的一半），被告之 “大了”，于是再猜 25（50的一半），被告之 “小了”，再猜 37（25 与 50 的中间数），小了，于是猜 43，大了，40，大了，38，小了，39，完全正确。过程如下表所示。</p>
<table>
	<tr align=center>
		<th>被猜数字</th>
		<th>第一次</th>
		<th>第二次</th>
		<th>第三次</th>
		<th>第四次</th>
		<th>第五次</th>
		<th>第六次</th>
		<th>第七次</th>
	</tr>
	<tr align=center>
		<td>39</td>
		<td>50</td>
		<td>25</td>
		<td>37</td>
		<td>43</td>
		<td>40</td>
		<td>38</td>
		<td>39</td>
	</tr>
	<tr align=center>
		<td>82</td>
		<td>50</td>
		<td>75</td>
		<td>88</td>
		<td>82</td>
		<td>-</td>
		<td>-</td>
		<td>-</td>
	</tr>
	<tr align=center>
		<td>99</td>
		<td>50</td>
		<td>75</td>
		<td>88</td>
		<td>96</td>
		<td>98</td>
		<td>99</td>
		<td>-</td>
	</tr>
	<tr align=center>
		<td>1</td>
		<td>50</td>
		<td>25</td>
		<td>12</td>
		<td>6</td>
		<td>3</td>
		<td>2</td>
		<td>1</td>
	</tr>
</table>
&emsp;&emsp;我们发现，如果用这种方式进行查找，效率高得不是一点点。对于折半查找的详细讲解，我们后面再说。不过对于这种在某个阶段都是两种结果的情形，比如开和关、0 和 1、真和假、上和下、对与错，正面与反面等，都适合用树状结构来建模，而这种树是一种很特殊的树状结构，叫做二叉树。
<blockquote>
<p><strong>二叉树（Binary Tree）是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树）或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</strong></p>
</blockquote>
<p>  下图就是一棵二叉树。<br>
<img src="https://img-blog.csdnimg.cn/3892d22f52ed48c6893a7f6cbe58d3d4.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-2-二叉树的特点">1.2 二叉树的特点</h2>
<p>  <strong>二叉树的特点有：</strong></p>
<ul>
<li>每个结点最多有两棵子树， 所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li>
<li>左子树和右 子树是有顺序的，次序不能任意颠倒。就像人是双手、双脚，但显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会极其别扭和难受。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。下图<br>
中，树 1 和树 2 是同一棵树，但它们却是不同的二叉树。就好像你一不小<br>
心，摔伤了手，伤的是左手还是右手，对你的生活影响度是完全不同的。<br>
<img src="https://img-blog.csdnimg.cn/2b46fca48fec486295f8c4371b2600f6.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<p>  <strong>二叉树具有五种基本形态：</strong></p>
<ol>
<li>空二叉树。</li>
<li>只有一个根结点。</li>
<li>根结点只有左子树。</li>
<li>根结点只有右子树。</li>
<li>根结点既有左子树又有右子树。</li>
</ol>
<p>  应该说这五种形态还是比较好理解的，那我现在问大家，如果是有三个结点的树，有几种形态？如果是有三个结点的二叉树，考虑一下，又有几种形态？<br>
  若只从形态上考虑，三个结点的树只有两种情况，那就是下图中有两层的树 1 和有三层的后四种的任意一种，但对于二叉树来说，由于要区分左右，所以就演变成五种形态，树 2、树 3、树 4 和树 5 分别代表不同的二叉树。<br>
<img src="https://img-blog.csdnimg.cn/01c13b551d3e405b8bf079e722d045b5.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="1-2-特殊二叉树">1.2 特殊二叉树</h2>
<p>  我们再来介绍一些特殊的二叉树。这些树可能暂时你不能理解它有什么用处，但先了解一下，以后会提到它们的实际用途。<br>
  <strong>1. 斜树</strong><br>
  顾名思义，斜树一定要是斜的，但是往哪斜还是有讲究。<font color=#6495ED><strong>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</strong></font>上图中的树 2 就是左斜树，树 5 就是右斜树。斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。<br>
  有人会想，这也能叫树呀，与我们的线性表结构不是一样吗。 对的，其实线性表结构就可以理解为是树的-种极其特殊的表现形式。<br>
  <strong>2. 满二叉树</strong><br>
  苏东坡曾有词云：“人有悲欢离合，月有阴晴圆缺，此事古难全”。意思就是完美是理想，不完美才是人生。我们通常举的例子也都是左高右低、参差不齐的二叉树。那是否存在完美的二叉树呢？<br>
  完美的二叉树是存在的。<br>
  <font color=#6495ED><strong>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</strong></font><br>
  下图就是一棵满二叉树，从样子上看就感觉它很完美。<br>
<img src="https://img-blog.csdnimg.cn/670f53fe70ad45c3acb2bdb648011539.png#pic_center" alt="在这里插入图片描述"><br>
  单是每个结点都存在左右子树，不能算是满二叉树， 还必须要所有的叶子都在同一层上，这就做到了整棵树的平衡。因此，满二叉树的特点有：<br>
   (1) 叶子只能出现在最下一层。出现在其他层就不可能达成平衡。<br>
   (2) 非叶子结点的度一定是2。 否则就是 “缺胳膊少腿” 了。<br>
   (3) 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。<br>
  <strong>3. 完全二叉树</strong><br>
  <font color=#6495ED><strong>对一棵具有n个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</strong></font>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/ea6705ab755d45a8827e54b5733d827d.png#pic_center" alt="在这里插入图片描述"><br>
  这是一种有些理解难度的特殊二叉树。<br>
  首先从字面上要区分，“完全” 和 “满” 的差异，满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。<br>
  其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。这里有个关键词是<font color=#8A2BE2><strong>按层序编号</strong></font>，像下图中的树 1，因为 5 结点没有左子树，却有右子树，那就使得按层序编号的第 10 个编号空档了，它不是完全二叉树。同样道理，下图中的树 2，由于 3 结点没有子树，所以使得 6、7 编号的位置空档了，它也不是完全二叉树。下图中的树 3 又是因为 5 编号下没有子树造成第 10 和第 11 位置空档，同样不是完全二叉树。只有上图中的树，尽管它不是满二叉树，但是编号是连续的，所以它是完全二叉树。<br>
<img src="https://img-blog.csdnimg.cn/08615b5ba92d4494a06c675d2a155e4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
  从这里我们也可以得出一些完全二叉树的特点：<br>
   (1) 叶子结点只能出现在最下两层。<br>
   (2) 最下层的叶子一定集中在左部连续位置。<br>
   (3) 倒数二层，若有叶子结点，一定都在右部连续位置。<br>
   (4) 如果结点度为 1，则该结点只有左孩子，即不存在只有右子树的情况。<br>
   (5) 同样结点数的二叉树，完全二叉树的深度最小。<br>
  从上面的例子，也给了我们一个判断某二叉树是否是完全二叉树的办法，那就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空档，就说明不是完全二叉树，否则就是。<br>
<br></p>
<h1 id="2-二叉树的性质">2. 二叉树的性质</h1>
<p>  二叉树有一些需要理解并记住的特性，以便于我们更好地使用它。</p>
<h2 id="2-1-二叉树的性质1">2.1 二叉树的性质1</h2>
<p>  <font color=#6495ED><strong>性质1：在二叉树的第 i 层上至多有 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>i</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^i}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点（i≥1）。</strong></font><br>
  这个性质很好记忆，观察一下满二叉树。<br>
<img src="https://img-blog.csdnimg.cn/670f53fe70ad45c3acb2bdb648011539.png#pic_center" alt="在这里插入图片描述"><br>
  第一层是根结点，只有一个，所以 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^1}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>=2^0^=1。<br>
  第二层有两个，2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^2}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>=2^1^=2。<br>
  第三层有四个，2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>3</mn></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^3}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>=2^2^=4。<br>
  第四层有八个，2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>4</mn></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^4}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>=2^3^=8。<br>
  通过数据归纳法的论证，可以很容易得出在二叉树的第<code>i</code>层上至多有 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>i</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^i}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点（i≥1）的结论。</p>
<h2 id="2-2-二叉树的性质2">2.2 二叉树的性质2</h2>
<p>  <font color=#6495ED><strong>性质2：深度为k的二叉树至多有 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>k</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^k}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点(k≥1)。</strong></font><br>
  注意这里一定要看清楚，是<code>2k</code>后再减去 1，而不是 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>k</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^k}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>。以前很多人不能完全理解，这样去记忆，就容易把性质2与性质1给弄混淆了。<br>
  深度为<code>k</code>意思就是有<code>k</code>层的二叉树，我们先来看看简单的。<br>
  如果有一层，至多1=2^1^-1个结点。<br>
  如果有二层，至多1+2=3=2^2^-1个结点。<br>
  如果有三层，至多1+2+4=7=2^3^-1个结点。<br>
  如果有四层，至多1+2+4+8=15=2^4^-1个结点。<br>
  通过数据归纳法的论证，可以得出，如果有<code>k</code>层，此二叉树至多有 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>k</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^k}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点。</p>
<h2 id="2-3-二叉树的性质3">2.3 二叉树的性质3</h2>
<p>  <font color=#6495ED><strong>性质3：对任何-棵二叉树T,如果其终端结点数为Do,度为2的结点数为n2,则no=n2+1。</strong></font><br>
  终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剩下的就是度为 1 或 2 的结点数了，我们设 n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为度是 1 的结点数。则树<code>T</code>结点总数 n=n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。<br>
  比如下图的例子，结点总数为 10，它是由 A、B、C、D 等度为 2 结点，F、G、H、I、J 等度为 0 的叶子结点和 E 这个度为 1 的结点组成。总和为 4+1+5=10。<br>
<img src="https://img-blog.csdnimg.cn/7ba77b23bfea4854a54279896e720464.png#pic_center" alt="在这里插入图片描述"><br>
  我们换个角度，再数一数它的连接线数，由于根结点只有分支出去，没有分支进入，所以分支线总数为结点总数减去 1。上图就是 9 个分支。对于 A、B、C、D 结点来说，它们都有两个分支线出去，而 E 结点只有一个分支线出去。所以总分支线为 4×2+1×1=9。<br>
  用代数表达就是分支线总数=n-1=n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+ 2n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。因为刚才我们有等式 n=n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所以可推导出 n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+2n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。结论就是 n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>+ 1。</p>
<h2 id="2-4-二叉树的性质4">2.4 二叉树的性质4</h2>
<p>  <font color=#6495ED><strong>性质4：具有n个结点的完全二叉树的深度为[log<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>n]+1（[x]表示不大于 x的最大整数）。</strong></font><br>
  由满二叉树的定义我们可以知道，深度为<code>k</code>的满二叉树的结点数<code>n</code>一定是 2^k^-1。因为这是最多的结点个数。那么对于 n=2^k^-1 倒推得到满二叉树的度数为 k=log<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(n+1)，比如结点数为 15 的满二叉树，深度为 4。<br>
  完全二叉树我们前面已经提到，它是一棵具有<code>n</code>个结点的二叉树，若按层序编号后其编号与同样深度的满二叉树中编号结点在二叉树中位置完全相同，那它就是完全二叉树。也就是说，它的叶子结点只会出现在最下面的两层。<br>
  它的结点数一定少于等于同样度数的满二叉树的结点数2^k^-1，但一定多于 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>k</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^k}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1。即满足 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>k</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^k}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1&lt;n≤2^k^-1。由于结点数<code>n</code>是整数，n≤2^k^-1 意味着 n&lt;2^k^，n&gt;2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>k</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^k}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1，意味着 n≥2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>k</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^k}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>，所以 2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mi>k</mi></msup><msup><mrow></mrow><mo>−</mo></msup><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">{^k}{^-}{^1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>≤n&lt;2^k^，不等式两边取对数，得到k-1≤log<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>n&lt;k，而<code>k</code>作为深度也是整数，因此 k=[log<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>n]+1。</p>
<h2 id="2-5-二叉树的性质5">2.5 二叉树的性质5</h2>
<p>  <font color=#6495ED><strong>性质5：如果对一棵有n个结点的完全二叉树（其深度为[log<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>n]+1）的结点按层序编号（从第1层到第[log<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>n]+1层，每层从左到右），对任-结点 i (1&lt;i≤n)有：</strong></font></p>
<ol>
<li><font color=#6495ED><strong>如果i=1，则结点 i 是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点[i/2]。</strong></font></li>
<li><font color=#6495ED><strong>如果2i&gt;n，则结点 i 无左孩子（结点i为叶子结点）；否则其左孩子是结点 2i。</strong></font></li>
<li><font color=#6495ED><strong>如果2i+1&gt;n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</strong></font></li>
</ol>
<p>  我们以下图为例，来理解这个性质。这是一个完全二叉树，度为 4，结点总数是 10。<br>
<img src="https://img-blog.csdnimg.cn/49a21a9ffdc64125a8f6f252b3afd4c2.png#pic_center" alt="在这里插入图片描述"><br>
  对于第一条来说是很显然的，<code>i=1</code>时就是根结点。<code>i&gt;1</code>时，比如结点 7，它的双亲就是 [7/2]=3，结点 9，它的双亲就是 [9/2]=4。<br>
  第二条，比如结点 6，因为 2×6=12 超过了结点总数 10，所以结点 6 无左孩子，它是叶子结点。同样，而结点 5，因为 2×5=10 正好是结点总数 10，所以它的左孩子是结点 10。<br>
  第三条，比如结点 5，因为 2×5+1=11，大于结点总数 10，所以它无右孩子。而结点 3，因为 2×3+1=7 小于 10，所以它的右孩子是结点 7。<br>
<br></p>
<h1 id="3-二叉树的存储结构">3. 二叉树的存储结构</h1>
<h2 id="3-1-二叉树顺序存储结构">3.1 二叉树顺序存储结构</h2>
<p>  前面我们已经谈到了树的存储结构，并且谈到顺序存储对树这种一对多的关系结构实现起来是比较困难的。但是二叉树是一种特殊的树，由于它的特殊性，使得用顺序存储结构也可以实现。<br>
  二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。<br>
  先来看看完全二叉树的顺序存储，-一完全二叉树如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/4a91fb144a584ef785328484dcb0de5a.png#pic_center" alt="在这里插入图片描述"><br>
  将这棵二叉树存入到数组中，相应的下标对应其同样的位置，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/e72fdf6bb66f485ebfcf96f58d05ee7e.png#pic_center" alt="在这里插入图片描述"><br>
  这下看出完全二叉树的优越性来了吧。由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。<br>
  当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为 “^” 而已。如下图，注意浅色结点表示不存在。<br>
<img src="https://img-blog.csdnimg.cn/3e389237675b4b0e82f54fe356d449a0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_6,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
  考虑种极端的情况，一棵深度为<code>k</code>的右斜树，它只有<code>k</code>个结点，却需要分配 2^k^-1 个存储单元空间，这显然是对存储空间的浪费，例如下图所示。所以，顺序存储结构一般只用于完全二叉树。<br>
<img src="https://img-blog.csdnimg.cn/1ce5a577939b4fac931b19e38c8b8e0f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-2-二叉链表">3.2 二叉链表</h2>
<p>  既然顺序存储适用性不强，我们就要考虑链式存储结构。<font color=#6495ED><strong>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域</strong></font>是比较自然的想法，<font color=#6495ED><strong>我们称这样的链表叫做叉链表。</strong></font>结点结构图如下表所示。<br>
<img src="https://img-blog.csdnimg.cn/6741ff4f21874684b07b918e398d8d38.png#pic_center" alt="在这里插入图片描述"><br>
  其中<code>data</code>是数据城，<code>lchild</code>和<code>rchild</code>都是指针域，分别存放指向左孩子和右孩子的指针。<br>
  以下是我们的二叉链表的结点结构定义代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>	/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p>  结构示意图如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/25cea8831f4445d795b19f30963b33e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
  就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。由于与树的存储结构类似，这里就不详述了。<br>
<br></p>
<h1 id="4-遍历二叉树">4. 遍历二叉树</h1>
<h2 id="4-1-二叉树的遍历原理">4.1 二叉树的遍历原理</h2>
<p>  假设，我手头有 20 张 100 元的和 2000 张 1 元的奖券，同时洒向了空中，大家比赛看谁最终捡的最多。如果是你，你会怎么做？<br>
  相信所有同学都会说，一定先捡 100 元的。道理非常简单，因为捡一张 100 元等于 1 元的捡 100 张，效率好得不是一点点。所以可以得到这样的结论，同样是捡奖券，在有限时间内，要达到最高效率，次序非常重要。对于二叉树的遍历来讲，次序同样显得很重要。</p>
<blockquote>
<p><strong>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问次且仅被访问一次。</strong></p>
</blockquote>
<p>  这里有两个关键词：<font color=#8A2BE2><strong>访问</strong></font>和<font color=#8A2BE2><strong>次序</strong></font>。<br>
  访问其实是要根据实际的需要来确定具体做什么，比如对每个结点进行相关计算，输出打印等，它算作是一个抽象操作。在这里我们可以简单地假定就是输出结点的数据信息。<br>
  二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的遍历方式。树的结点之间不存在唯一的前驱和后继关系，在访向一个结点后，下一个被访问的结点面临着不同的选择。就像你人生的道路上，高考填志愿要面临哪个城市、哪所大学、具体专业等选择，由于选择方式的不同，遍历的次序就完全不同了。</p>
<h2 id="4-2-二叉树的遍历方法">4.2 二叉树的遍历方法</h2>
<p>  二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为四种：</p>
<ol>
<li><strong>前序遍历</strong><br>
<font color=#6495ED><strong>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</strong></font>如下图所示，遍历的顺序为：ABDGHCEIF。<br>
<img src="https://img-blog.csdnimg.cn/9b913d623b99484cb676af09780dc23b.png" alt="在这里插入图片描述"></li>
<li><strong>中序遍历</strong><br>
<font color=#6495ED><strong>规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</strong></font>如下图所示，遍历的顺序为：GDHBAEICF。<br>
<img src="https://img-blog.csdnimg.cn/769bf895ceac42c18834523542b9205d.png" alt="在这里插入图片描述"></li>
<li><strong>后序遍历</strong><br>
<font color=#6495ED><strong>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访向根结点。</strong></font>如下图所示，遍历的顺序为：GHDBIEFCA。<br>
<img src="https://img-blog.csdnimg.cn/44d11fd9103f4956ac0a975a89070bfb.png" alt="在这里插入图片描述"></li>
<li><strong>层序遍历</strong><br>
<font color=#6495ED><strong>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</strong></font>如下图所示，遍历的顺序为：ABCDEFGHI。<br>
<img src="https://img-blog.csdnimg.cn/e43f2fd026d14ef3811663df8e127859.png" alt="在这里插入图片描述"><br>
  有同学会说，研究这么多遍历的方法干什么呢？<br>
  我们用图形的方式来表现树的结构，应该说是非常直观和容易理解，但是对于计算机来说，它只有循环、判断等方式来处理，也就是说，它只会处理线性序列，而我们刚才提到的四种遍历方法，其实都是在把树中的结点变成某种意义的线性序列，这就给程序的实现带来了好处。<br>
  另外不同的遍历提供了对结点依次处理的不同方式，可以在遍历过程中对结点进行各种处理。</li>
</ol>
<h2 id="4-3-前序遍历算法">4.3 前序遍历算法</h2>
<p>  二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。先来看看二叉树的前序遍历算法。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的前序遍历递归算法 */</span></span><br><span class="line"><span class="comment">/* 初始条件：二叉树T存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：前序递归遍历T */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%C&quot;</span>,T-&gt;data);	<span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">	PreOrderTraverse(T-&gt;lchild);	<span class="comment">/* 先序遍历左子树 */</span></span><br><span class="line">	PreOrderTraverse(T-&gt;rchild);	<span class="comment">/* 先序遍历右子树*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  假设我们现在有如下图这样一棵二叉树<code>T</code>。这树已经用二叉链表结构存储在内存当中。<br>
<img src="https://img-blog.csdnimg.cn/f53657377ae245e5bbe76e54f794124a.png#pic_center" alt="在这里插入图片描述"><br>
  那么当调用<code>PreOrderTraverse(T)</code>函数时，我们来看看程序是如何运行的。</p>
<ol>
<li>调用<code>PreOrderTraverse(T)</code>，<code>T</code>根结点不为<code>null</code>，所以执行<code>printf</code>，打印字母<code>A</code>，如所示。<br>
<img src="https://img-blog.csdnimg.cn/48cffc3ce8ca4ee3aefa19be200a0a52.png" alt="在这里插入图片描述"></li>
<li>调用<code>PreOrderTraverse(T-&gt;lchild);</code>访问了<code>A</code>结点的左孩子，不为<code>null</code>，执行<code>printf</code>显示字母<code>B</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/6333ddf8b0a24d8e880b1b9a3f202b4e.png" alt="在这里插入图片描述"></li>
<li>此时再次递归调用<code>PreOrderTraverse(T-&gt;lchild);</code>访问了<code>B</code>结点的左孩子，执行<code>printf</code>显示字母<code>D</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/0b9e924c3b284af189b35ef7ceddb5c7.png" alt="在这里插入图片描述"></li>
<li>再次递归调用<code>PreOrderTraverse(T-&gt;lchild);</code>访问了<code>D</code>结点的左孩子，执行<code>printf</code>显示字母<code>H</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/f0c5806033174245bf89fa9a9149c369.png" alt="在这里插入图片描述"></li>
<li>再次递归调用<code>PreOrderTraverse(T-&gt;lchild);</code>访问了<code>H</code>结点的左孩子，此时因为<code>H</code>结点无左孩子，所以<code>T==null</code>，返回此函数，此时递归调用<code>PreOrderTraverse(T&gt;rchild);</code>访问了<code>H</code>结点的右孩子，<code>printf</code>显示字母<code>K</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/e0511c9e8fb44fc39db22f5180d5684c.png" alt="在这里插入图片描述"></li>
<li>再次递归调用<code>PreOrderTraverse(T-&gt;lchild);</code>访向了<code>K</code>结点的左孩子，<code>K</code>结点无左孩子，返回，调用<code>PreOrderTraverse(T-&gt;rchild);</code>访问了<code>K</code>结点的右孩子，也是<code>null</code>，返回。于是此函数执行完毕，返回到上一级递归的函数（即打印<code>H</code>结点时的函数），也执行完毕，返回到打印结点<code>D</code>时的函数，调用<code>PreOrderTraverse(T-&gt;rchild);</code>访问了<code>D</code>结点的右孩子，不存在，返回到<code>B</code>结点，调用<code>PreOrderTraverse(T-&gt;rchild);</code>找到了结点<code>E</code>，打印字母<code>E</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/ea73bb6e464746bfa407423446f69ab1.png" alt="在这里插入图片描述"></li>
<li>由于结点<code>E</code>没有左右孩子，返回打印结点<code>B</code>时的递归函数，递归执行完毕，返回到最初的<code>PreOrderTraverse</code>，调用<code>PreOrderTraverse(T-&gt;rchid);</code>访问结点<code>A</code>的右孩子，打印字母<code>C</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/7d5e34714ca042f2bccb40be9a27e053.png" alt="在这里插入图片描述"></li>
<li>之后类似前面的递归调用，依次继续打印 F、1、G、J，步骤略。</li>
</ol>
<p>  综上，前序遍历这棵二叉树的节点顺序是：ABDHKECFIGJ。</p>
<h2 id="4-4-中序遍历算法">4.4 中序遍历算法</h2>
<p>  二叉树的中序遍历算法是如何呢？它和前序遍历算法仅仅只是代码的顺序上的差异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的中序遍历递归算法 */</span></span><br><span class="line"><span class="comment">/* 初始条件：二叉树T存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：中序递归遍历T */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	InOrderTraverse(T-&gt;lchild);	<span class="comment">/* 中序遍历左子树 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%C&quot;</span>,T-&gt;data);	<span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">	InOrderTraverse(T-&gt;rchild);	<span class="comment">/* 中序遍历右子树*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  换句话说，它等于是把调用左孩子的递归函数提前了，就这么简单。我们来看看当调用<code>InOrderTraverse(T)</code>函数时，程序是如何运行的。</p>
<ol>
<li>调用<code>InOrderTraverse (T)</code>，<code>T</code>的根结点不为<code>null</code>，于是调用<code>InOrderTraverse(T-&gt;lchild);</code>访问结点<code>B</code>。当前指针不为<code>null</code>，继续调用<code>InOrderTraverse (T-&gt;lchild);</code>访问结点D。不为<code>null</code>, 继续调用<code>InOrderTraverse(T-&gt;child);</code>访问结点<code>H</code>。继续调用<code>InOrderTraverse (T-&gt;lchild);</code>访问结点<code>H</code>的左孩子，发现当前指针为<code>null</code>，于是返回。打印当前结点<code>H</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/847a6920349447ccb7157ec420d6f92f.png" alt="在这里插入图片描述"></li>
<li>然后调用<code>InOrderTraverse(T-&gt;rchild);</code>访问结点<code>H</code>的右孩子<code>K</code>，因结点<code>K</code>无左孩子，所以打印<code>K</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/56563f07e8f44fc98e76dd988effad97.png" alt="在这里插入图片描述"></li>
<li>因为结点<code>K</code>没有右孩子，所以返回。打印结点<code>H</code>函数执行完毕，返回。打印字母<code>D</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/4f234e68476848a382a3bdb45cf14869.png" alt="在这里插入图片描述"></li>
<li>结点<code>D</code>无右孩子，此函数执行完毕，返回。打印字母<code>B</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/7a0e171250b541bca7aa6138b3a69c58.png" alt="在这里插入图片描述"></li>
<li>调用<code>InOrderTraverse(T-&gt;rchild);</code>访问结点<code>B</code>的右孩子<code>E</code>，因结点<code>E</code>无左孩<br>
子，所以打印<code>E</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/8589c65d921941e69159f80f74805bd8.png" alt="在这里插入图片描述"></li>
<li>结点<code>E</code>无右孩子，返回。结点<code>B</code>的递归函数执行完毕，返回到了最初我们调用<code>InOrderTraverse</code>的地方，打印字母<code>A</code>，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/612a507115ee448494c3e542ddbf1bc4.png" alt="在这里插入图片描述"></li>
<li>再调用<code>InOrderTraverse(T-&gt;rchild);</code>访向结点<code>A</code>的右孩子<code>C</code>，再递归访问结点<code>C</code>的左孩子<code>F</code>，结点<code>F</code>的左孩子<code>I</code>。因为<code>I</code>无左孩子，打印<code>I</code>，之后分别打印 F、C、G、J。步骤省略。</li>
</ol>
<p>  综上，中序遍历这棵二叉树的节点顺序是：HKDBEAIFCGJ。</p>
<h2 id="4-5-后序遍历法">4.5 后序遍历法</h2>
<p>  那么同样的，后序遍历也就很容易想到应该如何写代码了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的后序遍历递归算法 */</span></span><br><span class="line"><span class="comment">/* 初始条件：二叉树T存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果：中序递归遍历T */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostorderTraverse</span> <span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	PostorderTraverse (T-&gt;lchild);	<span class="comment">/* 后序遍历左子树 */</span></span><br><span class="line">	PostorderTraverse (T-&gt;rchild);	<span class="comment">/* 后序遍历右子树*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%C&quot;</span>,T-&gt;data);	<span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如下图所示，后序遍历是先递归左子树，由根结点<code>A→B→D→H</code>，结点<code>H</code>无左孩子，再查看结点<code>H</code>的右孩子<code>K</code>，因为结点<code>K</code>无左右孩子，所以打印<code>K</code>，返回。</p>
<h2 id="4-6-推导遍历结果">4.6 推导遍历结果</h2>
<p>  有一种题目为了考查你对二叉树遍历的掌握程度，是这样出题的。已知一棵二叉树的前序遍历序列为 ABCDEF，中序遍历序列为 CBAEDF，请问这棵二叉树的后序遍历结果是多少？<br>
  对于这样的题目，如果真的完全理解了前中后序的原理，是不难的。<br>
  三种遍历都是从根结点开始，前序遍历是先打印再递归左和右。所以前序遍历序列为 ABCDEF，第一个字母是<code>A</code>被打印出来，就说明<code>A</code>是根结点的数据。再由中序遍历序列是 CBAEDF，可以知道<code>C</code>和<code>B</code>是<code>A</code>的左子树的结点，E、D、F 是<code>A</code>的右子树的结点，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/31e886dc03974e66871d9c417b020f95.png#pic_center" alt="在这里插入图片描述"><br>
  然后我们看前序中的<code>C</code>和<code>B</code>，它的顺序是 ABCDEF，是先打印<code>B</code>后打印<code>C</code>，所以<code>B</code>应该是<code>A</code>的左孩子，而<code>C</code>就只能是<code>B</code>的孩子，此时是左孩子还是右孩子还不确定。再看中序序列是CBAEDF，<code>C</code>是在<code>B</code>的前面打印，这就说明<code>C</code>是<code>B</code>的左孩子，否则就是右孩子了，如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/09d37b8c0c9e4978bb85153897413a60.png#pic_center" alt="在这里插入图片描述"><br>
  再看前序中的 E、D、F，它的顺序是 ABCDEF，那就意味着<code>D</code>是<code>A</code>结点的右孩子，<code>E</code>和<code>F</code>是<code>D</code>的子孙，注意，它们中有一个不一定是孩子，还有可能是孙子。再来看中序序列是 CBAEDF，由于<code>E</code>在<code>D</code>的左侧，而<code>F</code>在右侧，所以可以确定<code>E</code>是<code>D</code>的左孩子，<code>F</code>是<code>D</code>的右孩子。因此最终得到的二叉树如下图所示。<br>
<img src="https://img-blog.csdnimg.cn/43065060d26242b3b91ea48fb364761d.png#pic_center" alt="在这里插入图片描述"><br>
  为了避免推导中的失误，你最好在心中递归遍历，检查一下 这棵树的前序和中序遍历序列是否与题目中的相同。<br>
  已经复原了二叉树，要获得它的后序遍历结果就是易如反掌，结果是 CBEFDA。<br>
  但其实，如果同学们足够熟练，不用画这棵二叉树，也可以得到后序的结果，因为刚才判断了<code>A</code>结点是根结点，那么它在后序序列中，一定是最后一个。 刚才推导出<code>C</code>是<code>B</code>的左孩子，而<code>B</code>是<code>A</code>的左孩子，那就意味着后序序列的前两位一定是<code>CB</code>。同样的办法也可以得到<code>EFD</code>这样的后序顺序，最终就自然的得到 CBEFDA 这样的序列，不用在草稿上画树状图了。<br>
  反过来，如果我们的题目是这样：二叉树的中序序列是 ABCDEFG，后序序列是 BDCAFGE，求前序序列。<br>
  这次简单点，由后序的 BDCAFGE，得到<code>E</code>是根结点，因此前序首字母是<code>E</code>。<br>
  于是根据中序序列分为两棵树 ABCD 和 FG，由后序序列的 BDCAFGE，知道<code>A</code>是<code>E</code>的左孩子，前序序列目前分析为EA。<br>
  再由中序序列的 ABCDEFG，知道 BCD 是<code>A</code>结点的右子孙，再由后序序列的 BDCAFGE 知道<code>C</code>结点是<code>A</code>结点的右孩子，前序序列目前分析得到 EAC。<br>
  中序序列 ABCDEFG，得到<code>B</code>是<code>C</code>的左孩子，<code>D</code>是<code>C</code>的右孩子，所以前序序列目前分析结果为 EACBD。<br>
  由后序序列 BDCAFGE，得到<code>G</code>是<code>E</code>的右孩子，于是<code>F</code>就是<code>G</code>的孩子。如果你是在考试时做这道题目，时间就是分数、名次、学历，那么你根本不需关心<code>F</code>是<code>G</code>的左还是右孩子，前序遍历序列的最终结果就是 EACBDGF。<br>
  不过细细分析，根据中序序列 ABCDEEG，是可以得出<code>F</code>是<code>G</code>的左孩子。<br>
  从这里我们也得到两个二叉树遍历的性质。</p>
<ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
</ul>
<p>  但要注意了，<font color=#6495ED><strong>已知前序和后序遍历，是不能确定一棵二叉树的</strong></font>，原因也很简单，比如前序序列是 ABC，后序序列是 CBA。我们可以确定<code>A</code>一定是根结点，但接下来，我们无法知道，哪个结点是左子树，哪个是右子树。这棵树可能有如下图所示的四种可能。<br>
<img src="https://img-blog.csdnimg.cn/5de1636d01a041e78cd9193f40974326.png#pic_center" alt="在这里插入图片描述"><br>
<br></p>
<h1 id="5-二叉树的建立">5. 二叉树的建立</h1>
<p>  说了半天，我们如何在内存中生成一棵二叉链表的二叉树呢？树都没有，哪来遍历。所以我们还得来谈谈关于二叉树建立的问题。<br>
  如果我们要在内存中建立一个如下图中左图这样的树，为了能让每个结点确认是否有左右孩子，我们对它进行了扩展，变成下图中右图的样子，也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如 “#”。 我们称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。比如下图的前序遍历序列就为 AB#D##C##。<br>
<img src="https://img-blog.csdnimg.cn/f12e1073bf004234bd0bf5ea3a5ca672.png#pic_center" alt="在这里插入图片描述"><br>
  有了这样的准备，我们就可以来看看如何生成一棵二叉树了。假设二叉树的结点均为一个字符，我们把刚才前序遍历序列 AB#D##C# 用键盘挨个输入。实现的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按前序输入二又树中结点的值(一个字符) */</span></span><br><span class="line"><span class="comment">/* #表示空树，构造二叉链表表示二叉树T。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">	TElemType ch;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%C&quot;</span>,&amp;ch);</span><br><span class="line">	ch=str[index++];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">		*T=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		<span class="keyword">if</span>(!*T)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		(*T)-&gt;data=ch;	<span class="comment">/* 生成根结点 */</span></span><br><span class="line">		CreateBiTree(&amp;(*T)-&gt;lchi1d);	<span class="comment">/* 构造左子树 */</span></span><br><span class="line">		CreateBiTree(&amp;(*T)-&gt;rchild);	<span class="comment">/* 构造右子树 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其实建立二叉树，也是利用了递归的原理。只不过在原来应该是打印结点的地方，改成了生成结点、给结点赋值的操作而已。所以大家理解了前面的遍历的话，对于这段代码就不难理解了。<br>
<br></p>
<h1 id="6-线索二叉树">6. 线索二叉树</h1>
<h2 id="6-1-线索二叉树的原理">6.1 线索二叉树的原理</h2>
<p>  我们现在提倡节约型社会，一切都应该节约为本。对待我们的程序当然也不例外，能不浪费的时间或空间，都应该考虑节省。我们再来观察下图，会发现指针域并不是都充分的利用了，有许许多多的 “^”，也就是空指针域的存在，这实在不是好现象，应该要想办法利用起来。<br>
<img src="https://img-blog.csdnimg.cn/f449fb50cd944e74bac3789830da9859.png#pic_center" alt="在这里插入图片描述"><br>
  首先我们要来看看这空指针有多少个呢？对于一个有<code>n</code>个结点的二叉链表，每个结点有指向左右孩子的两个指针域，所以一共是<code>2n</code>个指针域。而<code>n</code>个结点的二叉树一共有<code>n-1</code>条分支线数，也就是说，其实是存在<code>2n-(n-1)=n+1</code>个空指针域。比如上图有 10 个结点，而带有 “^&quot; 空指针城为 11。这些空间不存储任何事物，白白的浪费着内存的资源。<br>
  另一方面，我们在做遍历时，比如对上图做中序遍历时，得到了 HDIBJEAFCG 这样的字符序列，遍历过后，我们可以知道，结点 1 的前驱是<code>D</code>，后继是<code>B</code>，结点<code>F</code>的前驱是<code>A</code>，后继是<code>C</code>。也就是说，我们可以很清楚的知道任意一个结点，它的前驱和后继是哪一个。<br>
  可是这是建立在已经遍历过的基础之上的。在二叉链表上，我们只能知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱是谁，后继是谁。要想知道，必须遍历一次。 以后每次需要知道时，都必须先遍历一次。为什么不考虑在创建时就记住这些前驱和后继呢，那将是多大的时间上的节省。<br>
  综合刚才两个角度的分析后，我们可以考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址。就好像 GPS 导航仪一样，我们开车的时候，哪怕我们对具体目的地的位置一无所知， 但它每次都可以告诉我从当前位置的下一步应该走向哪里。这就是我们现在要研究的问题。我们把这种<font color=#6495ED><strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</strong></font><br>
  请看下图，我们把这棵二叉树进行中序遍历后，将所有的空指针域中的<code>rchild</code>，改为指向它的后继结点。于是我们就可以通过指针知道<code>H</code>的后继是<code>D</code>（图中①），<code>I</code>的后继是<code>B</code>（图中②），<code>J</code>的后继是E（图中③），<code>E</code>的后继是<code>A</code> （图中④），<code>F</code>的后继是<code>C</code> （图中⑤），<code>G</code>的后继因为不存在而指向<code>NULL</code>（图中⑥）。此时共有 6 个空指针域被利用。<br>
<img src="https://img-blog.csdnimg.cn/8fef8b79c82144b780b63c61307fcdc3.png#pic_center" alt="在这里插入图片描述"><br>
  再看下图，我们将这棵二叉树的所有空指针域中的<code>lchild</code>，改为指向当前结点的前驱。因此<code>H</code>的前驱是<code>NULL</code>（图中①），<code>I</code>的前驱是<code>D</code>（图中②），<code>J</code>的前驱是<code>B</code>（图中③），<code>F</code>的前驱是<code>A</code>（图中④），<code>G</code>的前驱是<code>C</code>（图中⑤）。一共 5 个空指针域被利用，正好和上面的后继加起来是 11 个。<br>
<img src="https://img-blog.csdnimg.cn/38a2e1c0763c4551a8ddf7b011902d0a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
  通过下图（空心箭头实线为前驱，虚线黑箭头为后继），就更容易看出，其实线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点、查找某个结点都带来了方便。所以我们<font color=#6495ED><strong>对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。</strong></font><br>
<img src="https://img-blog.csdnimg.cn/6a0a7583b4624dffb1609e1d93c5c97b.png#pic_center" alt="在这里插入图片描述"><br>
  不过好事总是多磨的，问题并没有彻底解决。我们如何知道某一结点的<code>lchild</code>是指向它的左孩子还是指向前驱？<code>rchild</code>是指向右孩子还是指向后继？比如<code>E</code>结点的<code>lchild</code>是指向它的左孩子<code>J</code>，而<code>rchild</code>却是指向它的后继<code>A</code>。显然我们在决定<code>lchild</code>是指向左孩子还是前驱，<code>rchild</code>是指向右孩子还是后继上是需要一个区分标志的。 因此，我们在每个结点再增设两个标志域<code>ltag</code>和<code>rtag</code>，注意<code>ltag</code>和<code>rtag</code>只是存放 0 或 1 数字的布尔型变量，其占用的内存空间要小于像<code>lchild</code>和<code>rchild</code>的指针变量。结点结构如下表所示。<br>
<img src="https://img-blog.csdnimg.cn/3806e7f695e345d88c9f9ecb1f853602.png#pic_center" alt="在这里插入图片描述"><br>
  <strong>其中：</strong></p>
<ul>
<li><code>ltag</code>为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱。</li>
<li><code>rtag</code>为 0 时指向该结点的右孩子，为 1 时指向该结点的后继。</li>
</ul>
<p>  因此对于本章节第一张图的二叉链表图可以修改为下图的样子。<br>
<img src="https://img-blog.csdnimg.cn/5a3b3a928ff54970bde1c66c25151280.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="6-2-线索二叉树结构实现">6.2 线索二叉树结构实现</h2>
<p>  由此二叉树的线案存储结构定义代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的二叉线索存储结构定义 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>Link,Thread&#125; PointerTag;	<span class="comment">/* Link=0表示指向左右孩子指针, */</span></span><br><span class="line">										<span class="comment">/* Thread=1表示指向前驱或后继的线索 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>	/* 二叉线索存储结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType data;	<span class="comment">/* 结点数据 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>	<span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">	PointerTag LTag;</span><br><span class="line">	PointerTag RTag;	<span class="comment">/* 左右标志 */</span></span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<p>  线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以<font color=#6495ED><strong>线索化的过程就是在遍历的过程中修改空指针的过程。</strong></font><br>
  中序遍历线索化的递归函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre;	<span class="comment">/* 全局变量，始终指向刚刚访问过的结点 */</span></span><br><span class="line"><span class="comment">/* 中序遍历进行中序线索化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		InThreading(p-&gt;lchi1d);	<span class="comment">/* 递归左子树线索化 */</span></span><br><span class="line">		<span class="keyword">if</span>(!p-&gt;<span class="number">1</span>child)	<span class="comment">/* ★★★没有左孩子 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;LTag=Thread;	<span class="comment">/* ★★★前驱线索 */</span></span><br><span class="line">			p-&gt;lchi1d=pre;	<span class="comment">/* ★★★左孩子指针指向前驱 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!pre-&gt;rchild)	<span class="comment">/* ★★★前驱没有右孩子 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;RTag=Thread;	<span class="comment">/* ★★★后继线索 */</span></span><br><span class="line">			pre-&gt;rchild=p;	<span class="comment">/* ★★★前驱右孩子指针指向后继(当前结点p) */</span></span><br><span class="line">		&#125;</span><br><span class="line">		pre=p;	<span class="comment">/* ★★★保持pre指向p的前驱 */</span></span><br><span class="line">		InThreading(p-&gt;rchild);	<span class="comment">/* 递归右子树线索化 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  你会发现，这代码除加<code>★★★</code>以外，和二叉树中序遍历的递归代码几乎完全一样。只不过将本是打印结点的功能改成了线索化的功能。<br>
  中间加粗部分代码是做了这样的一些事：<br>
  <code>if(p-&gt;lchild)</code>表示如果某结点的左指针域为空，因为其前驱结点刚刚访问过，赋值给了<code>pre</code>，所以可以将<code>pre</code>赋值给<code>p-&gt;lchild</code>，并修改<code>p-&gt;LTag=Thread</code>（也就是定义为 1）以完成前驱结点的线索化。<br>
  后继就要稍稍麻烦一些。因为此时<code>p</code>结点的后继还没有访问到，因此只能对它的前驱结点<code>pre</code>的右指针<code>rchild</code>做判断，<code>if(!pre-&gt;rchild)</code>表示如果为空，则<code>p</code>就是<code>pre</code>的后继，于是<code>pre-&gt;rchild=p</code>，并且设置<code>pre-&gt;RTag=Thread</code>，完成后继结点的线索化。<br>
  完成前驱和后继的判断后，别忘记将当前的结点<code>p</code>赋值给<code>pre</code>，以便于下一次使用。<br>
  有了线索二叉树后，我们对它进行遍历时发现，其实就等于是操作一个双向链表结构。<br>
  和双向链表结构一样，在二叉树线索链表上添加一个头结点，如下图所示，并令其<code>lchild</code>域的指针指向二叉树的根结点（图中的①），其<code>rchid</code>域的指针指向中序遍历时访问的最后一个结点（图中的②）。反之，令二叉树的中序序列中的第一个结点中，<code>lchild</code>域指针和最后一个结点的<code>rchild </code>域指针均指向头结点（图中的③和④）。这样定义的好处就是我们既可以从第一个结点起顺后继进行遍历，也可以从最后一个结点起顺前驱进行遍历。<br>
<img src="https://img-blog.csdnimg.cn/397fed4e1ecf4eb59f04e0cd7c47c6cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>
  遍历的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T指向头结点， 头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的 */</span></span><br><span class="line"><span class="comment">/* 最后一个结点。中序遍历二叉线索链表表示的二叉树T */</span></span><br><span class="line">Status <span class="title function_">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	BiThrTree p;</span><br><span class="line">	p=T-&gt;<span class="number">1</span>child;	<span class="comment">/* p指向根结点 */</span></span><br><span class="line">	<span class="keyword">while</span>(p!=T)	<span class="comment">/* 空树或遍历结束时，p==T */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(p-&gt;LTag==Link)	<span class="comment">/* 当LTag--O时循环到中序序列第一个结点 */</span></span><br><span class="line">			p=p-&gt;lchi1d;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;%c&quot;</span>,p-&gt;data);	<span class="comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">		<span class="keyword">while</span>(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)</span><br><span class="line">		&#123;</span><br><span class="line">			p=p-&gt;rchild;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);	<span class="comment">/* 访问后继节点 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;rchi1d;	<span class="comment">/* p进至其右子树根 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>代码中，第 6 行，<code>p=T&gt;lchild;</code>意思就是上图中的①，让<code>p</code>指向根结点开始遍历。</li>
<li>第 7~18 行，<code>while(p!=T)</code>其实意思就是循环直到图中的④的出现，此时意味着<code>p</code>指向了头结点，于是与<code>T</code>相等（<code>T</code>是指向头结点的指针），结束循环，否则一直循环下去进行遍历操作。</li>
<li>第 9~10 行，<code>whild(p-&gt;LTag==Link)</code>这个循环，就是由 A→B→D→H，此时<code>H</code>结点的<code>LTag</code>不是<code>Link</code>（就是不等于0），所以结束此循环。</li>
<li>第 11 行，打印<code>H</code>。</li>
<li>第 12~16 行，<code>while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchid!=T)</code>，由于结点<code>H</code>的<code>RTag==Thread</code>（就是等于 1），且不是指向头结点。因此打印<code>H</code>的后继<code>D</code>，之后因为<code>D</code>的<code>RTag</code>是<code>Link</code>，因此退出循环。</li>
<li>第17行，<code>p=p-&gt;rchil;</code>意味着<code>p</code>指向了结点<code>D</code>的右孩子<code>I</code>。</li>
<li>······就这样不断循环遍历，路径参照下图，直到打印出 HDIBJEAFCG，结束遍历操作。<br>
<img src="https://img-blog.csdnimg.cn/6a0a7583b4624dffb1609e1d93c5c97b.png" alt="在这里插入图片描述"></li>
</ol>
<p>  从这段代码也可以看出，它等于是一个链表的扫描，所以时间复杂度为<strong>O(n)</strong>。<br>
  由于它充分利用了空指针域的空间（这等于节省了空间），又保证了创建时的一次遍历就可以终生受用前驱后继的信息（这意味着节省了时间）。所以在实际问题中，<font color=#6495ED><strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</strong></font><br>
<br></p>
<h1 id="7-总结">7. 总结</h1>
<p>  二叉树每个结点最多两棵子树，有左右之分。本章提到了斜树，满二叉树、完全二叉树等特殊二叉树的概念。<br>
  我们接着谈到它的各种性质，这些性质给我们研究二叉树带来了方便。<br>
  二叉树的存储结构由于其特殊性使得既可以用顺序存储结构又可以用链式存储结构表示。<br>
  遍历是二叉树最重要的一门学问，前序、中序、后序以及层序遍历都是需要熟练掌握的知识。要让自己要学会用计算机的运行思维去模拟递归的实现，可以加深我们对递归的理解。不过，并非二叉树遍历就一定要用到递归， 只不过递归的实现比较优雅而已。这点需要明确。<br>
  二叉树的建立自然也是可以通过递归来实现。<br>
  研究中也发现，二叉链表有很多浪费的空指针可以利用，查找某个结点的前驱和后继为什么非要每次遍历才可以得到，这就引出了如何构造一棵线索二叉树的问题。线索二叉树给二叉树的结点查找和遍历带来了高效率。<br>
  下一章再讲，树、森林与二叉树之间的转换。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.progrem-park.top/">一位木带感情的码农</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.progrem-park.top/2021/11/08/algorithm_10/">https://www.progrem-park.top/2021/11/08/algorithm_10/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归 <a href=https://www.progrem-park.top/>程序园</a> 所有，如有转载，请注明来自原作者。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/algorithm/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/09/algorithm_11/"><img class="prev-cover" src="/img/algorithm/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《数据结构与算法》（十一）- 树、森林与二叉树的转换及哈夫曼树详解</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/02/algorithm_9/"><img class="next-cover" src="/img/algorithm/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《数据结构与算法》（九）- 树详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/09/algorithm_11/" title="《数据结构与算法》（十一）- 树、森林与二叉树的转换及哈夫曼树详解"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-09</div><div class="title">《数据结构与算法》（十一）- 树、森林与二叉树的转换及哈夫曼树详解</div></div></a></div><div><a href="/2021/10/11/algorithm_1/" title="《数据结构与算法》（一）- 数据结构详解11111"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-11</div><div class="title">《数据结构与算法》（一）- 数据结构详解11111</div></div></a></div><div><a href="/2021/11/11/algorithm_14/" title="《数据结构与算法》（十四）- 图的应用：最短路径"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-11</div><div class="title">《数据结构与算法》（十四）- 图的应用：最短路径</div></div></a></div><div><a href="/2021/11/10/algorithm_13/" title="《数据结构与算法》（十三）- 图的应用：最小生成树"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-10</div><div class="title">《数据结构与算法》（十三）- 图的应用：最小生成树</div></div></a></div><div><a href="/2021/11/11/algorithm_15/" title="《数据结构与算法》（十五）- 图的应用：有向无环图"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-11</div><div class="title">《数据结构与算法》（十五）- 图的应用：有向无环图</div></div></a></div><div><a href="/2021/11/10/algorithm_12/" title="《数据结构与算法》（十二）- 图详解"><img class="cover" src="/img/algorithm/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-10</div><div class="title">《数据结构与算法》（十二）- 图详解</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatat_img.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">一位木带感情的码农</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">200</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/program-park"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/program-park" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lkm869666@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_44758876" target="_blank" title="CSDN"><i class="fa-solid fa-c"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">网站正在优化中......</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 二叉树简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 二叉树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1.2 二叉树的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">1.2 特殊二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">2. 二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A81"><span class="toc-text">2.1 二叉树的性质1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A82"><span class="toc-text">2.2 二叉树的性质2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A83"><span class="toc-text">2.3 二叉树的性质3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A84"><span class="toc-text">2.4 二叉树的性质4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A85"><span class="toc-text">2.5 二叉树的性质5</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">3. 二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">3.1 二叉树顺序存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-text">3.2 二叉链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">4. 遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86"><span class="toc-text">4.1 二叉树的遍历原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-text">4.2 二叉树的遍历方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">4.3 前序遍历算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">4.4 中序遍历算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%B3%95"><span class="toc-text">4.5 后序遍历法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%8E%A8%E5%AF%BC%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C"><span class="toc-text">4.6 推导遍历结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">5. 二叉树的建立</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">6. 线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">6.1 线索二叉树的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.2 线索二叉树结构实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-text">7. 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/30/reptile_1/" title="Python 爬虫基础之 urllib 库的深入使用详解"><img src="/img/reptile/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python 爬虫基础之 urllib 库的深入使用详解"/></a><div class="content"><a class="title" href="/2022/08/30/reptile_1/" title="Python 爬虫基础之 urllib 库的深入使用详解">Python 爬虫基础之 urllib 库的深入使用详解</a><time datetime="2022-08-30T09:15:02.000Z" title="发表于 2022-08-30 17:15:02">2022-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/linux_6/" title="Linux 防火墙常用命令总结"><img src="/img/linux/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 防火墙常用命令总结"/></a><div class="content"><a class="title" href="/2022/08/15/linux_6/" title="Linux 防火墙常用命令总结">Linux 防火墙常用命令总结</a><time datetime="2022-08-15T07:20:44.000Z" title="发表于 2022-08-15 15:20:44">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/31/linux_5/" title="Linux 基础命令之 tar 解压缩详解"><img src="/img/linux/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 基础命令之 tar 解压缩详解"/></a><div class="content"><a class="title" href="/2022/07/31/linux_5/" title="Linux 基础命令之 tar 解压缩详解">Linux 基础命令之 tar 解压缩详解</a><time datetime="2022-07-31T00:22:50.000Z" title="发表于 2022-07-31 08:22:50">2022-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/13/nginx_16/" title="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离"><img src="/img/nginx/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离"/></a><div class="content"><a class="title" href="/2022/07/13/nginx_16/" title="Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离">Nginx 从入门到入坟（十五）- Nginx + Tomcat 部署实现动静分离</a><time datetime="2022-07-13T07:33:23.000Z" title="发表于 2022-07-13 15:33:23">2022-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/04/nginx_15/" title="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究"><img src="/img/nginx/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究"/></a><div class="content"><a class="title" href="/2022/07/04/nginx_15/" title="Nginx 从入门到入坟（十四）- Nginx 缓存深入研究">Nginx 从入门到入坟（十四）- Nginx 缓存深入研究</a><time datetime="2022-07-04T04:20:02.000Z" title="发表于 2022-07-04 12:20:02">2022-07-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/9.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 一位木带感情的码农</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://www.progrem-park.top/2021/11/08/algorithm_10/'
    this.page.identifier = '/2021/11/08/algorithm_10/'
    this.page.title = '《数据结构与算法》（十）- 二叉树详解'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>