<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 爬虫基础之 urllib 库的深入使用详解</title>
      <link href="/2022/08/30/reptile_1/"/>
      <url>/2022/08/30/reptile_1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-urllib库的使用">1. urllib库的使用</h1><h2 id="1-1-获取数据">1.1 获取数据</h2><p>  爬虫的定义我这里就不多说了，直接进入正题，如何利用<code>urllib</code>库去使用爬虫。模拟浏览器向服务器发送请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;http://www.某du.com&#x27;</span>)</span><br></pre></td></tr></table></figure><p>  下面的方法能获取响应的页面源码，但是需要注意的是<code>read()</code>返回的是字节形式的二进制数据，所以需要<code>decode()</code>解码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>  返回的<code>reponse</code>的类型为<code>HTTPResponse</code>，该返回值常用的方法如下：</p><ul><li><strong>read()</strong> ：字节形式读取二进制数据，<code>read(Number)</code>返回指定字节的数据；</li><li><strong>readline()</strong> ：读取一行；</li><li><strong>readlines()</strong> ：一行一行读取所有；</li><li><strong>getcode()</strong> ：获取响应状态码；</li><li><strong>geturl()</strong> ：获取请求的URL；</li><li><strong>getheaders()</strong> ：获取headers；</li></ul><h2 id="1-2-下载">1.2 下载</h2><p>  除了获取数据，我们也能通过爬虫下载网页资源：</p><ul><li>下载网页：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlretrieve(<span class="string">&#x27;http://www.某du.com&#x27;</span>,<span class="string">&#x27;baidu.html&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>下载图片：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlretrieve(<span class="string">&#x27;https://xxxxx.cdn.bcebos.com/pic/fcfaaf51f3deb48f8f9616a7fd1f3a292cf578cf?x-bce-process=image/resize,m_lfit,h_500,limit_1/format,f_auto&#x27;</span>,<span class="string">&#x27;迪丽热巴.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>下载视频：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlretrieve(<span class="string">&#x27;https://vd2.xxxxxxxx.com/mda-magpzuurpki42hbv/v1-cae/sc/mda-magpzuurpki42hbv.mp4?v_from_s=hkapp-haokan-hbe&amp;auth_key=1661150989-0-0-5951edef259d3b8ceac0327beca694ac&amp;bcevod_channel=searchbox_feed&amp;pd=1&amp;cd=0&amp;pt=3&amp;logid=1189836669&amp;vid=12518682849229018276&amp;abtest=103579_1-103742_4&amp;klogid=1189836669&#x27;</span>,<span class="string">&#x27;迪丽热巴.mp4&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-请求对象request的定制">2. 请求对象request的定制</h1><blockquote><p><strong>User-Agent，中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本，浏览器内核、浏览器渲染引擎、浏览器语言、浏览器插件等</strong></p></blockquote><p>  URL 的组成有以下几个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http/httpswwww.某du.com80/443swd=迪丽热巴#</span><br><span class="line">协议主机端口号路径参数锚点</span><br></pre></td></tr></table></figure><p>  上面的例子我们是请求的<code>http</code>接口，能够正常爬取，但是请求<code>https</code>某度网址，会遇到<code>UA</code>反爬，也是很常见的一种反爬机制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com&#x27;</span></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/61ec838df1da40768026e08d52e440f9.png#pic_center" alt="在这里插入图片描述"></p><p>  所以在发送请求时，要带上我们的<code>UA</code>，<code>UA</code>的获取方法如下：</p><p><img src="https://img-blog.csdnimg.cn/543aca0fee964b35803f1d67dcc9d123.png#pic_center" alt="在这里插入图片描述"><br>  带上<code>UA</code>爬虫代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com&#x27;</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>  因为<code>urlopen()</code>方法不支持字典变量，所以我们可以将信息放入定制的<code>Request</code>对象中，再将<code>Request</code>对象放入<code>urlopen()</code>中。这里需要注意的是，<code>Request()</code>方法的参数必须使用关键字传参，查看<code>Request</code>源码，可以发现，第二个参数是<code>data=None</code>，所以不指定的话，默认会认为传入的<code>UA</code>是<code>data</code>参数：</p><p><img src="https://img-blog.csdnimg.cn/7fa42a5a989f440e87de55c361dabd7c.png#pic_center" alt="在这里插入图片描述"></p><h1 id="3-编解码">3. 编解码</h1><blockquote><p><strong>编码集的演变：由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc‐kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。<br>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</strong></p></blockquote><h2 id="3-1-get请求">3.1 get请求</h2><h3 id="3-1-1-quote">3.1.1 quote()</h3><p>  上面说了 URL 的组成和<code>UA</code>的作用，那么现在有一个需求：获取<code>https://www.某du.com/s?wd=迪丽热巴</code>的网页源码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com/s?wd=迪丽热巴&#x27;</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>  直接运行上面的代码，会发现报错：</p><p><img src="https://img-blog.csdnimg.cn/3c0a4978b000456f924614abf9b54397.png#pic_center" alt="在这里插入图片描述"><br>  这是因为编码的问题，我们需要将<code>迪丽热巴</code>四个字变成<code>unicode</code>编码的格式，而这需要依赖<code>urllib.parse</code>的<code>quote()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">name = urllib.parse.quote(<span class="string">&#x27;迪丽热巴&#x27;</span>)</span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com/s?wd=&#x27;</span> + name</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h3 id="3-1-2-urlencode">3.1.2 urlencode()</h3><p>  既然有将一个参数变成<code>unicode</code>编码格式的方法，那么肯定有将多个参数同时变为<code>unicode</code>编码格式的方法，毕竟我们平时用的接口不可能只有一个参数，这个方法就是<code>urlencode()</code>，它的参数类型是字典，应用场景：URL 同时有多个参数时，将多个参数变成<code>unicode</code>编码的格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span> : <span class="string">&#x27;迪丽热巴&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sex&#x27;</span> : <span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">a = urllib.parse.urlencode(data)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>  运行结果如下，将多个参数同时转为了<code>unicode</code>编码格式并用<code>&amp;</code>分割：</p><p><img src="https://img-blog.csdnimg.cn/1cf0a9b4c89f41a0af9fd79d688b86b3.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3-2-post请求">3.2 post请求</h2><p>  上面说的案例都是<code>get</code>请求接口，但其实我们遇到的更多的还是<code>post</code>请求接口，在请求时要带上参数值，以某度翻译为例，找到发送单词请求数据的 URL：</p><p><img src="https://img-blog.csdnimg.cn/8ee72c85d4b84760adf3b9f6b93ea64d.png#pic_center" alt="在这里插入图片描述"><br>  请求地址为<code>https://fanyi.某du.com/sug</code>，且以<code>post</code>方式发送。携带的参数为<code>&#123;kw:copy&#125;</code>，返回的数据为一组<code>json</code>数据，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://fanyi.某du.com/sug&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;kw&#x27;</span> : <span class="string">&#x27;copy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post请求的参数必须进行编码，编码后必须调用encode()</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong></p><ul><li><code>get</code>请求方式的参数必须编码，参数是拼接到 URL 后面，编码之后不需要调用<code>encode()</code>方法；</li><li><code>post</code>请求方式的参数必须编码，参数是放在请求对象定制的方法中，编码之后需要调用<code>encode()</code>方法；</li></ul><h2 id="3-3-案例：某度详细翻译">3.3 案例：某度详细翻译</h2><p>  前面的案例用过了某度翻译的<code>post</code>的接口，但其实某度翻译还有一个某度详细翻译的接口，返回的数据更加详细：</p><p><img src="https://img-blog.csdnimg.cn/8dce122e647c402f944de43e30ac1218.png#pic_center" alt="在这里插入图片描述"><br>  该接口需要的参数如下：</p><p><img src="https://img-blog.csdnimg.cn/ce1b08d764d8456d894ee209edea159b.png#pic_center" alt="在这里插入图片描述"><br>  爬虫代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://fanyi.某du.com/v2transapi?from=en&amp;to=zh&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;zh&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;simple_means_flag&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;479144.240793&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;68566c3678a1d2d18424ef21037ad1cd&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;common&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post请求的参数必须进行编码，编码后必须调用encode()</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 请求对象的定制</span></span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line"><span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="comment"># 获取响应的数据</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>  运行代码，遇到报错：</p><p><img src="https://img-blog.csdnimg.cn/2211079b1ba8467781063cf59c13d1ed.png#pic_center" alt="在这里插入图片描述"><br>  这是因为请求头中的数据没有全部放到<code>headers</code>中：</p><p><img src="https://img-blog.csdnimg.cn/ee3b495d8f2a42309f06deab8ae57c22.png#pic_center" alt="在这里插入图片描述"><br>  将请求头的数据全部放入<code>headers</code>即可，这里我使用的<code>Sublime Text</code>修改的数据格式，否则手动改还是有些费事：</p><p><img src="https://img-blog.csdnimg.cn/3b2de1a4a30045299ac3148938eae1a3.png#pic_center" alt="在这里插入图片描述"><br>  加入请求头数据后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://fanyi.某du.com/v2transapi?from=en&amp;to=zh&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;zh&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;simple_means_flag&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;479144.240793&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;68566c3678a1d2d18424ef21037ad1cd&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;common&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>:<span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Acs-Token&#x27;</span>:<span class="string">&#x27;1661151781547_1661235691501_0f9CZMIZ5F98s+p/e4nt/8nbrZ+AlxwEaULsxFVtWLyXY5q1G9TLC9A94gcj+3pNbT9maF1j+iqywD1ReX5S2xJ4XVhHgh2AoNNoG3kKPIvkKt1xg5LC/q465CS7LldtxQiHZH7aVD3hI98PAkb/BP/WJL94eJnMUR5z3TWWHWHznmhHc3DBZphXD7bvfieuSSSTrSfQJKh1gZAAED7Qd+FkTJPyTmx71HOYgDoKXgL8at5CVbstnRlGybS6HKSaJ+q9fAy8R9pup4Op9+6xuNh2sFR9axAE+92cP8gcQLqUd7B745Bv7Bbjv1odwUqbFJUcsLMyu1qH0yi46MQlbQ==&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>:<span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Length&#x27;</span>:<span class="string">&#x27;116&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;BIDUPSID=EDEDD8AC90775AB7BB2E2A9BA887CB6A; PSTM=1643847626; BAIDUID=EDEDD8AC90775AB76211B82417CB627A:FG=1; __yjs_duid=1_3f010fc33690405f6d48831d8577999f1644021279727; FANYI_WORD_SWITCH=1; REALTIME_TRANS_SWITCH=1; HISTORY_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; APPGUIDE_10_0_2=1; BDUSS=VhuaU9TRWVWZmY2ZjhvTURUWkxsYnV6VGNrdDhuVnpLeGdiU3BWazZlYk5RQmRqRVFBQUFBJCQAAAAAAAAAAAEAAAA5xXOd0KHQob70z8LKvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2z72LNs-9iV; BDUSS_BFESS=VhuaU9TRWVWZmY2ZjhvTURUWkxsYnV6VGNrdDhuVnpLeGdiU3BWazZlYk5RQmRqRVFBQUFBJCQAAAAAAAAAAAEAAAA5xXOd0KHQob70z8LKvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2z72LNs-9iV; ZFY=fiXfZrdJz5x8NkMm:AiKmd1ufNDjZkiFrzNjDBw7nRpY:C; BAIDUID_BFESS=EDEDD8AC90775AB76211B82417CB627A:FG=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; ariaDefaultTheme=undefined; RT=&quot;z=1&amp;dm=baidu.com&amp;si=1ehud9ig578&amp;ss=l74cz1z6&amp;sl=k&amp;tt=co6&amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&amp;ld=d781&amp;ul=f7iu&amp;hd=f7jy&quot;; BA_HECTOR=2l2kal8180842k0k842ga5kc1hg8dvk16; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1660717558,1660788138,1661134918,1661223741; PSINO=1; H_PS_PSSID=36559_36463_36641_36982_36885_34812_36917_36779_37137_26350_37089_37194; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1661235691&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>:<span class="string">&#x27;https://fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://fanyi.baidu.com/?aldtype=16047&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua&#x27;</span>:<span class="string">&#x27;&quot;Chromium&quot;;v=&quot;104&quot;, &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;104&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>:<span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>:<span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>:<span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>:<span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>:<span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>:<span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post请求的参数必须进行编码，编码后必须调用encode()</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 请求对象的定制</span></span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line"><span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="comment"># 获取响应的数据</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>  执行后发现还是报错：</p><p><img src="https://img-blog.csdnimg.cn/2622c1e1a3d24e229ca9ffb4ee1b5c51.png#pic_center" alt="在这里插入图片描述"><br>  这是因为接收的编码格式不支持<code>utf-8</code>，将<code>'Accept-Encoding':'gzip, deflate, br'</code>注释即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://fanyi.某du.com/v2transapi?from=en&amp;to=zh&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;zh&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;simple_means_flag&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;479144.240793&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;68566c3678a1d2d18424ef21037ad1cd&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;common&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;Accept-Encoding&#x27;:&#x27;gzip, deflate, br&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Acs-Token&#x27;</span>:<span class="string">&#x27;1661151781547_1661235691501_0f9CZMIZ5F98s+p/e4nt/8nbrZ+AlxwEaULsxFVtWLyXY5q1G9TLC9A94gcj+3pNbT9maF1j+iqywD1ReX5S2xJ4XVhHgh2AoNNoG3kKPIvkKt1xg5LC/q465CS7LldtxQiHZH7aVD3hI98PAkb/BP/WJL94eJnMUR5z3TWWHWHznmhHc3DBZphXD7bvfieuSSSTrSfQJKh1gZAAED7Qd+FkTJPyTmx71HOYgDoKXgL8at5CVbstnRlGybS6HKSaJ+q9fAy8R9pup4Op9+6xuNh2sFR9axAE+92cP8gcQLqUd7B745Bv7Bbjv1odwUqbFJUcsLMyu1qH0yi46MQlbQ==&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>:<span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Length&#x27;</span>:<span class="string">&#x27;116&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;BIDUPSID=EDEDD8AC90775AB7BB2E2A9BA887CB6A; PSTM=1643847626; BAIDUID=EDEDD8AC90775AB76211B82417CB627A:FG=1; __yjs_duid=1_3f010fc33690405f6d48831d8577999f1644021279727; FANYI_WORD_SWITCH=1; REALTIME_TRANS_SWITCH=1; HISTORY_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; APPGUIDE_10_0_2=1; BDUSS=VhuaU9TRWVWZmY2ZjhvTURUWkxsYnV6VGNrdDhuVnpLeGdiU3BWazZlYk5RQmRqRVFBQUFBJCQAAAAAAAAAAAEAAAA5xXOd0KHQob70z8LKvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2z72LNs-9iV; BDUSS_BFESS=VhuaU9TRWVWZmY2ZjhvTURUWkxsYnV6VGNrdDhuVnpLeGdiU3BWazZlYk5RQmRqRVFBQUFBJCQAAAAAAAAAAAEAAAA5xXOd0KHQob70z8LKvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2z72LNs-9iV; ZFY=fiXfZrdJz5x8NkMm:AiKmd1ufNDjZkiFrzNjDBw7nRpY:C; BAIDUID_BFESS=EDEDD8AC90775AB76211B82417CB627A:FG=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; ariaDefaultTheme=undefined; RT=&quot;z=1&amp;dm=baidu.com&amp;si=1ehud9ig578&amp;ss=l74cz1z6&amp;sl=k&amp;tt=co6&amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&amp;ld=d781&amp;ul=f7iu&amp;hd=f7jy&quot;; BA_HECTOR=2l2kal8180842k0k842ga5kc1hg8dvk16; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1660717558,1660788138,1661134918,1661223741; PSINO=1; H_PS_PSSID=36559_36463_36641_36982_36885_34812_36917_36779_37137_26350_37089_37194; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1661235691&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>:<span class="string">&#x27;https://fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://fanyi.baidu.com/?aldtype=16047&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua&#x27;</span>:<span class="string">&#x27;&quot;Chromium&quot;;v=&quot;104&quot;, &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;104&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>:<span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>:<span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>:<span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>:<span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>:<span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>:<span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post请求的参数必须进行编码，编码后必须调用encode()</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 请求对象的定制</span></span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line"><span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="comment"># 获取响应的数据</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>  需要注意的是，在整个请求标头中，最重要的就是<code>cookie</code>，事实上将请求标头中除去<code>cookie</code>外所有的行全部注释，爬虫也能正常运行。</p><blockquote><p><strong>cookie 一般是登录后产生（post），用来保持登录状态的，一般登录一次，下一次访问该网站下的其他网址时就不需要登录了，这就是由于cookie的作用。cookie 就是给无状态的 HTTP/HTTPS 协议添加了一种保持之前状态的功能，这样下次处理信息的时候就不用重新获取信息了。<br>cookie 还可以来判断是否是爬虫程序，因为一般的爬虫程序中并不会携带 cookie，有些比较严格的网站，不登录也需要携带 cookie 访问，也就是说 cookie 的应用场景并不仅仅只有登录后才需要。</strong></p></blockquote><h1 id="4-Ajax">4. Ajax</h1><blockquote><p><strong>Ajax 即 “Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指⼀种创建交互式网页应用的网页开发技术。用于创建快速动态网页，在无需重新加载整个网页的情况下，能够更新部分网页的技术。</strong><br><strong>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某个部分进行更新，而传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个页面。</strong></p></blockquote><h2 id="4-1-Ajax的get请求">4.1 Ajax的get请求</h2><p>  以爬取某瓣网电影前十页数据为案例，某瓣网的分页就是用<code>Ajax</code>实现的。先完成一个小目标，爬取第一页数据，找到某瓣网数据接口：</p><p><img src="https://img-blog.csdnimg.cn/0709326ec6a24a4fb6c10f402c8024b1.png#pic_center" alt="在这里插入图片描述"><br>  爬取首页数据并写入到文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20&#x27;</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;douban.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file.write(content)</span><br></pre></td></tr></table></figure><p>  查看文件内容，快捷键<code>ctrl+alt+L</code>自动对齐，已爬取到第一页的数据：</p><p><img src="https://img-blog.csdnimg.cn/f7e72165a07746de9d36ea5a3a993a59.png#pic_center" alt="在这里插入图片描述"><br>  下面就是爬取前十页的数据了。通过观察，找到下面三个接口，这三个接口是豆瓣网电影前三页的接口，可以明显看到这三个接口的规律，接口是根据<code>start=(page-1)*20</code>来区分页数的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20</span><br><span class="line">https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=20&amp;limit=20</span><br><span class="line">https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=40&amp;limit=20</span><br></pre></td></tr></table></figure><p>  知道了接口规律，那么接下来就是爬取前十页数据了，代码已封装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回request对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_request</span>(<span class="params">page</span>):</span><br><span class="line">    base_url = <span class="string">&#x27;https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span>: (page - <span class="number">1</span>) * <span class="number">20</span>,</span><br><span class="line">        <span class="string">&#x27;limit&#x27;</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将data转换为unicode编码格式</span></span><br><span class="line">    data = urllib.parse.urlencode(data)</span><br><span class="line">    url = base_url + data</span><br><span class="line">    <span class="comment"># 定制request</span></span><br><span class="line">    request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取响应数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">page, content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;douban_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span>  file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始页码：&#x27;</span>))</span><br><span class="line">    end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束页码：&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">        request = create_request(page)</span><br><span class="line">        content = get_content(request)</span><br><span class="line">        down_load(page, content)</span><br></pre></td></tr></table></figure><p>  运行代码可以得到对应页面的数据文件，效果我就不放了。</p><h2 id="4-2-Ajax的post请求">4.2 Ajax的post请求</h2><p>  下面以爬取某德基餐厅信息的案例来演示，如何爬取<code>Ajax</code>的<code>post</code>请求。先登录某德基官网，找到对应的<code>post</code>接口。（图片违规，不让我放上来。。。。。。。）<br>  然后通过对比前三页接口的不同，找到不同页码接口之间的规律：</p><p><img src="https://img-blog.csdnimg.cn/8640788300ea4e79a414fe24d307b957.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4199a65f97234d908ac5716dcf8165d9.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/eaa886b1d3ab4a24bc437d84336f4de0.png#pic_center" alt="在这里插入图片描述"><br>  可以明显发现，该接口是通过<code>pageIndex</code>参数控制页码，<code>pageSize</code>控制每页的数量，<code>cname</code>控制地区。下面就直接放代码了，难点不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回request对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_request</span>(<span class="params">page</span>):</span><br><span class="line">    base_url = <span class="string">&#x27;http://www.某fc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;cname&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pid&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pageIndex&#x27;</span>: page,</span><br><span class="line">        <span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将data转换为unicode编码格式，post接口需要用encode()编码</span></span><br><span class="line">    data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 定制请求对象</span></span><br><span class="line">    request = urllib.request.Request(url=base_url, data=data, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取响应数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">page, content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;某fc_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始页码：&#x27;</span>))</span><br><span class="line">    end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束页码：&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">        request = create_request(page)</span><br><span class="line">        content = get_content(request)</span><br><span class="line">        down_load(page, content)</span><br></pre></td></tr></table></figure><h1 id="5-捕获异常">5. 捕获异常</h1><p>  如果我们想让自己的爬虫代码更加健壮的话，也是需要捕获异常的，这里就介绍两个异常类，<code>HTTPError</code>和<code>URLError</code>，<code>HTTPError</code>类是<code>URLError</code>类的子类。<br>  当然实际平时爬虫的使用中，捕获异常使用的并不多，所以我这里就不做过多的介绍了，直接拿上一个某德基的代码改一下放这里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回request对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_request</span>(<span class="params">page</span>):</span><br><span class="line">    base_url = <span class="string">&#x27;http://www.某fc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;cname&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pid&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pageIndex&#x27;</span>: page,</span><br><span class="line">        <span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将data转换为unicode编码格式，post接口需要用encode()编码</span></span><br><span class="line">    data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 定制请求对象</span></span><br><span class="line">    request = urllib.request.Request(url=base_url, data=data, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取响应数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">page, content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;某fc_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始页码：&#x27;</span>))</span><br><span class="line">        end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束页码：&#x27;</span>))</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">            request = create_request(page)</span><br><span class="line">            content = get_content(request)</span><br><span class="line">            down_load(page, content)</span><br><span class="line">    <span class="keyword">except</span> urllib.error.HTTPError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;系统正在升级&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> urllib.error.URLError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;您访问的域名不存在&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="6-cookie登录">6. cookie登录</h1><p>  在很多网站中，和上面案例中的网站有一个不一样的地方，就是未登录状态和登录状态所展示出来的数据是不一样的，这里就讲一下，如果想采集登录之后才展示出来的数据，应该怎么去写代码。这里就以某博<code>https://某bo.cn/</code>为例，采集个人主页的信息，首先按照上面讲过的代码进行尝试（因为涉及个人隐私，所以代码中的链接 uid 和后续的 cookie 我都会做随机修改处理，各位以自己的为准即可）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://某bo.cn/6328349562/info&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>  运行代码会发现编码不对：</p><p><img src="https://img-blog.csdnimg.cn/895ef61125804162b2917a0b79b1e2a8.png#pic_center" alt="在这里插入图片描述"><br>  而查看个人信息网页的源代码，编码格式确实是<code>utf-8</code>，之所以编码不对是因为我们没有登录信息，请求个人信息主页时会自动跳转到登录页面，而登录页面的编码格式却是<code>gb2312</code>，这也是一个小的爬虫手段，所以我们只需要改一下编码格式为<code>gb2312</code>即可。可是随之而来的问题是，我们这样获取的是登录页面的信息，而我们实际想要的是个人信息主页，应该怎么去绕过登录页面直接到达个人信息主页呢，这就需要一个重要的东西，就是<code>cookie</code>，在个人信息主页，打开检查，点击网络的<code>info</code>，将请求头的东西都复制出来：</p><p><img src="https://img-blog.csdnimg.cn/fb2d4676c7854df5851b88ca9dd27fef.jpeg#pic_center" alt="在这里插入图片描述"><br>  前面带有冒号的可以不要，放入代码的<code>headers</code>中，可以用前面说过的正则方法，方便快捷。注意编码格式需要改回<code>utf-8</code>，因为这里不需要再去登录页了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://某bo.cn/6347449799/info&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;accept&#x27;</span>:<span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;accept-encoding&#x27;:&#x27;gzip, deflate, br&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;accept-language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cache-control&#x27;</span>:<span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>:<span class="string">&#x27;_T_WM=f1c3ebd01cf7dde23704b362ixs82v8q; SUB=_2A25OA26gDeRhGeBN71UV9CfLwjWIHXVtDHLorDV6PUNbktANLUjfkmdQ7XiRIiAWGcim-RPUJFDBLv9yPaBCUSFB; SUBP=0033WrSXqPxfM725Ws9jqgMF26451P9D9WFzL6FUia2PJzLiF9NnWlEC5JpX5KzhUgL.Foq0ShNESD.N2K.2dKCoIE7LxK-L1KBLB-qLxKBLB.BLBKWaUJYLxKBLBonL12BLxKqL1MDUVG6Efeh2centt; SSOLoginState=1661038641; ALF=1664046284; MLOGIN=1; M_WEIBOCN_PARAMS=luicode%3D20084629&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;referer&#x27;</span>:<span class="string">&#x27;https://weibo.cn/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua&#x27;</span>:<span class="string">&#x27;&quot;Chromium&quot;;v=&quot;104&quot;, &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;104&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>:<span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>:<span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-fetch-dest&#x27;</span>:<span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-fetch-mode&#x27;</span>:<span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-fetch-site&#x27;</span>:<span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-fetch-user&#x27;</span>:<span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>  如此便可获取到个人主页的信息，效果图我就不放了，懒。</p><h1 id="7-Handler处理器">7. Handler处理器</h1><p>  随着业务逻辑逐渐复杂，请求对象的定制已经满足不了我们的需求，长期爬取一个网站，会被网站识别为爬虫，对我们的设备进行封 IP 操作，所以我们就需要动态<code>cookie</code>和代理来解决这个问题，而代理就是以<code>Handler</code>为基础，这里还是先用百度的简单案例，讲一下如何使用<code>Handler</code>处理器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"><span class="comment"># 获取handler对象</span></span><br><span class="line">handler = urllib.request.HTTPHandler()</span><br><span class="line"><span class="comment"># 获取opener对象</span></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"><span class="comment"># 调用open方法</span></span><br><span class="line">response = opener.<span class="built_in">open</span>(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h1 id="8-代理的基本使用">8. 代理的基本使用</h1><p>  当我们使用爬虫长期、高频的访问某个网站，就会被识别为爬虫，封禁设备 IP，从而导致无法访问该网站，而代理，就是为了隐藏我们的真实 IP，防止被封禁。当然代理不仅仅是这一个用途，像我们打游戏时开的加速器就是代理，访问外网的资源也需要使用代理，以及一些私密单位的内部资源都需要代理来进行访问，代理也能用来提高访问速度，通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。<br>  那么下面我就来演示一下，如何用代理爬取网站信息。首先我们上某度网站，某度<code>ip</code>，可以直接显示出我们的本机<code>ip</code>：</p><p><img src="https://img-blog.csdnimg.cn/59b4986709cc4f889549bc04de53d276.png#pic_center" alt="在这里插入图片描述"><br>  我们先使用之前请求对象定制的方法，来爬取该网站信息看是否能正常获取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com/s?wd=ip&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;代理.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(content)</span><br></pre></td></tr></table></figure><p>  打开<code>代理.html</code>文件，可以看到和我们正常访问一模一样。<br>  然后换成<code>Hanlder</code>处理器，使用代理访问，我这里用的是<code>快代理</code>网站的免费代理，连接不太稳定，可能换几个代理才有一个能用的：</p><p><img src="https://img-blog.csdnimg.cn/6f487c24ae1546b586f9a265b5078166.png#pic_center" alt="在这里插入图片描述"><br>  代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.某du.com/s?wd=ip&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"><span class="comment"># response = urllib.request.urlopen(request)</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;223.82.60.202:8060&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 获取handler对象</span></span><br><span class="line">handler = urllib.request.ProxyHandler(proxies=proxies)</span><br><span class="line"><span class="comment"># 获取opener对象</span></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"><span class="comment"># 调用open方法</span></span><br><span class="line">response = opener.<span class="built_in">open</span>(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;代理.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(content)</span><br></pre></td></tr></table></figure><p>  效果图如下：</p><p><img src="https://img-blog.csdnimg.cn/5cac1e1a3da04b3aafeeb83aea0b86a6.png#pic_center" alt="在这里插入图片描述"><br>  当然在我们实际生产中，只用一个代理也是不现实的，也会面临被封<code>ip</code>的风险，所有就有了<code>代理池</code>的概念。</p><blockquote><p><strong>代理池就是由代理IP组成的池子, 它可以提供多个稳定可用的代理IP。</strong></p></blockquote><p>  我们在做爬虫的时候, 最常见一种反爬手段就是<code>ip</code>反爬，也就是当同一个<code>ip</code>高频的访问这个网站次数过多，就会限制这个<code>ip</code>访问。所以就需要使用代理来隐藏我们的真实<code>ip</code>，同时为了保证我们的代理能长期稳定的使用，就需要随机使用代理池里的代理地址，最简单的代理池实现方式就是将代理地址都放到一个列表里，创建一个随机数，每次请求都随机的从代理池中取一个代理使用，我这里就不贴代码了，就是一个很简单的功能。<br>  这篇博客就说这些简单的爬虫基础吧，已经万字长文了，后面再更新深入的爬虫相关知识。</p><h1 id="参考文献">参考文献</h1><p>  【1】<a href="https://www.bilibili.com/video/BV1Db4y1m7Ho?p=51">https://www.bilibili.com/video/BV1Db4y1m7Ho?p=51</a><br>  【2】<a href="https://blog.csdn.net/itcast_cn/article/details/123678415">https://blog.csdn.net/itcast_cn/article/details/123678415</a><br>  【3】<a href="https://www.runoob.com/python3/python-urllib.html">https://www.runoob.com/python3/python-urllib.html</a><br>  【4】<a href="https://blog.csdn.net/m0_46473590/article/details/118328217">https://blog.csdn.net/m0_46473590/article/details/118328217</a><br>  【5】<a href="https://blog.csdn.net/Y_peak/article/details/120068358">https://blog.csdn.net/Y_peak/article/details/120068358</a><br>  【6】<a href="https://www.weixueyuan.net/a/739.html">https://www.weixueyuan.net/a/739.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AttributeEroor: ‘list‘ object has no attribute ‘clear‘</title>
      <link href="/2021/08/13/python_12/"/>
      <url>/2021/08/13/python_12/</url>
      
        <content type="html"><![CDATA[<p>今天在测试时出现了<code>AttributeEroor: 'list' object has no attribute 'clear'</code>的报错<br><img src="https://img-blog.csdnimg.cn/671f43f13029467797a9d7fb3d2be34d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>经过查询发现，原来是 python2.7 版本的列表没有clear()方法，把<code>dataList.clear()</code>改为<code>dataList = []</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug记录 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之对文件进行哈希校验</title>
      <link href="/2021/08/10/python_11/"/>
      <url>/2021/08/10/python_11/</url>
      
        <content type="html"><![CDATA[<p>需求为对文件进行加密，保留哈希，防止别人篡改文件，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time,re,os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> watchdog.events <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> watchdog.observers <span class="keyword">import</span> Observer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotation_left</span>(<span class="params">x, num</span>):</span><br><span class="line">    <span class="comment"># 循环左移</span></span><br><span class="line">    num %= <span class="number">32</span></span><br><span class="line">    left = (x &lt;&lt; num) % (<span class="number">2</span> ** <span class="number">32</span>)</span><br><span class="line">    right = (x &gt;&gt; (<span class="number">32</span> - num)) % (<span class="number">2</span> ** <span class="number">32</span>)</span><br><span class="line">    result = left ^ right</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Int2Bin</span>(<span class="params">x, k</span>):</span><br><span class="line">    x = <span class="built_in">str</span>(<span class="built_in">bin</span>(x)[<span class="number">2</span>:])</span><br><span class="line">    result = <span class="string">&quot;0&quot;</span> * (k - <span class="built_in">len</span>(x)) + x</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SM3</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 常量初始化</span></span><br><span class="line">        self.IV = [<span class="number">0x7380166F</span>, <span class="number">0x4914B2B9</span>, <span class="number">0x172442D7</span>, <span class="number">0xDA8A0600</span>, <span class="number">0xA96F30BC</span>, <span class="number">0x163138AA</span>, <span class="number">0xE38DEE4D</span>, <span class="number">0xB0FB0E4E</span>]</span><br><span class="line">        self.T = [<span class="number">0x79cc4519</span>, <span class="number">0x7a879d8a</span>]</span><br><span class="line">        self.maxu32 = <span class="number">2</span> ** <span class="number">32</span></span><br><span class="line">        self.w1 = [<span class="number">0</span>] * <span class="number">68</span></span><br><span class="line">        self.w2 = [<span class="number">0</span>] * <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ff</span>(<span class="params">self, x, y, z, j</span>):</span><br><span class="line">        <span class="comment"># 布尔函数FF</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">16</span>:</span><br><span class="line">            result = x ^ y ^ z</span><br><span class="line">        <span class="keyword">elif</span> j &gt;= <span class="number">16</span>:</span><br><span class="line">            result = (x &amp; y) | (x &amp; z) | (y &amp; z)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gg</span>(<span class="params">self, x, y, z, j</span>):</span><br><span class="line">        <span class="comment"># 布尔函数GG</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">16</span>:</span><br><span class="line">            result = x ^ y ^ z</span><br><span class="line">        <span class="keyword">elif</span> j &gt;= <span class="number">16</span>:</span><br><span class="line">            result = (x &amp; y) | (~x &amp; z)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">p</span>(<span class="params">self, x, mode</span>):</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 置换函数P</span></span><br><span class="line">        <span class="comment"># 输入参数X的长度为32bit(=1个字)</span></span><br><span class="line">        <span class="comment"># 输入参数mode共两种取值：0和1</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="number">0</span>:</span><br><span class="line">            result = x ^ rotation_left(x, <span class="number">9</span>) ^ rotation_left(x, <span class="number">17</span>)</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="number">1</span>:</span><br><span class="line">            result = x ^ rotation_left(x, <span class="number">15</span>) ^ rotation_left(x, <span class="number">23</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_fill</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="comment"># 填充消息，使其长度为512bit的整数倍</span></span><br><span class="line">        <span class="comment"># 输入参数msg为bytearray类型</span></span><br><span class="line">        <span class="comment"># 中间参数msg_new_bin为二进制string类型</span></span><br><span class="line">        <span class="comment"># 输出参数msg_new_bytes为bytearray类型</span></span><br><span class="line">        length = <span class="built_in">len</span>(msg)  <span class="comment"># msg的长度（单位：byte）</span></span><br><span class="line">        l = length * <span class="number">8</span>  <span class="comment"># msg的长度（单位：bit）</span></span><br><span class="line"></span><br><span class="line">        num = length // <span class="number">64</span></span><br><span class="line">        remain_byte = length % <span class="number">64</span></span><br><span class="line">        msg_remain_bin = <span class="string">&quot;&quot;</span></span><br><span class="line">        msg_new_bytes = <span class="built_in">bytearray</span>((num + <span class="number">1</span>) * <span class="number">64</span>)  <span class="comment">##填充后的消息长度，单位：byte</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将原数据存储至msg_new_bytes中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            msg_new_bytes[i] = msg[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># remain部分以二进制字符串形式存储</span></span><br><span class="line">        remain_bit = remain_byte * <span class="number">8</span>  <span class="comment"># 单位：bit</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(remain_byte):</span><br><span class="line">            msg_remain_bin += <span class="string">&quot;&#123;:08b&#125;&quot;</span>.<span class="built_in">format</span>(msg[num * <span class="number">64</span> + i])</span><br><span class="line"></span><br><span class="line">        k = (<span class="number">448</span> - l - <span class="number">1</span>) % <span class="number">512</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># k为满足 l + k + 1 = 448 % 512 的最小非负整数</span></span><br><span class="line">            k += <span class="number">512</span></span><br><span class="line"></span><br><span class="line">        msg_remain_bin += <span class="string">&quot;1&quot;</span> + <span class="string">&quot;0&quot;</span> * k + Int2Bin(l, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">64</span> - remain_byte):</span><br><span class="line">            <span class="built_in">str</span> = msg_remain_bin[i * <span class="number">8</span> + remain_bit: (i + <span class="number">1</span>) * <span class="number">8</span> + remain_bit]</span><br><span class="line">            temp = length + i</span><br><span class="line">            msg_new_bytes[temp] = <span class="built_in">int</span>(<span class="built_in">str</span>, <span class="number">2</span>)  <span class="comment"># 将2进制字符串按byte为组转换为整数</span></span><br><span class="line">        <span class="keyword">return</span> msg_new_bytes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_msg_extend</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="comment"># 扩展函数: 将512bit的数据msg扩展为132个字（w1共68个字，w2共64个字）</span></span><br><span class="line">        <span class="comment"># 输入参数msg为bytearray类型,长度为512bit=64byte</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">16</span>):</span><br><span class="line">            self.w1[i] = <span class="built_in">int</span>.from_bytes(msg[i * <span class="number">4</span>:(i + <span class="number">1</span>) * <span class="number">4</span>], byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>, <span class="number">68</span>):</span><br><span class="line">            self.w1[i] = self.p(self.w1[i - <span class="number">16</span>] ^ self.w1[i - <span class="number">9</span>] ^ rotation_left(self.w1[i - <span class="number">3</span>], <span class="number">15</span>),</span><br><span class="line">                                <span class="number">1</span>) ^ rotation_left(self.w1[i - <span class="number">13</span>], <span class="number">7</span>) ^ self.w1[i - <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">            self.w2[i] = self.w1[i] ^ self.w1[i + <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 测试扩展数据w1和w2</span></span><br><span class="line">        <span class="comment"># print(&quot;w1:&quot;)</span></span><br><span class="line">        <span class="comment"># for i in range(0, len(self.w1), 8):</span></span><br><span class="line">        <span class="comment">#     print(hex(self.w1[i]))</span></span><br><span class="line">        <span class="comment"># print(&quot;w2:&quot;)</span></span><br><span class="line">        <span class="comment"># for i in range(0, len(self.w2), 8):</span></span><br><span class="line">        <span class="comment">#     print(hex(self.w2[i]))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_compress</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="comment"># 压缩函数</span></span><br><span class="line">        <span class="comment"># 输入参数v为初始化参数，类型为bytes/bytearray，大小为256bit</span></span><br><span class="line">        <span class="comment"># 输入参数msg为512bit的待压缩数据</span></span><br><span class="line"></span><br><span class="line">        self.sm3_msg_extend(msg)</span><br><span class="line">        ss1 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        A = self.IV[<span class="number">0</span>]</span><br><span class="line">        B = self.IV[<span class="number">1</span>]</span><br><span class="line">        C = self.IV[<span class="number">2</span>]</span><br><span class="line">        D = self.IV[<span class="number">3</span>]</span><br><span class="line">        E = self.IV[<span class="number">4</span>]</span><br><span class="line">        F = self.IV[<span class="number">5</span>]</span><br><span class="line">        G = self.IV[<span class="number">6</span>]</span><br><span class="line">        H = self.IV[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">16</span>:</span><br><span class="line">                ss1 = rotation_left((rotation_left(A, <span class="number">12</span>) + E + rotation_left(self.T[<span class="number">0</span>], j)) % self.maxu32, <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">elif</span> j &gt;= <span class="number">16</span>:</span><br><span class="line">                ss1 = rotation_left((rotation_left(A, <span class="number">12</span>) + E + rotation_left(self.T[<span class="number">1</span>], j)) % self.maxu32, <span class="number">7</span>)</span><br><span class="line">            ss2 = ss1 ^ rotation_left(A, <span class="number">12</span>)</span><br><span class="line">            tt1 = (self.ff(A, B, C, j) + D + ss2 + self.w2[j]) % self.maxu32</span><br><span class="line">            tt2 = (self.gg(E, F, G, j) + H + ss1 + self.w1[j]) % self.maxu32</span><br><span class="line">            D = C</span><br><span class="line">            C = rotation_left(B, <span class="number">9</span>)</span><br><span class="line">            B = A</span><br><span class="line">            A = tt1</span><br><span class="line">            H = G</span><br><span class="line">            G = rotation_left(F, <span class="number">19</span>)</span><br><span class="line">            F = E</span><br><span class="line">            E = self.p(tt2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 测试IV的压缩中间值</span></span><br><span class="line">            <span class="comment"># print(&quot;j= %d：&quot; % j, hex(A)[2:], hex(B)[2:], hex(C)[2:], hex(D)[2:], hex(E)[2:], hex(F)[2:], hex(G)[2:], hex(H)[2:])</span></span><br><span class="line"></span><br><span class="line">        self.IV[<span class="number">0</span>] ^= A</span><br><span class="line">        self.IV[<span class="number">1</span>] ^= B</span><br><span class="line">        self.IV[<span class="number">2</span>] ^= C</span><br><span class="line">        self.IV[<span class="number">3</span>] ^= D</span><br><span class="line">        self.IV[<span class="number">4</span>] ^= E</span><br><span class="line">        self.IV[<span class="number">5</span>] ^= F</span><br><span class="line">        self.IV[<span class="number">6</span>] ^= G</span><br><span class="line">        self.IV[<span class="number">7</span>] ^= H</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_update</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="comment"># 迭代函数</span></span><br><span class="line">        <span class="comment"># 输入参数msg为bytearray类型</span></span><br><span class="line">        <span class="comment"># msg_new为bytearray类型</span></span><br><span class="line">        msg_new = self.sm3_fill(msg)  <span class="comment"># msg_new经过填充后一定是512的整数倍</span></span><br><span class="line">        n = <span class="built_in">len</span>(msg_new) // <span class="number">64</span>  <span class="comment"># n是整数，n&gt;=1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">            self.sm3_compress(msg_new[i * <span class="number">64</span>:(i + <span class="number">1</span>) * <span class="number">64</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_final</span>(<span class="params">self</span>):</span><br><span class="line">        digest_str = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.IV)):</span><br><span class="line">            digest_str += <span class="built_in">hex</span>(self.IV[i])[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> digest_str.upper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hashFile</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            contents = fp.read()</span><br><span class="line">            self.sm3_update(<span class="built_in">bytearray</span>(contents))</span><br><span class="line">        <span class="keyword">return</span> self.sm3_final()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileName</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 获取指定目录下的所有指定后缀的文件名 &#x27;&#x27;&#x27;</span></span><br><span class="line">    f_list = os.listdir(path)</span><br><span class="line">    <span class="comment"># print f_list</span></span><br><span class="line">    <span class="built_in">list</span> = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f_list:</span><br><span class="line">        <span class="comment"># os.path.splitext():分离文件名与扩展名</span></span><br><span class="line">        <span class="keyword">if</span> os.path.splitext(i)[<span class="number">1</span>] == <span class="string">&#x27;.tsidx&#x27;</span>:</span><br><span class="line">            <span class="built_in">list</span>.append(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileEventHandler</span>(<span class="title class_ inherited__">FileSystemEventHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        FileSystemEventHandler.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_created</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="keyword">if</span> event.is_directory:</span><br><span class="line">            <span class="built_in">print</span>(event.src_path)</span><br><span class="line">            time.sleep(<span class="number">15</span>)</span><br><span class="line">            <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;db_\d+_\d+_\d+&quot;</span>).findall(event.src_path.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]):</span><br><span class="line">                <span class="built_in">list</span> = getFileName(event.src_path)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">                    file_digest = SM3().hashFile(event.src_path + <span class="string">&quot;/&quot;</span> + <span class="built_in">list</span>[i])</span><br><span class="line">                    file = <span class="built_in">open</span>(event.src_path + <span class="string">&quot;/sm3(&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;).txt&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                    file.write(file_digest+ <span class="string">&quot; &quot;</span> + <span class="built_in">list</span>[i] + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                    file.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    observer = Observer()</span><br><span class="line">    event_handler = FileEventHandler()</span><br><span class="line">    observer.schedule(event_handler, <span class="string">&quot;/tmp&quot;</span>, <span class="literal">True</span>)</span><br><span class="line">    observer.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        observer.stop()</span><br><span class="line">    observer.join()</span><br></pre></td></tr></table></figure><p>代码中借鉴了<a href="https://blog.csdn.net/weixin_43936250/article/details/105543266">https://blog.csdn.net/weixin_43936250/article/details/105543266</a>的sm3加密，和<a href="https://blog.csdn.net/jerry_liufeng/article/details/109603462">https://blog.csdn.net/jerry_liufeng/article/details/109603462</a>的目录实时监控</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 新建脚本开头模板设置</title>
      <link href="/2021/08/09/pycharm_2/"/>
      <url>/2021/08/09/pycharm_2/</url>
      
        <content type="html"><![CDATA[<ol><li>点击菜单栏左上角<code>File</code>，选择<code>Settings</code>（快捷键：【ctrl】+【Alt】+【s】）</li><li>点击<code>Editor</code>，选择<code>File and Code Templates</code><br><img src="https://img-blog.csdnimg.cn/de03e74452a043bfa740554007d14f11.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>选择<code>Python Script</code><br><img src="https://img-blog.csdnimg.cn/d573faf7480248338b178f34be96a700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>在对应位置上写上对应的代码<br><img src="https://img-blog.csdnimg.cn/82d0a25ac4e848738ecdc0ca98f0b0ca.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是我写的代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##!/usr/bin/python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time : $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"># @Author : $&#123;USER&#125;</span><br><span class="line"># @Email : 邮箱地址</span><br><span class="line"># @File : $&#123;NAME&#125;.py</span><br><span class="line"># @Project : $&#123;PROJECT_NAME&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>保存之后新建py文件开头就会有模板了<br><img src="https://img-blog.csdnimg.cn/7bff6be93bb3445f9afd47dc0b3f10d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p>其他可用的预定义模板变量：<br><img src="https://img-blog.csdnimg.cn/748921f6945048fd8f44f3ca444a4759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 修改背景颜色</title>
      <link href="/2021/08/09/pycharm_1/"/>
      <url>/2021/08/09/pycharm_1/</url>
      
        <content type="html"><![CDATA[<ol><li>打开PyCharm，可以看的默认是黑色的<br><img src="https://img-blog.csdnimg.cn/73065aa97c87436eb397bc57d495c556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击菜单栏左上角<code>File</code>，选择<code>Settings</code>（快捷键：【ctrl】+【Alt】+【s】）<br><img src="https://img-blog.csdnimg.cn/7c54d55693584cc3826a82900726f379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击<code>Editor</code>，选择<code>color Scheme</code>，默认Scheme有八种，这样就可以修改背景主题了<br><img src="https://img-blog.csdnimg.cn/4ef1279c4d70496da10592c1247b31ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下安装 Scala</title>
      <link href="/2021/08/09/scala_2/"/>
      <url>/2021/08/09/scala_2/</url>
      
        <content type="html"><![CDATA[<ol><li><p>安装scala首先需要java6以上的支持，这里是java的安装教程：<a href="https://blog.csdn.net/weixin_44758876/article/details/119546446">windows下安装java</a></p></li><li><p>然后去官网下载自己需要的版本，我这里下载的是2.12.14的：<a href="https://www.scala-lang.org/download/2.12.14.html">https://www.scala-lang.org/download/2.12.14.html</a></p></li><li><p>点击安装包安装<br><img src="https://img-blog.csdnimg.cn/c653a5e23a2f414ebdecd2ecc4bb4860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一路默认即可，路径可以自己指定</p></li><li><p>配置环境变量，左下角搜索高级系统设置<br><img src="https://img-blog.csdnimg.cn/3ea274b434c14bc4ae2ad91119263ca6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>点击环境变量，点击新建，设置变量名和路径<br><img src="https://img-blog.csdnimg.cn/33bc0d683c9847f9aad7b3af9655d3d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>创建SCALA_HOME变量<br><img src="https://img-blog.csdnimg.cn/33a26cd48f654b97b5ce8fec05be66db.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p></li><li><p>再编辑CLASSPATH变量，在后面加入<code>;%SCALA_HOME%\bin;%SCALA_HOME%\lib\dt.jar;%SCALA_HOME%\lib\tools.jar</code>内容<br><img src="https://img-blog.csdnimg.cn/69833fd7dc93441a81fb1906a1689868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>选择Path变量，点击编辑，再点击新建<br><img src="https://img-blog.csdnimg.cn/f7a4451fad0d4e33ae1ad674b0a38f05.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5dcd102337044fff84fabbb92deaec99.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>新建，加入下面两行内容，然后保存即可<br><img src="https://img-blog.csdnimg.cn/75ec44cebbfb47c1927071e6bf330169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>最后验证安装成功即可<br><img src="https://img-blog.csdnimg.cn/a32e58381e96426b9217414633ec7c75.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下安装 Java</title>
      <link href="/2021/08/09/java_3/"/>
      <url>/2021/08/09/java_3/</url>
      
        <content type="html"><![CDATA[<ol><li>首先上官网下载安装包：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></li><li>点击安装包进行安装<br><img src="https://img-blog.csdnimg.cn/b7c8369895fa4657b3f2f1315c9d0097.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0104b276bc9946d28819d942553eace9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>安装完毕，配置环境变量</li><li>左下角搜索高级系统设置<br><img src="https://img-blog.csdnimg.cn/3ea274b434c14bc4ae2ad91119263ca6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击环境变量，点击新建，设置变量名和路径<br><img src="https://img-blog.csdnimg.cn/33bc0d683c9847f9aad7b3af9655d3d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/cae6cf8193dd4e4599162f187a4ec225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>再新建CLASSPATH变量，注意内容是<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code><br><img src="https://img-blog.csdnimg.cn/a5e0448a943349049a0bc8df6a1f4886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>选择Path变量，点击编辑，再点击新建<br><img src="https://img-blog.csdnimg.cn/f7a4451fad0d4e33ae1ad674b0a38f05.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5dcd102337044fff84fabbb92deaec99.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击新建，在下面追加<code>%JAVA_HOME%\bin</code>和<code>%JAVA_HOME%\jre\bin</code><br><img src="https://img-blog.csdnimg.cn/8860873e87f9406081e8daab8075b6a6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>保存生效，然后验证安装成功即可<br><img src="https://img-blog.csdnimg.cn/f374542af6334bf790b6cdf3ad0a9fb6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下安装 Python 环境</title>
      <link href="/2021/08/09/python_10/"/>
      <url>/2021/08/09/python_10/</url>
      
        <content type="html"><![CDATA[<ol><li>首先去官网下载安装包：<a href="https://www.python.org/">https://www.python.org/</a><br>我下载的是3.9.6版本，目前最新的版本</li><li>运行安装包，选择自定义安装，也可以选择默认安装<br><img src="https://img-blog.csdnimg.cn/c94ba6a274204027bd4a05f220b9da95.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5d596d7f6954476ca3bb76334bd012a3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>安装在指定目录下<br><img src="https://img-blog.csdnimg.cn/646a1960e3654ecdb528f311e2342e27.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>安装完毕后，可以禁用系统的Path长度自动限制，后面会省去不少麻烦<br><img src="https://img-blog.csdnimg.cn/2299da22c8f24990bd1d37a3b70831a7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>打印“hello python”，检验安装成功<br><img src="https://img-blog.csdnimg.cn/a95c3f39357844bf893a6dba9e1899a3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之 API 数据合并（第二版）</title>
      <link href="/2021/07/29/python_9/"/>
      <url>/2021/07/29/python_9/</url>
      
        <content type="html"><![CDATA[<p>这是继上一篇<a href="https://blog.csdn.net/weixin_44758876/article/details/118413513">python脚本之api数据合并</a>之后做出的第二版，最近比较忙一直拖到现在才想起来更新。<br>第一版实现的是单参数的合并，这一版就是实现多参数的合并了，样例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/api/login/001-1/index/1</span><br><span class="line">/api/login/001-2/index/2</span><br><span class="line">/api/login/001-3/index/3</span><br><span class="line">/api/login/001-4/index/4</span><br></pre></td></tr></table></figure><p>最后合并成下面的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/login/&#123;id1&#125;/index/&#123;id2&#125;</span><br></pre></td></tr></table></figure><p>代码加注释一共三百行左右，说实话我自己看着都费事，所以做了个xmind思维导图，和部分模块的“白话版”代码。<br>思维导图：<br><img src="https://img-blog.csdnimg.cn/57f88939f81a4f5199c6790944e7a5aa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图画的一般，，，，凑合看吧。<br>“白话版”代码块放最后，先上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,math,datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将包含数字的段替换为“&#123;id1&#125;，&#123;id2&#125;，&#123;id3&#125;...”</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="built_in">list</span> = re.findall(<span class="string">&#x27;/[^/,]*\d[^/,]*&#x27;</span>, data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        data = data.replace(<span class="built_in">list</span>[i], <span class="string">&quot;/&#123;id&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;&#125;&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># C:\\Users\\lkm86\\Desktop\\API自动发现2021-06-24 17_46_41.csv</span></span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\lkm86\\Desktop\\API自动发现2021-07-20 16_04_32.csv&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 读取数据</span></span><br><span class="line">    content = file.readlines()</span><br><span class="line">    <span class="comment"># 存放一个包含数字的段的要计数api</span></span><br><span class="line">    patternList = []</span><br><span class="line">    <span class="comment"># 存放一个包含数字的段的api</span></span><br><span class="line">    patternBranch = []</span><br><span class="line">    <span class="comment"># 存放多个包含数字的段的api</span></span><br><span class="line">    patternsDict = &#123;&#125;</span><br><span class="line">    <span class="comment"># # 存放多个包含数字的段的api</span></span><br><span class="line">    patternsBranch = &#123;&#125;</span><br><span class="line">    <span class="comment"># 存放最终结果</span></span><br><span class="line">    patterns = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    数据分组，划分为：</span></span><br><span class="line"><span class="string">        （1）不包含数字；</span></span><br><span class="line"><span class="string">        （2）1个段包含数字；</span></span><br><span class="line"><span class="string">        （3）N+1个段包含数字。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 遍历数据列表</span></span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> content:</span><br><span class="line">        <span class="comment"># 取出api中包含数字的段</span></span><br><span class="line">        apiList = re.findall(<span class="string">&#x27;/[^/,]*\d[^/,]*&#x27;</span>, lines)</span><br><span class="line">        <span class="comment"># 正则匹配是否有包含数字的段</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(apiList) &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 替换包含数字的段为“&#123;id&#125;”</span></span><br><span class="line">            api = sub(lines)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将替换后的api表达式再和别的字段合并放入patternsDict，后续计数使用</span></span><br><span class="line">            <span class="keyword">if</span> patternsDict.get(<span class="built_in">len</span>(apiList)) == <span class="literal">None</span>:</span><br><span class="line">                patternsDict[<span class="built_in">len</span>(apiList)] = [api.strip()]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                patternsDict[<span class="built_in">len</span>(apiList)].append(api.strip())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将未做替换的api和其余字段合并并放入patternsBranch，后续过滤符合表达式的api使用</span></span><br><span class="line">            <span class="keyword">if</span> patternsBranch.get(<span class="built_in">len</span>(apiList)) == <span class="literal">None</span>:</span><br><span class="line">                patternsBranch[<span class="built_in">len</span>(apiList)] = [lines.strip()]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                patternsBranch[<span class="built_in">len</span>(apiList)].append(lines.strip())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(apiList) == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 替换包含数字的段为“&#123;id&#125;”</span></span><br><span class="line">            api = sub(lines)</span><br><span class="line">            <span class="comment"># 将替换后的api表达式再和别的字段合并放入patternList，后续计数使用</span></span><br><span class="line">            patternList.append(api.strip())</span><br><span class="line">            <span class="comment"># 将未做替换的api和其余字段合并并放入patternBranch，后续过滤符合表达式的api使用</span></span><br><span class="line">            patternBranch.append(lines.strip())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将不包含数字的数据直接放入patterns，并计算与总数据量的占比</span></span><br><span class="line">            patterns[lines.strip()] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    处理一个段包含数据的api</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(patternList) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 将patternList计数，得到字典cnt，key是patternList的原数据，value是原数据出现的次数</span></span><br><span class="line">        cnt = Counter(patternList)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历字典cnt</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> cnt.keys():</span><br><span class="line">            <span class="comment"># 判断表达式出现次数是否小于2</span></span><br><span class="line">            <span class="keyword">if</span> cnt[key] &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 将表达式中的api的“&#123;id1&#125;”替换为是否包含数字的正则表达式</span></span><br><span class="line">                reString = key.replace(<span class="string">&quot;&#123;id1&#125;&quot;</span>, <span class="string">&quot;[^\\/]*\d[^\\/]*&quot;</span>)</span><br><span class="line">reString = <span class="string">&quot;^&quot;</span> + reString + <span class="string">&quot;$&quot;</span></span><br><span class="line">                <span class="comment"># 遍历patternBranch</span></span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> patternBranch:</span><br><span class="line">                    <span class="comment"># 判断patternBranch中数据的api是否符合正则表达式reString</span></span><br><span class="line">                    <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(line):</span><br><span class="line">                        <span class="comment"># 将符合正则表达式的放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">                        patterns[line] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将表达式出现次数大于等于2的放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">                patterns[key] = math.ceil(cnt[key] / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    处理N+1个段包含数据的api</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 遍历转换“&#123;id&#125;”后的正则表达式</span></span><br><span class="line">    <span class="keyword">for</span> keyDict <span class="keyword">in</span> patternsDict.keys():</span><br><span class="line">        <span class="comment"># 将包含“&#123;id&#125;”个数相同的api统一计数</span></span><br><span class="line">        cnt = Counter(patternsDict[keyDict])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断如果计数的key为1就说明只有一个表达式，不需要再做是否匹配表达式这一操作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cnt) &gt; <span class="number">1</span> :</span><br><span class="line">            <span class="comment"># 遍历计数字典cnt</span></span><br><span class="line">            <span class="keyword">for</span> keyCnt <span class="keyword">in</span> cnt.keys():</span><br><span class="line">                <span class="comment"># 替换表达式为正则，以此筛选出符合当前格式的数据</span></span><br><span class="line">                reString = re.<span class="built_in">compile</span>(<span class="string">&#x27;/[^/,]*\d[^/,]*&#x27;</span>).sub(<span class="string">&quot;/[^/,]*\\\d[^/,]*&quot;</span>, keyCnt)</span><br><span class="line">                reString = <span class="string">&quot;^&quot;</span> + reString + <span class="string">&quot;$&quot;</span></span><br><span class="line">                <span class="comment"># 如果value小于或等于2，说明此表达式最多由两条数据生成，就不产生表达式，直接将匹配此表达式的数据加入到 patterns</span></span><br><span class="line">                <span class="keyword">if</span> cnt[keyCnt] &lt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                    <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line">                        <span class="comment"># 符合当前表达式格式的数据加入patterns</span></span><br><span class="line">                        <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(data):</span><br><span class="line">                            patterns[data] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 存放要计数的数据</span></span><br><span class="line">                    dataList = []</span><br><span class="line">                    <span class="comment"># 存放不是&#123;id&#125;的段的下标</span></span><br><span class="line">                    idList = []</span><br><span class="line">                    <span class="comment"># 计数，防止下标越界</span></span><br><span class="line">                    num = <span class="number">1</span></span><br><span class="line">                    <span class="comment"># keyDict为当前处理的数据的“&#123;id&#125;”个数，个数多少就循环多少次，可以得到相同数据类型下不是真的参数的包含数字的段的下标</span></span><br><span class="line">                    <span class="keyword">while</span> num &lt;= keyDict:</span><br><span class="line">                        <span class="comment"># 清空dataList</span></span><br><span class="line">                        dataList.clear()</span><br><span class="line">                        <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                        <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line">                            <span class="comment"># 判断数据是否符合当前表达式格式</span></span><br><span class="line">                            <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(data):</span><br><span class="line"></span><br><span class="line">                                <span class="comment"># 存放转换后的数据</span></span><br><span class="line">                                dataString = <span class="string">&quot;&quot;</span></span><br><span class="line">                                <span class="comment"># 计数，和num做对比</span></span><br><span class="line">                                datanum = <span class="number">1</span></span><br><span class="line">                                <span class="comment"># 根据包含数字的部分拆分数据</span></span><br><span class="line">                                <span class="built_in">list</span> = re.split(<span class="string">&quot;(/[^/,]*\d[^/,]*)&quot;</span>, data)</span><br><span class="line">                                <span class="comment"># 遍历拆分后的列表</span></span><br><span class="line">                                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                                    <span class="comment"># 判断是否包含数字，不包含直接和dataString拼接</span></span><br><span class="line">                                    <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;/[^/,]*\d[^/,]*&quot;</span>).findall(i):</span><br><span class="line">                                        <span class="comment"># 判断是否和num相同，相同则不转换为“/&#123;id&#125;”，不相同则转换为“/&#123;id&#125;”</span></span><br><span class="line">                                        <span class="keyword">if</span> datanum == num:</span><br><span class="line">                                            dataString = dataString + i</span><br><span class="line">                                        <span class="keyword">else</span>:</span><br><span class="line">                                            dataString = dataString + <span class="string">&quot;/&#123;id&#125;&quot;</span></span><br><span class="line">                                        <span class="comment"># 计数+1</span></span><br><span class="line">                                        datanum = datanum + <span class="number">1</span></span><br><span class="line">                                    <span class="keyword">else</span>:</span><br><span class="line">                                        dataString = dataString + i</span><br><span class="line"></span><br><span class="line">                                <span class="comment"># 将转换后的数据放入dataList，后续计数使用</span></span><br><span class="line">                                dataList.append(dataString)</span><br><span class="line">                        <span class="comment"># 去重，得到当前类型的数据中，“&#123;id&#125;”的值不同的个数</span></span><br><span class="line">                        dataSet = <span class="built_in">set</span>(dataList)</span><br><span class="line">                        <span class="comment"># 如果“&#123;id&#125;”值不同的个数占全部的60%以下，则判定当前段不是真正的参数，将当前段的下标加入到idList</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(dataSet) / <span class="built_in">len</span>(dataList) &lt; <span class="number">0.6</span>:</span><br><span class="line">                            idList.append(num)</span><br><span class="line">                        <span class="comment"># 计数 +1</span></span><br><span class="line">                        num = num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 存放转换“&#123;id&#125;”后的数据，计数使用</span></span><br><span class="line">                    pattern = []</span><br><span class="line">                    <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                    <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line">                        <span class="comment"># 判断数据是否符合当前表达式格式</span></span><br><span class="line">                        <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(data):</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 存放转换后的数据</span></span><br><span class="line">                            dataString = <span class="string">&quot;&quot;</span></span><br><span class="line">                            <span class="comment"># 计数，判断idList中包不包含当前下标的段</span></span><br><span class="line">                            datanum1 = <span class="number">1</span></span><br><span class="line">                            <span class="comment"># 计数，统计当前数据有几个“&#123;id&#125;”</span></span><br><span class="line">                            datanum2 = <span class="number">1</span></span><br><span class="line">                            <span class="comment"># 根据包含数字的部分拆分数据</span></span><br><span class="line">                            <span class="built_in">list</span> = re.split(<span class="string">&quot;(/[^/,]*\d[^/,]*)&quot;</span>, data)</span><br><span class="line">                            <span class="comment"># 遍历拆分后的列表</span></span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                                <span class="comment"># 判断当前段是否包含数字，如果不包含直接和dataString拼接</span></span><br><span class="line">                                <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;/[^/,]*\d[^/,]*&quot;</span>).findall(i):</span><br><span class="line">                                    <span class="comment"># 如果当前下标的段在idList中，则表示当前包含数字的段非真正的“&#123;id&#125;”；不在idList中，就拼接“&#123;id&#125;”</span></span><br><span class="line">                                    <span class="keyword">if</span> datanum1 <span class="keyword">in</span> idList:</span><br><span class="line">                                        dataString = dataString + i</span><br><span class="line">                                    <span class="keyword">else</span>:</span><br><span class="line">                                        dataString = dataString + <span class="string">&quot;/&#123;id&quot;</span> + <span class="built_in">str</span>(datanum2) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                                        datanum2 = datanum2 + <span class="number">1</span></span><br><span class="line">                                    <span class="comment"># 计数+1</span></span><br><span class="line">                                    datanum1 = datanum1 + <span class="number">1</span></span><br><span class="line">                                <span class="keyword">else</span>:</span><br><span class="line">                                    dataString = dataString + i</span><br><span class="line"></span><br><span class="line">                            pattern.append(dataString)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 计数，也是去重，之所以不直接去重是因为要计算当前表达式的个数来算百分比</span></span><br><span class="line">                    patternsCnt = Counter(pattern)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 将表达式加入列表patterns</span></span><br><span class="line">                    <span class="keyword">for</span> key <span class="keyword">in</span> patternsCnt.keys():</span><br><span class="line">                        patterns[key] = math.ceil(patternsCnt[key] / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 遍历计数字典cnt</span></span><br><span class="line">            <span class="keyword">for</span> keyCnt <span class="keyword">in</span> cnt.keys():</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果value小于或等于2，说明此表达式最多由两条数据生成，就不产生表达式，直接将匹配此表达式的数据加入到 patterns</span></span><br><span class="line">                <span class="keyword">if</span> cnt[keyCnt] &lt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表，将数据直接加入patterns</span></span><br><span class="line">                    <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line">                        patterns[data] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 存放要计数的数据</span></span><br><span class="line">                    dataList = []</span><br><span class="line">                    <span class="comment"># 存放不是&#123;id&#125;的段的下标</span></span><br><span class="line">                    idList = []</span><br><span class="line">                    <span class="comment"># 计数，防止下标越界</span></span><br><span class="line">                    num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># keyDict为当前处理的数据的“&#123;id&#125;”个数，个数多少就循环多少次，可以得到相同数据类型下不是真的参数的包含数字的段的下标</span></span><br><span class="line">                    <span class="keyword">while</span> num &lt;= keyDict:</span><br><span class="line">                        <span class="comment"># 清空dataList</span></span><br><span class="line">                        dataList.clear()</span><br><span class="line">                        <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                        <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 存放转换后的数据</span></span><br><span class="line">                            dataString = <span class="string">&quot;&quot;</span></span><br><span class="line">                            <span class="comment"># 计数，和num做对比</span></span><br><span class="line">                            datanum = <span class="number">1</span></span><br><span class="line">                            <span class="comment"># 根据包含数字的部分拆分数据</span></span><br><span class="line">                            <span class="built_in">list</span> = re.split(<span class="string">&quot;(/[^/,]*\d[^/,]*)&quot;</span>, data)</span><br><span class="line">                            <span class="comment"># 遍历拆分后的列表</span></span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                                <span class="comment"># 判断是否包含数字，不包含直接和dataString拼接</span></span><br><span class="line">                                <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;/[^/,]*\d[^/,]*&quot;</span>).findall(i):</span><br><span class="line">                                    <span class="comment"># 判断是否和num相同，相同则不转换为“/&#123;id&#125;”，不相同则转换为“/&#123;id&#125;”</span></span><br><span class="line">                                    <span class="keyword">if</span> datanum == num:</span><br><span class="line">                                        dataString = dataString + i</span><br><span class="line">                                    <span class="keyword">else</span>:</span><br><span class="line">                                        dataString = dataString + <span class="string">&quot;/&#123;id&#125;&quot;</span></span><br><span class="line">                                    <span class="comment"># 计数+1</span></span><br><span class="line">                                    datanum = datanum + <span class="number">1</span></span><br><span class="line">                                <span class="keyword">else</span>:</span><br><span class="line">                                    dataString = dataString + i</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 将转换后的数据放入dataList，后续计数使用</span></span><br><span class="line">                            dataList.append(dataString)</span><br><span class="line">                        <span class="comment"># 去重，得到当前类型的数据中，“&#123;id&#125;”的值不同的个数</span></span><br><span class="line">                        dataSet = <span class="built_in">set</span>(dataList)</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 如果“&#123;id&#125;”值不同的个数占全部的60%以下，则判定当前段不是真正的参数，将当前段的下标加入到idList</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(dataSet) / <span class="built_in">len</span>(dataList) &lt; <span class="number">0.6</span>:</span><br><span class="line">                            idList.append(num)</span><br><span class="line">                        <span class="comment"># 计数 +1</span></span><br><span class="line">                        num = num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 存放转换“&#123;id&#125;”后的数据，计数使用</span></span><br><span class="line">                    pattern = []</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                    <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 存放转换后的数据</span></span><br><span class="line">                        dataString = <span class="string">&quot;&quot;</span></span><br><span class="line">                        <span class="comment"># 计数，判断idList中包不包含当前下标的段</span></span><br><span class="line">                        datanum1 = <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 计数，统计当前数据有几个“&#123;id&#125;”</span></span><br><span class="line">                        datanum2 = <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 根据包含数字的部分拆分数据</span></span><br><span class="line">                        <span class="built_in">list</span> = re.split(<span class="string">&quot;(/[^/,]*\d[^/,]*)&quot;</span>, data)</span><br><span class="line">                        <span class="comment"># 遍历拆分后的列表</span></span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                            <span class="comment"># 判断当前段是否包含数字，如果不包含直接和dataString拼接</span></span><br><span class="line">                            <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;/[^/,]*\d[^/,]*&quot;</span>).findall(i):</span><br><span class="line">                                <span class="comment"># 如果当前下标的段在idList中，则表示当前包含数字的段非真正的“&#123;id&#125;”；不在idList中，就拼接“&#123;id&#125;”</span></span><br><span class="line">                                <span class="keyword">if</span> datanum1 <span class="keyword">in</span> idList:</span><br><span class="line">                                    dataString = dataString + i</span><br><span class="line">                                <span class="keyword">else</span>:</span><br><span class="line">                                    dataString = dataString + <span class="string">&quot;/&#123;id&quot;</span> + <span class="built_in">str</span>(datanum2) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                                    datanum2 = datanum2 + <span class="number">1</span></span><br><span class="line">                                <span class="comment"># 计数+1</span></span><br><span class="line">                                datanum1 = datanum1 + <span class="number">1</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                dataString = dataString + i</span><br><span class="line"></span><br><span class="line">                        pattern.append(dataString)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 计数，也是去重，之所以不直接去重是因为要计算当前表达式的个数来算百分比</span></span><br><span class="line">                    patternsCnt = Counter(pattern)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 将表达式加入列表patterns</span></span><br><span class="line">                    <span class="keyword">for</span> key <span class="keyword">in</span> patternsCnt.keys():</span><br><span class="line">                        patterns[key] = math.ceil(patternsCnt[key] / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    打印输出</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> patterns.keys():</span><br><span class="line">        <span class="built_in">print</span>(key)</span><br><span class="line">        <span class="built_in">print</span>(patterns[key])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(datetime.datetime.now())</span><br><span class="line">    main()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(datetime.datetime.now())</span><br></pre></td></tr></table></figure><p>处理多参数数据模块的“白话版”代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">patternsDict&#123;</span><br><span class="line">2：</span><br><span class="line">[......],</span><br><span class="line">3：</span><br><span class="line">[&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot;,</span><br><span class="line">&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot;,</span><br><span class="line">&quot;/api/login/&#123;id1&#125;/index/&#123;id2&#125;/&#123;id3&#125;&quot;,</span><br><span class="line">......],</span><br><span class="line">4：</span><br><span class="line">[......]</span><br><span class="line">&#125;</span><br><span class="line">patternsBranch&#123;</span><br><span class="line">2：</span><br><span class="line">[......],</span><br><span class="line">3：</span><br><span class="line">[&quot;/api/1/login/1/index/1&quot;,</span><br><span class="line">&quot;/api/2/login/2/index/2&quot;,</span><br><span class="line">&quot;/api/login/1/index/1/1&quot;,</span><br><span class="line">......],</span><br><span class="line">4：</span><br><span class="line">[......]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">假设 patternsDict[3] 中&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot;有 5 个，&quot;/api/login/&#123;id1&#125;/index/&#123;id2&#125;/&#123;id3&#125;&quot;有 4 个</span><br><span class="line"></span><br><span class="line">遍历patternsDict</span><br><span class="line">cnt = Counter(patternsDict[key])</span><br><span class="line"></span><br><span class="line">cnt&#123;</span><br><span class="line">&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot; ： 5 ,</span><br><span class="line">&quot;/api/login/&#123;id1&#125;/index/&#123;id2&#125;/&#123;id3&#125;&quot; : 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如果len(cnt)为1就说明只有一个表达式，不需要再做下面是否匹配表达式这一操作</span><br><span class="line">if len(cnt) &gt; 1 :</span><br><span class="line"></span><br><span class="line">遍历cnt</span><br><span class="line"></span><br><span class="line">转换数据得到正则表达式</span><br><span class="line">例：&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot;，得到正则表达式&quot;/api/[^/,]*\d[^/,]*/login/[^/,]*\d[^/,]*/index/[^/,]*\d[^/,]*&quot;</span><br><span class="line"></span><br><span class="line">如果value小于等于2，不再进行计算，直接把符合当前key的表达式的数据加入 patterns （patterns存放最终结果）</span><br><span class="line"></span><br><span class="line">如果value大于2，进行下一步计算</span><br><span class="line"></span><br><span class="line">while循环，循环次数为当前patternsDict[key]，也就是包含数字的段的个数</span><br><span class="line"></span><br><span class="line">遍历patternsBranch[3]</span><br><span class="line">“/api/1/login/1/index/1”转换为“/api/&#123;id&#125;/login/1/index/1”，</span><br><span class="line">将“/api/&#123;id&#125;/login/1/index/1”放入dataList</span><br><span class="line"></span><br><span class="line">注：随着while的循环，patternsBranch[3]的数据会不断转换成“/api/1/login/&#123;id&#125;/index/1”、“/api/1/login/1/index/&#123;id&#125;”</span><br><span class="line"></span><br><span class="line">dataSet = set(dataList)，得到去重后的dataSet</span><br><span class="line">if len(dataSet) / len(dataList) &lt; 0.6 :</span><br><span class="line">判断len(dataSet)不到len(dataList)的五分之三，说明当前 &#123;id&#125; 不是真的参数，将当前 &#123;id&#125; 的下标加入idList</span><br><span class="line"></span><br><span class="line">遍历patternsBranch[3]（也就是遍历一条条data）</span><br><span class="line"></span><br><span class="line">判断是否符合当前key的正则表达式</span><br><span class="line"></span><br><span class="line">根据idList中记录的下标，将data中对应下标的包含数字的段转换为 &#123;id1&#125;、&#123;id2&#125;、&#123;id3&#125;...</span><br><span class="line"></span><br><span class="line">将转换后的data，放入列表 pattern 中</span><br><span class="line"></span><br><span class="line">patternsCnt = Counter(pattern) ， 得到patternsCnt&#123;</span><br><span class="line">&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot; : 5 ,</span><br><span class="line">&quot;/api/login/&#123;id1&#125;/index/&#123;id2&#125;/&#123;id3&#125;&quot; : 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将patternsCnt中的表达式放入 patterns （patterns存放最终结果）</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">重复if len(cnt) &gt; 1 后面的计算，只是不需要再做“判断是否符合当前key的正则表达式”这一操作</span><br></pre></td></tr></table></figure><p>整体代码不用心花时间看肯定是看不懂的，需要的就慢慢看吧。。。。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> API数据合并 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的基本数据类型与特殊数据类型详解</title>
      <link href="/2021/07/29/redis_8/"/>
      <url>/2021/07/29/redis_8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、官网介绍">一、官网介绍</h1><p><img src="https://img-blog.csdnimg.cn/20210712203520640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作<code>数据库</code>、<code>缓存</code>和<code>消息中间件</code>。 它支持多种类型的数据结构，如<code>字符串（strings）</code>， <code>散列（hashes）</code>，<code>列表（lists）</code>，<code>集合（sets）</code>，<code>有序集合（sorted sets）</code> 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p><h1 id="二、Redis常用的五大数据类型">二、Redis常用的五大数据类型</h1><p>Redis常用的五大数据类型为：<code>String（字符串）</code>、<code>List（列表）</code>、<code>Set（集合）</code>、<code>Hash（哈希，类似java里的map）</code>、<code>Zset（sorted set：有序集合）</code>。</p><h2 id="1-String（字符串）">1. String（字符串）</h2><p>String 是 Redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。<br>String 类型是 Redis 最基本的数据类型（可以为整形、浮点型和字符串，统称为元素），最大能存储 <code>512MB</code>。</p><h3 id="1-1-常用命令">1.1 常用命令</h3><ul><li><code>set : 设置值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 v1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li><code>get : 获取值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>获取所有的key</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>exists : 判断某个key是否存在</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXISTS key1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li><code>append : 追加字符串，如果当前key不存在，就相当于‘set key’</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; APPEND key1 &quot;hello&quot;</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;v1hello&quot;</span><br></pre></td></tr></table></figure><ul><li><code>strlen : 获取字符串的长度</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; STRLEN key1</span><br><span class="line">(integer) 7</span><br></pre></td></tr></table></figure><ul><li><code>incr : 自增</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>decr : 自减</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure><ul><li><code>incrby : 加</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incrby views 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><ul><li><code>decrby : 减</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; decrby views 5</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;-2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>getrange : 获取字符串指定下标范围的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 &quot;hello,redis&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;hello,redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 5</span><br><span class="line">&quot;hello,&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 -1</span><br><span class="line">&quot;hello,redis&quot;</span><br></pre></td></tr></table></figure><ul><li><code>setrange : 替换字符串指定下标的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key2 &quot;abcdefghijklmn&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;abcdefghijklmn&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETRANGE key2 1 xx</span><br><span class="line">(integer) 14</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;axxdefghijklmn&quot;</span><br></pre></td></tr></table></figure><ul><li><code>setex : 设置过期时间</code></li><li><code>ttl : 查看剩余过期时间</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置“key3”30秒后过期</span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) 20</span><br></pre></td></tr></table></figure><ul><li><code>setnx : 设置值，前提是键必须不存在</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key4 v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key4&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;key1&quot;</span><br><span class="line">127.0.0.1:6379&gt; setnx key4 v3</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get key4</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>mset : 批量设置值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;k3&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>mget : 批量获取值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br></pre></td></tr></table></figure><ul><li><code>msetnx : 批量设置值，前提是键必须不存在</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;k3&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v2 k4 v4# msetnx 是一个原子性的操作，要么一起成功，要么一起失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ul><li><code>设置一个对象</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># user:&#123;id&#125;:&#123;filed&#125;</span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>设置一个对象，用json字符串保存</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set user:1 &#123;name:zhangsan,age:26&#125;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">&quot;&#123;name:zhangsan,age:26&#125;&quot;</span><br></pre></td></tr></table></figure><ul><li><code>getset 组合命令</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; getset key1 hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; getset key1 redis</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure><p><code>想知道更多详细的命令可以访问：</code> <a href="https://blog.csdn.net/weixin_44758876/article/details/118191804">Redis命令详解</a></p><h3 id="1-2-使用场景">1.2 使用场景</h3><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存、存储</li></ul><h3 id="1-3-数据结构">1.3 数据结构</h3><p>String的数据结构为简单动态字符串（Simple Dynamic String,缩写SDS）。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList ，采用预分配冗余空间的方式来减少内存的频繁分配。<br><img src="https://img-blog.csdnimg.cn/59d3706049054848bdb41c586fee4085.png#pic_center" alt="在这里插入图片描述"><br>如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len 。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。<br><br></p><h2 id="2-List（列表）">2. List（列表）</h2><p><img src="https://img-blog.csdnimg.cn/5050488cb18a4a088afc6def567707f1.png#pic_center" alt="在这里插入图片描述"></p><p>Redis 的列表类型是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个<code>双向链表</code>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><h3 id="2-1-常用命令">2.1 常用命令</h3><ul><li><code>lrange : 获取列表的多个元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lindex : 获取列表指定下标的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line">&quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 1</span><br><span class="line">&quot;two&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 3</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ul><li><code>llen : 获取列表的长度</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><ul><li><code>lpush : 将一个值或多个值插入列表的头部</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list two three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br></pre></td></tr></table></figure><ul><li><code>rpush : 将一个值或多个值插入列表的尾部</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush list two three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lpop : 移除列表头部的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">&quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;three&quot;</span><br></pre></td></tr></table></figure><ul><li><code>rpop : 移除列表尾部的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line">&quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lrem : 移除列表指定的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lrem : 移除列表指定的多个元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 one</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><ul><li><code>ltrim : 截取列表指定下标内的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist &quot;hello&quot; &quot;hello1&quot; &quot;hello2&quot; &quot;hello3&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br><span class="line">3) &quot;hello2&quot;</span><br><span class="line">4) &quot;hello3&quot;</span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello1&quot;</span><br><span class="line">2) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>rpoplpush : 移除列表最后一个元素，将该元素移动到新的列表中（新列表不存在时会自动创建）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br><span class="line">3) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist</span><br><span class="line">&quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class="line">1) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lset : 将列表中指定下标的值替换为另一个值（更新操作，更新不存在的下标会报错）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists list</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list 1 other</span><br><span class="line">(error) ERR index out of range</span><br></pre></td></tr></table></figure><ul><li><code>linsert : 将某个具体的值插入到列表中指定元素的前面或后面</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before &quot;world&quot; &quot;other&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;other&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after &quot;world&quot; &quot;new&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;other&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">4) &quot;new&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用场景">2.2 使用场景</h3><ul><li>List 类型经常会被用于消息队列的服务，以完成多程序之间的消息交换</li><li>消息队列（lpush rpop）</li><li>栈（lpush lpop）</li></ul><h3 id="2-3-数据结构">2.3 数据结构</h3><p>List的数据结构为快速链表 quickList 。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。<br>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br>当数据量比较多的时候才会改成quicklist。<br>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<br><img src="https://img-blog.csdnimg.cn/04f1550332bc48d797f57011add50a1a.png#pic_center" alt="在这里插入图片描述"><br>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h2 id="3-Set（集合）">3. Set（集合）</h2><p>set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<code>自动排重</code>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。<br>edis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的<code>复杂度都是O(1)</code>。<br>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。</p><h3 id="3-1-常用命令">3.1 常用命令</h3><ul><li><code>smembers : 查看集合的所有元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sadd : 往集合中添加值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;Redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;Redis&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br><span class="line">4) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;hello1&quot; &quot;hello2&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">4) &quot;Redis&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line">6) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sismember : 判断集合中是否存在指定元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">4) &quot;Redis&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line">6) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello3</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><ul><li><code>scard : 获取集合所有元素的个数</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;Redis&quot;</span><br><span class="line">4) &quot;redis&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line">6) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><ul><li><code>srem : 移除集合中指定元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;Redis&quot;</span><br><span class="line">4) &quot;redis&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line">6) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; srem myset world</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;Redis&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;hello1&quot;</span><br><span class="line">5) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>srandmember : 随机获取集合中的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;Redis&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;hello1&quot;</span><br><span class="line">5) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line">&quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) &quot;Redis&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>spop : 随机删除集合中的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;Redis&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;hello1&quot;</span><br><span class="line">5) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line">&quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;Redis&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line">&quot;Redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;hello1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>smove : 将集合中指定的元素移动到另一个集合中</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 &quot;hello1&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sdiff : 获取两个集合之间的差集</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff set2 set1</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">2) &quot;d&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sinter : 获取两个集合之间的交集</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2</span><br><span class="line">1) &quot;c&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sunion : 获取两个集合之间的并集</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunion set1 set2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;e&quot;</span><br><span class="line">5) &quot;d&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-使用场景">3.2 使用场景</h3><ul><li>用户之间的共同关注、共同爱好、二度好友</li><li>推荐好友</li><li>六度分割理论</li></ul><h3 id="3-3-数据结构">3.3 数据结构</h3><p>Set数据结构是dict字典，字典是用哈希表实现的。<br>Java中 HashSet 的内部实现使用的是 HashMap ，只不过所有的 value 都指向同一个对象。Redis的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向同一个内部值。</p><h2 id="4-Hash（哈希）">4. Hash（哈希）</h2><p>Redis hash 是一个键值对集合。<br>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。<br>类似 Java 里面的<code>Map&lt;String,Object&gt;</code>。</p><p>举个例子，用户ID为查找的 key ，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key/value 结构来存储，主要有以下2种存储方式：</p><ol><li>每次修改用户的某个属性需要，先反序列化改好后再序列化回去，开销较大。<br><img src="https://img-blog.csdnimg.cn/81bd9b7532f4442695a5416f9837ec4c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>用户ID数据冗余。<br><img src="https://img-blog.csdnimg.cn/001df24aca2c40ba8a8321e402347f9e.png#pic_center" alt="在这里插入图片描述"></li></ol><p>通过 <code>key(用户ID) + field(属性标签)</code> 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。<br><img src="https://img-blog.csdnimg.cn/75dd0fc25371410dbc2baf86e9b6c633.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-1-常用命令">4.1 常用命令</h3><ul><li><code>hkeys : 获取hash中所有的field</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;field2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hvals : 获取hash中所有的value</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hset : 设置hash的field-value值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash field1 &quot;hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;hello&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hmset : 设置多个hash的field-value值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;field2&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hget : 获取hash中指定的value</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hmget : 获取hash中指定的多个value</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hgetall : 获取hash中所有的值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;field2&quot;</span><br><span class="line">4) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hdel : 删除hash中指定的field（对应的value同样被删除）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;field2&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hlen : 获取hash的元素数量</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">2) &quot;field1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><ul><li><code>hexists : 判断hash中的指定元素是否存在</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">2) &quot;field1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field3</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><ul><li><code>hincrby : 使hash中指定field的值增量</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash field1 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field1 1</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field1 -1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;3&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hsetnx : 设置hash的field-value值，如果field存在则不能设置，如果field不存在可以设置</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx myhash field1 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field1 hello1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br></pre></td></tr></table></figure><h3 id="4-2-使用场景">4.2 使用场景</h3><ul><li>hash更适合存储对象，而string更适合存储字符串</li><li>用户信息，经常变动的信息</li></ul><h3 id="4-3-数据结构">4.3 数据结构</h3><p>Hash类型对应的数据结构是两种：<code>ziplist（压缩列表）</code>，<code>hashtable（哈希表）</code>。<br>当 field-value 长度较短且个数较少时，使用 ziplist ，否则使用 hashtable 。</p><h2 id="5-Zset（sorted-set：有序集合）">5. Zset（sorted set：有序集合）</h2><p>Redis有序集合zset与普通集合set非常相似，是一个<code>没有重复元素</code>的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<code>评分（score）</code>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<code>集合的成员是唯一的，但是评分可以是重复了</code> 。<br>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h3 id="5-1-常用命令">5.1 常用命令</h3><ul><li><code>zrange : 获取zset集合的多个元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 1</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><ul><li><code>zadd : 向zset集合中添加数据</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><ul><li><code>zrangebyscore : 排序，从小到大</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd salary 2500 zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 1000 wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;1000&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;5000&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +2500 withscores</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;1000&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br></pre></td></tr></table></figure><ul><li><code>zrevrange : 排序，从大到小</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;zhaoliu&quot;</span><br><span class="line">4) &quot;wangwu&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1 withscores</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;5000&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;zhaoliu&quot;</span><br><span class="line">6) &quot;2000&quot;</span><br><span class="line">7) &quot;wangwu&quot;</span><br><span class="line">8) &quot;1000&quot;</span><br></pre></td></tr></table></figure><ul><li><code>zrem : 删除zset集合中的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem salary wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br></pre></td></tr></table></figure><ul><li><code>zcard : 获取zset集合所有元素的个数</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><ul><li><code>zcount : 获取指定区间内的元素数量</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1 withscores</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;5000&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;zhaoliu&quot;</span><br><span class="line">6) &quot;2000&quot;</span><br><span class="line">7) &quot;wangwu&quot;</span><br><span class="line">8) &quot;1000&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcount salary 2000 5000</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h3 id="5-2-使用场景">5.2 使用场景</h3><ul><li>存储班级成绩表、工资表排序</li><li>带权重排序，普通消息为1，重要消息为2</li><li>排行榜应用实现、取TopN</li></ul><h3 id="5-3-数据结构">5.3 数据结构</h3><p>SortedSet（zset） 是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素 value 赋予一个权重 score ，另一方面它又类似于<code>TreeSet</code>，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</p><p>zset 底层使用了两个数据结构：</p><ol><li>hash ，hash 的作用就是关联元素 value 和权重 score ，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</li><li>跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</li></ol><h3 id="5-4-跳跃表（跳表）">5.4 跳跃表（跳表）</h3><h4 id="5-4-1-简介">5.4.1 简介</h4><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。 Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><h4 id="5-4-2-实例">5.4.2 实例</h4><p><strong>对比有序链表和跳跃表，从链表中查询出“51”：</strong></p><ol><li>有序链表<br><img src="https://img-blog.csdnimg.cn/b84964b25e504d4ca76524d5582676f8.png#pic_center" alt="在这里插入图片描述">要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</li><li>跳跃表<br><img src="https://img-blog.csdnimg.cn/1e8d09a0060e4f50a4a894f64d440aee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层；<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下；<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</li></ol><p><strong>从此可以看出跳跃表比有序链表效率要高。</strong></p><h1 id="三、Redis的三种特殊数据类型">三、Redis的三种特殊数据类型</h1><p><code>Geospatial（地理信息）</code>、<code>HyperLogLog（基数统计）</code>、Bitmaps</p><h2 id="1-Geospatial（地理信息）">1. Geospatial（地理信息）</h2><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO 是 Geographic（地理信息）的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。 redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</p><h3 id="1-1-常用命令-2">1.1 常用命令</h3><ul><li><code>geoadd : 添加地理位置，两级无法直接添加（一般会下载城市数据通过java程序一次性导入），有效的经度是 -180 度到 180 度，有效的纬度是 -85.05112878 度到 85.05112878 度，当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.405285 39.904989 beijing</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.472644 31.231706 shanghai</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 114.085947 22.547 shenzhen</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 113.280637 23.125178 guangzhou</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li><code>geopos : 获取指定地区的坐标值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city beijing</span><br><span class="line">1) 1) &quot;116.40528291463851929&quot;</span><br><span class="line">   2) &quot;39.9049884229125027&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos china:city beijing shanghai</span><br><span class="line">1) 1) &quot;116.40528291463851929&quot;</span><br><span class="line">   2) &quot;39.9049884229125027&quot;</span><br><span class="line">2) 1) &quot;121.47264629602432251&quot;</span><br><span class="line">   2) &quot;31.23170490709807012&quot;</span><br></pre></td></tr></table></figure><ul><li><code>geodist : 获取两个位置之间的直线距离</code><ul><li>m 表示单位为米 [ 默认值 ]</li><li>km 表示单位为千米</li><li>mi 表示单位为英里</li><li>ft 表示单位为英尺</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai</span><br><span class="line">&quot;1067597.9668&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km</span><br><span class="line">&quot;1067.5980&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai mi</span><br><span class="line">&quot;663.3763&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai ft</span><br><span class="line">&quot;3502618.0013&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing guangzhou km</span><br><span class="line">&quot;1889.3706&quot;</span><br></pre></td></tr></table></figure><ul><li><code>georadius : 以给定的维度为中心，找出半径内的元素</code><ul><li>withdist : 显示到中心位置的距离</li><li>withcoord : 显示半径内元素的坐标</li><li>count : 限定显示几个元素</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km</span><br><span class="line">1) &quot;shenzhen&quot;</span><br><span class="line">2) &quot;guangzhou&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 900 km</span><br><span class="line">1) &quot;guangzhou&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withdist</span><br><span class="line">1) 1) &quot;shenzhen&quot;</span><br><span class="line">   2) &quot;923.4929&quot;</span><br><span class="line">2) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) &quot;831.2636&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 900 km withdist</span><br><span class="line">1) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) &quot;831.2636&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withcoord</span><br><span class="line">1) 1) &quot;shenzhen&quot;</span><br><span class="line">   2) 1) &quot;114.08594459295272827&quot;</span><br><span class="line">      2) &quot;22.54699993773966327&quot;</span><br><span class="line">2) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) 1) &quot;113.28063815832138062&quot;</span><br><span class="line">      2) &quot;23.12517743834835215&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withdist withcoord</span><br><span class="line">1) 1) &quot;shenzhen&quot;</span><br><span class="line">   2) &quot;923.4929&quot;</span><br><span class="line">   3) 1) &quot;114.08594459295272827&quot;</span><br><span class="line">      2) &quot;22.54699993773966327&quot;</span><br><span class="line">2) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) &quot;831.2636&quot;</span><br><span class="line">   3) 1) &quot;113.28063815832138062&quot;</span><br><span class="line">      2) &quot;23.12517743834835215&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withdist withcoord count 1</span><br><span class="line">1) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) &quot;831.2636&quot;</span><br><span class="line">   3) 1) &quot;113.28063815832138062&quot;</span><br><span class="line">      2) &quot;23.12517743834835215&quot;</span><br></pre></td></tr></table></figure><ul><li><code>georadiusbymember : 以指定元素为中心，找出半径内的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city beijing 1500 km</span><br><span class="line">1) &quot;shanghai&quot;</span><br><span class="line">2) &quot;beijing&quot;</span><br></pre></td></tr></table></figure><ul><li><code>geohash : 返回一个或多个位置元素，以Geohash表示（会返回一个11个字符的Geohash字符串）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，则距离越近</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing guangzhou</span><br><span class="line">1) &quot;wx4g0b7xrt0&quot;</span><br><span class="line">2) &quot;ws0e9cb3yj0&quot;</span><br></pre></td></tr></table></figure><p><strong>GEO底层的实现原理其实就是Zset，可以使用Zset命令来操作GEO</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) &quot;shenzhen&quot;</span><br><span class="line">2) &quot;guangzhou&quot;</span><br><span class="line">3) &quot;shanghai&quot;</span><br><span class="line">4) &quot;beijing&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) &quot;shenzhen&quot;</span><br><span class="line">2) &quot;guangzhou&quot;</span><br><span class="line">3) &quot;shanghai&quot;</span><br></pre></td></tr></table></figure><h3 id="1-2-使用场景-2">1.2 使用场景</h3><ul><li>附近的人</li><li>打车距离计算</li></ul><h2 id="2-HyperLogLog（基数统计）">2. HyperLogLog（基数统计）</h2><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量）,可以使用 Redis 的 incr 、incrby 轻松实现。<br>但像 UV（UniqueVisitor，独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。<br>解决基数问题有很多种方案：</p><ol><li>数据存储在 MySQL 表中，使用 distinct count 计算不重复个数</li><li>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理</li></ol><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了 HyperLogLog<br>Redis HyperLogLog 是用来做<code>基数统计的算法</code>，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h3 id="2-1-常用命令-2">2.1 常用命令</h3><ul><li><code>pfadd : 添加指定元素到HyperLogLog中（如果执行命令后HyperLogLog估计的近似基数发生变化，则返回1，否则返回0）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e f g h i j k l m</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey2 f s v z a b i j l</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey a</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><ul><li><code>pfcount : 统计HyperLogLog的元素个数，计算HyperLogLog的近似基数（可以计算多个HyperLogLog，比如用HyperLogLog存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e f g h i j k l m</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey</span><br><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey2 f s v z a b i j l</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey2</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey mykey2</span><br><span class="line">(integer) 16</span><br></pre></td></tr></table></figure><ul><li><code>pfmerge : 将一个或多个HyperLogLog合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfcount mykey</span><br><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey2</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey mykey2</span><br><span class="line">(integer) 16</span><br><span class="line">127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey3</span><br><span class="line">(integer) 16</span><br></pre></td></tr></table></figure><h3 id="2-2-使用场景-2">2.2 使用场景</h3><ul><li>网页的UV统计</li></ul><h2 id="3-Bitmaps（位图）">3. Bitmaps（位图）</h2><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是 01100001、 01100010 和 01100011，如下图：<br><img src="https://img-blog.csdnimg.cn/9ace81b9faa2438f91e20654cc7025dc.png#pic_center" alt="在这里插入图片描述"><br>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用Bitmaps和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做<code>偏移量</code>。</li></ol><p><img src="https://img-blog.csdnimg.cn/6ed7f1c8e8814073b725d97f65607f6e.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-1-常用命令-2">3.1 常用命令</h3><ul><li><code>setbit : 设置Bitmaps中某个偏移量的值（0或1）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>实例：</strong> 每个独立用户是否访问过网站存放在 Bitmaps 中， 将访问的用户记做 1， 没有访问的用户记做 0， 用偏移量作为用户的 id。<br>设置键的第 offset 个位的值（从0算起） ， 假设现在有 20 个用户，userid=1， 6， 11， 15， 19 的用户对网站进行了访问， 那么当前 Bitmaps 初始化结果如图：<br><img src="https://img-blog.csdnimg.cn/fb11189682884b79a71f232119982347.png#pic_center" alt="在这里插入图片描述"><br>unique:users:20201106 代表 2020-11-06 这天的独立访问用户的 Bitmaps<br><img src="https://img-blog.csdnimg.cn/efc2112d7e3e453f89d8455bee9885c1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong><font color=red>注：</font></strong> 很多应用的用户 id 以一个指定数字（例如10000） 开头， 直接将用户 id 和 Bitmaps 的偏移量对应势必会造成一定的浪费， 通常的做法是每次做 setbit 操作时将用户id减去这个指定数字。<br>在第一次初始化 Bitmaps 时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成 Redis 的阻塞。</p><ul><li><code>getbit : 获取Bitmaps中某个偏移量的值（获取键的第offset位的值（从0开始算））</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>实例：</strong> 获取 id=8 的用户是否在 2020-11-06 这天访问过， 返回 0 说明没有访问过：<br><img src="https://img-blog.csdnimg.cn/246d76ed52be4fd1a90688e45fbd9742.png#pic_center" alt="在这里插入图片描述"><br><strong><font color=red>注：</font></strong> 因为 100 根本不存在，所以也是返回 0</p><ul><li><code>bitcount : 统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p><strong>实例：</strong> 计算 2022-11-06 这天的独立访问用户数量<br><img src="https://img-blog.csdnimg.cn/9ddc7b9bef2c471a871a04ff2d2f270b.png#pic_center" alt="在这里插入图片描述"><br>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19</p><p><img src="https://img-blog.csdnimg.cn/a6785cc6cbd04b208336a5565c7994c3.png#pic_center" alt="在这里插入图片描述"></p><ul><li><code>bitop : 复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit bitmap1 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap1 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap1 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap2 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap2 3 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap2 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitop and bitmap3 bitmap1 bitmap2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitcount bitmap3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitop or bitmap4 bitmap1 bitmap2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitcount bitmap4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; bitop xor bitmap5 bitmap1 bitmap2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitcount bitmap5</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3 id="3-2-使用场景-2">3.2 使用场景</h3><ul><li>统计用户信息</li><li>区分活跃、不活跃用户；登录、未登录等等</li><li>上班打卡</li></ul><h3 id="3-3-Bitmaps与set对比">3.3 Bitmaps与set对比</h3><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table><tr align=center><th colspan="4">set 和 Bitmaps 存储一天活跃用户对比</th></tr><tr align=center><td>数据类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr align=center><td>集合类型</td><td>64位</td><td>50000000</td><td>64位 * 50000000 = 400MB</td></tr><tr align=center><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位 * 100000000 = 12.5MB</td></tr></table>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的<table><tr align=center><th colspan="4">set 和 Bitmaps 存储独立用户空间对比</th></tr><tr align=center><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr align=center><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr align=center><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></table>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0<table><tr align=center><th colspan="4">set 和 Bitmaps 存储一天活跃用户对比（独立用户比较少）</th></tr><tr align=center><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr align=center><td>集合类型</td><td>64位</td><td>100000</td><td>64位 * 100000 = 800KB</td></tr><tr align=center><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位 * 100000000 = 12.5MB</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法 —— 两数之和</title>
      <link href="/2021/07/22/leetcode_1/"/>
      <url>/2021/07/22/leetcode_1/</url>
      
        <content type="html"><![CDATA[<p><strong>原题：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h1 id="1-方法一">1. 方法一</h1><p>暴力破解，没什么思路可说的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> num1 <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> num2 <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num1 + num2 == target:</span><br><span class="line">                    <span class="keyword">if</span> (num1 == num2) &amp; (nums.count(num1) == <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> [nums.index(num1),nums.index(num2, nums.index(num1) + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h1 id="2-方法二">2. 方法二</h1><p>解题关键主要是想找到 num2 = target - num1，判断num2 是否也在 list 中，找到 num2，再直接返回 num2 的索引即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target - nums[num] <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> (nums.count(target - nums[num]) == <span class="number">1</span>) &amp; (target - nums[num] == nums[num]):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> [num, nums.index(target - nums[num], num + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h1 id="3-方法三">3. 方法三</h1><p>遍历数组 nums，num 为当前下标，每个值都判断字典 dic 中是否存在 target-nums[num] 的 key 值；如果存在则找到了两个值，如果不存在则将当前的 (nums[num],num) 存入字典 dic 中，继续遍历直到找到为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> dic.get(target - nums[num]) == <span class="literal">None</span> :</span><br><span class="line">                dic[nums[num]] = num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [dic[target - nums[num]], num]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 单线程为什么还这么快？</title>
      <link href="/2021/07/12/redis_7/"/>
      <url>/2021/07/12/redis_7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-官网的解释">1. 官网的解释</h1><p><img src="https://img-blog.csdnimg.cn/20210712192848680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CPU并不是您使用Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制。例如，使用在一般Linux系统上运行的流水线Redis每秒可以发送一百万个请求，因此，如果您的应用程序主要使用O（N）或O（log（N））命令，则几乎不会使用过多的CPU 。<br>但是，为了最大程度地利用CPU，您可以在同一服务器上启动多个Redis实例，并将它们视为不同的服务器。在某个时候，单个实例可能还不够，因此，如果您要使用多个CPU，则可以开始考虑更早地分片的某种方法。<br>但是，在Redis 4.0中，我们开始使Redis具有更多线程。目前，这仅限于在后台删除对象，以及阻止通过Redis模块实现的命令。对于将来的版本，计划是使Redis越来越线程化。</p><h1 id="2-Redis为什么是单线程的？">2. Redis为什么是单线程的？</h1><p>Redis是基于<code>内存操作</code>的，CPU并不是Redis的瓶颈，Redis的瓶颈是机器的<code>内存</code>和<code>网络带宽</code>，既然可以使用单线程来实现，那当然就使用单线程了。</p><p>相反，如果使用多线程的话，多个CPU还要进行<code>上下文切换</code>，CPU上下文切换的效率远远比不上直接在内存中读取的速度；并且，采用多线程，还会带来数据安全的问题，假如我们在操作redis的List、Hash等数据结构时，多线程就可能存在数据不安全的情况，这时候就需要加锁，一旦加锁就又影响了程序的执行速度。</p><h1 id="3-Redis单线程的优势和劣势">3. Redis单线程的优势和劣势</h1><p><code>优势</code>：</p><ol><li>代码更清晰，处理逻辑更简单；</li><li>不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>不存在“多进程或者多线程导致的切换”而消耗CPU。</li></ol><p><code>劣势</code>：</p><ol><li>无法发挥多核CPU性能（可以通过在单机开多个Redis实例来完善，单一线程只能用到一个CPU核心，所以可以在同一个多核的服务器中，启动多个实例，组成<code>master-master</code>或者<code>master-slave</code>的形式，耗时的读命令可以完全在 slave 进行，充分发挥 Redis 的作用）。</li></ol><h1 id="4-Redis速度为什么那么快？">4. Redis速度为什么那么快？</h1><ol><li>Redis是纯内存数据库，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制；</li><li>Redis使用单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，<code>减少了线程切换时上下文的切换和竞争</code>，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li><li>Redis采用了<code>非阻塞I/O多路复用机制</code>。</li></ol><h1 id="5-Redis的多路IO复用">5. Redis的多路IO复用</h1><p>redis 采用网络IO多路复用技术，来保证在多连接的时候系统的高吞吐量。<br><code>多路</code>指的是多个socket网络连接，<code>复用</code>指的是复用一个线程。</p><p>多路复用主要有三种技术：select，poll，epoll（epoll是最新的、也是目前最好的多路复用技术），可以同时监察多个流的 I/O 事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流，并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作，从而提高效率。</p><p>采用多路I/O复用技术的原因：</p><ol><li>可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）；</li><li>Redis在内存中操作数据的速度非常快（内存里的操作不会成为这里的性能瓶颈）。</li></ol><p>主要以上两点造就了Redis具有很高的吞吐量。</p><h1 id="6-Redis的持久化">6. Redis的持久化</h1><p>由于redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。</p><p>redis提供两种方式进行持久化，一种是<code>RDB持久化</code>（原理是将redis在内存中的数据库记录定时 dump到磁盘上的RDB持久化），另外一种是<code>AOF（append only file）持久化</code>（原理是将redis的操作日志以追加的方式写入文件）。</p><p>持久化似乎和redis的速度并没有直接关系，但是这保证的redis数据的安全性和可靠性，也起到数据备份的作用。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之 API 数据合并</title>
      <link href="/2021/07/02/python_8/"/>
      <url>/2021/07/02/python_8/</url>
      
        <content type="html"><![CDATA[<p>最近有个需求，就是数据源那边会过来许多api数据，样例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/api/login/001-1,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/001-2,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/001-3,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/001-4,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/index,10.145.205.53:10081,POST,100</span><br></pre></td></tr></table></figure><p>可以看到过来的数据除了id字段，其余部分是一样的，这样就造成了数据的重复占用资源，理想的情况是将数据合并成下面的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/api/login/&#123;id&#125;,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/index,10.145.205.53:10081,POST,100</span><br></pre></td></tr></table></figure><p>用 <code>&#123;id&#125;</code> 来替代无意义的段，并且后面要加入合并出来的<code>/api/login/&#123;id&#125;</code>占总数据量的百分比，PM要求的处理速度是10w条/s，目前做的是第一版，后续会更新第二版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,math,datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\lkm86\\Desktop\\data.csv&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 读取数据</span></span><br><span class="line">    content = file.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存放要计数的api</span></span><br><span class="line">    patternList = []</span><br><span class="line">    <span class="comment"># 存放包含数字的api</span></span><br><span class="line">    patternBranch = []</span><br><span class="line">    <span class="comment"># 存放最终结果</span></span><br><span class="line">    patternDict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 正则匹配是否包含数字</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;\/[^\\/]*\d[^\\/]*\/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历数据列表</span></span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> content:</span><br><span class="line">        <span class="comment"># 取出api字段</span></span><br><span class="line">        line = lines[:lines.index(<span class="string">&quot;,&quot;</span>)]</span><br><span class="line">        <span class="comment"># 给api后面加”/“方面后续正则匹配</span></span><br><span class="line">        <span class="keyword">if</span> line[-<span class="number">1</span>] != <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            line += <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="comment"># 正则匹配是否有包含数字的段</span></span><br><span class="line">        <span class="keyword">if</span> pattern.findall(line):</span><br><span class="line">            <span class="comment"># 替换包含数字的段为“&#123;id&#125;”</span></span><br><span class="line">            url = pattern.sub(<span class="string">&#x27;/&#123;id&#125;/&#x27;</span>, line)</span><br><span class="line">            <span class="comment"># 将替换后的api表达式再和别的字段合并放入patternList，后续计数使用</span></span><br><span class="line">            patternList.append(url + lines[lines.index(<span class="string">&quot;,&quot;</span>):].strip())</span><br><span class="line">            <span class="comment"># 将加了“/”且未做替换的api和其余字段合并并放入patternBranch，后续过滤符合表达式的api使用</span></span><br><span class="line">            patternBranch.append(line + lines[lines.index(<span class="string">&quot;,&quot;</span>):].strip())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将不包含数字的数据直接放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">            patternDict[lines.strip()] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># 将patternList计数，得到字典cnt，key是patternList的原数据，value是原数据出现的次数</span></span><br><span class="line">    cnt = Counter(patternList)</span><br><span class="line">    <span class="comment"># 遍历字典cnt</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> cnt.keys():</span><br><span class="line">        <span class="comment"># 判断表达式出现次数是否小于2</span></span><br><span class="line">        <span class="keyword">if</span> cnt[key] &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 获取表达式中的api字段</span></span><br><span class="line">            <span class="built_in">str</span> = key[:key.index(<span class="string">&quot;,&quot;</span>)]</span><br><span class="line">            <span class="comment"># 将表达式中的api的“&#123;id&#125;”替换为是否包含数字的正则表达式</span></span><br><span class="line">            reString = <span class="built_in">str</span>.replace(<span class="string">&quot;&#123;id&#125;&quot;</span>, <span class="string">&quot;[^\\/]*\d[^\\/]*&quot;</span>)</span><br><span class="line">            <span class="comment"># 遍历patternBranch</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> patternBranch:</span><br><span class="line">                <span class="comment"># 判断patternBranch中数据的api是否符合正则表达式reString</span></span><br><span class="line">                <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(line[:line.index(<span class="string">&quot;,&quot;</span>)]):</span><br><span class="line">                    <span class="comment"># 将符合正则表达式的放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">                    patternDict[line.strip()] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将表达式出现次数大于等于2的放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">            patternDict[key] = math.ceil(cnt[key] / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历最终结果</span></span><br><span class="line">    <span class="comment"># for key in patternDict.keys():</span></span><br><span class="line">    <span class="comment">#     print(key)</span></span><br><span class="line">    <span class="comment">#     print(patternDict[key])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(datetime.datetime.now())</span><br><span class="line">    main()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(datetime.datetime.now())</span><br></pre></td></tr></table></figure><p>我的文件里是11w条数据，测试结果符合需求：<br><img src="https://img-blog.csdnimg.cn/20210702144315762.png" alt="在这里插入图片描述"><br>当然，现在第一版只考虑了出现一个<code>&#123;id&#125;</code>的情况，如果出现像下面的这种数据，这个脚本就不能计算出正确的结果了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/api/login/001-1/index/1</span><br><span class="line">/api/login/001-2/index/2</span><br><span class="line">/api/login/001-3/index/3</span><br><span class="line">/api/login/001-4/index/4</span><br></pre></td></tr></table></figure><p>如果出现这种两个甚至多个包含数字的段的情况的话，处理过程就要复杂的多了，这个等后续第二版再来想办法实现。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> API数据合并 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 保证状态一致性的原理</title>
      <link href="/2021/07/01/flink_15/"/>
      <url>/2021/07/01/flink_15/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是状态一致性">1. 什么是状态一致性</h1><p>有状态的流处理，内部每个算子任务都可以有自己的状态，对于流处理器内部来说，所谓的状态一致性，其实就是我们所说的计算结果要保证准确。一条数据不应该丢失，也不应该重复计算。在遇到故障时可以恢复状态，恢复以后的重新计算，结果应该也是完全正确的。</p><p><strong>在流处理中，一致性分为三个级别：</strong></p><ul><li><strong>at-most-once（最多一次）</strong>:<ul><li>这其实是没有正确性保障的委婉说法——故障发生之后， 计数结果可能丢失，类似的还有 udp</li></ul></li><li><strong>at-least-once（至少一次）</strong>:<ul><li>这表示计数结果可能大于正确值， 但绝不会小于正确值。也就是说， 计数程序在发生故障后可能多算， 但是绝不会少算</li><li>它意味着所有事件最终都会处理，虽然有些可能会处理多次</li></ul></li><li><strong>exactly-once（精确一次）</strong>:<ul><li>这指的是系统保证在发生故障后得到的计数结果与正确值一致</li><li>它不但能够保证事件没有丢失，而且每个事件对于内部状态的更新都只有一次</li><li>Flink利用Checkpoints机制来保证精确一次语义</li></ul></li></ul><p>曾经， at-least-once 非常流行。第一代流处理器(如 Storm 和 Samza)刚问世时只保证 at-least-once， 原因有二：</p><ul><li>保证 exactly-once 的系统实现起来更复杂。这在基础架构层(决定什么代表正确， 以及 exactly-once 的范围是什么)和实现层都很有挑战性</li><li>流处理系统的早期用户愿意接受框架的局限性， 并在应用层想办法弥补(例如使应用程序具有幂等性， 或者用批量计算层再做一遍计算)</li></ul><p>最先保证 exactly-once 的系统(Storm Trident 和 Spark Streaming)在性能和表现力这两个方面付出了很大的代价。为了保证 exactly-once，这些系统无法单独地对每条记录运用应用逻辑， 而是同时处理多条(一批)记录， 保证对每一批的处理要么全部成功，要么全部失败。这就导致在得到结果前，必须等待一批记录处理结束。因此， 用户经常不得不使用两个流处理框架(一个用来保证 exactly-once， 另一个用来对每个元素做低延迟处理)， 结果使基础设施更加复杂。曾经， 用户不得不在保证exactly-once 与获得低延迟和效率之间权衡利弊。Flink 避免了这种权衡。<br><img src="https://img-blog.csdnimg.cn/20210701151633327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 使用了一种轻量级快照机制，检查点(checkpoint)来保证 exactly-once语义。有状态流应用的一致性检查点，其实就是：所有任务的状态，在某个时间点的一份拷贝(一份快照)。而这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候。应用状态的一致性检查点，是 Flink故障恢复机制的核心。<br>Flink 的一个重大价值在于，<code>它既保证了 exactly-once， 也具有低延迟和高吞吐的处理能力</code>。</p><h1 id="2-端到端的状态一致性">2. 端到端的状态一致性</h1><p>目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在 Flink 流处理器内部保证的； 而在真实应用中， 流处理应用除了流处理器以外还包含了数据源（ 例如 Kafka） 和输出到持久化系统。<br>端到端的一致性保证， 意味着结果的正确性贯穿了整个流处理应用的始终； 每一个组件都保证了它自己的一致性， <code>整个端到端的一致性级别取决于所有组件中一致性最弱的组件</code>。具体可以划分如下：</p><ul><li>内部保证 —— 依赖 checkpoint</li><li>source 端 —— 需要外部源可重设数据的读取位置</li><li>sink 端 —— 需要保证从故障恢复时， 数据不会重复写入外部系统</li></ul><p><strong>其中前两种在上文已经介绍过了，下面说说 Sink 如何提供端到端的精确一次性保障。</strong><br>应用若是想提供端到端的精确一次性保障，就需要一些特殊的Sink连接器，根据情况不同，这些连接器可以使用两种技术来实现精确一次保障：</p><ul><li><strong>幂等性写入（idempotent write）</strong><ul><li>幂等操作的含义就是可以多次执行，但是只会引起一次改变，也就是说， 后面再重复执行就不起作用了</li><li>例如我们将相同的键值对插入一个哈希结构中就是一个幂等操作， 因为由于该键值对已存在后，无论插入多少次都不会改变结果</li><li>由于可以在不改变结果的前提下多次执行，因此幂等性写操作在一定程度上减轻Flink检查点机制所带来的重复结果的影响</li></ul></li><li><strong>事务性写入（transactional write）</strong><ul><li>事务性写其实就是原子性写，即只有在上次成功的检查点之前计算的结果才会被写入外部Sink系统</li><li>事务性写虽然不会像幂等性写那样出现重放过程中的不一致现象，但是会增加一定延迟，因为结果只有在检查点完成后才对外可见</li><li>实现思想：构建的事务对应着Checkpoints，待Checkpoints真正完成的时候，才把所有对应的结果写入Sink系统中</li></ul></li></ul><p>对于事务性写入， 具体又有两种实现方式： <code>预写日志（ WAL）</code> 和<code>两阶段提交（ 2PC）</code>。<br><strong>预写日志</strong></p><ul><li>把结果数据先当成状态保存，然后在收到Checkpoints完成的通知时，一次性写入Sink系统</li><li>简单易于实现，由于数据提前在状态后端做了缓存，所以无论什么Sink系统都能用这种方式一批搞定</li><li>但同时它也存在问题，写入数据时出现故障则会导致一部分数据成功一部分失败</li><li>DataStream API提供了一个模板类<code>GenericWriteAheadSink</code>，来实现这种事务性Sink</li></ul><p><strong>两阶段提交</strong></p><ul><li>对于每个Checkpoints，Sink任务会启动一个事务，并将接下来所有接收的数据添加到事务里</li><li>然后将这些数据写入外部 Sink，但不提交它们，这时只是“预提交”</li><li>当它收到Checkpoints完成的通知时，它才正式提交事务，实现结果的真正写入</li><li>这种方式真正实现了精确一次，它需要一个提供事务支持的外部Sink系统，Flink提供了<code>TwoPhaseCommitSinkFunction</code>接口</li><li>对外部Sink系统的要求<ul><li>外部Sink系统必须提供事务支持，或者Sink任务必须能够模拟外部系统上的事务</li><li>在Checkpoints的隔离期间里，必须能够开启一个事务并接受数据写入</li><li>在收到Checkpoints完成的通知之前，事务必须是“等待提交”的状态。在故障恢复的情况下，这可能需要一些时间。如果这个时候 Sink系统关闭事务（例如超时了），那么未提交的数据就会丢失</li><li>Sink任务必须能够在进程失败后恢复事务</li><li>提交事务必须是幂等操作</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210701153024608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="3-检查点（checkpoint）">3. 检查点（checkpoint）</h1><p>Flink 具体如何保证 exactly-once 呢? 它使用一种被称为&quot;检查点&quot;（checkpoint）的特性，在出现故障时将系统重置回正确状态。下面通过简单的类比来解释检查点 的作用。<br>假设你和两位朋友正在数项链上有多少颗珠子，如下图所示。你捏住珠子，边数边拨，每拨过一颗珠子就给总数加一。你的朋友也这样数他们手中的珠子。当你分神忘记数到哪里时，怎么办呢? 如果项链上有很多珠子，你显然不想从头再数一 遍，尤其是当三人的速度不一样却又试图合作的时候，更是如此(比如想记录前一分钟三人一共数了多少颗珠子，回想一下一分钟滚动窗口)。<br><img src="https://img-blog.csdnimg.cn/20210519111950813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>于是，你想了一个更好的办法：在项链上每隔一段就松松地系上一根有色皮筋，将珠子分隔开；当珠子被拨动的时候，皮筋也可以被拨动； 然后，你安排一个助手， 让他在你和朋友拨到皮筋时记录总数。用这种方法，当有人数错时，就不必从头开始数。相反，你向其他人发出错误警示，然后你们都从上一根皮筋处开始重数，助手则会告诉每个人重数时的起始数值，例如在粉色皮筋处的数值是多少。<br>Flink 检查点的作用就类似于皮筋标记。数珠子这个类比的关键点是：对于指定的皮筋而言，珠子的相对位置是确定的;  这让皮筋成为重新计数的参考点。总状态(珠子的总数)在每颗珠子被拨动之后更新一次，助手则会保存与每根皮筋对应的检查点状态，如当遇到粉色皮筋时一共数了多少珠子，当遇到橙色皮筋时又是多少。当问题出现时，这种方法使得重新计数变得简单。<br><strong>Flink的检查点算法：</strong><br>Flink 检查点的核心作用是确保状态正确，即使遇到程序中断，也要正确。记住 这一基本点之后，我们用一个例子来看检查点是如何运行的。Flink 为用户提供了用 来定义状态的工具。例如，以下这个 Scala 程序按照输入记录的第一个字段(一个字 符串)进行分组并维护第二个字段的计数状态。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = ... </span><br><span class="line"><span class="keyword">val</span> counts: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = stream</span><br><span class="line">.keyBy(record =&gt; record._1)</span><br><span class="line">.mapWithState((in: (<span class="type">String</span>, <span class="type">Int</span>), state: <span class="type">Option</span>[<span class="type">Int</span>])=&gt; </span><br><span class="line">state <span class="keyword">match</span> &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="type">Some</span>(c) =&gt; ( (in._1, c + in._2), <span class="type">Some</span>(c + in._2) ) </span><br><span class="line"><span class="keyword">case</span> <span class="type">None</span> =&gt; ( (in._1, in._2), <span class="type">Some</span>(in._2) )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该程序有两个算子: keyBy 算子用来将记录按照第一个元素(一个字符串)进行分 组，根据该 key 将数据进行重新分区，然后将记录再发送给下一个算子: 有状态的 map 算子(mapWithState)。map 算子在接收到每个元素后，将输入记录的第二个字段 的数据加到现有总数中，再将更新过的元素发射出去。下图表示程序的初始状态: 输 入流中的 6 条记录被检查点分割线(checkpoint barrier)隔开，所有的 map 算子状态均为 0(计数还未开始)。所有 key 为 a 的记录将被顶层的 map 算子处理，所有 key 为 b 的记录将被中间层的 map 算子处理，所有 key 为 c 的记录则将被底层的 map 算子处理。<br><img src="https://img-blog.csdnimg.cn/20210519112714781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="按 key 累加计数程序初始状态"><br>上图是程序的初始状态。注意，a、b、c 三组的初始计数状态都是 0，即三个圆 柱上的值。ckpt 表示检查点分割线（checkpoint barriers）。每条记录在处理顺序上 严格地遵守在检查点之前或之后的规定，例如[“b”,2]在检查点之前被处理，[“a”,2] 则在检查点之后被处理。<br>当该程序处理输入流中的 6 条记录时，涉及的操作遍布 3 个并行实例(节点、CPU 内核等)。那么，检查点该如何保证 exactly-once 呢?<br>检查点分割线和普通数据记录类似。它们由算子处理，但并不参与计算，而是 会触发与检查点相关的行为。当读取输入流的数据源(在本例中与 keyBy 算子内联) 遇到检查点屏障时，它将其在输入流中的位置保存到持久化存储中。如果输入流来 自消息传输系统(Kafka)，这个位置就是偏移量。Flink 的存储机制是插件化的，持久 化存储可以是分布式文件系统，如 HDFS。下图展示了这个过程（遇到 checkpoint barrier 时， 保存其在输入流中的位置）<br><img src="https://img-blog.csdnimg.cn/20210519113405164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当 Flink 数据源(在本例中与 keyBy 算子内联)遇到检查点分界线（barrier）时， 它会将其在输入流中的位置保存到持久化存储中。这让 Flink 可以根据该位置重启。<br>检查点像普通数据记录一样在算子之间流动。当 map 算子处理完前 3 条数据并 收到检查点分界线时，它们会将状态以异步的方式写入持久化存储，如下图所示（保存 map 算子状态， 也就是当前各个 key 的计数值）<br><img src="https://img-blog.csdnimg.cn/20210519113643798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>位于检查点之前的所有记录([“b”,2]、[“b”,3]和[“c”,1])被 map 算子处理之后的情 况。此时，持久化存储已经备份了检查点分界线在输入流中的位置(备份操作发生在 barrier 被输入算子处理的时候)。map 算子接着开始处理检查点分界线，并触发将状 态异步备份到稳定存储中这个动作。<br>当 map 算子的状态备份和检查点分界线的位置备份被确认之后，该检查点操作 就可以被标记为完成，如下图所示。我们在无须停止或者阻断计算的条件下，在一 个逻辑时间点(对应检查点屏障在输入流中的位置)为计算状态拍了快照。通过确保 备份的状态和位置指向同一个逻辑时间点，后文将解释如何基于备份恢复计算，从 而保证 exactly-once。值得注意的是，当没有出现故障时，Flink 检查点的开销极小， 检查点操作的速度由持久化存储的可用带宽决定。回顾数珠子的例子: 除了因为数 错而需要用到皮筋之外，皮筋会被很快地拨过。<br><img src="https://img-blog.csdnimg.cn/20210519113733345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>检查点操作完成，状态和位置均已备份到稳定存储中。输入流中的所有数据记 录都已处理完成。值得注意的是，备份的状态值与实际的状态值是不同的。备份反 映的是检查点的状态。<br>如果检查点操作失败，Flink 可以丢弃该检查点并继续正常执行，因为之后的某 一个检查点可能会成功。虽然恢复时间可能更长，但是对于状态的保证依旧很有力。 只有在一系列连续的检查点操作失败之后，Flink 才会抛出错误，因为这通常预示着 发生了严重且持久的错误。<br>现在来看看下图所示的情况：检查点操作已经完成，但故障紧随其后（故障紧跟检查点， 导致最底部的实例丢失）<br><img src="https://img-blog.csdnimg.cn/20210519113827989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在这种情况下（故障时的状态恢复），Flink 会重新拓扑(可能会获取新的执行资源)，将输入流倒回到 上一个检查点，然后恢复状态值并从该处开始继续计算。在本例中，[“a”,2]、[“a”,2] 和[“c”,2]这几条记录将被重播。<br>下图展示了这一重新处理过程。从上一个检查点开始重新计算，可以保证在剩 下的记录被处理之后，得到的 map 算子的状态值与没有发生故障时的状态值一致。<br><img src="https://img-blog.csdnimg.cn/20210519114227718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 将输入流倒回到上一个检查点屏障的位置，同时恢复 map 算子的状态值。 然后，Flink 从此处开始重新处理。这样做保证了在记录被处理之后，map 算子的状 态值与没有发生故障时的一致。<br>Flink 检查点算法的正式名称是<code>异步分界线快照(asynchronous barrier snapshotting)</code>。该算法大致基于 Chandy-Lamport 分布式快照算法。<br>检查点是 Flink 最有价值的创新之一，因为<strong>它使 Flink 可以保证 exactly-once， 并且不需要牺牲性能</strong>。</p><h1 id="4-Flink-Kafka-如何实现端到端的-exactly-once-语义">4. Flink+Kafka 如何实现端到端的 exactly-once 语义</h1><p>我们知道，端到端的状态一致性的实现，需要每一个组件都实现，对于 Flink + Kafka 的数据管道系统（Kafka 进、Kafka 出）而言，各组件怎样保证 exactly-once 语义呢？</p><ul><li>内部 —— 利用 checkpoint 机制，把状态存盘，发生故障的时候可以恢复，保证内部的状态一致性</li><li>source —— kafka consumer 作为 source，可以将偏移量保存下来，如果后续任务出现了故障，恢复的时候可以由连接器重置偏移量，重新消费数据，保证一致性</li><li>sink —— kafka producer 作为 sink，采用两阶段提交 sink，需要实现一个 <code>TwoPhaseCommitSinkFunction</code></li></ul><p>内部的 checkpoint 机制我们已经有了了解，那 source 和 sink 具体又是怎样运行的呢？接下来我们逐步做一个分析。<br>我们知道 Flink 由 JobManager 协调各个 TaskManager 进行 checkpoint 存储， checkpoint 保存在 StateBackend 中，默认 StateBackend 是内存级的，也可以改为文件级的进行持久化保存。<br><img src="https://img-blog.csdnimg.cn/20210519114544418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当 checkpoint 启动时，JobManager 会将检查点分界线（barrier）注入数据流； barrier 会在算子间传递下去。<br><img src="https://img-blog.csdnimg.cn/20210519114628309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>每个算子会对当前的状态做个快照，保存到状态后端。对于 source 任务而言， 就会把当前的 offset 作为状态保存起来。下次从 checkpoint 恢复时，source 任务可以重新提交偏移量，从上次保存的位置开始重新消费数据。<br><img src="https://img-blog.csdnimg.cn/20210519114708854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>每个内部的 transform 任务遇到 barrier 时，都会把状态存到 checkpoint 里。<br>sink 任务首先把数据写入外部 kafka，这些数据都属于预提交的事务（还不能被消费）；当遇到 barrier 时，把状态保存到状态后端，并开启新的预提交事务。<br><img src="https://img-blog.csdnimg.cn/20210519114806911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当所有算子任务的快照完成，也就是这次的 checkpoint 完成时，JobManager 会向所有任务发通知，确认这次 checkpoint 完成。<br>当 sink 任务收到确认通知，就会正式提交之前的事务，kafka 中未确认的数据 就改为“已确认”，数据就真正可以被消费了。<br><img src="https://img-blog.csdnimg.cn/20210519114847109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以我们看到，执行过程实际上是一个两段式提交，每个算子执行完成，会进 行“预提交”，直到执行完 sink 操作，会发起“确认提交”，如果执行失败，预提 交会放弃掉。<br>具体的两阶段提交步骤总结如下：</p><ul><li>第一条数据来了之后，开启一个 kafka 的事务（transaction），正常写入 kafka 分区日志但标记为未提交，这就是“预提交”</li><li>jobmanager 触发 checkpoint 操作，barrier 从 source 开始向下传递，遇到 barrier 的算子将状态存入状态后端，并通知 jobmanager</li><li>sink 连接器收到 barrier，保存当前状态，存入 checkpoint，通知 jobmanager，并开启下一阶段的事务，用于提交下个检查点的数据</li><li>jobmanager 收到所有任务的通知，发出确认信息，表示 checkpoint 完成</li><li>sink 任务收到 jobmanager 的确认信息，正式提交这段时间的数据</li><li>外部 kafka 关闭事务，提交的数据可以正常消费了</li></ul><p>所以我们也可以看到，如果宕机需要通过 StateBackend 进行恢复，只能恢复所有确认提交的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 的状态后端（State Backends）</title>
      <link href="/2021/07/01/flink_14/"/>
      <url>/2021/07/01/flink_14/</url>
      
        <content type="html"><![CDATA[<h1 id="1-State-Backends-的作用">1. State Backends 的作用</h1><p>有状态的流计算是Flink的一大特点，状态本质上是数据，数据是需要维护的，例如数据库就是维护数据的一种解决方案。State Backends 的作用就是用来维护State的。一个 State Backend 主要负责两件事：<code>Local State Management(本地状态管理)</code> 和 <code>Remote State Checkpointing（远程状态备份）</code>。</p><h1 id="2-Local-State-Management（本地状态管理）">2. Local State Management（本地状态管理）</h1><p><code>State Management</code> 的主要任务是确保状态的更新和访问。类似于数据库系统对数据的管理，State Backends 的状态管理就是提供对 State 的访问或更新操作，从这一点上看，State Backends 与数据库很相似。Flink 提供的 State Backends 主要有两种形式的状态管理：</p><ul><li>直接将 State 以对象的形式存储到JVM的堆上面</li><li>将 State 对象序列化后存储到 RocksDB 中（RocksDB会写到本地的磁盘上）</li></ul><p>以上两种方式，第一种存储到JVM堆中，因为是在内存中读写，延迟会很低，但State的大小受限于内存的大小；第二种方式存储到State Backends上（本地磁盘上），读写较内存会慢一些，但不受内存大小的限制，同时因为state存储在磁盘上，可以减少应用程序对内存的占用。根据使用经验，对延迟不是特别敏感的应用，选择第二种方式较好，尤其是State比较大的情况下。</p><h1 id="3-Remote-State-Checkpointing（远程状态备份）">3. Remote State Checkpointing（远程状态备份）</h1><p>Flink程序是分布式运行的，而State都是存储到各个节点上的，一旦TaskManager节点出现问题，就会导致State的丢失。State Backend 提供了 <code>State Checkpointing</code> 的功能，将 TaskManager 本地的 State 的备份到远程的存储介质上，可以是分布式的存储系统或者数据库。不同的 State Backends 备份的方式不同，会有效率高低的区别。</p><h1 id="4-可用的状态后端">4. 可用的状态后端</h1><ul><li><strong>MemoryStateBackend</strong><ul><li>对于状态管理，MemoryStateBackend直接将State对象存储到TaskManager的JVM堆上，如MapState会被存储为一个HashMap对象</li><li>对于远程备份，MemoryStateBackend会将State备份到JobManager的堆内存上，这种方式是非常不安全的，且受限于JobManager的内存大小</li></ul></li><li><strong>FsStateBackend</strong><ul><li>对于状态管理，FsStateBackend与MemoryStateBackend一样，将State存储到TaskManager的JVM堆上</li><li>对于远程备份，FsStateBackend会将State写入到远程的文件系统，如HDFS中</li></ul></li><li><strong>RocksDBStateBackend</strong><ul><li>对于状态管理，RocksDBStateBackend将state存储到TaskManager节点上的RocksDB数据库实例上</li><li>对于远程备份，RocksDBstateBackend会将State备份到远程的存储系统中</li></ul></li></ul><h2 id="4-1-MemoryStateBackend">4.1 MemoryStateBackend</h2><p><code>MemoryStateBackend </code>是将状态维护在 Java 堆上的一个内部状态后端。键值状态和窗口算子使用哈希表来存储数据（values）和定时器（timers）。当应用程序 checkpoint 时，此后端会在将状态发给 JobManager 之前快照下状态，JobManager 也将状态存储在 Java 堆上。默认情况下，<code>MemoryStateBackend</code> 配置成支持异步快照。异步快照可以避免阻塞数据流的处理，从而避免反压的发生。当然，使用 <code>new MemoryStateBackend(MAX_MEM_STATE_SIZE, false)</code> 也可以禁用该特点。<br><strong>缺点：</strong></p><ul><li>默认情况下，每一个状态的大小限制为 5 MB。可以通过 <code>MemoryStateBackend</code> 的构造函数增加这个大小。状态大小受到 akka 帧大小的限制(maxStateSize &lt;= akka.framesize 默认 10 M)，所以无论怎么调整状态大小配置，都不能大于 akka 的帧大小。也可以通过 akka.framesize 调整 akka 帧大小</li><li>状态的总大小不能超过 JobManager 的内存</li></ul><p><strong>使用场景：</strong></p><ul><li>本地测试、几乎无状态的作业，比如 ETL、JobManager 不容易挂，或挂掉影响不大的情况</li><li>不推荐在生产场景使用</li></ul><h2 id="4-2-FsStateBackend">4.2 FsStateBackend</h2><p><code>FsStateBackend</code>需要配置的主要是文件系统，如 URL（类型，地址，路径）。<br>当选择使用 <code>FsStateBackend</code>时，正在进行的数据会被存在TaskManager的内存中。在checkpoint时，此后端会将状态快照写入配置的文件系统和目录的文件中，同时会在JobManager的内存中（在高可用场景下会存在 Zookeeper 中）存储极少的元数据。容量限制上，单 TaskManager 上 State 总量不超过它的内存，总大小不超过配置的文件系统容量。</p><p>默认情况下，<code>FsStateBackend</code> 配置成提供异步快照，以避免在状态 checkpoint 时阻塞数据流的处理。该特性可以实例化 <code>FsStateBackend</code> 时传入false的布尔标志来禁用掉，例如：<code>new FsStateBackend(path, false)</code><br><strong>使用场景：</strong></p><ul><li>处理大状态，长窗口，或大键值状态的有状态处理任务， 例如分钟级窗口聚合或 join</li><li>适合用于高可用方案（需要开启HA的作业）</li><li>可以在生产环境中使用</li></ul><h2 id="4-3-RocksDBStateBackend">4.3 RocksDBStateBackend</h2><p><code>RocksDBStateBackend</code> 的配置也需要一个文件系统（类型，地址，路径）。<br><code>RocksDB</code> 是一种嵌入式的本地数据库。<code>RocksDBStateBackend</code> 将处理中的数据使用 <code>RocksDB</code> 存储在本地磁盘上。在 checkpoint 时，整个 <code>RocksDB</code> 数据库会被存储到配置的文件系统中，或者在超大状态作业时可以将增量的数据存储到配置的文件系统中。同时 Flink 会将极少的元数据存储在 JobManager 的内存中，或者在 Zookeeper 中（对于高可用的情况）。<code>RocksDB</code> 默认也是配置成异步快照的模式。</p><p><code>RocksDB</code>是一个 key/value 的内存存储系统，和其他的 key/value 一样，先将状态放到内存中，如果内存快满时，则写入到磁盘中，但需要注意<code>RocksDB</code>不支持同步的 Checkpoint，构造方法中没有同步快照这个选项。不过<code>RocksDB</code>支持增量的 Checkpoint，也是目前唯一增量 Checkpoint 的 Backend，意味着并不需要把所有 sst 文件上传到 Checkpoint 目录，仅需要上传新生成的 sst 文件即可。它的 Checkpoint 存储在外部文件系统（本地或HDFS），其容量限制只要单个 TaskManager 上 State 总量不超过它的内存+磁盘，单Key最大2G，总大小不超过配置的文件系统容量即可。<br><strong>缺点：</strong></p><ul><li>RocksDB支持的单key和单value的大小最大为每个 2^31 字节。这是因为 RocksDB 的 JNI API 是基于byte[]的</li><li>对于使用具有合并操作的状态的应用程序，例如 ListState，随着时间可能会累积到超过 2^31 字节大小，这将会导致在接下来的查询中失败</li></ul><p><strong>使用场景：</strong></p><ul><li>最适合用于处理大状态，长窗口，或大键值状态的有状态处理任务</li><li>非常适合用于高可用方案</li><li>最好是对状态读写性能要求不高的作业</li></ul><p><strong>RocksDB的安装方法：</strong></p><p><a href="https://blog.csdn.net/weixin_44758876/article/details/117710577">CentOS7 安装RocksDB</a><br><a href="https://blog.csdn.net/weixin_44758876/article/details/117717889">Ubuntu下安装RocksDB</a></p><p>综上所述，<code>MemoryStateBackend</code> 和 <code>FsStateBackend</code> 都是在内存中进行状态管理，所以可以获取较低的读写延迟，但会受限于TaskManager的内存大小；而<code>RocksDBStateBackend</code>直接将State存储到RocksDB数据库中，所以不受JobManager的内存限制，但会有读写延迟，同时 <code>RocksDBStateBackend</code> 支持增量备份，这是其他两个都不支持的特性。一般来说，如果不是对延迟有极高的要求，<code>RocksDBStateBackend</code>是更好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 的状态管理</title>
      <link href="/2021/07/01/flink_13/"/>
      <url>/2021/07/01/flink_13/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Flink中的状态">1. Flink中的状态</h1><p><img src="https://img-blog.csdnimg.cn/20210701114405912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>由一个任务维护，并且用来计算某个结果的所有数据，都属于这个任务的状态</li><li>可以认为状态就是一个本地变量，可以被任务的业务逻辑访问</li><li>Flink 会进行状态管理，包括状态一致性、故障处理以及高效存储和访问，以便开发人员可以专注于应用程序的逻辑</li></ul><h1 id="2-管理状态的原因">2. 管理状态的原因</h1><p>有状态的计算是流处理框架要实现的重要功能，因为稍复杂的流处理场景都需要记录状态，然后在新流入数据的基础上不断更新状态。下面的几个场景都需要使用流处理的状态功能：</p><ul><li>数据流中的数据有重复，我们想对重复数据去重，需要记录哪些数据已经流入过应用，当新数据流入时，根据已流入过的数据来判断去重</li><li>检查输入流是否符合某个特定的模式，需要将之前流入的元素以状态的形式缓存下来。比如，判断一个温度传感器数据流中的温度是否在持续上升</li><li>对一个时间窗口内的数据进行聚合分析，分析一个小时内某项指标的75分位或99分位的数值</li><li>在线机器学习场景下，需要根据新流入数据不断更新机器学习的模型参数</li></ul><p>Flink的一个算子有多个子任务，每个子任务分布在不同实例上，我们可以把状态理解为某个算子子任务在其当前实例上的一个变量，变量记录了数据流的历史信息。当新数据流入时，我们可以结合历史信息来进行计算。实际上，Flink的状态是由算子的子任务来创建和管理的。一个状态更新和获取的流程如下图所示，一个算子子任务接收输入流，获取对应的状态，根据新的计算结果更新状态。一个简单的例子是对一个时间窗口内输入流的某个整数字段求和，那么当算子子任务接收到新元素时，会获取已经存储在状态中的数值，然后将当前输入加到状态上，并将状态数据更新。</p><h1 id="3-Flink的状态分类">3. Flink的状态分类</h1><h2 id="3-1-Managed-State和Raw-State">3.1 Managed State和Raw State</h2><p>Flink有两种基本类型的状态：托管状态（Managed State）和原生状态（Raw State）。<br>Managed State是由Flink管理的，Flink帮忙存储、恢复和优化，Raw State是开发者自己管理的，需要自己序列化。<br><img src="https://img-blog.csdnimg.cn/20210701115754125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">两者的具体区别有：</p><ul><li>从状态管理的方式上来说，Managed State由Flink Runtime托管，状态是自动存储、自动恢复的，Flink在存储管理和持久化上做了一些优化。当我们横向伸缩，或者说我们修改Flink应用的并行度时，状态也能自动重新分布到多个并行实例上。Raw State是用户自定义的状态</li><li>从状态的数据结构上来说，Managed State支持了一系列常见的数据结构，如ValueState、ListState、MapState等。Raw State只支持字节，任何上层数据结构需要序列化为字节数组。使用时，需要用户自己序列化，以非常底层的字节数组形式存储，Flink并不知道存储的是什么样的数据结构</li><li>从具体使用场景来说，绝大多数的算子都可以通过继承Rich函数类或其他提供好的接口类，在里面使用Managed State。Raw State是在已有算子和Managed State不够用时，用户自定义算子时使用</li></ul><p>对Managed State继续细分，它又有两种类型：<strong>Keyed State</strong>和<strong>Operator State</strong>。<br><img src="https://img-blog.csdnimg.cn/20210701122339865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="3-1-1-Operator-State">3.1.1 Operator State</h3><p><strong>算子状态（Operator State）的作用范围限定为算子任务</strong>。这意味着由同一并行任务所处理的所有数据都可以访问到相同的状态，  状态对于同一任务而言是共享的。算子状态不能由相同或不同算子的另一个任务访问。<br><img src="https://img-blog.csdnimg.cn/20210519105207400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 为算子状态提供三种基本数据结构：</p><ul><li>列表状态（List state）<ul><li>将状态表示为一组数据的列表</li></ul></li><li>联合列表状态（Union list state）<ul><li>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保 存点（savepoint）启动应用程序时如何恢复</li></ul></li><li>广播状态（Broadcast state）<ul><li>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态</li></ul></li></ul><h3 id="3-1-2-Keyed-State">3.1.2 Keyed State</h3><p>键控状态是根据输入数据流中定义的键（key）来维护和访问的。Flink 为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个 key 对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的 key。因此，具有相同 key 的所有数据都会访问相同的状态。Keyed State 很类似于一个分布式的 key-value map 数据结构，只能用于 KeyedStream（ keyBy 算子处理之后）。<br><img src="https://img-blog.csdnimg.cn/20210519105522865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 的 Keyed State 支持以下数据类型：</p><ul><li>ValueState[T]保存单个的值，值的类型为 T<ul><li>获取状态<ul><li>ValueState.value()</li></ul></li><li>更新状态<ul><li>ValueState.update(value: T)</li></ul></li></ul></li><li>ListState[T]保存一个列表，列表里的元素的数据类型为 T<ul><li>添加元素<ul><li>ListState.add(value: T)</li><li>ListState.addAll(values: java.util.List[T])</li></ul></li><li>获取列表<ul><li>oListState.get() 返回 Iterable[T]</li></ul></li><li>更新列表<ul><li>ListState.update(values: java.util.List[T])</li></ul></li></ul></li><li>MapState[K, V]保存 Key-Value 键值对<ul><li>获取某个key下的value<ul><li>MapState.get(key: K)</li></ul></li><li>对某个key设置value<ul><li>MapState.put(key: K, value: V)</li></ul></li><li>判断某个key是否存在<ul><li>MapState.contains(key: K)</li></ul></li><li>删除某个key以及对应的value<ul><li>MapState.remove(key: K)</li></ul></li><li>返回MapState中所有的元素<ul><li>MapState.entries()</li></ul></li><li>返回一个迭代器<ul><li>MapState.iterator()</li></ul></li></ul></li><li>ReducingState[T]</li><li>AggregatingState[I, O]<ul><li>ReducingState[T]和AggregatingState[IN, OUT]与ListState[T]同属于MergingState[T]。与ListState[T]不同的是，ReducingState[T]只有一个元素，而不是一个列表。它的原理是新元素通过add(value: T)加入后，与已有的状态元素使用ReduceFunction合并为一个元素，并更新到状态里。AggregatingState[IN, OUT]与ReducingState[T]类似，也只有一个元素，只不过AggregatingState[IN, OUT]的输入和输出类型可以不一样。ReducingState[T]和AggregatingState[IN, OUT]与窗口上进行ReduceFunction和AggregateFunction很像，都是将新元素与已有元素做聚合</li></ul></li></ul><p><strong>注意</strong>，Flink的核心代码目前使用Java实现的，而Java的很多类型与Scala的类型不太相同，比如List和Map。这里不再详细解释Java和Scala的数据类型的异同，但是开发者在使用Scala调用这些接口，比如状态的接口，需要注意将Java的类型转为Scala的类型。对于List和Map的转换，只需要需要引用import scala.collection.JavaConversions._，并在必要的地方添加后缀asScala或asJava来进行转换。此外，Scala和Java的空对象使用习惯不太相同，Java一般使用null表示空，Scala一般使用None。</p><h1 id="4-状态一致性">4. 状态一致性</h1><p>当在分布式系统中引入状态时， 自然也引入了一致性问题。一致性实际上是“正确性级别”的另一种说法，也就是说在成功处理故障并恢复之后得到的结果，与没有发生任何故障时得到的结果相比， 前者到底有多正确？<br>在流处理中， 一致性可以分为 3 个级别：</p><ul><li>at-most-once: 这其实是没有正确性保障的委婉说法——故障发生之后， 计数结果可能丢失。同样的还有 udp</li><li>at-least-once: 这表示计数结果可能大于正确值， 但绝不会小于正确值。也就是说， 计数程序在发生故障后可能多算， 但是绝不会少算</li><li>exactly-once: 这指的是系统保证在发生故障后得到的计数结果与正确值一致</li></ul><p>曾经， at-least-once 非常流行。第一代流处理器(如 Storm 和 Samza)刚问世时只保证 at-least-once， 原因有二：</p><ul><li>保证 exactly-once 的系统实现起来更复杂。这在基础架构层(决定什么代表正确， 以及 exactly-once 的范围是什么)和实现层都很有挑战性</li><li>流处理系统的早期用户愿意接受框架的局限性， 并在应用层想办法弥补(例如使应用程序具有幂等性， 或者用批量计算层再做一遍计算)</li></ul><p>最先保证 exactly-once 的系统(Storm Trident 和 Spark Streaming)在性能和表现力这两个方面付出了很大的代价。为了保证 exactly-once，这些系统无法单独地对每条记录运用应用逻辑， 而是同时处理多条(一批)记录， 保证对每一批的处理要么全部成功，要么全部失败。这就导致在得到结果前，必须等待一批记录处理结束。因此，  用户经常不得不使用两个流处理框架(一个用来保证 exactly-once， 另一个用来对每个元素做低延迟处理)， 结果使基础设施更加复杂。曾经， 用户不得不在保证exactly-once 与获得低延迟和效率之间权衡利弊。Flink 避免了这种权衡。<br>Flink 的一个重大价值在于，<strong>它既保证了 exactly-once， 也具有低延迟和高吞吐的处理能力</strong>。</p><br><p><strong>部分内容摘自</strong><a href="https://zhuanlan.zhihu.com/p/104171679">https://zhuanlan.zhihu.com/p/104171679</a></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 命令详解</title>
      <link href="/2021/06/24/redis_6/"/>
      <url>/2021/06/24/redis_6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、全局命令">一、全局命令</h1><ol><li>查看当前所有key</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure><ol start="2"><li>判断某个key是否存在（存在返回1，不存在返回0）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><ol start="3"><li>查看key是什么类型（key不存在返回none）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><ol start="4"><li>删除key（返回成功删除key的个数）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><ol start="5"><li>键重命名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line">renamenx key newkey 只有newkey不存在时才会被覆盖</span><br></pre></td></tr></table></figure><ol start="6"><li>为指定的key设置过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key 10单位秒，过期后会自动删除</span><br><span class="line">expireat key 10单位秒，10秒后过期</span><br><span class="line">pexpire key 1000单位毫秒，超过过期时间后会自动删除</span><br><span class="line">pexpireat key 1000单位毫秒，1000毫秒后过期</span><br></pre></td></tr></table></figure><ol start="7"><li>查看还有多少秒过期，-1表示永不过期，-2表示已过期</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure><ol start="8"><li>随机返回一个key</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure><ol start="9"><li>迁移键</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">（1）move key db （不建议再生产环境中使用）把指定的键从源数据库移动到目标数据库</span><br><span class="line">（2）dump+restore</span><br><span class="line">dump key</span><br><span class="line">Restore key ttl value</span><br><span class="line">Dump+restore可以实现在不同的redis实例之间进行数据迁移的功能，整个迁移的过程分为两步;</span><br><span class="line">1)在源redis上，dump命令会将键值序列化，格式采用的是RDB格式</span><br><span class="line">2)在目标redis上，restore命令将上面序列化的值进行复原，其中ttl参数代表过期时间，ttl=0代表没有过期时间</span><br><span class="line">=======例=======</span><br><span class="line">源redis</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">&quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; dump redis</span><br><span class="line">&quot;\x00\x05world\a\x00\xe6\xe3\xe9w\xd8c\xa7\xd8&quot;</span><br><span class="line">目标redis</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; restore redis 0 &quot;\x00\x05world\a\x00\xe6\xe3\xe9w\xd8c\xa7\xd8&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">&quot;world&quot;</span><br><span class="line">（3）migrate</span><br><span class="line">migrate实际上是把dump、restore、del 3个命令进行组合，从而简化了操作步骤</span><br><span class="line">源redis中执行</span><br><span class="line">127.0.0.1:6379&gt; migrate xxx.xxx.xxx.xxx 6379 flower 0 1000 replace</span><br><span class="line">（将键flower迁移至目标xxx.xxx.xxx.xxx:6379的库0中，超时时间为1000毫秒，replace表示目标库如果存在键flower，则覆盖）</span><br></pre></td></tr></table></figure><ol start="10"><li>遍历key</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）全量遍历键</span><br><span class="line">keys pattern</span><br><span class="line">（2）渐进式遍历</span><br><span class="line">scan 可以有效的解决keys命令存在的阻塞问题，scan每次的额复杂度是O(1)</span><br></pre></td></tr></table></figure><h1 id="二、数据库管理">二、数据库管理</h1><ol><li>切换数据库（默认16个，根据编号0-15区分不同数据库，进入redis后默认是0库）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 3</span><br></pre></td></tr></table></figure><ol start="2"><li>查看当前数据库的key的数量</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure><ol start="3"><li>清空当前数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure><ol start="4"><li>清空所有数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure><h1 id="三、针对key的操作">三、针对key的操作</h1><ol><li>设置值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex]  [px]  [nx|xx]</span><br><span class="line">ex为键值设置秒级过期时间</span><br><span class="line">px为键值设置毫秒级过期时间</span><br><span class="line">nx键必须不存在，才可以设置成功，用于添加</span><br><span class="line">xx与nx相反，键必须存在，才可以设置成功，用于更新</span><br><span class="line">setnx、setex 与上面的nx、ex作用相同</span><br></pre></td></tr></table></figure><ol start="2"><li>获取值（不存在则返回nil）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key </span><br></pre></td></tr></table></figure><ol start="3"><li>批量设置值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ......]</span><br><span class="line">mset a 1 b 2 c 3 d 4</span><br></pre></td></tr></table></figure><ol start="4"><li>批量获取值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ......]</span><br></pre></td></tr></table></figure><ol start="5"><li>计数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">decr key /inceby key increment /decrby key increment</span><br><span class="line">返回结果分为3中情况：</span><br><span class="line">值不是整数，返回错误；</span><br><span class="line">值是整数，返回自增后的结果；</span><br><span class="line">键不存在，按照值为0自增，返回结果为1。</span><br></pre></td></tr></table></figure><ol start="6"><li>追加值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value 可以向字符串尾部追加值</span><br></pre></td></tr></table></figure><ol start="7"><li>字符串长度</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key每个汉字占用3个字字节</span><br></pre></td></tr></table></figure><ol start="8"><li>设置并返回原值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset key value</span><br></pre></td></tr></table></figure><ol start="9"><li>设置指定位置的字符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setrange key offeset value</span><br><span class="line">127.0.0.1:6379&gt; get liming</span><br><span class="line">&quot;class4&quot;</span><br><span class="line">127.0.0.1:6379&gt; setrange liming 0 m</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; get liming</span><br><span class="line">&quot;mlass4&quot;</span><br></pre></td></tr></table></figure><ol start="10"><li>获取部分字符串</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end </span><br><span class="line">start和end分别为开始和结束的偏移量，偏移量从0开始</span><br></pre></td></tr></table></figure><h1 id="四、Hash操作">四、Hash操作</h1><ol><li>设置值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br><span class="line">hset user:1 name tom</span><br></pre></td></tr></table></figure><ol start="2"><li>获取值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 name Tom</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget user:1 name</span><br><span class="line">&quot;Tom&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ol start="3"><li>删除field</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field ......]</span><br><span class="line">会删除一个或多个field，返回结果为成功删除fiel的个数</span><br></pre></td></tr></table></figure><ol start="4"><li>计算field的个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><ol start="5"><li>批量设置或获取field-value</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hmget key field [field ......]</span><br><span class="line">Hmset key field value [field value]</span><br></pre></td></tr></table></figure><ol start="6"><li>判断field是否存在</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><ol start="7"><li>获取所有field</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;grand&quot;</span><br><span class="line">4) &quot;city&quot;</span><br></pre></td></tr></table></figure><ol start="8"><li>获取所有value</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;beijing&quot;</span><br></pre></td></tr></table></figure><ol start="9"><li>获取所有的field、value</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure><ol start="10"><li>计算value字符串的长度</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hstrlen key field</span><br></pre></td></tr></table></figure><h1 id="五、列表List操作">五、列表List操作</h1><h2 id="1-添加">1. 添加</h2><ol><li>从右边插入元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value......]</span><br></pre></td></tr></table></figure><ol start="2"><li>从左边插入元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush key value [value......]</span><br></pre></td></tr></table></figure><ol start="3"><li>向某个元素前或者后插入元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">linsert key before|after pivot value</span><br><span class="line">linsert命令会从列表中找到等于pivot的元素，在其前或者后插入一个新的元素value</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e f b a </span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after f g</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">5) &quot;e&quot;</span><br><span class="line">6) &quot;f&quot;</span><br><span class="line">7) &quot;g&quot;</span><br><span class="line">8) &quot;b&quot;</span><br><span class="line">9) &quot;a&quot;</span><br></pre></td></tr></table></figure><h2 id="2-查找">2. 查找</h2><ol><li>获取指定范围内的元素列表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end 索引下标从左到右分别是0到N-1，从右到左分别是-1到-N；end选项包含了自身</span><br><span class="line">lrange key 0 -1 可以从左到右获取列表的所有元素</span><br><span class="line">lrange mylist 1 3 获取列表中第2个到第4个元素</span><br></pre></td></tr></table></figure><ol start="2"><li>获取列表指定下标的元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex key index</span><br></pre></td></tr></table></figure><ol start="3"><li>获取列表长度</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure><h2 id="3-删除">3. 删除</h2><ol><li>从列表右侧弹出元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpop key</span><br></pre></td></tr></table></figure><ol start="2"><li>从列表左侧弹出元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br></pre></td></tr></table></figure><ol start="3"><li>删除指定元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br><span class="line">Lrem命令会从列表中找到=value的元素进行删除，根据count的不同分为3种情况：</span><br><span class="line">1）Count&gt;0,从左到有，删除最多count个元素</span><br><span class="line">2）Count&lt;0,从右到左，删除最多count绝对值个元素</span><br><span class="line">3）Count=0,删除所有  </span><br><span class="line"></span><br><span class="line">列表listaaa为a a a a java php b a b</span><br><span class="line">127.0.0.1:6379&gt; lrem listaaa 5 a</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange listaaa 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;php&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem listaaa 3 php</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange listaaa 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;b&quot;</span><br></pre></td></tr></table></figure><h2 id="4-修改">4. 修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue 修改指定索引下标的元素</span><br><span class="line">Eg：lset listaaa 1 python </span><br></pre></td></tr></table></figure><h2 id="5-阻塞操作">5. 阻塞操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ...] timeout</span><br><span class="line">brpop key [key ...] timeout</span><br><span class="line">blpop和brpop是lpop、rpop的阻塞版本，除了弹出方式不同，使用方法基本相同，timeout阻塞时间</span><br></pre></td></tr></table></figure><ol><li>列表为空</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brpop list:test 3 3秒后返回</span><br><span class="line">brpop list:test 0 一直处于阻塞中</span><br></pre></td></tr></table></figure><ol start="2"><li>列表不为空</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brpop mylist 0 立刻返回</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; brpop mylist 0</span><br><span class="line">1) &quot;mylist&quot;</span><br><span class="line">2) &quot;a&quot;</span><br></pre></td></tr></table></figure><h1 id="六、Set操作（不可重复）">六、Set操作（不可重复）</h1><h2 id="1-集合内的操作">1. 集合内的操作</h2><ol><li>添加元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element .....] 返回结果为添加成功的元素个数</span><br></pre></td></tr></table></figure><ol start="2"><li>删除元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key element [element .....] 返回结果为删除成功的元素个数</span><br></pre></td></tr></table></figure><ol start="3"><li>计算元素个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scard key scard的时间复杂度为O(1),直接用redis内部的变量</span><br></pre></td></tr></table></figure><ol start="4"><li>判断元素是否在集合中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sismember key element 在集合中则返回1，否则返回0</span><br></pre></td></tr></table></figure><ol start="5"><li>随机从集合返回指定个数元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Srandmember key [count] count可不写，默认为1</span><br></pre></td></tr></table></figure><ol start="6"><li>从集合随机弹出元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spop key [count] 3.2版本开始支持[count]</span><br></pre></td></tr></table></figure><ol start="7"><li>获取所有元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Smembers key 它和lrange、hgetall都属于比较重的命令，有时候可以使用sscan来完成</span><br></pre></td></tr></table></figure><h2 id="2-集合间的操作">2. 集合间的操作</h2><ol><li>求多个集合的交集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter key [ key ......]</span><br></pre></td></tr></table></figure><ol start="2"><li>求多个集合的并集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sunion key [key ......]</span><br></pre></td></tr></table></figure><ol start="3"><li>求多个集合的差集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdiff key [key ......]第一个key里面有的，第二个key里面没有的</span><br></pre></td></tr></table></figure><ol start="4"><li>将交集、并集、差集的结果保存</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [ key ......]</span><br><span class="line">sunionstore destination key [ key ......]</span><br><span class="line">sdiffstore destination key [ key ......]</span><br><span class="line">例如：sinterstore user:1_2:inter user:1 user:2 user:1_2:incr也是集合类型</span><br></pre></td></tr></table></figure><h1 id="七、ZADD操作（有序集合）">七、ZADD操作（有序集合）</h1><ol><li>添加成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member[score member .....] 返回结果为添加成功的元素个数</span><br></pre></td></tr></table></figure><ol start="2"><li>计算成员个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard key scard的时间复杂度为O(1),直接用redis内部的变量</span><br></pre></td></tr></table></figure><ol start="3"><li>计算某个成员分数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsore key member</span><br></pre></td></tr></table></figure><ol start="4"><li>计算成员的排名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br></pre></td></tr></table></figure><ol start="5"><li>删除成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member .......]</span><br></pre></td></tr></table></figure><ol start="6"><li>增加成员的分数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure><ol start="7"><li>返回指定排名范围的成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key start end [withscores] 从低分到高分</span><br><span class="line">zrevrange key start end [withscores] 从高分到低分</span><br></pre></td></tr></table></figure><ol start="8"><li>返回指定分数范围的成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key min max [withscores] [limit offset count ] 按照分数从低分到高分</span><br><span class="line">zrevrange key max min [withscores] [limit offset count ] 按照分数从高分到低分</span><br></pre></td></tr></table></figure><ol start="9"><li>返回指定分数范围的成员个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure><ol start="10"><li>删除指定排名内的升序元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure><ol start="11"><li>删除指定分数范围的成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebystore key min max</span><br></pre></td></tr></table></figure><h1 id="八、pub-sub-发布、订阅">八、pub/sub(发布、订阅)</h1><ol><li>发布消息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br><span class="line">publish channel:sports &#x27;I want to go eatting&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>订阅消息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel .....]</span><br><span class="line">subscribe channel:sports</span><br></pre></td></tr></table></figure><ol start="3"><li>取消订阅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsubscribe channel [channel .....]</span><br></pre></td></tr></table></figure><ol start="4"><li>按照模式订阅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psubscribe pattern [pattern ......]</span><br></pre></td></tr></table></figure><ol start="5"><li>按照模式取消订阅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unpsubscribe pattern [pattern ......]</span><br></pre></td></tr></table></figure><ol start="6"><li>查询订阅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）查看活跃的频道</span><br><span class="line">pubsub channels</span><br><span class="line">127.0.0.1:6379&gt; pubsub channels</span><br><span class="line">   1) &quot;channel:sports&quot;</span><br><span class="line">   2) &quot;__sentinel__:hello&quot;</span><br><span class="line">（2）查看频道订阅数</span><br><span class="line">pubsub numsub [channel ......]</span><br><span class="line">pubsub numsub channel:sports</span><br><span class="line">（3）查看模式订阅数</span><br><span class="line">pubsub numpat</span><br></pre></td></tr></table></figure><ol start="7"><li>说明：<br>客户端在执行订阅命令之后进入了订阅状态，只能接收四个命令：subscribe、psubscribe、unsubscribe、punsubscribe；<br>新开启的订阅客户端，无法收到该频道之前的消息，因为redis不会对发布的消息进行持久化。</li></ol><h1 id="九、Transaction（事务）">九、Transaction（事务）</h1><ol><li>取消执行事务块内的所有命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure><ol start="2"><li>执行事务块内的命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure><ol start="3"><li>标记一个事务块的开始</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure><ol start="4"><li>取消watch命令对所有key的监视</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure><ol start="5"><li>监视一个或者多个key，如果事务执行之前，这个kye被其它命令所动，则事务被打断</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key [key ...]</span><br></pre></td></tr></table></figure><h1 id="十、Connection（连接）">十、Connection（连接）</h1><ol><li>登录redis时输入密码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure><ol start="2"><li>打印一个特定的信息message，测试时使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo message</span><br></pre></td></tr></table></figure><ol start="3"><li>测试与服务器的连接，如果正常则返回pong</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure><ol start="4"><li>请求服务器关闭与当前客户端的连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><ol start="5"><li>切换到指定的数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select index</span><br></pre></td></tr></table></figure><h1 id="十一、Server-服务器">十一、Server(服务器)</h1><ol><li>后台异步保存数据到硬盘</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure><ol start="2"><li>为连接设置、获取名字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client setname/client getname</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭地址为 ip:port的客户端</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client kill ip:port</span><br></pre></td></tr></table></figure><ol start="4"><li>以人类可读的方式，返回所有的连接客户端信息和统计数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client list</span><br></pre></td></tr></table></figure><ol start="5"><li>取得运行redis服务器的配置参数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get parameter</span><br></pre></td></tr></table></figure><ol start="6"><li>设置redis服务器的配置参数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set parameter value</span><br></pre></td></tr></table></figure><ol start="7"><li>重置info命令的某些统计数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config resetstat </span><br></pre></td></tr></table></figure><ol start="8"><li>返回redis服务器的各种信息和统计数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info [section]</span><br></pre></td></tr></table></figure><ol start="9"><li>返回最近一次redis成功将数据保存到磁盘时的时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastsave</span><br></pre></td></tr></table></figure><ol start="10"><li>实时打印出redis服务器接收到的指令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor</span><br></pre></td></tr></table></figure><ol start="11"><li>将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure><ol start="12"><li>将当前服务器转变为指定服务器的从属服务器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof host port</span><br></pre></td></tr></table></figure><ol start="13"><li>Redis 用来记录查询执行时间的日志系统</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog subcommand [argument]</span><br></pre></td></tr></table></figure><p><strong>部分内容摘自<a href="https://segmentfault.com/a/1190000010999677">https://segmentfault.com/a/1190000010999677</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-benchmark 性能测试详解</title>
      <link href="/2021/06/24/redis_5/"/>
      <url>/2021/06/24/redis_5/</url>
      
        <content type="html"><![CDATA[<p>redis-benchmark是Redis自带的压测工具<br><img src="https://img-blog.csdnimg.cn/20210624161259995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>压测命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -c 50 -n 10000</span><br></pre></td></tr></table></figure><p>压测需要一段时间来完成，因为它需要依次压测多个命令的结果：get、set、incr、lpush等等，如果只需要压测某个命令，如：get，那么可以在以上的命令后加一个参数 -t：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.1 -p 6086 -c 50 -n 10000 -t get</span><br></pre></td></tr></table></figure><p>压测出来的结果很长，我这里就不全部截图解释了，只说明一下 set 命令的结果：<br><img src="https://img-blog.csdnimg.cn/20210624162225366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>先看上面的部分，可以看到 0.14s 写入了1w条数据，50个客户端并发，每次只写入 3 个字节，只有一台服务器来处理这些请求；中间的部分就是不同毫秒时处理总数据的百分比以及延迟；最后的部分就是算出的平均吞吐量了。总体来说，吞吐速度还是很不错的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 pip安装第三方库失败，WARNING: You are using pip version 20.2.3； however, version 21.1.2 is available.</title>
      <link href="/2021/06/24/python_7/"/>
      <url>/2021/06/24/python_7/</url>
      
        <content type="html"><![CDATA[<p>在安装clickhouse_driver时报错：<br>WARNING: You are using pip version 20.2.3; however, version 21.1.2 is available.<br>You should consider upgrading via the ‘c:\software\python3.9.2\python.exe -m pip install --upgrade pip’ command.<br><img src="https://img-blog.csdnimg.cn/20210624122613961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>原因是因为pip版本过低导致，所以只需要升级pip即可<br>百度上的 easy_install -U pip 命令已经弃用了，应该使用 python -m pip install -U pip 命令来升级<br><img src="https://img-blog.csdnimg.cn/20210624123222322.png" alt="在这里插入图片描述"><br>可以看到提示安装了新版本并卸载了旧版本，可以通过 pip show pip 命令来查看当前版本<br><img src="https://img-blog.csdnimg.cn/20210624123359189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后就可以正常安装第三方库了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug记录 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的简单学习</title>
      <link href="/2021/06/21/redis_4/"/>
      <url>/2021/06/21/redis_4/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Redis是什么？">一. Redis是什么？</h1><p><strong>Redis（<font color=red>Re</font>mote <font color=red>Di</font>ctionary <font color=red>S</font>erver），即<font color=red>远程字典服务</font>。是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供了多种语言的API。</strong><br><strong>当下最热门的 NoSQL 技术之一，也被称为结构化数据库。</strong></p><h1 id="二-Redis能干什么？">二. Redis能干什么？</h1><ul><li><strong>内存存储、持久化数据</strong></li><li><strong>效率高，可配合关系型数据库做高速缓存</strong></li><li><strong>发布订阅系统</strong></li><li><strong>地图信息分析</strong></li><li><strong>计时器、计数器</strong></li></ul><h1 id="三-Redis的特性">三. Redis的特性</h1><ul><li><strong>数据类型的多样化，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）</strong></li><li><strong>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的</strong></li><li><strong>数据可持久化</strong></li><li><strong>数据缓存在内存中，会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</strong></li><li><strong>实现了master-slave(主从)同步</strong></li></ul><h1 id="四-Redis的安装">四. Redis的安装</h1><p><a href="https://blog.csdn.net/weixin_44758876/article/details/117252173">Redis6.2.3安装教程</a></p><h1 id="五-默认的安装文件">五. 默认的安装文件</h1><ul><li><strong>redis-benchmark</strong><ul><li>性能测试工具，可以在自己本子运行，看看自己本子性能如何</li></ul></li><li><strong>redis-check-aof</strong><ul><li>修复有问题的AOF文件</li></ul></li><li><strong>redis-check-dump</strong><ul><li>修复有问题的dump.rdb文件</li></ul></li><li><strong>redis-sentinel</strong><ul><li>Redis集群使用</li></ul></li><li><strong>redis-server</strong><ul><li>Redis服务器启动命令</li></ul></li><li><strong>redis-cli</strong><ul><li>客户端，操作入口</li></ul></li></ul><h1 id="六-Redis的启动">六. Redis的启动</h1><p><a href="https://blog.csdn.net/weixin_44758876/article/details/118087310">Redis6.2.3启动教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6.2.3 启动教程</title>
      <link href="/2021/06/21/redis_3/"/>
      <url>/2021/06/21/redis_3/</url>
      
        <content type="html"><![CDATA[<h1 id="前台启动（不推荐）">前台启动（不推荐）</h1><p><strong>通过 redis-server 命令启动，使用默认配置文件（命令行窗口不能关闭，否则服务停止）</strong><br><img src="https://img-blog.csdnimg.cn/20210621151414295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="后台启动（推荐）">后台启动（推荐）</h1><ol><li><strong>修改 redis.conf 文件，将daemonize no 改成 yes，让服务在后台启动</strong></li><li><strong>通过 redis-server redis.conf 命令启动Redis（不在安装目录下需要指定文件路径）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 你的reids安装路径/bin/redis.conf</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>用客户端访问 redis-cli（如果更改了端口，使用<code>redis-cli</code>客户端连接时，也需要指定端口，例：redis-cli -p 6380）</strong><br><img src="https://img-blog.csdnimg.cn/20210621152703984.png" alt="在这里插入图片描述"></li><li><strong>通过 ping 测试验证</strong><br><img src="https://img-blog.csdnimg.cn/20210621152940704.png" alt="在这里插入图片描述"></li><li><strong>通过 redis-cli shutdown 关闭服务</strong><br><img src="https://img-blog.csdnimg.cn/20210621153245531.png" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL 数据库简介</title>
      <link href="/2021/06/21/database_1/"/>
      <url>/2021/06/21/database_1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-NoSQL数据库概述">1. NoSQL数据库概述</h1><p><strong>NoSQL(NoSQL = <font color=red>Not Only SQL</font> )，意即“不仅仅是SQL”，泛指<font color=red>非关系型的数据库</font>。<br>NoSQL 不依赖业务逻辑方式存储，而以简单的<font color=red>key-value</font>模式存储（数据存储的类型不需要一个固定形式）。因此大大的增加了数据库的扩展能力。</strong></p><ul><li><strong>不遵循 SQL 标准</strong></li><li><strong>不支持 ACID</strong></li><li><strong>远超于 SQL 的性能</strong></li></ul><h1 id="2-NoSQL特点">2. NoSQL特点</h1><ul><li><strong>方便扩展（数据之间没有关系，很好扩展）</strong></li><li><strong>大数据量高性能（Redis 一秒写8万次，读取11万，NoSQL的缓存记录级是细粒度的缓存，性能会比较高）</strong></li><li><strong>高可用、高可扩</strong></li><li><strong>键值对存储、列存储、文档存储、图形数据库（社交关系）</strong></li></ul><h1 id="3-NoSQL适用场景">3. NoSQL适用场景</h1><ul><li><strong>对数据高并发的读写</strong></li><li><strong>海量数据的读写</strong></li><li><strong>对数据高可扩展性</strong></li></ul><h1 id="4-NoSQL不适用场景">4. NoSQL不适用场景</h1><ul><li><strong>需要事务支持</strong></li><li><strong>基于 sql 的结构化查询存储，处理复杂的关系，需要即席查询</strong></li></ul><h1 id="5-常见的NoSQL四大分类">5. 常见的NoSQL四大分类</h1><h2 id="5-1-Key-Value数据库">5.1 Key-Value数据库</h2><h3 id="5-1-2-Memcache">5.1.2 Memcache</h3><p><img src="https://img-blog.csdnimg.cn/20210621112936999.png" alt="在这里插入图片描述"></p><ul><li><strong>早期出现的 NoSQL 数据库</strong></li><li><strong>数据都在内存中，一般不持久化</strong></li><li><strong>支持简单的 key-value 模式，支持类型单一</strong></li><li><strong>一般是作为缓存数据库辅助持久化的数据库</strong></li></ul><h3 id="5-1-2-Redis">5.1.2 Redis</h3><p><img src="https://img-blog.csdnimg.cn/20210621113126120.png" alt="在这里插入图片描述"></p><ul><li><strong>几乎覆盖了 Mencached 的绝大部分功能</strong></li><li><strong>数据都在内存中，支持持久化，主要用作备份恢复</strong></li><li><strong>除了支持简单的 key-value 模式，还支持多种数据结构的存储，比如 list、set、hash、zset等</strong></li><li><strong>一般是作为缓存数据库辅助持久化的数据库</strong></li></ul><h2 id="5-2-文档型数据库">5.2 文档型数据库</h2><h3 id="5-1-1-MongoDB">5.1.1 MongoDB</h3><p><img src="https://img-blog.csdnimg.cn/20210621113356833.png" alt="在这里插入图片描述"></p><ul><li><strong>高性能、开源、模式自由(schema free)的文档型数据库</strong></li><li><strong>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</strong></li><li><strong>与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容</strong></li><li><strong>虽然是key-value模式，但是对 value（尤其是 json ）提供了丰富的查询功能</strong></li><li><strong>支持二进制数据及大型对象</strong></li><li><strong>可以根据数据的特点替代RDBMS ，成为独立的数据库，或者配合RDBMS，存储特定的数据</strong></li></ul><h2 id="5-3-列存储数据库">5.3 列存储数据库</h2><h3 id="5-3-1-HBase">5.3.1 HBase</h3><p><img src="https://img-blog.csdnimg.cn/20210621140526303.png" alt="在这里插入图片描述"></p><ul><li><strong>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中</strong></li><li><strong>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表</strong></li></ul><h3 id="5-3-2-Cassandra">5.3.2 Cassandra</h3><p><img src="https://img-blog.csdnimg.cn/20210621140645260.png" alt="在这里插入图片描述"></p><ul><li><strong>Apache Cassandra 是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</strong></li></ul><h2 id="5-4-图关系型数据库">5.4 图关系型数据库</h2><p><img src="https://img-blog.csdnimg.cn/20210621140836877.png" alt="在这里插入图片描述"><br><strong>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)</strong><br><img src="https://img-blog.csdnimg.cn/20210621140953565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲲鹏处理器虚拟机免费申请教程</title>
      <link href="/2021/06/17/resource_2/"/>
      <url>/2021/06/17/resource_2/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>注册一个账户</strong><br><a href="https://dw.pcl.ac.cn/cloud/login">https://dw.pcl.ac.cn/cloud/login</a><br><img src="https://img-blog.csdnimg.cn/20210617110656790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210617110802964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210617110843396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>注册成功之后输入用户名和密码登录，然后点击“开发者云”</strong><br><img src="https://img-blog.csdnimg.cn/20210617111140206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>这时候会验证你的邮箱，激活账号</strong></li><li><strong>验证成功之后，登录账号，再点击“开发者云”，会出现下面的页面，然后点击“需求申请”</strong><br><img src="https://img-blog.csdnimg.cn/20210617111402820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>点击之后会出现申请详情，根据自己的需要填入需要申请的资源，填写完毕，点击“提交”</strong><br><img src="https://img-blog.csdnimg.cn/20210617111703570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>提交之后，等待申请通过即可，一般一天之内就会通过（申请1核1G通过会很快）</strong><br><img src="https://img-blog.csdnimg.cn/2021061711211461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>我这里申请的1核1G不到两个小时就通过了，申请通过之后会发邮件通知，然后我们再点击左边菜单的“云主机”，就可以看到已经通过的主机了，再点击右边的“详情”，就可以看到对应的ip和连接端口</strong><br><img src="https://img-blog.csdnimg.cn/20210617112443321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210617112824623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>然后就可以通过ssh工具连接服务器了，我这里用的是xshell</strong><br><img src="https://img-blog.csdnimg.cn/20210617112945343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>在“云主机”菜单中，还可以点击“更多操作”，这里可以做申请更多端口、关机、重启、删除等操作</strong><img src="https://img-blog.csdnimg.cn/20210617113213256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p><strong>部分内容摘抄自<a href="https://blog.csdn.net/frdevolcqzyxynjds/article/details/105578249">https://blog.csdn.net/frdevolcqzyxynjds/article/details/105578249</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 资源共享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源共享，鲲鹏CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink1.12.4 配置文件详解</title>
      <link href="/2021/06/09/flink_12/"/>
      <url>/2021/06/09/flink_12/</url>
      
        <content type="html"><![CDATA[<h1 id="1-flink-conf-yaml">1. flink-conf.yaml</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"># Jobmanager的地址，taskmanager必须要识别并能连上。</span><br><span class="line"># 只有standalone的集群模式起作用，当执行bin/jobmanager.sh --host&lt;hostname&gt;的时候将被覆盖</span><br><span class="line"># 在YARN或者Mesos的集群模式下将自动替换为jobmanager所在节点的hostname</span><br><span class="line"># JobMaster节点IP地址</span><br><span class="line">jobmanager.rpc.address</span><br><span class="line"></span><br><span class="line"># JobMaster端口号，默认6123</span><br><span class="line">jobmanager.rpc.port：6123</span><br><span class="line"></span><br><span class="line"># JobManager能够使用的内存的最大值</span><br><span class="line">jobmanager.heap.size: 1024m</span><br><span class="line"></span><br><span class="line"># taskmanager 能够使用的最大内存大小</span><br><span class="line">taskmanager.memory.process.size: 2048m</span><br><span class="line"></span><br><span class="line"># taskmanager最大内存，不包含虚拟机的metaspace和其他的开销（不能和taskmanager.memory.process.size同时设置）</span><br><span class="line"># taskmanager.memory.flink.size： 2048m</span><br><span class="line"></span><br><span class="line"># 这俩不能和taskmanager.memory.flink.size或taskmanager.memory.process.size同时设置</span><br><span class="line"># 指定JVM堆内存大小</span><br><span class="line"># taskmanager.memory.task.heap.size: 2048m</span><br><span class="line"># 指定JVM托管内存大小</span><br><span class="line"># taskmanager.memory.managed.size: 512m</span><br><span class="line"></span><br><span class="line"># 每个TaskManager提供的slot数量，每个slot上能运行一个并行的pipeline任务。</span><br><span class="line">taskmanager.numberOfTaskSlots: 1</span><br><span class="line"></span><br><span class="line"># 没有指定并行度的情况下，默认的全局并行度</span><br><span class="line">parallelism.default: 1</span><br><span class="line"></span><br><span class="line"># 默认的文件系统的数据结构和授权</span><br><span class="line"># 如果是本地文件，那么格式为: &#x27;file:///&#x27;</span><br><span class="line"># 如果是HDFS文件，那么格式为：&#x27;hdfs://namenode_name:9870&#x27;</span><br><span class="line"># fs.default-scheme</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># 高可用配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># 高可用模型的选择有：&#x27;NONE&#x27; 或者 &#x27;zookeeper&#x27;</span><br><span class="line"># high-availability: zookeeper</span><br><span class="line"></span><br><span class="line"># 指定master恢复所需要的元数据存储的路径。这个路径需要存储像持久化数据流图一样的大对象</span><br><span class="line"># high-availability.storageDir: hdfs:///flink/ha/</span><br><span class="line"></span><br><span class="line"># # ZooKeeper集群的地址，用于协调高可用模型的建立</span><br><span class="line"># high-availability.zookeeper.quorum: localhost:2181</span><br><span class="line"></span><br><span class="line"># 如果zookeeper安全策略开启，那么下面这个值就应该是creator，默认是oepn</span><br><span class="line"># high-availability.zookeeper.client.acl: open</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># 容错和检查点配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># Flink后端会默认存储算子的状态，当checkpointing是开启状态的时候</span><br><span class="line"># Flink支持的后端存储有 &#x27;jobmanager（MemoryStateBackend）&#x27;, &#x27;filesystem&#x27;, &#x27;rocksdb&#x27;, 或者自定的类&lt;class-name-of-factory&gt;.</span><br><span class="line"># state.backend: filesystem</span><br><span class="line"></span><br><span class="line"># 自动存储检查点的数据文件和元数据的默认目录，这个目录必须能被所有的进程、节点访问</span><br><span class="line"># state.checkpoints.dir: hdfs://namenode-host:port/flink-checkpoints</span><br><span class="line"></span><br><span class="line"># 手动保存状态时 savepoints 的目录(可选)，用于状态存储写文件时使用</span><br><span class="line">state.savepoints.dir: hdfs://namenode-host:port/flink-checkpoints</span><br><span class="line"></span><br><span class="line"># 是否开启增量存储(类似RocksDB存储转态的情况)</span><br><span class="line"># state.backend.incremental: false</span><br><span class="line"></span><br><span class="line"># 故障恢复的策略，怎么样从失败的任务重恢复计算。配置可选: full 或者 region</span><br><span class="line"># full: 表示集群中的任务发生故障的时候，所有的task重新启动</span><br><span class="line"># region: 表示集群中的任务发生故障的时候，仅重启被失败失败任务所影响的下游的任务和产生数据的上游任务。</span><br><span class="line">jobmanager.execution.failover-strategy: region</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># REST和前端设置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># Web端运行时监视器端口</span><br><span class="line">rest.port: 8081</span><br><span class="line"></span><br><span class="line"># Web Server的地址配置，用于REST api调用</span><br><span class="line">#rest.address: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 配置REST端口绑定的范围</span><br><span class="line">#rest.bind-port: 8080-8090</span><br><span class="line"></span><br><span class="line"># 配置Server地址并绑定server</span><br><span class="line">#rest.bind-address: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 配置任务提交是否在网页端开启，默认开启</span><br><span class="line">#web.submit.enable: false</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># 高级配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># 指定默认的本地临时目录。Flink在运行时会把临时数据写到本地文件系统，</span><br><span class="line"># 比如 Flink 接收到的JAR、应用程序状态(当用RocksDB存储应用程序状态时)，要避免目录里的数据被服务器自动清空</span><br><span class="line"># 否则 job 重启时可能因找不到元数据导致恢复失败</span><br><span class="line"># 注意：推荐是添加多个文件夹地址(unix系统使用冒号隔开，windows使用逗号隔开)，多个文件夹地址可以是相同的，多文件地址的配置致使Flink创建多个线程来出来，提高读写效率和吞度量</span><br><span class="line"># io.tmp.dirs: /tmp </span><br><span class="line"></span><br><span class="line"># 是否在 TM 启动时预先分配 TM 管理的内存</span><br><span class="line">taskmanager.memory.preallocate: false</span><br><span class="line"></span><br><span class="line"># 类加载顺序的设定，Flink默认是&#x27;child-first&#x27;，还可以选：&#x27;parent-first&#x27;</span><br><span class="line"># &#x27;child-first&#x27;这种加载机制允许用户在自己的应用中使用不同的依赖或者JAR包的版本。</span><br><span class="line"># classloader.resolve-order: child-first</span><br><span class="line"></span><br><span class="line"># 网络堆栈能使用的内存总量的配置。这些配置一般不需要调优。</span><br><span class="line"># 当遇到&quot;Insufficient number of network buffers&quot; 错误的时候就需要调整下面的参数了。</span><br><span class="line"># 默认最小是64MB, 最大值是 1GB</span><br><span class="line"># TM 节点为网络缓冲区分配的内存，默认占JVM堆内存10%</span><br><span class="line"># taskmanager.memory.network.fraction: 0.1</span><br><span class="line"># 网络缓冲区最小值</span><br><span class="line"># taskmanager.memory.network.min: 64mb</span><br><span class="line"># 网络缓冲区最大值</span><br><span class="line"># taskmanager.memory.network.max: 1gb</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># Flink集群安全配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># Kerberos认证，主要用在Hadoop,Zookeeper, connectors上的安全组件</span><br><span class="line"># 通常开启的步骤为：</span><br><span class="line"># 1. 配置本地的krb5.conf文件</span><br><span class="line"># 2. 提供Kerberos的凭证(可以是一个keytab或者一个ticket cache)</span><br><span class="line"># 3. 针对不同的JAAS的登录上下文，激活Kerberos的凭证</span><br><span class="line"># 4. 使用JAAS/SASL配置连接</span><br><span class="line"></span><br><span class="line"># 下面这些配置是说明Kerberos怎么提供安全凭证的。</span><br><span class="line"># 当用户提供了keytab path 和 principal，keytab将用于代贴ticket cache </span><br><span class="line"></span><br><span class="line"># 是否从 Kerberos ticket 缓存中读取</span><br><span class="line"># security.kerberos.login.use-ticket-cache: true</span><br><span class="line"></span><br><span class="line"># 包含用户凭据的 Kerberos 密钥表文件的绝对路径</span><br><span class="line"># security.kerberos.login.keytab: /path/to/kerberos/keytab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 与 keytab 关联的 Kerberos 主体名称</span><br><span class="line"># security.kerberos.login.principal: flink-user</span><br><span class="line"></span><br><span class="line"># 以逗号分隔的登录上下文列表，用于提供 Kerberos 凭据</span><br><span class="line"># 例如，Client，KafkaClient 使用凭证进行 ZooKeeper 身份验证和 Kafka 身份验证# security.kerberos.login.contexts: Client,KafkaClient</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># Zookeeper 安全配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># 当zookeeper开启了安全模式，下面的配置就是必要的。</span><br><span class="line"></span><br><span class="line"># 如果zookeeper配置了服务名称，就需要修改下面这个配置</span><br><span class="line"># zookeeper.sasl.service-name: zookeeper</span><br><span class="line"></span><br><span class="line"># 该配置必须匹配 security.kerberos.login.contexts 配置中的列表（含有一个）</span><br><span class="line"># zookeeper.sasl.login-context-name: Client</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># 历史任务服务器配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># HistoryServer 通过bin/historyserver.sh (start|stop)开启和关闭</span><br><span class="line"></span><br><span class="line"># 用于上传执行完成的job。也是HistoryServer监控的目录。</span><br><span class="line">#jobmanager.archive.fs.dir: hdfs:///completed-jobs/</span><br><span class="line"></span><br><span class="line"># 基于 Web 的 HistoryServer 的地址</span><br><span class="line">#historyserver.web.address: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 基于 Web 的 HistoryServer 的端口号</span><br><span class="line">#historyserver.web.port: 8082</span><br><span class="line"></span><br><span class="line"># 以逗号分隔的目录列表，指定监控已完成的job所在的地址</span><br><span class="line">#historyserver.archive.fs.dir: hdfs:///completed-jobs/</span><br><span class="line"></span><br><span class="line"># 刷新受监控目录的时间间隔（毫秒）</span><br><span class="line">#historyserver.archive.fs.refresh-interval: 10000</span><br></pre></td></tr></table></figure><h1 id="2-masters">2. masters</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 集群的 master 节点</span><br><span class="line">localhost:8081</span><br></pre></td></tr></table></figure><h1 id="3-workers">3. workers</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 集群中所有的工作节点</span><br><span class="line">localhost</span><br></pre></td></tr></table></figure><h1 id="4-zoo-cfg">4. zoo.cfg</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 每个 tick 的毫秒数</span><br><span class="line">tickTime=2000</span><br><span class="line"> </span><br><span class="line"># 初始同步阶段可以采用的 tick 数</span><br><span class="line">initLimit=10</span><br><span class="line"> </span><br><span class="line"># 在发送请求和获取确认之间可以传递的 tick 数</span><br><span class="line">syncLimit=5</span><br><span class="line"> </span><br><span class="line"># 存储快照的目录</span><br><span class="line"># dataDir=/tmp/zookeeper</span><br><span class="line"> </span><br><span class="line"># 客户端将连接的端口</span><br><span class="line">clientPort=2181</span><br><span class="line"> </span><br><span class="line"># ZooKeeper quorum peers</span><br><span class="line">server.1=localhost:2888:3888</span><br><span class="line"># server.2=host:peer-port:leader-port</span><br></pre></td></tr></table></figure><h1 id="5-日志配置">5. 日志配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在不同平台下Flink运行的日志文件</span><br><span class="line">log4j-cli.properties</span><br><span class="line">log4j-console.properties</span><br><span class="line">log4j-yarn-session.properties</span><br><span class="line">log4j.properties</span><br><span class="line">logback-console.xml</span><br><span class="line">logback-yarn.xml</span><br><span class="line">logback.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 1.12.4 RocksDBStateBackend 优化</title>
      <link href="/2021/06/09/flink_11/"/>
      <url>/2021/06/09/flink_11/</url>
      
        <content type="html"><![CDATA[<p><strong>在使用RocksDB作为state存储之后，发现性能被严重影响，吞吐能力下降了几倍不止，所以根据网上的几篇调优文档做了自己的优化，感谢下面这些博客做出的贡献：</strong><br><a href="https://www.jianshu.com/p/2e61c2c83c57">https://www.jianshu.com/p/2e61c2c83c57</a><br><a href="https://blog.csdn.net/wangshuo2019/article/details/107250801/">https://blog.csdn.net/wangshuo2019/article/details/107250801/</a><br><a href="https://blog.csdn.net/huang358468/article/details/115221066">https://blog.csdn.net/huang358468/article/details/115221066</a><br><a href="https://github.com/apachecn/flink-doc-zh/blob/master/docs/1.7/119.md">https://github.com/apachecn/flink-doc-zh/blob/master/docs/1.7/119.md</a><br><a href="https://www.jianshu.com/p/df98fa755a2d">https://www.jianshu.com/p/df98fa755a2d</a><br><a href="https://blog.csdn.net/weixin_44904816/article/details/105672235">https://blog.csdn.net/weixin_44904816/article/details/105672235</a><br><a href="https://blog.csdn.net/yscoder/article/details/117064790">https://blog.csdn.net/yscoder/article/details/117064790</a></p><p><strong>下面是我自己的flink-conf.yaml文件关于RocksDB的优化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">state.backend: rocksdb</span><br><span class="line"># 激活RocksDB压缩过滤清除</span><br><span class="line">state.backend.rocksdb.ttl.compaction.filter.enabled: true</span><br><span class="line"># block大小，默认4KB</span><br><span class="line">state.backend.rocksdb.block.blocksize: 32kb</span><br><span class="line"># block cache大小，默认8MB，内存余量充足建议128m或256m，提升读的性能</span><br><span class="line">state.backend.rocksdb.block.cache-size: 128m</span><br><span class="line">state.backend.rocksdb.compaction.level.use-dynamic-size: true</span><br><span class="line"># 后台负责 flush 和 compaction 的最大并发线程数，默认为1</span><br><span class="line">state.backend.rocksdb.thread.num: 4</span><br><span class="line"># 指定checkpoint的data files和meta data存储的目录，该目录必须对所有参与的TaskManagers及JobManagers可见</span><br><span class="line">state.checkpoints.dir: file:///ssd/flink2kafka/flink-1.12.4/data</span><br><span class="line"># 用于指定定时器服务的工厂类实现类，默认为“HEAP”</span><br><span class="line">state.backend.rocksdb.timer-service.factory: rocksdb</span><br><span class="line"># 用于指定同时可以操作RocksDBStateBackend的线程数量，默认是1</span><br><span class="line">state.backend.rocksdb.checkpoint.transfer.thread.num: 2</span><br><span class="line"># 配置任务本地恢复</span><br><span class="line">state.backend.local-recovery: true</span><br><span class="line"># 指定RocksDB存储状态数据的本地文件路径，在每个TaskManager提供该路径节点中的状态存储</span><br><span class="line">state.backend.rocksdb.localdir: /ssd/flink2kafka/flink-1.12.4/rocksdb</span><br><span class="line"># 设为 false 禁用 RocksDB 内存托管</span><br><span class="line">state.backend.rocksdb.memory.managed: true</span><br><span class="line"># 限制每个slot的RocksDB内存的使用上限，避免了OOM的风险</span><br><span class="line">state.backend.rocksdb.memory.fixed-per-slot: 20mb</span><br><span class="line"># 默认值 0.5，即 50% 的给定内存会分配给写缓冲区使用</span><br><span class="line">state.backend.rocksdb.memory.write-buffer-ratio: 0.9</span><br><span class="line"># 默认值 0.1，即 10% 的 block cache 内存会优先分配给索引及过滤</span><br><span class="line">state.backend.rocksdb.memory.high-prio-pool-ratio: 0.1</span><br><span class="line">#state.backend.rocksdb.metrics.estimate-num-keys: true</span><br><span class="line">state.backend.rocksdb.metrics.num-running-compactions: true</span><br><span class="line"># 监控当前的实际延迟写入率</span><br><span class="line">state.backend.rocksdb.metrics.background-errors: true</span><br><span class="line"># 启用了Flink RocksDB指标</span><br><span class="line">state.backend.rocksdb.metrics.block-cache-capacity: true</span><br><span class="line">state.backend.rocksdb.metrics.block-cache-pinned-usage: true</span><br><span class="line">state.backend.rocksdb.metrics.block-cache-usage: true</span><br><span class="line">state.backend.rocksdb.metrics.estimate-table-readers-mem: true</span><br><span class="line"># 监控待处理的压缩，如果压缩失败返回1，否则返回0</span><br><span class="line">state.backend.rocksdb.metrics.compaction-pending: true</span><br><span class="line"># L1层单个 sstable 文件的大小阈值，默认值为64MB</span><br><span class="line">state.backend.rocksdb.compaction.level.target-file-size-base: 32m</span><br><span class="line"># L1层的数据总大小阈值，默认值为256MB，建议设为 target_file_size_base 的倍数，且不能太小</span><br><span class="line">state.backend.rocksdb.compaction.level.max-size-level-base: 160m</span><br></pre></td></tr></table></figure><p><strong>调优之前一定要先了解RocksDB的原理，才能根据自己的实际情况去调整参数</strong><br><strong>这是官方对于RocksDBStateBackend配置的解释：</strong><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.12/deployment/config.html#advanced-rocksdb-state-backends-options">https://ci.apache.org/projects/flink/flink-docs-release-1.12/deployment/config.html#advanced-rocksdb-state-backends-options</a></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 下安装 RocksDB</title>
      <link href="/2021/06/08/rocksdb_2/"/>
      <url>/2021/06/08/rocksdb_2/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>安装依赖</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc g++ libsnappy-dev zlib1g-dev libbz2-dev liblz4-dev libzstd-dev libgflags-dev</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>下载安装包并解压（安装包链接放在最后）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf rocksdb-6.16.6.tar.gz</span><br><span class="line">cd rocksdb-6.16.4/</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>编译安装</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 编译静态库</span><br><span class="line">make static_lib</span><br><span class="line">// 编译动态库</span><br><span class="line">make shared_lib</span><br></pre></td></tr></table></figure><p><strong>如果出现下面的错误：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误示例</span><br><span class="line">$DEBUG_LEVEL is 0</span><br><span class="line">GEN util/build_version.cc</span><br><span class="line">CCLD librocksdb.so.6.13.0</span><br><span class="line">/usr/bin/ld: ./memory/concurrent_arena.o: relocation R_X86_64_TPOFF32 against symbol _ZN7rocksdb15ConcurrentArena9tls_cpuidE&#x27; can not be used when making a shared object; recompile with -fPIC /usr/bin/ld: ./monitoring/iostats_context.o: relocation R_X86_64_TPOFF32 against symbol _ZN7rocksdb15iostats_contextE&#x27; can not be used when making a shared object; recompile with -fPIC</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make shared_lib</span><br><span class="line">make static_lib</span><br></pre></td></tr></table></figure><p><strong>编译完成会得到下面几个文件（第一个为静态编译得到的，后四个为动态编译得到的）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">librocksdb.a</span><br><span class="line">librocksdb.so</span><br><span class="line">librocksdb.so.6</span><br><span class="line">librocksdb.so.6.16</span><br><span class="line">librocksdb.so.6.16.4</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>环境配置（我这里软连接创建失败了，但是没有影响安装）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将动态库文件复制到系统库目录下</span><br><span class="line">sudo cp librocksdb.so.6.16.4 /usr/local/lib</span><br><span class="line">// 链接其他动态库</span><br><span class="line">sudo ln -s librocksdb.so.6.16.4 /usr/local/lib/librocksdb.so.6.16</span><br><span class="line">sudo ln -s librocksdb.so.6.16.4 /usr/local/lib/librocksdb.so.6</span><br><span class="line">sudo ln -s librocksdb.so.6.16.4 /usr/local/lib/librocksdb.so</span><br></pre></td></tr></table></figure><p><strong>vi /etc/profile</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</span><br><span class="line">export LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><p><strong>最后source /etc/profile</strong><br><strong>致此安装完毕</strong></p><p><strong>安装包链接：</strong><br>链接：<a href="https://pan.baidu.com/s/1oFANkJPUIQUzwJLF3NF3mw">https://pan.baidu.com/s/1oFANkJPUIQUzwJLF3NF3mw</a><br>提取码：ofwb</p><p><strong>文章摘自</strong><a href="https://www.jianshu.com/p/575b2e27b028">https://www.jianshu.com/p/575b2e27b028</a></p>]]></content>
      
      
      <categories>
          
          <category> RocksDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocksDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 安装 RocksDB</title>
      <link href="/2021/06/08/rocksdb_1/"/>
      <url>/2021/06/08/rocksdb_1/</url>
      
        <content type="html"><![CDATA[<p><strong>安装之前需要确定服务器是否挂yum源，木有的自行百度挂源哈</strong></p><ol><li><strong>安装依赖</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz git gcc gcc-c++ lz4-devel</span><br><span class="line">yum -y install snappy snappy-devel zlib zlib-devel bzip2 bzip2-devel lz4 lz4-devel zstd</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>下载安装cmake（所有的安装包都放在文末，环境不通外网的可以直接去下载）（注意下面添加的环境变量路径改成自己的）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -O   https://cmake.org/files/v3.6/cmake-3.6.0-Linux-x86_64.tar.gz</span><br><span class="line">tar -xvzf cmake-3.6.0-Linux-x86_64.tar.gz </span><br><span class="line">yum remove cmake</span><br><span class="line"></span><br><span class="line">cat &gt;&gt;/etc/profile &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">export PATH=\$PATH:/opt/cmake-3.6.0-Linux-x86_64/bin</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>安装gflags（我这里不知道为什么下载下来的是v2.2.2.tar.gz，这不重要，照常解压就行）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wget   https://github.com/gflags/gflags/archive/v2.2.2.tar.gz</span><br><span class="line">tar -xvzf gflags-2.2.2.tar.gz</span><br><span class="line">cd gflags-2.2.2/</span><br><span class="line">mkdir build</span><br><span class="line">cd build/</span><br><span class="line">cmake -DBUILD_SHARED_LIBS=ON -DBUILD_STATIC_LIBS=ON -DINSTALL_HEADERS=ON -DINSTALL_SHARED_LIBS=ON -DINSTALL_STATIC_LIBS=ON ..</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cat &gt;&gt;/etc/profile &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/usr/local/lib</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>下载安装RocksDB</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/facebook/rocksdb/archive/v6.14.6.tar.gz</span><br><span class="line">tar -xvzf rocksdb-6.14.6.tar.gz </span><br><span class="line">cd rocksdb-6.14.6/</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/local/rocksdb ..</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cat &gt;&gt;/etc/profile &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">export CPLUS_INCLUDE_PATH=\$CPLUS_INCLUDE_PATH:/usr/local/rocksdb/include/</span><br><span class="line">export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/usr/local/rocksdb/lib64/</span><br><span class="line">export LIBRARY_PATH=\$LIBRARY_PATH:/usr/local/rocksdb/lib64/</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>ldb工具进行测试</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">cd rocksdb-6.14.6/build/tools/</span><br><span class="line"></span><br><span class="line">执行./ldb -help，会出现下面的说明</span><br><span class="line"></span><br><span class="line">ldb - RocksDB Tool</span><br><span class="line"></span><br><span class="line">commands MUST specify --db=&lt;full_path_to_db_directory&gt; when necessary</span><br><span class="line"></span><br><span class="line">commands can optionally specify --env_uri=&lt;uri_of_environment&gt; if necessary</span><br><span class="line"></span><br><span class="line">The following optional parameters control if keys/values are input/output as hex or as plain strings:</span><br><span class="line">  --key_hex : Keys are input/output as hex</span><br><span class="line">  --value_hex : Values are input/output as hex</span><br><span class="line">  --hex : Both keys and values are input/output as hex</span><br><span class="line"></span><br><span class="line">The following optional parameters control the database internals:</span><br><span class="line">  --column_family=&lt;string&gt; : name of the column family to operate on. default: default column family</span><br><span class="line">  --ttl with &#x27;put&#x27;,&#x27;get&#x27;,&#x27;scan&#x27;,&#x27;dump&#x27;,&#x27;query&#x27;,&#x27;batchput&#x27; : DB supports ttl and value is internally timestamp-suffixed</span><br><span class="line">  --try_load_options : Try to load option file from DB.</span><br><span class="line">  --disable_consistency_checks : Set options.force_consistency_checks = false.</span><br><span class="line">  --ignore_unknown_options : Ignore unknown options when loading option file.</span><br><span class="line">  --bloom_bits=&lt;int,e.g.:14&gt;</span><br><span class="line">  --fix_prefix_len=&lt;int,e.g.:14&gt;</span><br><span class="line">  --compression_type=&lt;no|snappy|zlib|bzip2|lz4|lz4hc|xpress|zstd&gt;</span><br><span class="line">  --compression_max_dict_bytes=&lt;int,e.g.:16384&gt;</span><br><span class="line">  --block_size=&lt;block_size_in_bytes&gt;</span><br><span class="line">  --auto_compaction=&lt;true|false&gt;</span><br><span class="line">  --db_write_buffer_size=&lt;int,e.g.:16777216&gt;</span><br><span class="line">  --write_buffer_size=&lt;int,e.g.:4194304&gt;</span><br><span class="line">  --file_size=&lt;int,e.g.:2097152&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data Access Commands:</span><br><span class="line">  put &lt;key&gt; &lt;value&gt; [--create_if_missing] [--ttl]</span><br><span class="line">  get &lt;key&gt; [--ttl]</span><br><span class="line">  batchput &lt;key&gt; &lt;value&gt; [&lt;key&gt; &lt;value&gt;] [..] [--create_if_missing] [--ttl]</span><br><span class="line">  scan [--from] [--to]  [--ttl] [--timestamp] [--max_keys=&lt;N&gt;q]  [--start_time=&lt;N&gt;:- is inclusive] [--end_time=&lt;N&gt;:- is exclusive] [--no_value]</span><br><span class="line">  delete &lt;key&gt;</span><br><span class="line">  deleterange &lt;begin key&gt; &lt;end key&gt;</span><br><span class="line">  query [--ttl]</span><br><span class="line">    Starts a REPL shell.  Type help for list of available commands.</span><br><span class="line">  approxsize [--from] [--to] </span><br><span class="line">  checkconsistency</span><br><span class="line">  list_file_range_deletes [--max_keys=&lt;N&gt;] : print tombstones in SST files.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Admin Commands:</span><br><span class="line">  dump_wal --walfile=&lt;write_ahead_log_file_path&gt; [--header]  [--print_value]  [--write_committed=true|false] </span><br><span class="line">  compact [--from] [--to] </span><br><span class="line">  reduce_levels --new_levels=&lt;New number of levels&gt; [--print_old_levels]</span><br><span class="line">  change_compaction_style --old_compaction_style=&lt;Old compaction style: 0 for level compaction, 1 for universal compaction&gt; --new_compaction_style=&lt;New compaction style: 0 for level compaction, 1 for universal compaction&gt;</span><br><span class="line">  dump [--from] [--to]  [--ttl] [--max_keys=&lt;N&gt;] [--timestamp] [--count_only] [--count_delim=&lt;char&gt;] [--stats] [--bucket=&lt;N&gt;] [--start_time=&lt;N&gt;:- is inclusive] [--end_time=&lt;N&gt;:- is exclusive] [--path=&lt;path_to_a_file&gt;]</span><br><span class="line">  load [--create_if_missing] [--disable_wal] [--bulk_load] [--compact]</span><br><span class="line">  manifest_dump [--verbose] [--json] [--path=&lt;path_to_manifest_file&gt;]</span><br><span class="line">  file_checksum_dump [--path=&lt;path_to_manifest_file&gt;]</span><br><span class="line">  list_column_families</span><br><span class="line">  create_column_family --db=&lt;db_path&gt; &lt;new_column_family_name&gt;</span><br><span class="line">  drop_column_family --db=&lt;db_path&gt; &lt;column_family_name_to_drop&gt;</span><br><span class="line">  dump_live_files</span><br><span class="line">  idump [--from] [--to]  [--input_key_hex] [--max_keys=&lt;N&gt;] [--count_only] [--count_delim=&lt;char&gt;] [--stats]</span><br><span class="line">  repair</span><br><span class="line">  backup [--backup_env_uri]  [--backup_dir]  [--num_threads]  [--stderr_log_level=&lt;int (InfoLogLevel)&gt;] </span><br><span class="line">  restore [--backup_env_uri]  [--backup_dir]  [--num_threads]  [--stderr_log_level=&lt;int (InfoLogLevel)&gt;] </span><br><span class="line">  checkpoint [--checkpoint_dir] </span><br><span class="line">  write_extern_sst &lt;output_sst_path&gt;</span><br><span class="line">  ingest_extern_sst &lt;input_sst_path&gt; [--move_files]  [--snapshot_consistency]  [--allow_global_seqno]  [--allow_blocking_flush]  [--ingest_behind]  [--write_global_seqno] </span><br><span class="line">  unsafe_remove_sst_file &lt;SST file number&gt;</span><br><span class="line">    MUST NOT be used on a live DB.</span><br><span class="line"></span><br><span class="line"># ./ldb --db=/tmp/test_db --create_if_missing put a1 b1</span><br><span class="line">OK</span><br><span class="line"># ./ldb --db=/tmp/test_db scan</span><br><span class="line">a1 : b1</span><br><span class="line"># ./ldb --db=/tmp/test_db get a1</span><br><span class="line">b1</span><br><span class="line"># ./ldb --db=/tmp/test_db get a2</span><br><span class="line">Failed: NotFound: </span><br><span class="line"># cd /tmp/test_db/</span><br><span class="line"># ll</span><br><span class="line">-rw-r--r-- 1 root root    26 Jun  9 17:52 000003.log</span><br><span class="line">-rw-r--r-- 1 root root    16 Jun  9 17:52 CURRENT</span><br><span class="line">-rw-r--r-- 1 root root    37 Jun  9 17:52 IDENTITY</span><br><span class="line">-rw-r--r-- 1 root root     0 Jun  9 17:52 LOCK</span><br><span class="line">-rw-r--r-- 1 root root 18821 Jun  9 17:53 LOG</span><br><span class="line">-rw-r--r-- 1 root root 18589 Jun  9 17:52 LOG.old.1623232363821351</span><br><span class="line">-rw-r--r-- 1 root root 18821 Jun  9 17:52 LOG.old.1623232374342461</span><br><span class="line">-rw-r--r-- 1 root root 18821 Jun  9 17:52 LOG.old.1623232385039046</span><br><span class="line">-rw-r--r-- 1 root root    13 Jun  9 17:52 MANIFEST-000001</span><br><span class="line">-rw-r--r-- 1 root root  5793 Jun  9 17:52 OPTIONS-000005</span><br></pre></td></tr></table></figure><p><strong>安装包百度云链接：</strong><br>链接：<a href="https://pan.baidu.com/s/1oFANkJPUIQUzwJLF3NF3mw">https://pan.baidu.com/s/1oFANkJPUIQUzwJLF3NF3mw </a><br>提取码：ofwb</p><p>文章借鉴<a href="https://blog.51cto.com/u_860143/2452514">https://blog.51cto.com/u_860143/2452514</a></p>]]></content>
      
      
      <categories>
          
          <category> RocksDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocksDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 实现字符串 MD5 加密</title>
      <link href="/2021/06/08/java_2/"/>
      <url>/2021/06/08/java_2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Util</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">stringMD5</span><span class="params">(String input)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）</span></span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span>MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line"><span class="comment">//            输入的字符串转换成字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] inputByteArray = input.getBytes();</span><br><span class="line"><span class="comment">//            inputByteArray是输入字符串转换得到的字节数组</span></span><br><span class="line">            messageDigest.update(inputByteArray);</span><br><span class="line"><span class="comment">//            转换并返回结果，也是字节数组，包含16个元素</span></span><br><span class="line">            <span class="type">byte</span>[] resultByteArray = messageDigest.digest();</span><br><span class="line"><span class="comment">//            字符数组转换成字符串返回</span></span><br><span class="line">            <span class="keyword">return</span> byteArrayToHex(resultByteArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    将字节数组换成成16进制的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">byteArrayToHex</span><span class="params">(<span class="type">byte</span>[] byteArray)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        首先初始化一个字符数组，用来存放每个16进制字符</span></span><br><span class="line">        <span class="type">char</span>[] hexDigits = &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））</span></span><br><span class="line">        <span class="type">char</span>[] resultCharArray =<span class="keyword">new</span> <span class="title class_">char</span>[byteArray.length * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : byteArray) &#123;</span><br><span class="line">            resultCharArray[index++] = hexDigits[b&gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">            resultCharArray[index++] = hexDigits[b&amp; <span class="number">0xf</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        字符数组组合成字符串返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(resultCharArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MD5Util</span> <span class="variable">md5Util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MD5Util</span>();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">in</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> md5Util.stringMD5(in);</span><br><span class="line">            System.out.println(<span class="string">&quot;加密前：&quot;</span> + in);</span><br><span class="line">            System.out.println(<span class="string">&quot;加密后：&quot;</span> + value + <span class="string">&quot;，长度：&quot;</span> + value.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果图：</strong><br><img src="https://img-blog.csdnimg.cn/20210608093502559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码出自<a href="https://www.cnblogs.com/hihtml5/p/6064999.html">https://www.cnblogs.com/hihtml5/p/6064999.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MD5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 1.12.4 TaskManager 的内存调优（standalone 模式）</title>
      <link href="/2021/06/06/flink_10/"/>
      <url>/2021/06/06/flink_10/</url>
      
        <content type="html"><![CDATA[<p>这篇博客是对上篇<a href="https://blog.csdn.net/weixin_44758876/article/details/117448806">《基于Flink&amp;Kafka完成的流式模块》</a>的补充，在上一篇里已经做了很多优化以及详细的注释，这里要补充一下内存方面的优化。<br><strong>因为在生产环境中实际部署之前，还是没有考虑到同时消费多个topic记录的偏移量是很大的，同时模拟的数据量并没有达到实际生产环境的数据量，所以在部署的时候因为TaskManager内存不足，一直处理内存中的数据导致没有及时发送心跳让JobManager以为TaskManager已经挂掉（实际上后来确实是会挂掉），所以就针对内存方面进行了优化。</strong></p><ol><li><strong>我们可以通过修改 flink-conf.yaml 文件，调整TaskManager的最大内存，我这里是改成了4个g</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定TaskManager进程的总内存</span><br><span class="line">taskmanager.memory.process.size: 4096m</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>当然如果我们需要确定自己的内存时，可以通过下面两个参数来指定（我采用的就是这种方式），注意这个不能和上面的方法同时指定</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 指定JVM堆内存大小</span><br><span class="line">taskmanager.memory.task.heap.size: 2048m</span><br><span class="line"># 指定JVM托管内存大小</span><br><span class="line">taskmanager.memory.managed.size: 512m</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>也可以通过下面的参数指定内存大小，第一种和这种方式属于比较简单的，第二种就需要了解自己环境数据的具体生产量来设置了</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定Flink总内存</span><br><span class="line">taskmanager.memory.flink.size</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Error while executing topic command : Replication factor: 2 larger than available brokers: 1</title>
      <link href="/2021/06/03/kafka_2/"/>
      <url>/2021/06/03/kafka_2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210603140034820.png" alt="在这里插入图片描述"><br><strong>创建topic时报错，是因为topic副本数不能超过服务器个数，我用的是单节点kafka，所以这里把命令改成<font color=red>–replication-factor 1</font>即可</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> Bug记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 1.12.4 Standalone 模式部署</title>
      <link href="/2021/06/03/flink_9/"/>
      <url>/2021/06/03/flink_9/</url>
      
        <content type="html"><![CDATA[<ol><li>这里用三台机器测试，需要jdk1.8支持，没有的可以自己去下载安装，我就不放教程了</li><li>准备好安装包，官网下载地址：<br><a href="https://flink.apache.org/zh/downloads.html">https://flink.apache.org/zh/downloads.html</a></li><li>依次上传到服务器上<br><img src="https://img-blog.csdnimg.cn/20210603115754832.png" alt="在这里插入图片描述"></li><li>解压</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf flink-1.12.4-bin-scala_2.12.tgz</span><br></pre></td></tr></table></figure><ol start="5"><li>依次修改conf目录下的flink-conf.yaml文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobmanager.rpc.address: 主节点ip（JobManager）</span><br></pre></td></tr></table></figure><ol start="6"><li>修改conf下的masters</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主节点ip:8081</span><br></pre></td></tr></table></figure><ol start="7"><li>修改conf下的workers</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从节点ip</span><br><span class="line">从节点ip</span><br></pre></td></tr></table></figure><ol start="8"><li>在主节点上启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/start-cluster.sh</span><br></pre></td></tr></table></figure><ol start="9"><li>登录web界面，可以看到到这里就安装成功了<br><img src="https://img-blog.csdnimg.cn/20210603132748156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 集群部署教程</title>
      <link href="/2021/06/03/kafka_1/"/>
      <url>/2021/06/03/kafka_1/</url>
      
        <content type="html"><![CDATA[<ol><li>Kafka部署需要Java环境，可以使用CentOS自带的或者自己重新安装新版本</li><li>首先准备好安装包，官网下载地址：<br><a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a></li><li>我这里下载的2.8.0的版本，目前为止最新的版本，一共三台服务器，依次上传上去并解压</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kafka_2.12-2.8.0.tgz</span><br></pre></td></tr></table></figure><ol start="4"><li>解压之后，可以看到下面的内容<br><img src="https://img-blog.csdnimg.cn/20210603110026267.png" alt="在这里插入图片描述"></li><li>然后先建立zookeeper集群，我这里使用的是kafka自带的，修改config目录下的zookeeper.properties文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#自定义的zookeeper数据目录</span><br><span class="line">dataDir=/opt/module/kafka_2.12-2.8.0/zkdata</span><br><span class="line">#端口</span><br><span class="line">clientPort=2181</span><br><span class="line">maxClientCnxns=10</span><br><span class="line">#zk的基本时间单元，毫秒</span><br><span class="line">tickTime=2000</span><br><span class="line">#Leader-Follower初始通信时限 tickTime*10</span><br><span class="line">initLimit=10</span><br><span class="line">#Leader-Follower同步通信时限 tickTime*5</span><br><span class="line">syncLimit=5</span><br><span class="line">#自定义的zookeeper日志目录</span><br><span class="line">dataLogDir=/opt/module/kafka_2.12-2.8.0/zklog</span><br><span class="line">admin.enableServer=false</span><br><span class="line">#broker Id的服务地址</span><br><span class="line">server.1=192.168.44.131:2888:3888</span><br><span class="line">server.2=192.168.44.132:2888:3888</span><br><span class="line">server.3=192.168.44.133:2888:3888</span><br></pre></td></tr></table></figure><ol start="6"><li>创建数据目录及日志目录对应文件夹</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir zkdata</span><br><span class="line">mkdir zklog</span><br></pre></td></tr></table></figure><ol start="7"><li>在zookeeper数据目录下添加myid文件（内容需和zookeeper.properties文件中的server.x一致）<br><img src="https://img-blog.csdnimg.cn/20210603111649868.png" alt="在这里插入图片描述"></li><li>依次修改kafka配置，config下的server.properties文件（<a href="http://xn--broker-9e4jn0gt3hnr2c06kvr8j.id">每台服务器除broker.id</a> 和 本机ip 两个属性需要修改之外，其他属性保持一致）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># broker 的全局唯一编号，不能重复</span><br><span class="line">broker.id=1</span><br><span class="line"># 配置监听,修改为本机ip</span><br><span class="line">listeners=PLAINTEXT://192.168.44.131:9092</span><br><span class="line"># 处理网络请求的线程数量，默认</span><br><span class="line">num.network.threads=3</span><br><span class="line"># 处理磁盘IO的线程数量，默认</span><br><span class="line">num.io.threads=8</span><br><span class="line"># 发送套接字的缓冲区大小，默认</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line"># 接收套接字的缓冲区大小，默认</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line"># 请求套接字的缓冲区大小，默认</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line"># kafka 运行日志存放路径</span><br><span class="line">log.dirs=/opt/module/kafka_2.12-2.8.0/kafka</span><br><span class="line"># topic 在当前broker上的分片个数，与broker保持一致</span><br><span class="line">num.partitions=1</span><br><span class="line"># 允许删除topic</span><br><span class="line">delete.topic.enable=true</span><br><span class="line"># 用来恢复和清理data下数据的线程数量，默认</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=1</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line"># segment文件保留的最长时间，超时将被删除，默认</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line"># 配置三台服务zookeeper连接地址</span><br><span class="line">zookeeper.connect=192.168.44.131:2181,192.168.44.132:2181,192.168.44.133:2181</span><br><span class="line">zookeeper.connection.timeout.ms=30000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure><ol start="9"><li>依次启动zookeeper</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><ol start="10"><li>依次启动kafka</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure><ol start="11"><li>启动成功使用jps命令，可以看到下面两个进程，到这里就安装完成了<br><img src="https://img-blog.csdnimg.cn/20210603113106801.png" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 实时消费多个 topic 数据</title>
      <link href="/2021/06/02/flink_8/"/>
      <url>/2021/06/02/flink_8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210427105014204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><br></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;10.7.2.20:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topics = <span class="keyword">new</span> util.<span class="type">LinkedList</span>[<span class="type">String</span>]</span><br><span class="line">    topics.add(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    topics.add(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    val stream = env.addSource(new FlinkKafkaConsumer[String](&quot;test&quot;, new SimpleStringSchema(), properties))</span></span><br><span class="line">    <span class="keyword">val</span> stream = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](topics, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">    stream.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>开启两个Kafka生产者，分别是test1、test2两个topic，输入测试数据：</strong><br><img src="https://img-blog.csdnimg.cn/2021060222212277.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210602222309857.png" alt="在这里插入图片描述"><br><br><br><strong>可以看到数据都打印在控制台了：</strong><br><br><br><img src="https://img-blog.csdnimg.cn/20210602222432373.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 查看 CPU 信息、使用率、核数、操作系统、内存使用率、磁盘空间</title>
      <link href="/2021/06/02/linux_2/"/>
      <url>/2021/06/02/linux_2/</url>
      
        <content type="html"><![CDATA[<h1 id="查看CPU信息、使用率、核数">查看CPU信息、使用率、核数</h1><ol><li><strong>查看物理CPU个数</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>查看逻辑CPU个数</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;processor&quot;| wc –l</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>每个物理CPU的核数</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>也可以直接通过 lscpu 命令查看</strong><br><img src="https://img-blog.csdnimg.cn/20210602115655940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这是两个CPU，20核，支持超线程，40个逻辑CPU</p></li><li><p><strong>查看是否支持超线程<br>如果&quot;siblings&quot;和&quot;cpu cores&quot;一致，则说明不支持超线程，或者超线程未打开；<br>如果&quot;siblings&quot;是&quot;cpu cores&quot;的两倍，则说明支持超线程，并且超线程已打开</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;sibling&quot;|uniq</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>查看逻辑CPU个数以及CPU型号</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>查看CPU是32位运行还是64位运行</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>获取CPU详细信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><ol start="9"><li><strong>top 命令查看CPU使用率</strong><br><img src="https://img-blog.csdnimg.cn/20210602143004722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">第一行（top）</span><br><span class="line">13:44:03 ： 系统当前时间</span><br><span class="line">68 days, 20:13 ： 系统从启动后到现在的运作时间</span><br><span class="line">7 users ： 当前登录到系统的用户数（确切的说是登录到用户的终端数，同一个用户同一时间对系统多个终端的连接将被视为多个用户连接到系统，这里的用户数也将表现为终端的数目）</span><br><span class="line">load average ： 当前系统负载的平均值，后面的三个值分别为1分钟前、5分钟前、15分钟前进程的平均数，一般的可以认为这个数值超过 CPU 数目时，CPU 将比较吃力的负载当前系统所包含的进程</span><br><span class="line">第二行（Tasks）</span><br><span class="line">550 total ： 当前系统进程总数</span><br><span class="line">2 running ： 当前运行中的进程数</span><br><span class="line">557 sleeping ： 当前处于等待状态中的进程数</span><br><span class="line">0 stopped ： 停止的进程数</span><br><span class="line">0 zombie ： 僵尸进程数</span><br><span class="line">第三行（%Cpu）</span><br><span class="line">8.1 us ： 用户空间占用CPU百分比，不包含renice值为负的任务占用的CPU的时间</span><br><span class="line">1.2 sy ： 内核空间占用CPU百分比</span><br><span class="line">0.0 ni ： 用户进程空间内改变过优先级的进程占用CPU百分比</span><br><span class="line">90.4 id ： 空闲CPU百分比</span><br><span class="line">0.0 wa ： 等待I/O的CPU时间百分比</span><br><span class="line">0.0 hi ： CPU硬中断时间百分比</span><br><span class="line">0.2 si ： CPU软中断时间百分比</span><br><span class="line">第四行（Mem）</span><br><span class="line">26403968+total ： 物理内存总量</span><br><span class="line">24978953+used ： 使用的物理内存量</span><br><span class="line">14250160 free ： 空闲的物理内存量</span><br><span class="line">817276 buffers ： 用作内核缓存的物理内存量</span><br><span class="line">第五行（反映着交换分区（Swap）的使用情况，通常，交换分区被频繁使用的情况，将被视作物理内存不足而造成的）</span><br><span class="line">0 total ： 交换区总量</span><br><span class="line">0 used ： 使用的交换区总量</span><br><span class="line">0 free ： 空闲交换区总量</span><br><span class="line">20137419+cached ： 缓冲的交换区总量</span><br><span class="line">进程信息：</span><br><span class="line">PID ： 进程的ID</span><br><span class="line">USER ： 进程的所有者</span><br><span class="line">PR ： 进程的优先级别，越小越优先被执行</span><br><span class="line">NI ： 值</span><br><span class="line">VIRT ： 进程占用的虚拟内存</span><br><span class="line">RES ： 进程占用的物理内存</span><br><span class="line">SHR ： 进程使用的共享内存</span><br><span class="line">S ： 进程的状态；S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</span><br><span class="line">%CPU ： 进程占用CPU的使用率</span><br><span class="line">%MEN ： 进程使用的物理内存和总内存的百分比</span><br><span class="line">TIME+ ： 该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</span><br><span class="line">COMMAND ： 进程启动命令名称</span><br><span class="line">top 运行中可以通过 top 的内部命令对进程的显示方式进行控制：</span><br><span class="line">s改变画面更新频率</span><br><span class="line">l关闭或开启第一部分第一行 top 信息的表示</span><br><span class="line">t关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示</span><br><span class="line">m关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示</span><br><span class="line">N以 PID 的大小的顺序排列表示进程列表</span><br><span class="line">P以 CPU 占用率大小的顺序排列进程列表</span><br><span class="line">M以内存占用率大小的顺序排列进程列表</span><br><span class="line">h显示帮助</span><br><span class="line">n设置在进程列表所显示进程的数量</span><br><span class="line">q退出 top</span><br><span class="line">s改变画面更新周期</span><br></pre></td></tr></table></figure><p><strong>总核数 = 物理CPU个数 X 每颗物理CPU的核数</strong><br><strong>总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</strong></p><h1 id="查看操作系统信息">查看操作系统信息</h1><ol><li><strong>查看操作系统内核信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uname -a显示全部信息</span><br><span class="line">-m 或 --machine显示电脑类型</span><br><span class="line">-r 或 --release显示操作系统的发行编号</span><br><span class="line">-s 或 --sysname显示操作系统名称</span><br><span class="line">-v显示操作系统的版本</span><br><span class="line">-p 或 --processor输出处理器类型或&quot;unknown&quot;</span><br><span class="line">-i 或 --hardware-platform输出硬件平台或&quot;unknown&quot;</span><br><span class="line">-o 或 --operating-system输出操作系统名称</span><br><span class="line">-- help显示帮助</span><br><span class="line">-- version显示版本信息</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>查看操作系统版本</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue或cat /etc/centos-release或cat /etc/redhat-release</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>查看操作系统版本信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><h1 id="查看内存使用率">查看内存使用率</h1><ol><li><strong>查看内存详细信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>free 查看内存使用情况</strong><br><img src="https://img-blog.csdnimg.cn/20210602150519836.png" alt="在这里插入图片描述"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">total ： 总计物理内存的大小</span><br><span class="line">used ： 已使用内存大小</span><br><span class="line">free ： 可用内存大小</span><br><span class="line">Shared ： 多个进程共享的内存总额</span><br><span class="line">buffers/cached ： 被 buffer 和 cache 使用的物理内存大小</span><br><span class="line"></span><br><span class="line">free -b ： 以bytes为单位来显示内存的信息</span><br><span class="line">free -k ： 以kb为单位来显示内存的信息</span><br><span class="line">free -m ： 以m为单位来显示内存的信息</span><br><span class="line">free -g ： 以G为单位来显示内存的信息</span><br><span class="line">free -h ： 以适于人类可读方式显示内存信息。-h与其他命令最大不同是-h选项会在数字后面加上适于人类可读的单位</span><br><span class="line">free -l ： 显示高低内存的利用率</span><br><span class="line">free -t ： 显示linux的全部内存（如果我们需要每列的总计信息，我们可以在 free 命令后面跟上 -t 选项。这会在字底部额外加入一行显示）</span><br><span class="line">free -s N ： 表示每隔N秒打印一次内存信息，直到用ctrl+c结束</span><br><span class="line">free -c N ： 表示重复打印内存信息N次</span><br><span class="line">free -V ： 显示版本信息</span><br></pre></td></tr></table></figure><h1 id="查看磁盘空间">查看磁盘空间</h1><ol><li><strong>df 查看磁盘使用情况</strong><br><img src="https://img-blog.csdnimg.cn/20210602153116711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Filesystem ： 设备名称，代表该文件系统时哪个分区</span><br><span class="line">1K-blocks ： 总磁盘大小，下面的数字单位是1KB，可利用-h或-m来改变单位大小，也可以用-B来设置</span><br><span class="line">Used ： 已用磁盘大小</span><br><span class="line">Available ： 可用磁盘大小</span><br><span class="line">Use% ： 已用磁盘百分比</span><br><span class="line">Mounted on ： 磁盘挂载的目录，即该磁盘挂载到了哪个目录下面</span><br><span class="line"></span><br><span class="line">-a 或 --all ： 显示所有的文件系统，包括虚拟文件系统</span><br><span class="line">-B 或 --block-size ： 指定单位大小，比如1k，1m等</span><br><span class="line">-h 或 --human-readable ： 以人们易读的GB、MB、KB等格式显示</span><br><span class="line">-H 或 --si ： 和-h参数一样，但是不是以1024，而是1000，即1k=1000，而不是1k=1024</span><br><span class="line">-i 或 --inodes ： 不用硬盘容量，而是以inode的数量来显示</span><br><span class="line">-k ： 以KB的容量显示各文件系统，相当于--block-size=1k</span><br><span class="line">-m ： 以KB的容量显示各文件系统，相当于--block-size=1m</span><br><span class="line">-l ： --local，只显示本地文件系统</span><br><span class="line">--no-sync ： 在统计使用信息之前不调用sync命令(默认)</span><br><span class="line">-sync ： 在统计使用信息之前调用sync命令</span><br><span class="line">-P 或 --portability ： 使用POSIX格式显示，参考示例6</span><br><span class="line">-t 或 --type=TYPE ： 只显示指定类型的文件系统，参考示例7</span><br><span class="line">-T 或 --print-type ： 显示文件系统类型，参考示例8</span><br><span class="line">-x 或 --exclude-type=TYPE ： 不显示指定类型的文件系统</span><br><span class="line">--help ： 显示帮助信息</span><br><span class="line">--version ： 显示版本信息</span><br></pre></td></tr></table></figure><ol start="2"><li>指定一个文件夹，查看该文件夹所在磁盘的使用情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df /home</span><br></pre></td></tr></table></figure><ol start="3"><li>指定一个文件，查看该文件所在磁盘的使用情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df /bin/ls</span><br></pre></td></tr></table></figure><ol start="4"><li>指定多个文件或文件夹，查看所在磁盘的使用情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df /bin/ls /home</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>du 查看文件、目录所占磁盘容量</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [文件或目录名称] （默认情况下，只统计目录的容量大小）</span><br><span class="line">参数：</span><br><span class="line">-a 或 --all ：  列出所有的文件和目录容量大小而不仅仅列出目录容量大小，默认情况只是统计目录的容量大小</span><br><span class="line">-B 或 --block-size=SIZE ： 指定单位大小</span><br><span class="line">-b 或 --bytes ： 以字节为单位列出文件和目录的容量大小</span><br><span class="line">-c 或 --total ： 除了列出文件和目录的容量大小外，列出总的容量大小</span><br><span class="line">-h 或 --human-readable ： 以人们易读的方式(KB,MB,GB)显示容量大小</span><br><span class="line">--si ： 和-h参数类似，但是单位换算时是以1000进行换算，而不是1024</span><br><span class="line">-k ： 和--block-size=1k类似，以KB为单位</span><br><span class="line">-m ： 和--block-size=1m类似，以MB为单位</span><br><span class="line">-s 或 --summarize ： 仅列出总量，而不列出每个目录和文件的大小</span><br><span class="line">-S 或 --separate-dirs ： 和-s参数类似，但是统计时不包含子目录的容量大小</span><br><span class="line">--max-depth=N ： 类似于默认情况的du，但是，递归显示时的递归深度小于等于N。如果--max-depth=0，就相当于-s参数，只统计总量而已。如果--max-depth=1，就相当于du -s 目录/*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Flink &amp; Kafka 完成的流式模块</title>
      <link href="/2021/06/01/flink_7/"/>
      <url>/2021/06/01/flink_7/</url>
      
        <content type="html"><![CDATA[<p><strong>没错，这是基于下面几篇博客完成的功能：</strong><br><a href="https://blog.csdn.net/weixin_44758876/article/details/117447744">Flink基于MapState实时去重</a><br><a href="https://blog.csdn.net/weixin_44758876/article/details/117114785">Flink接收kafka source数据</a><br><a href="https://blog.csdn.net/weixin_44758876/article/details/117448373">Java通过UDP端口发送数据</a><br><strong>我也是在边开发边写博客呀（心累），这篇就是之前说的“flink对接kafka去重加细节优化”的博客，加入了优化部分，解决了kafka丢失数据的问题，当然UDP也会丢少量数据，大概不到千分之一吧，业务不允许的可以通过TCP发送，代码我也会加到下面。<br>等会看到那详细的注释你们就明白我有多细心了（嘿嘿），给个关注我就不心累了-。-</strong><br><strong>不多哔哔了，上代码：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.distinct</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.<span class="type">SocketUDPClient</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.restartstrategy.<span class="type">RestartStrategies</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.&#123;<span class="type">MapState</span>, <span class="type">MapStateDescriptor</span>, <span class="type">StateTtlConfig</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">KeyedProcessFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.runtime.state.filesystem.<span class="type">FsStateBackend</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">CheckpointingMode</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.<span class="type">CheckpointConfig</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.&#123;<span class="type">RichSinkFunction</span>, <span class="type">SinkFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Kafka2flink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="comment">//    开启CheckPointing</span></span><br><span class="line">    env.enableCheckpointing(<span class="number">100000</span>)</span><br><span class="line"><span class="comment">//    设置重启，出现异常重启3次，隔5秒一次（默认固定延迟无限重启）</span></span><br><span class="line">    env.getConfig.setRestartStrategy(<span class="type">RestartStrategies</span>.fixedDelayRestart(<span class="number">2</span>, <span class="type">Time</span>.seconds(<span class="number">2</span>)))</span><br><span class="line"><span class="comment">//    checkpoint最小间隔（确保检查点之间有至少1000 ms的间隔）</span></span><br><span class="line">    env.getCheckpointConfig.setMinPauseBetweenCheckpoints(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//    checkpoint的超时时间（检查点必须在2分钟内完成，否则被丢弃）</span></span><br><span class="line">    env.getCheckpointConfig.setCheckpointTimeout(<span class="number">120000</span>)</span><br><span class="line"><span class="comment">//    同一时间只允许进行一个检查点</span></span><br><span class="line">    env.getCheckpointConfig.setMaxConcurrentCheckpoints(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//    设置statebackend</span></span><br><span class="line">    <span class="keyword">val</span> stateBackend = <span class="keyword">new</span> <span class="type">FsStateBackend</span>(<span class="string">&quot;file:///ssd/flink2kafka/flink-1.12.4/data&quot;</span>)</span><br><span class="line">    env.setStateBackend(stateBackend)</span><br><span class="line"><span class="comment">//    一旦Flink处理程序被cancel后，会保留Checkpoint数据，以便根据实际需要恢复到指定的Checkpoint</span></span><br><span class="line">    env.getCheckpointConfig.enableExternalizedCheckpoints(<span class="type">CheckpointConfig</span>.<span class="type">ExternalizedCheckpointCleanup</span>.<span class="type">RETAIN_ON_CANCELLATION</span>)</span><br><span class="line"><span class="comment">//    设置Checkpoint模式（与kafka整合，设置Checkpoint模式为exactly-once）</span></span><br><span class="line">    env.getCheckpointConfig.setCheckpointingMode(<span class="type">CheckpointingMode</span>.<span class="type">EXACTLY_ONCE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Kafka props</span></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line"><span class="comment">//    指定Kafka的Broker地址</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;10.7.2.20:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Checkpoint成功后，还会向Kafka特殊的topic中写偏移量（此处不建议改为false）</span></span><br><span class="line"><span class="comment">//    设置为false后，则不会向特殊topic中写偏移量</span></span><br><span class="line"><span class="comment">//    KafkaSource.setCommitOffsetsOnCheckpoints(false)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    创建Kafka DataStream        setStartFromGroupOffsets():从上次消费位点开始消费</span></span><br><span class="line">    <span class="keyword">val</span> stream = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties).setStartFromGroupOffsets())</span><br><span class="line"></span><br><span class="line"><span class="comment">//    val stream: DataStream[String] = env.socketTextStream(&quot;10.7.2.20&quot;, 9999)</span></span><br><span class="line">    <span class="keyword">val</span> streamdata = stream.map(x =&gt; &#123;</span><br><span class="line">      (x, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">      .keyBy(_._1)</span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">Deduplicator</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">//    streamdata</span></span><br><span class="line"><span class="comment">//      .print()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    通过TCP端口发送到第三方</span></span><br><span class="line">    streamdata.map(data =&gt; &#123;data + <span class="string">&quot;\n&quot;</span>&#125;).writeToSocket(<span class="string">&quot;10.7.2.21&quot;</span>, <span class="number">6666</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>())</span><br><span class="line"><span class="comment">//    自定义sink 通过UDP端口发送到第三方</span></span><br><span class="line"><span class="comment">//    streamdata.addSink(new udpSink())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">udpSink</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>[<span class="type">String</span>](<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> socketUDPClient: <span class="type">SocketUDPClient</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    socketUDPClient = <span class="keyword">new</span> <span class="type">SocketUDPClient</span>(<span class="string">&quot;10.7.2.21&quot;</span>, <span class="number">6666</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invoke</span></span>(value: <span class="type">String</span>, context: <span class="type">SinkFunction</span>.<span class="type">Context</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    socketUDPClient.send(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    socketUDPClient.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deduplicator</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>[<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>](<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> state: <span class="type">MapState</span>[<span class="type">String</span>, <span class="type">String</span>] = _</span><br><span class="line">  <span class="keyword">val</span> dec = <span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;state&quot;</span>, classOf[<span class="type">String</span>], classOf[<span class="type">String</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ttlConfig = <span class="type">StateTtlConfig</span></span><br><span class="line">      .newBuilder(<span class="type">Time</span>.seconds(<span class="number">3</span>)) <span class="comment">//这是state存活时间10s</span></span><br><span class="line">      .setUpdateType(<span class="type">StateTtlConfig</span>.<span class="type">UpdateType</span>.<span class="type">OnReadAndWrite</span>)<span class="comment">//设置过期时间更新方式</span></span><br><span class="line">      .setStateVisibility(<span class="type">StateTtlConfig</span>.<span class="type">StateVisibility</span>.<span class="type">NeverReturnExpired</span>)<span class="comment">//永远不要返回过期的状态</span></span><br><span class="line"><span class="comment">//      .cleanupInRocksdbCompactFilter(5)//处理完1000个状态查询时候，会启用一次CompactFilter</span></span><br><span class="line">      .build</span><br><span class="line">    dec.enableTimeToLive(ttlConfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> context = getRuntimeContext</span><br><span class="line">    context.getMapState(dec)</span><br><span class="line">    state = context.getMapState(<span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;state&quot;</span>, classOf[<span class="type">String</span>], classOf[<span class="type">String</span>]))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(i: (<span class="type">String</span>, <span class="type">String</span>), context: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>]#<span class="type">Context</span>, collector: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.contains(i._1)) &#123;</span><br><span class="line">      state.put(i._1, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      state.put(i._1, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">      collector.collect(i._1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这是UDP发送的工具类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketUDPClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketUDPClient</span><span class="params">(String ip, <span class="type">int</span> port)</span> <span class="keyword">throws</span> UnknownHostException, SocketException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ip = InetAddress.getByName(ip);</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line"><span class="comment">//        创建一个UDP套接字，与本地任意一个未使用的UDP端口绑定</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"><span class="comment">//        与本地一个固定的UDP端口绑定</span></span><br><span class="line"><span class="comment">//        socket=new DatagramSocket(9000);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String data)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先准备一个待发送的数据报</span></span><br><span class="line">            <span class="type">byte</span>[] outputData=data.getBytes();</span><br><span class="line">            <span class="comment">//构建一个数据报文。</span></span><br><span class="line">            DatagramPacket outputPacket=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(outputData, outputData.length, ip, port);</span><br><span class="line">            <span class="comment">//给EchoUDPServer发送数据报</span></span><br><span class="line">            socket.send(outputPacket);  <span class="comment">//给EchoUDPServer发送数据报</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)</span><br><span class="line">            socket.close();<span class="comment">//释放本地端口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>哦对，还有pom文件（我可真细心）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink2kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.12.4<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- flink连接器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该插件用于将Scala代码编译成class文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 声明绑定到maven的compile阶段 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><br><p><em>喜欢的小伙伴给个关注吧~~~</em></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 通过 UDP 端口发送数据</title>
      <link href="/2021/06/01/java_1/"/>
      <url>/2021/06/01/java_1/</url>
      
        <content type="html"><![CDATA[<p><strong>其实我是因为flink没有封装好的sink，所以自定义了sink来调用这个类。。。。。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketUDPClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketUDPClient</span><span class="params">(String ip, <span class="type">int</span> port)</span> <span class="keyword">throws</span> UnknownHostException, SocketException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ip = InetAddress.getByName(ip);</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line"><span class="comment">//        创建一个UDP套接字，与本地任意一个未使用的UDP端口绑定</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"><span class="comment">//        与本地一个固定的UDP端口绑定</span></span><br><span class="line"><span class="comment">//        socket=new DatagramSocket(9000);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String data)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先准备一个待发送的数据报</span></span><br><span class="line">            <span class="type">byte</span>[] outputData=data.getBytes();</span><br><span class="line">            <span class="comment">//构建一个数据报文。</span></span><br><span class="line">            DatagramPacket outputPacket=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(outputData, outputData.length, ip, port);</span><br><span class="line">            <span class="comment">//给EchoUDPServer发送数据报</span></span><br><span class="line">            socket.send(outputPacket);  <span class="comment">//给EchoUDPServer发送数据报</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)</span><br><span class="line">            socket.close();<span class="comment">//释放本地端口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法变量都是封装好的，直接调用完事</strong></p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 基于 MapState 实时去重</title>
      <link href="/2021/06/01/flink_6/"/>
      <url>/2021/06/01/flink_6/</url>
      
        <content type="html"><![CDATA[<p><strong>我这里的业务背景比较复杂，数据是非结构化的且类型很多，更致命的是数据没有唯一ID字段！！！所以只能基于整条数据去分区去重，本来打算用布隆过滤器来实现，可是布隆过滤器的误判太搞人了，业务不允许，所以还是用MapState来做，这里去掉了flink优化的代码，便于学习和观看，后面我会写一个flink对接kafka去重加细节优化的博客，感兴趣的可以给个关注。</strong><br><img src="https://img-blog.csdnimg.cn/20210427105014204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">flinkMapState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    </span><br><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;10.7.2.20&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="keyword">val</span> streamdata = stream.map(x =&gt; &#123;</span><br><span class="line">      (x, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">      .keyBy(_._1)</span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">Deduplicator</span>())</span><br><span class="line">      </span><br><span class="line">    streamdata</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deduplicator</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>[<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>](<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state: <span class="type">MapState</span>[<span class="type">String</span>, <span class="type">String</span>] = _</span><br><span class="line">  <span class="keyword">val</span> dec = <span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;state&quot;</span>, classOf[<span class="type">String</span>], classOf[<span class="type">String</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> ttlConfig = <span class="type">StateTtlConfig</span></span><br><span class="line">      .newBuilder(<span class="type">Time</span>.seconds(<span class="number">3</span>)) <span class="comment">//这是state存活时间10s</span></span><br><span class="line">      .setUpdateType(<span class="type">StateTtlConfig</span>.<span class="type">UpdateType</span>.<span class="type">OnReadAndWrite</span>)<span class="comment">//设置过期时间更新方式</span></span><br><span class="line">      .setStateVisibility(<span class="type">StateTtlConfig</span>.<span class="type">StateVisibility</span>.<span class="type">NeverReturnExpired</span>)<span class="comment">//永远不要返回过期的状态</span></span><br><span class="line"><span class="comment">//      .cleanupInRocksdbCompactFilter(5)//处理完1000个状态查询时候，会启用一次CompactFilter</span></span><br><span class="line">      .build</span><br><span class="line">    dec.enableTimeToLive(ttlConfig)</span><br><span class="line">    <span class="keyword">val</span> context = getRuntimeContext</span><br><span class="line">    context.getMapState(dec)</span><br><span class="line">    state = context.getMapState(<span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;state&quot;</span>, classOf[<span class="type">String</span>], classOf[<span class="type">String</span>]))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(i: (<span class="type">String</span>, <span class="type">String</span>), context: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>]#<span class="type">Context</span>, collector: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.contains(i._1)) &#123;</span><br><span class="line">      state.put(i._1, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      state.put(i._1, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">      collector.collect(i._1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果图我就不放了，这代码我已经跑了N+1次了，如果你们运行不动的话，，，，，，那就是你们的问题了哈哈</strong></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 提交任务的两种方式（非 flink on yarn）</title>
      <link href="/2021/06/01/flink_5/"/>
      <url>/2021/06/01/flink_5/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h1 id="程序打包">程序打包</h1><ol><li><strong>先在pom里加上插件</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该插件用于将Scala代码编译成class文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 声明绑定到maven的compile阶段 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>按照下面的步骤把程序打包即可</strong><br><img src="https://img-blog.csdnimg.cn/20210529215625732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>到上面的路径下找到自己的包即可</strong><br><img src="https://img-blog.csdnimg.cn/20210529215810563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h1 id="web页面提交">web页面提交</h1><ol><li><strong>到自己的flink web页面，按照下面的步骤依次点击上传自己的程序包</strong><br><img src="https://img-blog.csdnimg.cn/20210529220032675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>再按照下面的步骤提交jar包</strong><br><img src="https://img-blog.csdnimg.cn/20210529222215770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>提交成功之后就会出现下面的页面</strong><br><img src="https://img-blog.csdnimg.cn/20210601165502645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h1 id="命令行提交">命令行提交</h1><p><strong>命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run -m master:8081 -p 4 -c [全类名] [jar包所在路径] --[属性名] 属性值</span><br></pre></td></tr></table></figure><p><strong>命令参数说明：</strong></p><ul><li><strong>-m</strong><ul><li>指定主机名后面的端口为JobManager的 rest 通信端口，而不是 RPC 的端口，RPC通信端口是6123（在提交任务时，是通过 REST 端口号（HTTP端口号），将任务上传到JobManager）</li></ul></li><li><strong>-p</strong><ul><li>指定并行度（即使用几个Task Slots）</li></ul></li><li><strong>-c</strong><ul><li>指定main方法的全类名</li></ul></li><li><strong>-s</strong><ul><li>指定savePoint 的路径（用于任务重启时接上次操作继续进行，恢复数据使用）</li></ul></li><li><strong>–hostname XXX --port XXX</strong><ul><li>传入main方法的参数（以 – 属性名 属性值 的方式）</li></ul></li></ul><p><strong>提交成功之后，web页面会有正在运行的任务：</strong><br><img src="https://img-blog.csdnimg.cn/20210601170904773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><br><p><em>喜欢的小伙伴给个关注吧~~~</em></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之模拟生产环境发送数据到 Kafka</title>
      <link href="/2021/05/31/python_6/"/>
      <url>/2021/05/31/python_6/</url>
      
        <content type="html"><![CDATA[<p><strong>模拟生产环境的速率发送数据到Kafka，仅限于开发环境使用，可以测试平台对数据的吞吐量以及稳定性。</strong><br><strong>KafkaProducer需求下载安装特定库支持，windows开发环境直接cmd打开命令窗口，执行 pip install kafka-python 即可</strong><br>脚本代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个KafkaProducer示例，用于向Kafka投递消息</span></span><br><span class="line">producer = KafkaProducer(</span><br><span class="line">    value_serializer=<span class="keyword">lambda</span> v: json.dumps(v).encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">    bootstrap_servers=[<span class="string">&#x27;10.7.2.20:9092&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment">#读取样例数据</span></span><br><span class="line">files = <span class="built_in">open</span>(<span class="string">&quot;样例数据文件的目录&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">content = files.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line">    index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(content) - <span class="number">1</span>)</span><br><span class="line">    producer.send(<span class="string">&quot;test&quot;</span>, content[index])</span><br><span class="line"></span><br><span class="line">producer.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 在 Linux 上单机部署教程</title>
      <link href="/2021/05/29/flink_4/"/>
      <url>/2021/05/29/flink_4/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>首先需要JDK1.8版本以上的支持，我这里就不放教程了</strong></li><li><strong>先去官网下载flink安装包，官网地址：</strong><br><a href="https://flink.apache.org/zh/downloads.html">https://flink.apache.org/zh/downloads.html</a><br><strong>我这里下载的是flink-1.12.4，scala2.12的版本，不同需求可以下载不同版本，安装步骤都一样</strong></li><li><strong>把包上传到服务器目录下</strong><br><img src="https://img-blog.csdnimg.cn/2021052921251886.png" alt="在这里插入图片描述"></li><li><strong>使用下面的命令解压</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf flink-1.12.4-bin-scala_2.12.tgz</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>然后进入解压后的flink目录下，用下面的命令执行启动脚本</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/start-cluster.sh</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>到这flink就安装完成了，可以通过jps命令查看是否有 TaskManagerRunner 及 StandaloneSessionClusterEntrypoint 这两个进程，有的话就说明启动成功</strong></li><li><strong>flink默认的web访问端口是8081，可以通过浏览器访问flink的 web UI</strong><br><img src="https://img-blog.csdnimg.cn/2021052921335624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode because</title>
      <link href="/2021/05/25/redis_2/"/>
      <url>/2021/05/25/redis_2/</url>
      
        <content type="html"><![CDATA[<p><strong>今天在测试时redis报错：</strong><br>redis.clients.jedis.exceptions.JedisDataException:拒绝redis在保护模式下运行，因为已启用保护模式，未指定绑定地址，未向客户端请求身份验证密码。在这种模式下，只接受来自环回接口的连接。如果您想从外部计算机连接到Redis，您可以采用以下解决方案之一：1）通过从服务器运行的同一主机连接到Redis，只需禁用保护模式，从环回接口发送命令’CONFIG SET protected mode no’，不过，如果你这样做的话，请确保Redis不能从互联网上公开访问。使用CONFIG REWRITE将此更改永久化。2） 或者，您可以通过编辑Redis配置文件，将protectedmode选项设置为no，然后重新启动服务器来禁用protectedmode。3） 如果只是为了测试而手动启动服务器，请使用“-protected mode no”选项重新启动服务器。4） 设置绑定地址或身份验证密码。注意：您只需要执行上述操作之一，服务器就可以开始接受来自外部的连接。</p><p><strong>解决方法：</strong></p><ol><li>修改redis配置文件(redis.conf)</li><li>将protected-mode yes改为protected-mode no<br><img src="https://img-blog.csdnimg.cn/2021052515201035.png" alt="在这里插入图片描述"></li><li>重启redis即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug记录 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6.2.3 安装教程</title>
      <link href="/2021/05/25/redis_1/"/>
      <url>/2021/05/25/redis_1/</url>
      
        <content type="html"><![CDATA[<ol><li>首先在redis官网下载软件包，网址如下：<br><a href="https://redis.io/download">https://redis.io/download</a><br><img src="https://img-blog.csdnimg.cn/20210525112604963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>下载后将包上传到Linux<br><img src="https://img-blog.csdnimg.cn/20210525112816978.png" alt="在这里插入图片描述"></li><li>tar -zxvf redis-6.2.3.tar.gz 解压后并进入解压后的目录<br><img src="https://img-blog.csdnimg.cn/20210525113026292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>使用make命令编译软件<br><img src="https://img-blog.csdnimg.cn/20210525113149934.png" alt="在这里插入图片描述"></li><li>报错是因为缺少部分依赖包<img src="https://img-blog.csdnimg.cn/20210525113341511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>依次执行下面的命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">yum -y  install tcl</span><br><span class="line">yum -y  install kernel-headers</span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line">echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure><ol start="7"><li>清理make</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make distclean</span><br></pre></td></tr></table></figure><ol start="8"><li>再依次执行下面的命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install PREFIX=你想安装的目录</span><br></pre></td></tr></table></figure><ol start="9"><li>然后复制redis.conf到自己的安装目录下</li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf 你的redis安装目录</span><br></pre></td></tr></table></figure><ol start="10"><li>添加环境变量</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#profile文件最后追加：</span><br><span class="line">export REDIS_HOME=你的redis安装目录</span><br><span class="line">export PATH=$PATH:$REDIS_HOME/bin</span><br></pre></td></tr></table></figure><ol start="11"><li>使环境变量生效</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><strong>到这里redis就安装完成了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 发送数据到 Kafka sink</title>
      <link href="/2021/05/21/flink_3/"/>
      <url>/2021/05/21/flink_3/</url>
      
        <content type="html"><![CDATA[<p><strong>前期准备好kafka环境，我这里是1.12.0版本的Flink，Kafka对应版本官方推荐2.4.1，Scala版本2.12，demo里用的是socket文本流做数据源</strong></p><ol><li>在kafka目录下启动zookeeper（我这里用的是kafka自带的）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><ol start="2"><li>启动kafka</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure><ol start="3"><li>开启socket文本流</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lk 9999</span><br></pre></td></tr></table></figure><ol start="4"><li>消费kafka指定topic消息，确认数据是否正常</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server IP:9092 --topic test</span><br></pre></td></tr></table></figure><ol start="5"><li>别忘了添加Kafka连接器依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>上代码</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaProducer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaSink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收socket 文本流</span></span><br><span class="line">    <span class="keyword">val</span> textDstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;开启socket服务器的IP&quot;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">    textDstream.addSink(<span class="keyword">new</span> <span class="type">FlinkKafkaProducer</span>[<span class="type">String</span>](<span class="string">&quot;KafkaIP:9092&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>()))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Kafka sink&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>在开启的socket服务中输入测试数据，查看已开启的Kafka消费者窗口是否有测试数据过来</li></ol><br><p><em>喜欢的小伙伴留下你的足迹吧~~~</em></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 接收 kafka source 数据</title>
      <link href="/2021/05/21/flink_2/"/>
      <url>/2021/05/21/flink_2/</url>
      
        <content type="html"><![CDATA[<p><strong>前期准备好kafka环境，我这里是1.12.0版本的Flink，Kafka对应版本官方推荐2.4.1，Scala版本2.12</strong></p><ol><li>在kafka目录下启动zookeeper（我这里用的是kafka自带的）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><ol start="2"><li>启动kafka</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure><ol start="3"><li>别忘了添加Kafka连接器依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>上代码</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;IP:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;topic名称&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">    stream.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Kafka Source&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>开启生产者控制台打印数据测试</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list IP:9092 -topic test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink：从入门到放弃</title>
      <link href="/2021/05/19/flink_1/"/>
      <url>/2021/05/19/flink_1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Flink简介">一、Flink简介</h1><p><strong>Apache Flink 是一个<font color=red>框架</font>和<font color=red>分布式</font>处理引擎，用于对<font color=red>无界</font>和<font color=red>有界数据流</font>进行<font color=red>状态</font>计算。</strong></p><h2 id="1-Flink组件栈">1. Flink组件栈</h2><p>每一层所包含的组件都提供了特定的抽象，用来服务于上层组件：<br><img src="https://img-blog.csdnimg.cn/20210416153047694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>物理部署层：</strong> Flink 支持本地运行、能在独立集群或者在被 YARN 管理的集群上运行， 也能部署在云上，该层主要涉及Flink的部署模式，目前Flink支持多种部署模式：本地、集群(Standalone、YARN)、云(GCE/EC2)、Kubenetes。Flink能够通过该层能够支持不同平台的部署，用户可以根据需要选择使用对应的部署模式。<br><strong>Runtime核心层：</strong> Runtime层提供了支持Flink计算的全部核心实现，为上层API层提供基础服务，该层主要负责对上层不同接口提供基础服务，也是Flink分布式计算框架的核心实现层，支持分布式Stream作业的执行、JobGraph到ExecutionGraph的映射转换、任务调度等。将DataSteam和DataSet转成统一的可执行的Task Operator，达到在流式引擎下同时处理批量计算和流式计算的目的。<br><strong>API&amp;Libraries层：</strong> Flink 首先支持了 Scala 和 Java 的 API，Python 也正在测试中。DataStream、DataSet、Table、SQL API，作为分布式数据处理框架，Flink同时提供了支撑计算和批计算的接口，两者都提供给用户丰富的数据处理高级API，例如Map、FlatMap操作等，也提供比较低级的Process Function API，用户可以直接操作状态和时间等底层数据。<br><strong>扩展库：</strong> Flink 还包括用于复杂事件处理的CEP，机器学习库FlinkML，图处理库Gelly等。Table 是一种接口化的 SQL 支持，也就是 API 支持(DSL)，而不是文本化的SQL 解析和执行。</p><h2 id="2-Flink基石">2. Flink基石</h2><p><img src="https://img-blog.csdnimg.cn/20210416160638126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>Checkpoint</strong><ul><li>Flink基于Chandy-Lamport算法实现了一个分布式的一致性的快照，从而提供了一致性的语义。</li></ul></li><li><strong>State</strong><ul><li>提供了一致性的语义之后，Flink为了让用户在编程时能够更轻松、更容易地去管理状态，还提供了一套非常简单明了的State API，包括里面的有ValueState、ListState、MapState，近期添加了BroadcastState，使用State API能够自动享受到这种一致性的语义。</li></ul></li><li><strong>Time</strong><ul><li>Flink还实现了Watermark的机制，能够支持基于事件的时间的处理，能够容忍迟到/乱序的数据。</li></ul></li><li><strong>Window</strong><ul><li>流计算中一般在对流数据进行操作之前都会先进行开窗，即基于一个什么样的窗口上做这个计算。Flink提供了开箱即用的各种窗口，比如滑动窗口、滚动窗口、会话窗口以及非常灵活的自定义的窗口。</li></ul></li></ul><h2 id="3-Fink的应用场景">3. Fink的应用场景</h2><h3 id="3-1-Event-driven-Applications【事件驱动】">3.1 Event-driven Applications【事件驱动】</h3><p><strong>事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。</strong> 比较典型的就是以 kafka 为代表的消息队列几乎都是事件驱动型应用。<br>事件驱动型应用是在计算存储分离的传统应用基础上进化而来。<br>在传统架构中，应用需要读写远程事务型数据库。<br>相反，事件驱动型应用是基于<strong>状态化流处理</strong>来完成。在该设计中，数据和计算不会分离，应用只需访问本地(内存或磁盘)即可获取数据。<br>系统容错性的实现依赖于定期向远程持久化存储写入 checkpoint。下图描述了传统应用和事件驱动型应用架构的区别。<br><img src="https://img-blog.csdnimg.cn/20210419161855636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从某种程度上来说，所有的实时的数据处理或者是流式数据处理都应该是属于Data Driven，流计算本质上是Data Driven 计算。应用较多的如风控系统，当风控系统需要处理各种各样复杂的规则时，Data Driven 就会把处理的规则和逻辑写入到Datastream 的API 或者是ProcessFunction 的API 中，然后将逻辑抽象到整个Flink 引擎，当外面的数据流或者是事件进入就会触发相应的规则，这就是Data Driven 的原理。在触发某些规则后，Data Driven 会进行处理或者是进行预警，这些预警会发到下游产生业务通知，这是Data Driven 的应用场景，Data Driven 在应用上更多应用于复杂事件的处理。</p><ul><li>典型实例：<ul><li>欺诈检测(Fraud detection)</li><li>异常检测(Anomaly detection)</li><li>基于规则的告警(Rule-based alerting)</li><li>业务流程监控(Business process monitoring)</li><li>Web应用程序(社交网络)<br><img src="https://img-blog.csdnimg.cn/20210419162232930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="3-2-Data-Analytics-Applications【数据分析】">3.2 Data Analytics Applications【数据分析】</h3><p><strong>数据分析任务需要从原始数据中提取有价值的信息和指标。</strong><br>如下图所示，Apache Flink 同时支持流式及批量分析应用。<br><img src="https://img-blog.csdnimg.cn/20210419162342556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Data Analytics Applications包含<strong>Batch analytics(批处理分析)</strong> 和<strong>Streaming analytics(流处理分析)</strong><br>Batch analytics可以理解为<strong>周期性查询</strong>：Batch Analytics 就是传统意义上使用类似于Map Reduce、Hive、Spark Batch 等，对作业进行分析、处理、生成离线报表。比如Flink应用凌晨从Recorded Events中读取昨天的数据，然后做周期查询运算，最后将数据写入Database或者HDFS，或者直接将数据生成报表供公司上层领导决策使用。<br>Streaming analytics可以理解为<strong>连续性查询</strong>：比如实时展示双十一天猫销售GMV(Gross Merchandise Volume成交总额)，用户下单数据需要实时写入消息队列，Flink 应用源源不断读取数据做实时计算，然后不断的将数据更新至Database或者K-VStore，最后做大屏实时展示。</p><ul><li>典型实例<ul><li>电信网络质量监控</li><li>移动应用中的产品更新及实验评估分析</li><li>消费者技术中的实时数据即席分析</li><li>大规模图分析</li></ul></li></ul><h3 id="3-3-Data-Pipeline-Applications【数据管道】">3.3 Data Pipeline Applications【数据管道】</h3><p>什么是数据管道？<br><strong>提取-转换-加载(ETL)是一种在存储系统之间进行数据转换和迁移的常用方法。</strong><br>ETL 作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库。<br>数据管道和 ETL 作业的用途相似，都可以转换、丰富数据，并将其从某个存储系统移动到另一个。<br>但数据管道是以<strong>持续流</strong>模式运行，而非周期性触发。<br>因此数据管道支持从一个不断生成数据的源头读取记录，并将它们以低延迟移动到终点。<br>例如：数据管道可以用来监控文件系统目录中的新文件，并将其数据写入事件日志；另一个应用可能会将事件流物化到数据库或增量构建和优化查询索引。<br>和周期性 ETL 作业相比，持续数据管道可以明显降低将数据移动到目的端的延迟。<br>此外，由于它能够持续消费和发送数据，因此用途更广，支持用例更多。<br>下图描述了周期性ETL作业和持续数据管道的差异。<br><img src="https://img-blog.csdnimg.cn/20210419162848396.png#pic_center" alt="在这里插入图片描述"><br><strong>Periodic ETL</strong>：比如每天凌晨周期性的启动一个Flink ETL Job，读取传统数据库中的数据，然后做ETL，最后写入数据库和文件系统。<br><strong>Data Pipeline</strong>：比如启动一个Flink 实时应用，数据源(比如数据库、Kafka)中的数据不断的通过Flink Data Pipeline流入或者追加到数据仓库(数据库或者文件系统)，或者Kafka消息队列。<br>Data Pipeline 的核心场景类似于数据搬运并在搬运的过程中进行部分数据清洗或者处理，而整个业务架构图的左边是Periodic ETL，它提供了流式ETL 或者实时ETL，能够订阅消息队列的消息并进行处理，清洗完成后实时写入到下游的Database或File system 中。</p><ul><li>典型实例<ul><li>电子商务中的持续 ETL(实时数仓)<ul><li>当下游要构建实时数仓时，上游则可能需要实时的Stream ETL。这个过程会进行实时清洗或扩展数据，清洗完成后写入到下游的实时数仓的整个链路中，可保证数据查询的时效性，形成实时数据采集、实时数据处理以及下游的实时Query。</li></ul></li><li>电子商务中的实时查询索引构建(搜索引擎推荐)<ul><li>搜索引擎这块以淘宝为例，当卖家上线新商品时，后台会实时产生消息流，该消息流经过Flink 系统时会进行数据的处理、扩展。然后将处理及扩展后的数据生成实时索引，写入到搜索引擎中。这样当淘宝卖家上线新商品时，能在秒级或者分钟级实现搜索引擎的搜索。</li></ul></li></ul></li></ul><h2 id="4-Flink的优点">4. Flink的优点</h2><p><img src="https://img-blog.csdnimg.cn/20210419164216526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>主要优点</strong><ul><li><font color=red>Flink 具备统一的框架处理有界和无界两种数据流的能力</font></li><li><font color=red>部署灵活，Flink 底层支持多种资源调度器</font>，包括Yarn、Kubernetes 等。Flink 自身带的Standalone 的调度器，在部署上也十分灵活</li><li><font color=red>极高的可伸缩性</font>，可伸缩性对于分布式系统十分重要，阿里巴巴双11大屏采用Flink 处理海量数据，使用过程中测得Flink 峰值可达17 亿条/秒。</li><li><font color=red>极致的流式处理性能</font>。Flink 相对于Storm 最大的特点是将状态语义完全抽象到框架中，支持本地状态读取，避免了大量网络IO，可以极大提升状态存取的性能。</li></ul></li><li><strong>其他优点</strong><ul><li><font color=red>同时支持高吞吐、低延迟、高性能</font><ul><li>Flink 是目前开源社区中唯一一套集高吞吐、低延迟、高性能三者于一身的分布式流式数据处理框架</li><li>Spark 只能兼顾高吞吐和高性能特性，无法做到低延迟保障,因为Spark是用批处理来做流处理</li><li>Storm 只能支持低延时和高性能特性，无法满足高吞吐的要求</li></ul></li><li><font color=red>支持事件时间(Event Time)概念</font><ul><li>在流式计算领域中，窗口计算的地位举足轻重，但目前大多数框架窗口计算采用的都是系统时间(Process Time)，也就是事件传输到计算框架处理时，系统主机的当前时间</li><li>Flink 能够支持基于事件时间(Event Time)语义进行窗口计算</li><li>这种基于事件驱动的机制使得事件即使乱序到达甚至延迟到达，流系统也能够计算出精确的结果，保持了事件原本产生时的时序性，尽可能避免网络传输或硬件系统的影响</li></ul></li><li><font color=red>支持有状态计算</font><ul><li>Flink1.4开始支持有状态计算</li><li>所谓状态就是在流式计算过程中将算子的中间结果保存在内存或者文件系统中，等下一个事件进入算子后可以从之前的状态中获取中间结果，计算当前的结果，从而无须每次都基于全部的原始数据来统计结果，极大的提升了系统性能，状态化意味着应用可以维护随着时间推移已经产生的数据聚合</li></ul></li><li><font color=red>支持高度灵活的窗口(Window)操作</font><ul><li>Flink 将窗口划分为基于 Time 、Count 、Session、以及Data-Driven等类型的窗口操作，窗口可以用灵活的触发条件定制化来达到对复杂的流传输模式的支持，用户可以定义不同的窗口触发机制来满足不同的需求</li></ul></li><li><font color=red>基于轻量级分布式快照(Snapshot/Checkpoints)的容错机制</font><ul><li>Flink 能够分布运行在上千个节点上，通过基于分布式快照技术的Checkpoints，将执行过程中的状态信息进行持久化存储，一旦任务出现异常停止，Flink 能够从 Checkpoints 中进行任务的自动恢复，以确保数据处理过程中的一致性</li><li>Flink 的容错能力是轻量级的，允许系统保持高并发，同时在相同时间内提供强一致性保证</li></ul></li><li><font color=red>基于 JVM 实现的独立的内存管理</font><ul><li>Flink 实现了自身管理内存的机制，通过使用散列，索引，缓存和排序有效地进行内存管理，通过序列化/反序列化机制将所有的数据对象转换成二进制在内存中存储，降低数据存储大小的同时，更加有效的利用空间。使其独立于 Java 的默认垃圾收集器，尽可能减少 JVM GC 对系统的影响</li></ul></li><li><font color=red>SavePoints 保存点</font><ul><li>对于 7 * 24 小时运行的流式应用，数据源源不断的流入，在一段时间内应用的终止有可能导致数据的丢失或者计算结果的不准确（比如集群版本的升级，停机运维操作等）</li><li>Flink 通过SavePoints 技术将任务执行的快照保存在存储介质上，当任务重启的时候，可以从事先保存的 SavePoints 恢复原有的计算状态，使得任务继续按照停机之前的状态运行</li><li>Flink 保存点提供了一个状态化的版本机制，使得能以无丢失状态和最短停机时间的方式更新应用或者回退历史数据</li></ul></li><li><font color=red>灵活的部署方式，支持大规模集群</font><ul><li>Flink 被设计成能用上千个点在大规模集群上运行</li><li>除了支持独立集群部署外，Flink 还支持 YARN 和Mesos 方式部署</li></ul></li><li><font color=red>Flink 的程序内在是并行和分布式的</font><ul><li>数据流可以被分区成 stream partitions，operators 被划分为operator subtasks，这些 subtasks 在不同的机器或容器中分不同的线程独立运行</li><li>operator subtasks 的数量就是operator的并行计算数，不同的 operator 阶段可能有不同的并行数</li></ul></li><li><font color=red>丰富的库</font><ul><li>Flink 拥有丰富的库来进行机器学习，图形处理，关系数据处理等</li></ul></li></ul></li></ul><h2 id="5-流处理-批处理">5. 流处理&amp;批处理</h2><p><img src="https://img-blog.csdnimg.cn/20210419171037746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>Batch Analytics 批量计算：</strong> 统一收集数据-&gt;存储到DB-&gt;对数据进行批量处理，就是传统意义上使用类似于 Map Reduce、Hive、Spark Batch 等，对作业进行分析、处理、生成离线报表</li><li><strong>Streaming Analytics 流式计算：</strong> 顾名思义，就是对数据流进行处理，如使用流式分析引擎如 Storm，Flink 实时处理分析数据，应用较多的场景如实时大屏、实时报表</li><li><strong>主要区别</strong><ul><li>与批量计算那样慢慢积累数据不同，流式计算立刻计算，数据持续流动，计算完之后就丢弃</li><li>批量计算是维护一张表，对表进行实施各种计算逻辑。流式计算相反，是必须先定义好计算逻辑，提交到流式计算系统，这个计算作业逻辑在整个运行期间是不可更改的</li><li>计算结果上，批量计算对全部数据进行计算后传输结果，流式计算是每次小批量计算后，结果可以立刻实时化展现</li></ul></li></ul><h2 id="6-流批统一">6. 流批统一</h2><p>在大数据处理领域，批处理任务与流处理任务一般被认为是两种不同的任务，一个大数据框架一般会被设计为只能处理其中一种任务：</p><ul><li>MapReduce只支持批处理任务</li><li>Storm只支持流处理任务</li><li>Spark Streaming采用micro-batch架构，本质上还是基于Spark批处理对流式数据进行处理</li><li>Flink通过灵活的执行引擎，能够同时支持批处理任务与流处理任务<br><img src="https://img-blog.csdnimg.cn/20210419171537108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><p>在执行引擎这一层，流处理系统与批处理系统最大不同在于节点间的<strong>数据传输方式</strong>：</p><ul><li>对于一个流处理系统，其节点间数据传输的标准模型是：当一条数据被处理完成后，序列化到缓存中，然后立刻通过网络传输到下一个节点，由下一个节点继续处理</li><li>对于一个批处理系统，其节点间数据传输的标准模型是：当一条数据被处理完成后，序列化到缓存中，并不会立刻通过网络传输到下一个节点，当缓存写满，就持久化到本地硬盘上，当所有数据都被处理完成后，才开始将处理后的数据通过网络传输到下一个节点</li></ul><p>这两种数据传输模式是两个极端，对应的是流处理系统对低延迟的要求和批处理系统对高吞吐量的要求。<br><strong>Flink的执行引擎采用了一种十分灵活的方式，同时支持了这两种数据传输模型：</strong></p><ul><li>Flink以固定的缓存块为单位进行网络数据传输，用户可以通过设置缓存块超时值指定缓存块的传输时机</li><li>如果缓存块的超时值为0，则Flink的数据传输方式类似上面所提到流处理系统的标准模型，此时系统可以获得最低的处理延迟</li><li>如果缓存块的超时值为无限大/-1，则Flink的数据传输方式类似上文所提到批处理系统的标准模型，此时系统可以获得最高的吞吐量</li><li>同时缓存块的超时值也可以设置为0到无限大之间的任意值。缓存块的超时阈值越小，则Flink流处理执行引擎的数据处理延迟越低，但吞吐量也会降低，反之亦然。通过调整缓存块的超时阈值，用户可根据需求灵活地权衡系统延迟和吞吐量</li></ul><p>默认情况下，流中的元素并不会一个一个的在网络中传输，而是缓存起来伺机一起发送(默认为32KB，通过taskmanager.memory.segment-size设置),这样可以避免导致频繁的网络传输,提高吞吐量，但如果数据源输入不够快的话会导致后续的数据处理延迟，所以可以使用env.setBufferTimeout(默认100ms)，来为缓存填入设置一个最大等待时间。等待时间到了之后，即使缓存还未填满，缓存中的数据也会自动发送</p><ul><li>timeoutMillis &gt; 0 表示最长等待 timeoutMillis 时间，就会flush</li><li>timeoutMillis = 0 表示每条数据都会触发 flush，直接将数据发送到下游，相当于没有Buffer了(避免设置为0，可能导致性能下降)</li><li>timeoutMillis = -1 表示只有等到 buffer满了或 CheckPoint的时候，才会flush。相当于取消了 timeout 策略</li></ul><p><strong>Flink以缓存块为单位进行网络数据传输,用户可以设置缓存块超时时间和缓存块大小来控制缓冲块传输时机,从而控制Flink的延迟性和吞吐量</strong></p><h1 id="二、Flink安装部署">二、Flink安装部署</h1><h2 id="1-Local本地模式">1. Local本地模式</h2><h3 id="1-1-原理">1.1 原理</h3><p><img src="https://img-blog.csdnimg.cn/20210420091847434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>Flink程序由JobClient进行提交</li><li>JobClient将作业提交给JobManager</li><li>JobManager负责协调资源分配和作业执行。资源分配完成后，任务将提交给相应的TaskManager</li><li>TaskManager启动一个线程以开始执行。TaskManager会向JobManager报告状态更改,如开始执行，正在进行或已完成</li><li>作业执行完成后，结果将发送回客户端（JobClient）</li></ol><h3 id="1-2-操作">1.2 操作</h3><ol><li><p>下载安装包<br><a href="https://archive.apache.org/dist/flink/">https://archive.apache.org/dist/flink/</a></p></li><li><p>上传flink-1.12.0-bin-scala_2.12.tgz到指定目录</p></li><li><p>解压</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf flink-1.12.0-bin-scala_2.12.tgz</span><br></pre></td></tr></table></figure></li><li><p>如果出现权限问题，需要修改权限</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R root:root /data/flink-1.12.0</span><br></pre></td></tr></table></figure></li><li><p>改名或创建软链接</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv flink-1.12.0 flink</span><br><span class="line">ln -s /data/flink-1.12.0 /data/flink</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-测试">1.3 测试</h3><ol><li><p>准备文件/data/words.txt</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/words.txt</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello me you her</span><br><span class="line">hello me you</span><br><span class="line">hello me</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li><li><p>启动Flink本地集群</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>使用jps可以查看到下面两个进程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- TaskManagerRunner</span><br><span class="line">- StandaloneSessionClusterEntrypoint</span><br></pre></td></tr></table></figure></li><li><p>访问Flink的Web UI<br><a href="http://xn--IP-im8ckc:8081/#/overview">http://IP地址:8081/#/overview</a><br><img src="https://img-blog.csdnimg.cn/20210420093806515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>slot在Flink里面可以认为是资源组，Flink是通过将任务分成子任务并且将这些子任务分配到slot来并行执行程序</p></li><li><p>执行官方示例</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run /data/flink/examples/batch/WordCount.jar --input /data/words.txt --output /data/out</span><br></pre></td></tr></table></figure></li><li><p>停止Flink</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/start-scala-shell.sh local</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-Standalone独立集群模式">2. Standalone独立集群模式</h2><h3 id="2-1-原理">2.1 原理</h3><p><img src="https://img-blog.csdnimg.cn/20210420094339920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>client客户端提交任务给JobManager</li><li>JobManager负责申请任务运行所需要的资源并管理任务和资源</li><li>JobManager分发任务给TaskManager执行</li><li>TaskManager定期向JobManager汇报状态</li></ol><h3 id="2-2-操作">2.2 操作</h3><ol><li>集群规划：</li></ol><ul><li>服务器: flink1(Master + Slave): JobManager + TaskManager</li><li>服务器: flink2(Slave): TaskManager</li><li>服务器: flink3(Slave): TaskManager</li></ul><ol start="2"><li><p>修改flink-conf.yaml</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/flink-conf.yaml</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jobmanager.rpc.address: node1</span><br><span class="line">taskmanager.numberOfTaskSlots: 2</span><br><span class="line">web.submit.enable: true</span><br><span class="line"></span><br><span class="line">#历史服务器</span><br><span class="line">jobmanager.archive.fs.dir: hdfs://flink1:8020/flink/completed-jobs/</span><br><span class="line">historyserver.web.address: flink1</span><br><span class="line">historyserver.web.port: 8082</span><br><span class="line">historyserver.archive.fs.dir: hdfs://flink1:8020/flink/completed-jobs/</span><br></pre></td></tr></table></figure></li><li><p>修改masters</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/masters</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flink1:8081</span><br></pre></td></tr></table></figure></li><li><p>修改slaves</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/workers</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flink1</span><br><span class="line">flink2</span><br><span class="line">flink3</span><br></pre></td></tr></table></figure></li><li><p>添加HADOOP_CONF_DIR环境变量</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_CONF_DIR=/data/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure></li><li><p>分发</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r /data/flink flink2:/data/flink</span><br><span class="line">scp -r /data/flink flink3:/data/flink</span><br><span class="line">scp  /etc/profile flink2:/etc/profile</span><br><span class="line">scp  /etc/profile flink3:/etc/profile</span><br></pre></td></tr></table></figure></li><li><p>source</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-测试">2.3 测试</h3><ol><li><p>启动集群，在flink1上执行如下命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure><p>或者单独启动</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/jobmanager.sh ((start|start-foreground) cluster)|stop|stop-all</span><br><span class="line">/data/flink/bin/taskmanager.sh start|start-foreground|stop|stop-all</span><br></pre></td></tr></table></figure></li><li><p>启动历史服务器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/historyserver.sh start</span><br></pre></td></tr></table></figure></li><li><p>访问Flink UI界面或使用jps查看<br><a href="http://flink1:8081/#/overview">http://flink1:8081/#/overview</a><br><a href="http://flink1:8082/#/overview">http://flink1:8082/#/overview</a><br>TaskManager界面：可以查看到当前Flink集群中有多少个TaskManager，每个TaskManager的slots、内存、CPU Core是多少<br><img src="https://img-blog.csdnimg.cn/20210420100505412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>执行官方测试案例</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run  /data/flink/examples/batch/WordCount.jar --input hdfs://flink1:8020/wordcount/input/words.txt --output hdfs://flink1:8020/wordcount/output/result.txt  --parallelism 2</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210420100734236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>查看历史日志<br><a href="http://flink1:50070/explorer.html#/flink/completed-jobs">http://flink1:50070/explorer.html#/flink/completed-jobs</a><br><a href="http://flink1:8082/#/overview">http://flink1:8082/#/overview</a></p></li><li><p>停止Flink集群</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/stop-cluster.sh</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-Standalone-HA高可用集群模式">3. Standalone-HA高可用集群模式</h2><h3 id="3-1-原理">3.1 原理</h3><p><img src="https://img-blog.csdnimg.cn/20210420101230750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从之前的架构中可以很明显的发现 JobManager 有明显的单点问题(SPOF，single point of failure)。JobManager 肩负着任务调度以及资源分配，一旦 JobManager 出现意外，其后果可想而知。<br>在 Zookeeper 的帮助下，一个 Standalone的Flink集群会同时有多个活着的 JobManager，其中只有一个处于工作状态，其他处于 Standby 状态。当工作中的 JobManager 失去连接后(如宕机或 Crash)，Zookeeper 会从 Standby 中选一个新的 JobManager 来接管 Flink 集群。</p><h3 id="3-2-操作">3.2 操作</h3><ol><li>集群规划</li></ol><ul><li>服务器: flink1(Master + Slave): JobManager + TaskManager</li><li>服务器: flink2(Master + Slave): JobManager + TaskManager</li><li>服务器: flink3(Slave): TaskManager</li></ul><ol start="2"><li><p>启动ZooKeeper</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh status</span><br><span class="line">zkServer.sh stop</span><br><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure></li><li><p>启动HDFS</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/hadoop/sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>停止Flink集群</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/stop-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>修改flink-conf.yaml</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/flink-conf.yaml</span><br></pre></td></tr></table></figure><p>增加如下内容</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#开启HA，使用文件系统作为快照存储</span><br><span class="line">state.backend: filesystem</span><br><span class="line">#启用检查点，可以将快照保存到HDFS</span><br><span class="line">state.backend.fs.checkpointdir: hdfs://flink1:8020/flink-checkpoints</span><br><span class="line">#使用zookeeper搭建高可用</span><br><span class="line">high-availability: zookeeper</span><br><span class="line"># 存储JobManager的元数据到HDFS</span><br><span class="line">high-availability.storageDir: hdfs://flink1:8020/flink/ha/</span><br><span class="line"># 配置ZK集群地址</span><br><span class="line">high-availability.zookeeper.quorum: flink1:2181,flink2:2181,flink3:2181</span><br></pre></td></tr></table></figure></li><li><p>修改masters</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/masters</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flink1:8081</span><br><span class="line">flink2:8081</span><br></pre></td></tr></table></figure></li><li><p>同步</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r /data/flink/conf/flink-conf.yaml flink2:/data/flink/conf/</span><br><span class="line">scp -r /data/flink/conf/flink-conf.yaml flink3:/data/flink/conf/</span><br><span class="line">scp -r /data/flink/conf/masters flink2:/data/flink/conf/</span><br><span class="line">scp -r /data/flink/conf/masters flink3:/data/flink/conf/</span><br></pre></td></tr></table></figure></li><li><p>修改flink2上的flink-conf.yaml</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/flink-conf.yaml</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobmanager.rpc.address: flink2</span><br></pre></td></tr></table></figure></li><li><p>重新启动Flink集群,flink1上执行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/stop-cluster.sh</span><br><span class="line">/data/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>使用jps命令查看<br>发现没有Flink相关进程被启动</p></li><li><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /data/flink/log/flink-root-standalonesession-0-node1.log</span><br></pre></td></tr></table></figure><p>发现如下错误<img src="https://img-blog.csdnimg.cn/20210420103648464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因为在Flink1.8版本后,Flink官方提供的安装包里没有整合HDFS的jar</p></li><li><p>下载jar包并在Flink的lib目录下放入该jar包并分发使Flink能够支持对Hadoop的操作<br><a href="https://flink.apache.org/downloads.html">https://flink.apache.org/downloads.html</a><br><img src="https://img-blog.csdnimg.cn/20210420103809956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>依次放入lib目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/flink/lib</span><br></pre></td></tr></table></figure></li><li><p>重新启动Flink集群，flink1上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>使用jps命令查看,发现三台机器服务已启动</p></li></ol><h3 id="3-3-测试">3.3 测试</h3><ol><li><p>访问WebUI<br><a href="http://flink1:8081/#/job-manager/config">http://flink1:8081/#/job-manager/config</a><br><a href="http://flink2:8081/#/job-manager/config">http://flink2:8081/#/job-manager/config</a></p></li><li><p>执行wordcount</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run  /data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure></li><li><p>kill掉其中一个master</p></li><li><p>重新执行wc,还是可以正常执行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run  /data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure></li><li><p>停止集群</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/stop-cluster.sh</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-Flink-On-Yarn模式">4. Flink On Yarn模式</h2><h3 id="4-1-原理">4.1 原理</h3><p>在实际开发中，使用Flink时，更多的使用方式是Flink On Yarn模式，原因如下：</p><ul><li>Yarn的资源可以按需使用，提高集群的资源利用率</li><li>Yarn的任务有优先级，根据优先级运行作业</li><li>基于Yarn调度系统，能够自动化地处理各个角色的 Failover(容错)<ul><li>JobManager 进程和 TaskManager 进程都由 Yarn NodeManager 监控</li><li>如果 JobManager 进程异常退出，则 Yarn ResourceManager 会重新调度 JobManager 到其他机器</li><li>如果 TaskManager 进程异常退出，JobManager 会收到消息并重新向 Yarn ResourceManager 申请资源，重新启动 TaskManager</li></ul></li></ul><h4 id="4-1-1-Flink如何和Yarn进行交互">4.1.1 Flink如何和Yarn进行交互</h4><p><img src="https://img-blog.csdnimg.cn/20210420105320520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420105324842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>Client上传jar包和配置文件到HDFS集群上</li><li>Client向Yarn ResourceManager提交任务并申请资源</li><li>ResourceManager分配Container资源并启动ApplicationMaster,然后AppMaster加载Flink的Jar包和配置构建环境,启动JobManager<br>JobManager和ApplicationMaster运行在同一个container上。<br>一旦他们被成功启动，AppMaster就知道JobManager的地址(AM它自己所在的机器)。<br>它就会为TaskManager生成一个新的Flink配置文件(他们就可以连接到JobManager)。<br>这个配置文件也被上传到HDFS上。<br>此外，AppMaster容器也提供了Flink的web服务接口。<br>YARN所分配的所有端口都是临时端口，这允许用户并行执行多个Flink</li><li>ApplicationMaster向ResourceManager申请工作资源,NodeManager加载Flink的Jar包和配置构建环境并启动TaskManager</li><li>TaskManager启动后向JobManager发送心跳包，并等待JobManager向其分配任务</li></ol><h4 id="4-1-2-两种方式">4.1.2 两种方式</h4><h5 id="4-1-2-1-Session模式">4.1.2.1 Session模式</h5><p><img src="https://img-blog.csdnimg.cn/20210420105510454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420105514949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>特点：</strong> 需要事先申请资源，启动JobManager和TaskManger<br><strong>优点：</strong> 不需要每次递交作业申请资源，而是使用已经申请好的资源，从而提高执行效率<br><strong>缺点：</strong> 作业执行完成以后，资源不会被释放，因此一直会占用系统资源<br><strong>应用场景：</strong> 适合作业递交比较频繁的场景，小作业比较多的场景</p><h5 id="4-1-2-2-Per-Job模式">4.1.2.2 Per-Job模式</h5><p><img src="https://img-blog.csdnimg.cn/20210420105630609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420105634918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>特点：</strong> 每次递交作业都需要申请一次资源<br><strong>优点：</strong> 作业运行完成，资源会立刻被释放，不会一直占用系统资源<br><strong>缺点：</strong> 每次递交作业都需要申请资源，会影响执行效率，因为申请资源需要消耗时间<br><strong>应用场景：</strong> 适合作业比较少的场景、大作业的场景</p><h3 id="4-2-操作">4.2 操作</h3><ol><li><p>关闭yarn的内存检查</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/hadoop/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure><p>添加：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 关闭yarn内存检查 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>说明:<br>是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true。<br>在这里面我们需要关闭，因为对于flink使用yarn模式下，很容易内存超标，这个时候yarn会自动杀掉job</p></li><li><p>同步</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /data/hadoop/etc/hadoop/yarn-site.xml flink2:/data/hadoop/etc/hadoop/yarn-site.xml</span><br><span class="line">scp -r /data/hadoop/etc/hadoop/yarn-site.xml flink3:/data/hadoop/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure></li><li><p>重启yarn</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/hadoop/sbin/stop-yarn.sh</span><br><span class="line">/data/hadoop/sbin/start-yarn.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-3-测试">4.3 测试</h3><h4 id="4-3-1-Session模式">4.3.1 Session模式</h4><ol><li><p>在yarn上启动一个Flink会话，flink1上执行以下命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/yarn-session.sh -n 2 -tm 800 -s 1 -d</span><br></pre></td></tr></table></figure><p>说明：申请2个CPU、1600M内存<br>-n 表示申请2个容器，这里指的就是多少个taskmanager<br>-tm 表示每个TaskManager的内存大小<br>-s 表示每个TaskManager的slots数量<br>-d 表示以后台程序方式运行</p></li><li><p>查看UI界面<br><a href="http://flink1:8088/cluster">http://flink1:8088/cluster</a><br><img src="https://img-blog.csdnimg.cn/20210420114840343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>使用flink run提交任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run  /data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p>运行完之后可以继续运行其他的小任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run /data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure></li><li><p>通过上方的ApplicationMaster可以进入Flink的管理界面<br><img src="https://img-blog.csdnimg.cn/20210420115043539.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021042011504793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>关闭yarn-session</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -kill application_1599402747874_0001</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202104201151345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/.yarn-properties-root</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-3-2-Per-Job分离模式">4.3.2 Per-Job分离模式</h4><ol><li><p>直接提交job</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run -m yarn-cluster -yjm 1024 -ytm 1024 </span><br><span class="line">/data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p>-m  jobmanager的地址<br>-yjm 1024 指定jobmanager的内存信息<br>-ytm 1024 指定taskmanager的内存信息</p></li><li><p>查看UI界面<br><a href="http://flink1:8088/cluster">http://flink1:8088/cluster</a><br><img src="https://img-blog.csdnimg.cn/20210420115506284.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420115515915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>注意<br>在之前版本中如果使用的是flink on yarn方式，想切换回standalone模式的话，如果报错需要删除：【/tmp/.yarn-properties-root】</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/.yarn-properties-root</span><br></pre></td></tr></table></figure><p>因为默认查找当前yarn集群中已有的yarn-session信息中的jobmanager</p></li></ol><h1 id="三、Flink入门案例">三、Flink入门案例</h1><h2 id="1-前置说明">1. 前置说明</h2><h3 id="1-1-API">1.1 API</h3><p>Flink提供了多个层次的API供开发者使用，越往上抽象程度越高，使用起来越方便；越往下越底层，使用起来难度越大<br><img src="https://img-blog.csdnimg.cn/20210427103102655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427103110578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><font color=red><strong>注：</strong></font>在Flink1.12时支持流批一体，DataSet API已经不推荐使用了，后续都会优先使用DataStream流式API，既支持无界数据处理/流处理，也支持有界数据处理/批处理</p><h3 id="1-2-编程模型">1.2 编程模型</h3><p>Flink 应用程序结构主要包含三部分,Source/Transformation/Sink,如下图所示<br><img src="https://img-blog.csdnimg.cn/20210427103511706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427103521568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-准备工作">2. 准备工作</h2><h3 id="2-1-pom文件">2.1 pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink_study_42<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定仓库位置，依次为aliyun、apache和cloudera仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>apache<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.apache.org/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-scala-bridge_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-java-bridge_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- flink执行计划,这是1.9版本之前的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- blink执行计划,1.11+默认的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner-blink_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;flink-cep_2.12&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- flink连接器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-sql-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-jdbc_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-csv<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">           &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">           &lt;artifactId&gt;flink-connector-filesystem_2.12&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">           &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">       &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;flink-jdbc_2.12&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">              &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">              &lt;artifactId&gt;flink-parquet_2.12&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">              &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">         &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.avro&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;avro&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;1.9.2&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.parquet&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;parquet-avro&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;1.10.0&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bahir<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-redis_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-runtime_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-hive_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-metastore<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-shaded-hadoop-2-uber<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5-10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;version&gt;8.0.20&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 高性能异步组件：Vertx--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-jdbc-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-redis-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 参考：https://blog.csdn.net/f641385712/article/details/84109098--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;4.4&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;libfb303&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;0.9.3&lt;/version&gt;</span></span><br><span class="line"><span class="comment">            &lt;type&gt;pom&lt;/type&gt;</span></span><br><span class="line"><span class="comment">            &lt;scope&gt;provided&lt;/scope&gt;</span></span><br><span class="line"><span class="comment">         &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">           &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">           &lt;artifactId&gt;guava&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">           &lt;version&gt;28.2-jre&lt;/version&gt;</span></span><br><span class="line"><span class="comment">       &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 编译插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--&lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt;--&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">useFile</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useFile</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disableXmlReport</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disableXmlReport</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Test.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Suite.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 打包插件(会包含所有依赖) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                                        zip -d learn_spark.jar META-INF/*.RSA META-INF/*.DSA META-INF/*.SF --&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.SF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.DSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.RSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="comment">&lt;!-- 设置jar包的入口类(可选) --&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span><span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-log4j-properties">2.2 log4j.properties</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=WARN, console</span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=%d&#123;HH:mm:ss,SSS&#125; %-5p %-60c %x - %m%n</span><br></pre></td></tr></table></figure><h2 id="3-Flink实现WordCount">3. Flink实现WordCount</h2><h3 id="3-1-编码步骤">3.1 编码步骤</h3><ol><li>准备环境-env</li><li>准备数据-source</li><li>处理数据-transformation</li><li>输出结果-sink</li><li>触发执行-execute</li></ol><p>其中创建环境可以使用下面三种方式</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getExecutionEnvironment() <span class="comment">//推荐使用</span></span><br><span class="line">createLocalEnvironment()</span><br><span class="line">createRemoteEnvironment(<span class="type">String</span> host, int port, <span class="type">String</span>... jarFiles)</span><br></pre></td></tr></table></figure><h3 id="3-2-代码实现">3.2 代码实现</h3><p><img src="https://img-blog.csdnimg.cn/20210427105014204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="3-2-1-批处理wordcount">3.2.1 批处理wordcount</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建执行环境</span></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取数据</span></span><br><span class="line"><span class="keyword">val</span> inputPath = <span class="string">&quot;D:\\Projects\\BigData\\TestWC1\\src\\main\\resources\\hello.txt&quot;</span> <span class="keyword">val</span> inputDS: <span class="type">DataSet</span>[<span class="type">String</span>] = env.readTextFile(inputPath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分词之后，对单词进行groupby 分组，然后用sum 进行聚合</span></span><br><span class="line"><span class="keyword">val</span> wordCountDS: <span class="type">AggregateDataSet</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = inputDS.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_, <span class="number">1</span>)).groupBy(<span class="number">0</span>).sum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印输出</span></span><br><span class="line">wordCountDS.print()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-流处理wordcount">3.2.2 流处理wordcount</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从外部命令中获取参数</span></span><br><span class="line"><span class="keyword">val</span> params: <span class="type">ParameterTool</span> = <span class="type">ParameterTool</span>.fromArgs(args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> host: <span class="type">String</span> = params.get(<span class="string">&quot;host&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> port: <span class="type">Int</span> = params.getInt(<span class="string">&quot;port&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建流处理环境</span></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收socket 文本流</span></span><br><span class="line"><span class="keyword">val</span> textDstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMap 和Map 需要引用的隐式转换</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = textDstream.flatMap(_.split(<span class="string">&quot;\\s&quot;</span>)).filter(_.nonEmpty).map((_, <span class="number">1</span>)).keyBy(<span class="number">0</span>).sum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dataStream.print().setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动executor，执行任务</span></span><br><span class="line">env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Flink原理">四、Flink原理</h1><h2 id="1-角色分工">1. 角色分工</h2><p>在实际生产中，Flink 都是以集群在运行，在运行的过程中包含了两类进程：</p><ul><li><strong>JobManager</strong><ul><li>它扮演的是集群管理者的角色，负责调度任务、协调 checkpoints、协调故障恢复、收集 Job 的状态信息，并管理 Flink 集群中的从节点 TaskManager</li></ul></li><li><strong>TaskManager</strong><ul><li>实际负责执行计算的 Worker，在其上执行 Flink Job 的一组 Task；TaskManager 还是所在节点的管理员，它负责把该节点上的服务器信息比如内存、磁盘、任务运行情况等向 JobManager 汇报</li></ul></li><li><strong>Client</strong><ul><li>用户在提交编写好的 Flink 工程时，会先创建一个客户端再进行提交，这个客户端就是 Client<br><img src="https://img-blog.csdnimg.cn/20210427112143315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427112153791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul></li></ul><h2 id="2-执行流程">2. 执行流程</h2><h3 id="2-1-Standalone版">2.1 Standalone版</h3><p><img src="https://img-blog.csdnimg.cn/20210427112250878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-On-Yarn版">2.2 On Yarn版</h3><p><img src="https://img-blog.csdnimg.cn/20210427112316946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>Client向HDFS上传Flink的Jar包和配置</li><li>Client向Yarn ResourceManager提交任务并申请资源</li><li>ResourceManager分配Container资源并启动ApplicationMaster,然后AppMaster加载Flink的Jar包和配置构建环境,启动JobManager</li><li>ApplicationMaster向ResourceManager申请工作资源,NodeManager加载Flink的Jar包和配置构建环境并启动TaskManager</li><li>TaskManager启动后向JobManager发送心跳包，并等待JobManager向其分配任务</li></ol><h2 id="3-Flink-Streaming-Dataflow">3. Flink Streaming Dataflow</h2><h3 id="3-1-Dataflow、Operator、Partition、SubTask、Parallelism">3.1 Dataflow、Operator、Partition、SubTask、Parallelism</h3><ul><li>Dataflow<ul><li>Flink程序在执行的时候会被映射成一个数据流模型</li></ul></li><li>Operator<ul><li>数据流模型中的每一个操作被称作Operator,Operator分为:Source/Transform/Sink</li></ul></li><li>Partition<ul><li>数据流模型是分布式的和并行的,执行中会形成1~n个分区</li></ul></li><li>Subtask<ul><li>多个分区任务可以并行,每一个都是独立运行在一个线程中的,也就是一个Subtask子任</li></ul></li><li>Parallelism<ul><li>并行度,就是可以同时真正执行的子任务数/分区数<br><img src="https://img-blog.csdnimg.cn/20210427113503606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="3-2-Operator传递模式">3.2 Operator传递模式</h3><p>数据在两个operator(算子)之间传递的时候有两种模式：</p><ul><li>One to One模式<ul><li>两个operator用此模式传递的时候，会保持数据的分区数和数据的排序；如上图中的Source1到Map1，它就保留的Source的分区特性，以及分区元素处理的有序性（类似于Spark中的窄依赖）</li></ul></li><li>Redistributing模式<ul><li>这种模式会改变数据的分区数；每个一个operator subtask会根据选择transformation把数据发送到不同的目标subtasks,比如keyBy()会通过hashcode重新分区,broadcast()和rebalance()方法会随机重新分区（类似于Spark中的宽依赖）</li></ul></li></ul><h3 id="3-3-Operator-Chain">3.3 Operator Chain</h3><p><img src="https://img-blog.csdnimg.cn/20210427113734406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>客户端在提交任务的时候会对Operator进行优化操作，能进行合并的Operator会被合并为一个Operator，合并后的Operator称为Operator chain，实际上就是一个执行链，每个执行链会在TaskManager上一个独立的线程中执行（就是SubTask）</p><h3 id="3-4-TaskSlot-And-Slot-Sharing">3.4 TaskSlot And Slot Sharing</h3><p><img src="https://img-blog.csdnimg.cn/20210427113853330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>任务槽（TaskSlot）<ul><li>每个TaskManager是一个JVM的进程, 为了控制一个TaskManager(worker)能接收多少个task，Flink通过Task Slot来进行控制<br>TaskSlot数量是用来限制一个TaskManager工作进程中可以同时运行多少个工作线程，TaskSlot 是一个 TaskManager 中的最小资源分配单位，一个 TaskManager 中有多少个 TaskSlot 就意味着能支持多少并发的Task处理</li></ul></li></ul><p>Flink将进程的内存进行了划分到多个slot中，内存被划分到不同的slot之后可以获得如下好处:</p><ul><li>TaskManager最多能同时并发执行的子任务数是可以通过TaskSolt数量来控制的</li><li>TaskSolt有独占的内存空间，这样在一个TaskManager中可以运行多个不同的作业，作业之间不受影响</li></ul><p><img src="https://img-blog.csdnimg.cn/20210427114058889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>槽共享（Slot Sharing）<ul><li>Flink允许子任务共享插槽，即使它们是不同任务(阶段)的子任务(subTask)，只要它们来自同一个作业<br>比如图左下角中的map和keyBy和sink 在一个 TaskSlot 里执行以达到资源共享的目的</li></ul></li></ul><p>允许插槽共享有两个主要好处：</p><ul><li>资源分配更加公平，如果有比较空闲的slot可以将更多的任务分配给它</li><li>有了任务槽共享，可以提高资源的利用率</li></ul><p><font color=red><strong>注：</strong></font><br>slot是静态的概念，是指taskmanager具有的并发执行能力<br>parallelism是动态的概念，是指程序运行时实际使用的并发能力</p><h2 id="4-Flink运行时的组件">4. Flink运行时的组件</h2><p>Flink运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作：</p><ul><li>作业管理器（JobManager）<ul><li>分配任务、调度checkpoint做快照</li></ul></li><li>任务管理器（TaskManager）<ul><li>主要干活的</li></ul></li><li>资源管理器（ResourceManager）<ul><li>管理分配资源</li></ul></li><li>分发器（Dispatcher）<ul><li>方便递交任务的接口，WebUI</li></ul></li></ul><p>因为Flink是用Java和Scala实现的，所以所有组件都会运行在Java虚拟机上。每个组件的职责如下：</p><ul><li><strong>作业管理器（JobManager）</strong><ul><li>控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager 所控制执行</li><li>JobManager 会先接收到要执行的应用程序，这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的JAR包</li><li>JobManager 会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务</li><li>JobManager 会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调</li></ul></li><li><strong>任务管理器（TaskManager）</strong><ul><li>Flink中的工作进程。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量</li><li>启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用。JobManager就可以向插槽分配任务（tasks）来执行了</li><li>在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据</li></ul></li><li><strong>资源管理器（ResourceManager）</strong><ul><li>主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger 插槽是Flink中定义的处理资源单元</li><li>Flink为不同的环境和资源管理工具提供了不同资源管理器，比如YARN、Mesos、K8s，以及standalone部署</li><li>当JobManager申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给JobManager。如果ResourceManager没有足够的插槽来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器</li></ul></li><li><strong>分发器（Dispatcher）</strong><ul><li>可以跨作业运行，它为应用提交提供了REST接口</li><li>当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager</li><li>Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息</li><li>Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式</li></ul></li></ul><h2 id="5-Flink执行图（ExecutionGraph）">5. Flink执行图（ExecutionGraph）</h2><p>由Flink程序直接映射成的数据流图是StreamGraph，也被称为逻辑流图，因为它们表示的是计算逻辑的高级视图。为了执行一个流处理程序，Flink需要将逻辑流图转换为物理数据流图（也叫执行图），详细说明程序的执行方式。<br>Flink 中的执行图可以分成四层：<font color=red>StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图</font><br><img src="https://img-blog.csdnimg.cn/2021042711515181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>原理介绍<ul><li>Flink执行executor会自动根据程序代码生成DAG数据流图</li><li>Flink 中的执行图可以分成四层：StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图<ul><li><strong>StreamGraph：</strong> 是根据用户通过 Stream API 编写的代码生成的最初的图。表示程序的拓扑结构</li><li><strong>JobGraph：</strong> StreamGraph经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。主要的优化为，将多个符合条件的节点 chain 在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗</li><li><strong>ExecutionGraph：</strong> JobManager 根据 JobGraph 生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构</li><li><strong>物理执行图：</strong> JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构</li></ul></li></ul></li><li>简单理解<ul><li><strong>StreamGraph：</strong> 最初的程序执行逻辑流程，也就是算子之间的前后顺序（在Client上生成）</li><li><strong>JobGraph：</strong> 将OneToOne的Operator合并为OperatorChain（在Client上生成）</li><li><strong>ExecutionGraph：</strong> 将JobGraph根据代码中设置的并行度和请求的资源进行并行化规划!（在JobManager上生成）</li><li><strong>物理执行图：</strong> 将ExecutionGraph的并行计划,落实到具体的TaskManager上，将具体的SubTask落实到具体的TaskSlot内进行运行</li></ul></li></ul><h1 id="五、流批一体API">五、流批一体API</h1><h2 id="1-DataStream-API">1. DataStream API</h2><ul><li>DataStream API 支持批执行模式<ul><li>Flink 的核心 API 最初是针对特定的场景设计的，尽管 Table API / SQL 针对流处理和批处理已经实现了统一的 API，但当用户使用较底层的 API 时，仍然需要在批处理（DataSet API）和流处理（DataStream API）这两种不同的 API 之间进行选择。鉴于批处理是流处理的一种特例，将这两种 API 合并成统一的 API，有一些非常明显的好处，比如：<ul><li>可复用性：作业可以在流和批这两种执行模式之间自由地切换，而无需重写任何代码。因此，用户可以复用同一个作业，来处理实时数据和历史数据</li><li>维护简单：统一的 API 意味着流和批可以共用同一组 connector，维护同一套代码，并能够轻松地实现流批混合执行，例如 backfilling 之类的场景</li></ul></li></ul></li></ul><p>考虑到这些优点，社区已朝着流批统一的 DataStream API 迈出了第一步：支持高效的批处理（FLIP-134）。从长远来看，这意味着 DataSet API 将被弃用（FLIP-131），其功能将被包含在 DataStream API 和 Table API / SQL 中。</p><h2 id="2-Source">2. Source</h2><h3 id="2-1-预定义Source">2.1 预定义Source</h3><h4 id="2-1-1-基于集合的Source">2.1.1 基于集合的Source</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义样例类，传感器id，时间戳，温度</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span>(<span class="params">id: <span class="type">String</span>, timestamp: <span class="type">Long</span>, temperature: <span class="type">Double</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sensor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="keyword">val</span> stream1: <span class="type">DataStream</span>[<span class="type">String</span>] = env</span><br><span class="line">.fromCollection(<span class="type">List</span>(</span><br><span class="line"><span class="type">SensorReading</span>(<span class="string">&quot;sensor_1&quot;</span>, <span class="number">1547718199</span>, <span class="number">35.8</span>),</span><br><span class="line"><span class="type">SensorReading</span>(<span class="string">&quot;sensor_6&quot;</span>, <span class="number">1547718201</span>, <span class="number">15.4</span>),</span><br><span class="line"><span class="type">SensorReading</span>(<span class="string">&quot;sensor_7&quot;</span>, <span class="number">1547718202</span>, <span class="number">6.7</span>),</span><br><span class="line"><span class="type">SensorReading</span>(<span class="string">&quot;sensor_10&quot;</span>, <span class="number">1547718205</span>, <span class="number">38.1</span>)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">stream1.print(<span class="string">&quot;stream1:&quot;</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">env.execute()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-基于文件的Source">2.1.2 基于文件的Source</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream2: <span class="type">DataStream</span>[<span class="type">String</span>] = env.readTextFile(<span class="string">&quot;FILE_PATH&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-3-基于Socket的Source">2.1.3 基于Socket的Source</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从外部命令中获取参数</span></span><br><span class="line"><span class="keyword">val</span> params: <span class="type">ParameterTool</span> = <span class="type">ParameterTool</span>.fromArgs(args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> host: <span class="type">String</span> = params.get(<span class="string">&quot;host&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> port: <span class="type">Int</span> = params.getInt(<span class="string">&quot;port&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建流处理环境</span></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收socket 文本流</span></span><br><span class="line"><span class="keyword">val</span> textDstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(host, port)</span><br><span class="line"></span><br><span class="line">textDstream.print().setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动executor，执行任务</span></span><br><span class="line">env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-Kafka-Source">2.1.4 Kafka Source</h4><p>需要引入Kafka连接器的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka-0.11</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.11_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建流处理环境</span></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> stream = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">stream.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动executor，执行任务</span></span><br><span class="line">env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-自定义Source">2.2 自定义Source</h3><p>除了以上的 source 数据来源， 我们还可以自定义 source。需要做的， 只是传入一个 SourceFunction 就可以。具体调用如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream = env.addSource( <span class="keyword">new</span> <span class="type">MySensorSource</span>() )</span><br></pre></td></tr></table></figure><p>我们希望可以随机生成传感器数据， MySensorSource 具体的代码实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySensorSource</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">SensorReading</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag: 表示数据源是否还在正常运行</span></span><br><span class="line"><span class="keyword">var</span> running: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">running = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个随机数发生器</span></span><br><span class="line"><span class="keyword">val</span> rand = <span class="keyword">new</span> <span class="type">Random</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curTemp = <span class="number">1.</span>to(<span class="number">10</span>).map(</span><br><span class="line">i =&gt; ( <span class="string">&quot;sensor_&quot;</span> + i, <span class="number">65</span> + rand.nextGaussian() * <span class="number">20</span> )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(running)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新温度值</span></span><br><span class="line">curTemp = curTemp.map(</span><br><span class="line">t =&gt; (t._1, t._2 + rand.nextGaussian() )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间戳</span></span><br><span class="line"><span class="keyword">val</span> curTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">curTemp.foreach(</span><br><span class="line">t =&gt; ctx.collect(<span class="type">SensorReading</span>(t._1, curTime, t._2))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span>.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Transformation">3. Transformation</h2><p><img src="https://img-blog.csdnimg.cn/20210427154434759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427154440564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>整体来说，流式数据上的操作可以分为四类：</p><ol><li>第一类是对于单条记录的操作，比如筛除掉不符合要求的记录（Filter 操作），或者将每条记录都做一个转换（Map 操作）</li><li>第二类是对多条记录的操作。比如说统计一个小时内的订单总成交量，就需要将一个小时内的所有订单记录的成交量加到一起。为了支持这种类型的操作，就得通过 Window 将需要的记录关联到一起进行处理</li><li>第三类是对多个流进行操作并转换为单个流。例如，多个流可以通过 Union、Join 或 Connect 等操作合到一起。这些操作合并的逻辑不同，但是它们最终都会产生了一个新的统一的流，从而可以进行一些跨流的操作</li><li>DataStream 还支持与合并对称的拆分操作，即把一个流按一定规则拆分为多个流（Split 操作），每个流是之前流的一个子集，这样我们就可以对不同的流作不同的处理</li></ol><h3 id="3-1-map">3.1 map</h3><p><strong>map:</strong> 将函数作用在集合中的每一个元素上,并返回作用后的结果<br><img src="https://img-blog.csdnimg.cn/20210427154625112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamMap = stream.map &#123; x =&gt; x * <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-flatMap">3.2 flatMap</h3><p><strong>flatMap:</strong> 将集合中的每个元素变成一个或多个元素,并返回扁平化之后的结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamFlatMap = stream.flatMap&#123;</span><br><span class="line">x =&gt; x.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flatMap 的函数签名：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>,<span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> ⇒ <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatMap(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))(i =&gt; <span class="type">List</span>(i,i))</span><br></pre></td></tr></table></figure><p>结果是 List(1,1,2,2,3,3)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">&quot;a b&quot;</span>, <span class="string">&quot;c d&quot;</span>).flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br></pre></td></tr></table></figure><p>结果是 List(a, b, c, d)</p><h3 id="3-3-filter">3.3 filter</h3><p><strong>filter:</strong> 按照指定的条件对集合中的元素进行过滤,过滤出返回true/符合条件的元素<br><img src="https://img-blog.csdnimg.cn/20210427155213297.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamFilter = stream.filter&#123;</span><br><span class="line">x =&gt; x == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-keyBy">3.4 keyBy</h3><p><strong>DataStream → KeyedStream：</strong> 逻辑地将一个流拆分成不相交的分区，每个分区包含具有相同 key 的元素，在内部以 hash 的形式实现的。<br><img src="https://img-blog.csdnimg.cn/20210427155521872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong><font color=red>注：</font></strong> 流处理中没有groupBy,而是keyBy</p><h3 id="3-5-滚动聚合算子（Rolling-Aggregation）">3.5 滚动聚合算子（Rolling Aggregation）</h3><p>这些算子可以针对 KeyedStream 的每一个支流做聚合：</p><ul><li>sum()</li><li>min()</li><li>max()</li><li>minBy()</li><li>maxBy()</li></ul><h3 id="3-6-Reduce">3.6 Reduce</h3><p><strong>KeyedStream → DataStream：</strong> 一个分组数据流的聚合操作，合并当前的元素 和上次聚合的结果，产生一个新的值，返回的流中包含每一次聚合的结果，而不是 只返回最后一次聚合的最终结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream2 = env.readTextFile(<span class="string">&quot;YOUR_PATH\\sensor.txt&quot;</span>)</span><br><span class="line">.map( data =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125;)</span><br><span class="line">.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">.reduce( (x, y) =&gt; <span class="type">SensorReading</span>(x.id, x.timestamp + <span class="number">1</span>, y.temperature) )</span><br></pre></td></tr></table></figure><h3 id="3-7-合并-拆分">3.7 合并&amp;拆分</h3><h4 id="3-7-1-Split-和-Select">3.7.1 Split 和 Select</h4><p><strong>Split：</strong> 根据某些特征把一个 DataStream 拆分成两个或者 多个 DataStream（<strong>DataStream → SplitStream</strong>）<br><img src="https://img-blog.csdnimg.cn/20210427160847349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Select：</strong> 从一个 SplitStream 中获取一个或者多个DataStream（<strong>SplitStream→DataStream</strong>）<br><img src="https://img-blog.csdnimg.cn/20210427160943799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>需求：</strong> 传感器数据按照温度高低（以 30 度为界），拆分成两个流</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> splitStream = stream2</span><br><span class="line">.split( sensorData =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (sensorData.temperature &gt; <span class="number">30</span>) <span class="type">Seq</span>(<span class="string">&quot;high&quot;</span>) <span class="keyword">else</span> <span class="type">Seq</span>(<span class="string">&quot;low&quot;</span>)</span><br><span class="line">&#125; )</span><br><span class="line"><span class="keyword">val</span> high = splitStream.select(<span class="string">&quot;high&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> low = splitStream.select(<span class="string">&quot;low&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> all = splitStream.select(<span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="3-7-2-Connect-和-CoMap">3.7.2 Connect 和 CoMap</h4><p><strong>Connect：</strong> 连接两个保持他们类型的数据流， 两个数据流被 Connect 之后， 只是被放在了一个同一个流中， 内部依然保持各自的数据和形式不发生任何变化， 两个流相互独立（<strong>DataStream,DataStream → ConnectedStreams</strong>）<br><img src="https://img-blog.csdnimg.cn/20210427161344411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>CoMap,CoFlatMap：</strong> 作用于 ConnectedStreams 上， 功能与 map 和 flatMap 一样， 对ConnectedStreams 中的每一个 Stream 分别进行 map 和 flatMap 处理（<strong>ConnectedStreams → DataStream</strong>）<br><img src="https://img-blog.csdnimg.cn/20210427162551975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> warning = high.map( sensorData =&gt; (sensorData.id, sensorData.temperature) )</span><br><span class="line"><span class="keyword">val</span> connected = warning.connect(low)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> coMap = connected.map(</span><br><span class="line">warningData =&gt; (warningData._1, warningData._2, <span class="string">&quot;warning&quot;</span>),</span><br><span class="line">lowData =&gt; (lowData.id, <span class="string">&quot;healthy&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="3-7-3-Union">3.7.3 Union</h4><p><strong>DataStream → DataStream：</strong> 对两个或者两个以上的 DataStream 进行 union 操 作，产生一个包含所有 DataStream 元素的新 DataStream<br><img src="https://img-blog.csdnimg.cn/20210427162915472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并以后打印 </span></span><br><span class="line"><span class="keyword">val</span> unionStream: <span class="type">DataStream</span>[<span class="type">StartUpLog</span>] = appStoreStream.union(otherStream) unionStream.print(<span class="string">&quot;union:::&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>Connect 与 Union 区别：</strong></p><ol><li>Union 之前两个流的类型必须是一样，Connect 可以不一样，在之后的 coMap 中再去调整成为一样的</li><li>Connect 只能操作两个流，Union 可以操作多个</li></ol><h3 id="3-8-分区">3.8 分区</h3><h4 id="3-8-1-rebalance重平衡分区">3.8.1 rebalance重平衡分区</h4><p>类似于Spark中的repartition,但是功能更强大,可以直接解决数据倾斜<br>Flink也有数据倾斜的时候，比如当前有数据量大概10亿条数据需要处理，在处理过程中可能会发生如图所示的状况，出现了数据倾斜，其他3台机器执行完毕也要等待机器1执行完毕后才算整体将任务完成：<br><img src="https://img-blog.csdnimg.cn/20210427163401911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以在实际的工作中，出现这种情况比较好的解决方案就是rebalance（内部使用round robin方法将数据均匀打散）<br><img src="https://img-blog.csdnimg.cn/20210427163434122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="3-8-2-其他分区">3.8.2 其他分区</h4><p><img src="https://img-blog.csdnimg.cn/20210427164148326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>recale分区：</strong> 基于上下游Operator的并行度，将记录以循环的方式输出到下游Operator的每个实例<br><strong>举例：</strong> 上游并行度是2，下游是4，则上游一个并行度以循环的方式将记录输出到下游的两个并行度上;上游另一个并行度以循环的方式将记录输出到下游另两个并行度上。若上游并行度是4，下游并行度是2，则上游两个并行度将记录输出到下游一个并行度上；上游另两个并行度将记录输出到下游另一个并行度上。</p><h3 id="3-9-支持的数据类型">3.9 支持的数据类型</h3><p>Flink 流应用程序处理的是以数据对象表示的事件流。所以在 Flink 内部， 我们需要能够处理这些对象。它们需要被序列化和反序列化， 以便通过网络传送它们； 或者从状态后端、检查点和保存点读取它们。为了有效地做到这一点，Flink 需要明确知道应用程序所处理的数据类型。Flink 使用类型信息的概念来表示数据类型，并为每个数据类型生成特定的序列化器、反序列化器和比较器。<br>Flink 还具有一个类型提取系统，该系统分析函数的输入和返回类型，以自动获取类型信息，从而获得序列化器和反序列化器。但是，在某些情况下，例如 lambda 函数或泛型类型， 需要显式地提供类型信息， 才能使应用程序正常工作或提高其性能。</p><h4 id="3-9-1-基础数据类型">3.9.1 基础数据类型</h4><p>Flink 支持所有的 Java 和 Scala 基础数据类型， Int, Double, Long, String, …</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.fromElements(<span class="number">1</span>L, <span class="number">2</span>L, <span class="number">3</span>L, <span class="number">4</span>L)</span><br><span class="line">numbers.map( n =&gt; n + <span class="number">1</span> )</span><br></pre></td></tr></table></figure><h4 id="3-9-2-Java-和Scala-元组（Tuples）">3.9.2 Java 和Scala 元组（Tuples）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> persons: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Integer</span>)] = env</span><br><span class="line">.fromElements( (<span class="string">&quot;Adam&quot;</span>, <span class="number">17</span>), (<span class="string">&quot;Sarah&quot;</span>, <span class="number">23</span>) ) </span><br><span class="line">persons.filter(p =&gt; p._2 &gt; <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h4 id="3-9-3-Scala-样例类（case-classes）">3.9.3 Scala 样例类（case classes）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> persons: <span class="type">DataStream</span>[<span class="type">Person</span>] = env.</span><br><span class="line">fromElements( <span class="type">Person</span>(<span class="string">&quot;Adam&quot;</span>, <span class="number">17</span>), <span class="type">Person</span>(<span class="string">&quot;Sarah&quot;</span>, <span class="number">23</span>) )</span><br><span class="line">persons.filter(p =&gt; p.age &gt; <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h4 id="3-9-4-Java-简单对象（POJOs）">3.9.4 Java 简单对象（POJOs）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">DataStream&lt;Person&gt; persons = env.fromElements(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alex&quot;</span>, <span class="number">42</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Wendy&quot;</span>, <span class="number">23</span>));</span><br></pre></td></tr></table></figure><h4 id="3-9-5-其它（Arrays-Lists-Maps-Enums-等等）">3.9.5 其它（Arrays, Lists, Maps, Enums, 等等）</h4><p>Flink 对 Java 和 Scala 中的一些特殊目的的类型也都是支持的，比如 Java 的 ArrayList，HashMap，Enum 等等。</p><h2 id="4-Sink">4. Sink</h2><p>Flink 没有类似于 spark 中 foreach 方法， 让用户进行迭代的操作。虽有对外的输出操作都要利用 Sink 完成。最后通过类似如下方式完成整个任务最终输出操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.addSink(<span class="keyword">new</span> <span class="type">MySink</span>(xxxx))</span><br></pre></td></tr></table></figure><p>官方提供了一部分的框架的 sink。除此以外， 需要用户自定义实现 sink</p><h3 id="4-1-Kafka">4.1 Kafka</h3><ol><li>pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka-0.11</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.11_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>主函数中添加sink</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> union = high.union(low).map(_.temperature.toString)</span><br><span class="line"></span><br><span class="line">union.addSink(<span class="keyword">new</span> <span class="type">FlinkKafkaProducer011</span>[<span class="type">String</span>](<span class="string">&quot;localhost:9092&quot;</span>,<span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>()))</span><br></pre></td></tr></table></figure><h3 id="4-2-Redis">4.2 Redis</h3><ol><li>pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.apache.bahir/flink-connector-redis</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bahir<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-redis_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义一个 redis 的 mapper 类， 用于定义保存到 redis 时调用的命令</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRedisMapper</span> <span class="keyword">extends</span> <span class="title">RedisMapper</span>[<span class="type">SensorReading</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCommandDescription</span></span>: <span class="type">RedisCommandDescription</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">RedisCommandDescription</span>(<span class="type">RedisCommand</span>.<span class="type">HSET</span>, <span class="string">&quot;sensor_temperature&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getValueFromData</span></span>(t: <span class="type">SensorReading</span>): <span class="type">String</span> = t.temperature.toString</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getKeyFromData</span></span>(t: <span class="type">SensorReading</span>): <span class="type">String</span> = t.id</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在主函数中调用</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">FlinkJedisPoolConfig</span>.<span class="type">Builder</span>().setHost(<span class="string">&quot;localhost&quot;</span>).setPort(<span class="number">6379</span>).build() </span><br><span class="line">dataStream.addSink( <span class="keyword">new</span> <span class="type">RedisSink</span>[<span class="type">SensorReading</span>](conf, <span class="keyword">new</span> <span class="type">MyRedisMapper</span>) )</span><br></pre></td></tr></table></figure><h3 id="4-3-Elasticsearch">4.3 Elasticsearch</h3><ol><li>pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch6_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在主函数中调用</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> httpHosts = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">HttpHost</span>]()</span><br><span class="line">httpHosts.add(<span class="keyword">new</span> <span class="type">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> esSinkBuilder = <span class="keyword">new</span> <span class="type">ElasticsearchSink</span>.<span class="type">Builder</span>[<span class="type">SensorReading</span>]( httpHosts,<span class="keyword">new</span> <span class="type">ElasticsearchSinkFunction</span>[<span class="type">SensorReading</span>] &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(t: <span class="type">SensorReading</span>, runtimeContext: <span class="type">RuntimeContext</span>, requestIndexer: <span class="type">RequestIndexer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;saving data: &quot;</span> + t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> json = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]() json.put(<span class="string">&quot;data&quot;</span>, t.toString)</span><br><span class="line"><span class="keyword">val</span> indexRequest = <span class="type">Requests</span>.indexRequest().index(<span class="string">&quot;sensor&quot;</span>).`<span class="class"><span class="keyword">type</span>`(<span class="params">&quot;readingData&quot;</span>).<span class="title">source</span>(<span class="params">json</span>)</span></span><br><span class="line">requestIndexer.add(indexRequest)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;saved successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line">dataStream.addSink( esSinkBuilder.build() )</span><br></pre></td></tr></table></figure><h3 id="4-4-JDBC自定义sink">4.4 JDBC自定义sink</h3><ol><li>pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加 MyJdbcSink</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJdbcSink</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>[<span class="type">SensorReading</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> conn: <span class="type">Connection</span> = _</span><br><span class="line"><span class="keyword">var</span> insertStmt: <span class="type">PreparedStatement</span> = _</span><br><span class="line"><span class="keyword">var</span> updateStmt: <span class="type">PreparedStatement</span> = _</span><br><span class="line"></span><br><span class="line"><span class="comment">// open 主要是创建连接</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>.open(parameters)</span><br><span class="line"></span><br><span class="line">conn = <span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">insertStmt = conn.prepareStatement(<span class="string">&quot;INSERT INTO temperatures (sensor, temp) VALUES (?, ?)&quot;</span>)</span><br><span class="line">updateStmt = conn.prepareStatement(<span class="string">&quot;UPDATE temperatures SET temp = ? WHERE sensor = ?&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用连接，执行sql</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invoke</span></span>(value: <span class="type">SensorReading</span>, context: <span class="type">SinkFunction</span>.<span class="type">Context</span>[_]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">updateStmt.setDouble(<span class="number">1</span>, value.temperature)</span><br><span class="line">updateStmt.setString(<span class="number">2</span>, value.id)</span><br><span class="line"></span><br><span class="line">updateStmt.execute()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (updateStmt.getUpdateCount == <span class="number">0</span>) &#123;</span><br><span class="line">insertStmt.setString(<span class="number">1</span>, value.id)</span><br><span class="line">insertStmt.setDouble(<span class="number">2</span>, value.temperature)</span><br><span class="line">insertStmt.execute()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">insertStmt.close()</span><br><span class="line">updateStmt.close()</span><br><span class="line">conn.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 main 方法中增加</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataStream.addSink(<span class="keyword">new</span> <span class="type">MyJdbcSink</span>())</span><br></pre></td></tr></table></figure><h1 id="六、Flink中的Window">六、Flink中的Window</h1><h2 id="1-Window概述">1. Window概述</h2><ol><li>简介<br>streaming 流式计算是一种被设计用于处理无限数据集的数据处理引擎，而无限数据集是指一种不断增长的本质上无限的数据集， 而 window 是一种<strong>切割无限数据为有限块进行处理</strong>的手段。<br>Window 是无限数据流处理的核心，可以将一个无限的 stream 拆分成有限大小的” buckets” 桶， 我们可以在这些桶上做计算操作。</li><li>为什么需要Window？<br>在流处理应用中，数据是连续不断的，有时我们需要做一些聚合类的处理，例如：在过去的1分钟内有多少用户点击了我们的网页。<br>在这种情况下，我们必须定义一个窗口(window)，用来收集最近1分钟内的数据，并对这个窗口内的数据进行计算。</li></ol><h2 id="2-Window的分类">2. Window的分类</h2><h3 id="2-1-按照time和count分类">2.1 按照time和count分类</h3><p><strong>time-window</strong>:时间窗口，根据时间划分窗口,如:每xx分钟统计最近xx分钟的数据。<br><strong>count-window</strong>:数量窗口，根据数量划分窗口,如:每xx个数据统计最近xx个数据。<br><img src="https://img-blog.csdnimg.cn/20210514102329841.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-按照side和size分类">2.2 按照side和size分类</h3><p>窗口有两个重要的属性: 窗口大小size和滑动间隔slide,根据它们的大小关系可分为：<br><img src="https://img-blog.csdnimg.cn/20210514102446708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>tumbling-window</strong>:滚动窗口，size=slide,如:每隔10s统计最近10s的数据<br><strong><font color=red>特点</font></strong>：时间对齐，窗口长度固定，没有重叠<br><strong><font color=red>适用场景</font></strong>：适合做 BI 统计等（做每个时间段的聚合计算）<br><img src="https://img-blog.csdnimg.cn/20210514102627862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>sliding-window</strong>:滑动窗口，size&gt;slide,如:每隔5s统计最近10s的数据<br><strong><font color=red>特点</font></strong>：时间对齐，窗口长度固定，可以有重叠<br><strong><font color=red>适用场景</font></strong>：对最近一个时间段内的统计（求某接口最近 5min 的失败率来决定是 否要报警）<br><img src="https://img-blog.csdnimg.cn/2021051410403539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>session-windows</strong>：会话窗口，size=slide,如:每隔10s统计最近10s的数据<br><strong><font color=red>特点</font></strong>：时间无对齐<br>session 窗口分配器通过 session 活动来对元素进行分组，session 窗口跟滚动窗 口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况，相反，当它 在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关 闭。一个 session 窗口通过一个 session 间隔来配置，这个 session 间隔定义了非活跃 周期的长度，当这个非活跃周期产生，那么当前的 session 将关闭并且后续的元素将 被分配到新的 session 窗口中去</p><p><strong><font color=red>注意</font></strong>：当size&lt;slide的时候,如每隔15s统计最近10s的数据,那么中间5s的数据会丢失,所有开发中不用</p><h3 id="2-3-总结">2.3 总结</h3><p>按照上面窗口的分类方式进行组合,可以得出如下的窗口:</p><ol><li>基于时间的滚动窗口tumbling-time-window——用的较多</li><li>基于时间的滑动窗口sliding-time-window——用的较多</li><li>基于数量的滚动窗口tumbling-count-window——用的较少</li><li>基于数量的滑动窗口sliding-count-window——用的较少</li></ol><p><strong><font color=red>注意</font></strong>：Flink还支持一个特殊的窗口:Session会话窗口,需要设置一个会话超时时间,如30s,则表示30s内没有数据到来,则触发上个窗口的计算</p><h2 id="3-Window-API">3. Window API</h2><h3 id="3-1-TimeWindow">3.1 TimeWindow</h3><p>TimeWindow 是将指定时间范围内的所有数据组成一个 window， 一次对一个window 里面的所有数据进行计算。</p><h4 id="3-1-1-滚动窗口">3.1.1 滚动窗口</h4><p>Flink 默认的时间窗口根据 Processing Time 进行窗口的划分，将 Flink 获取到的数据根据进入 Flink 的时间划分到不同的窗口中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow = dataStream</span><br><span class="line">.map(r =&gt; (r.id, r.temperature))</span><br><span class="line">.keyBy(_._1)</span><br><span class="line">.timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>))</span><br><span class="line">.reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</span><br></pre></td></tr></table></figure><p>时间间隔可以通过 <strong>Time.milliseconds(x)</strong>，<strong>Time.seconds(x)</strong>，<strong>Time.minutes(x)</strong> 等其中的一个来指定。</p><h4 id="3-1-2-滑动窗口">3.1.2 滑动窗口</h4><p>滑动窗口和滚动窗口的函数名是完全一致的， 只是在传参数时需要传入两个参数， 一个是 window_size， 一个是 sliding_size。</p><ul><li>下面代码中的 sliding_size 设置为了 5s，也就是说，每 5s 就计算输出结果一次， 每一次计算的 window 范围是 15s 内的所有元素：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = dataStream</span><br><span class="line">.map(r =&gt; (r.id, r.temperature))</span><br><span class="line">.keyBy(_._1)</span><br><span class="line">.timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>), <span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">.reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// .window(SlidingEventTimeWindows.of(Time.seconds(15),Time.sec onds(5))</span></span><br></pre></td></tr></table></figure><p>时间间隔可以通过 <strong>Time.milliseconds(x)</strong>，<strong>Time.seconds(x)</strong>，<strong>Time.minutes(x)</strong> 等其中的一个来指定。</p><h3 id="3-2-CountWindow">3.2 CountWindow</h3><p>CountWindow 根据窗口中相同 key 元素的数量来触发执行， 执行时只计算元素数量达到窗口大小的 key 对应的结果。<br><strong><font color=red>注：</font></strong> CountWindow 的 window_size 指的是相同 Key 的元素的个数，不是输入的所有元素的总数。</p><h4 id="3-2-1-滚动窗口">3.2.1 滚动窗口</h4><p>默认的 CountWindow 是一个滚动窗口，只需要指定窗口大小即可，当元素数量达到窗口大小时， 就会触发窗口的执行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = dataStream</span><br><span class="line">.map(r =&gt; (r.id, r.temperature))</span><br><span class="line">.keyBy(_._1)</span><br><span class="line">.countWindow(<span class="number">5</span>)</span><br><span class="line">.reduce((r1, r2) =&gt; (r1._1, r1._2.max(r2._2)))</span><br></pre></td></tr></table></figure><h4 id="3-2-2-滑动窗口">3.2.2 滑动窗口</h4><p>滑动窗口和滚动窗口的函数名是完全一致的， 只是在传参数时需要传入两个参数， 一个是 window_size， 一个是 sliding_size。</p><ul><li>下面代码中的 sliding_size 设置为了 2， 也就是说， 每收到两个相同 key 的数据就计算一次， 每一次计算的 window 范围是 10 个元素：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> keyedStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = dataStream.map(r =&gt; (r.id,r.temperature)).keyBy(<span class="number">0</span>)</span><br><span class="line"><span class="comment">//每当某一个key 的个数达到2 的时候,触发计算，计算最近该key 最近10 个元素的内容</span></span><br><span class="line"><span class="keyword">val</span> windowedStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">GlobalWindow</span>] = keyedStream.countWindow(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> sumDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = windowedStream.sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="3-3-window-function">3.3 window function</h3><p>window function 定义了要对窗口中收集的数据做的计算操作，主要可以分为两类：</p><ul><li>增量聚合函数（ incremental aggregation functions）<ul><li>每条数据到来就进行计算， 保持一个简单的状态</li><li>典型的增量聚合函数有ReduceFunction, AggregateFunction</li></ul></li><li>全窗口函数（ full window functions）<ul><li>先把窗口所有数据收集起来， 等到计算的时候会遍历所有数据</li><li>ProcessWindowFunction 就是一个全窗口函数</li></ul></li></ul><h3 id="3-4-其他API">3.4 其他API</h3><ul><li>.trigger() —— 触发器<ul><li>定义 window 什么时候关闭， 触发计算并输出结果</li></ul></li><li>.evitor() —— 移除器<ul><li>定义移除某些数据的逻辑</li></ul></li><li>.allowedLateness() —— 允许处理迟到的数据</li><li>.sideOutputLateData() —— 将迟到的数据放入侧输出流</li><li>.getSideOutput() —— 获取侧输出流<br><img src="https://img-blog.csdnimg.cn/2021051414553022.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><h1 id="七、时间语义与Wartermark">七、时间语义与Wartermark</h1><h2 id="1-Flink中的时间语义">1. Flink中的时间语义</h2><p>在Flink的流式处理中，会涉及到时间的不同概念，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210517094220598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Event Time</strong>： 是事件创建的时间。它通常由事件中的时间戳描述， 例如采集的日志数据中，每一条日志都会记录自己的生成时间，Flink 通过时间戳分配器访问事件时间戳。<br><strong>Ingestion Time</strong>： 是数据进入 Flink 的时间。<br><strong>Processing Time</strong>： 是每一个执行基于时间操作的算子的本地系统时间， 与机器相关， 默认的时间属性就是 Processing Time。</p><h2 id="2-EventTime的重要性">2. EventTime的重要性</h2><p><strong>在 Flink 的流式处理中， 绝大部分的业务都会使用 eventTime</strong>， 一般只在eventTime 无法使用时， 才会被迫使用 ProcessingTime 或者 IngestionTime。<br>如果要使用 EventTime，那么需要引入 EventTime 的时间属性，引入方式如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="comment">// 从调用时刻开始给env 创建的每一个stream 追加时间特征</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br></pre></td></tr></table></figure><h2 id="3-Watermark">3. Watermark</h2><h3 id="3-1-基本概念">3.1 基本概念</h3><p>我们知道，流处理从事件产生，到流经 source，再到 operator，中间是有一个过程和时间的， 虽然大部分情况下， 流到 operator 的数据都是按照事件产生的时间顺序来的， 但是也不排除由于网络、分布式等原因， 导致乱序的产生， 所谓乱序， 就是指 Flink 接收到的事件的先后顺序不是严格按照事件的 Event Time 顺序排列的。<br><img src="https://img-blog.csdnimg.cn/20210517100326243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>那么此时出现一个问题，一旦出现乱序，如果只根据 eventTime 决定 window 的运行， 我们不能明确数据是否全部到位， 但又不能无限期的等下去， 此时必须要有个机制来保证一个特定的时间后， 必须触发 window 去进行计算了， 这个特别的机制， 就是 Watermark。</p><ul><li>Watermark 是一种衡量 Event Time 进展的机制。</li><li>Watermark 是用于处理乱序事件的， 而正确的处理乱序事件， 通常用Watermark 机制结合 window 来实现。</li><li>数据流中的 Watermark 用于表示 timestamp 小于 Watermark 的数据，都已经到达了， 因此， window 的执行也是由 Watermark 触发的。</li><li>Watermark 可以理解成一个延迟触发机制，我们可以设置 Watermark 的延时时长 t，每次系统会校验已经到达的数据中最大的 maxEventTime，然后认定 eventTime小于 maxEventTime - t 的所有数据都已经到达， 如果有窗口的停止时间等于maxEventTime – t， 那么这个窗口被触发执行。</li></ul><p>有序流的 Watermarker 如下图所示（ Watermark 设置为 0）：<img src="https://img-blog.csdnimg.cn/20210517100655646.png#pic_center" alt="在这里插入图片描述"><br>乱序流的 Watermarker 如下图所示（ Watermark 设置为 2）：<br><img src="https://img-blog.csdnimg.cn/20210517100742702.png#pic_center" alt="在这里插入图片描述"><br>当 Flink 接收到数据时， 会按照一定的规则去生成 Watermark， 这条 Watermark 就等于当前所有到达数据中的 maxEventTime - 延迟时长，也就是说，Watermark 是基于数据携带的时间戳生成的， 一旦 Watermark 比当前未触发的窗口的停止时间要晚， 那么就会触发相应窗口的执行。由于 event time 是由数据携带的， 因此， 如果运行过程中无法获取新的数据， 那么没有被触发的窗口将永远都不被触发。<br>上图中，我们设置的允许最大延迟到达时间为 2s，所以时间戳为 7s 的事件对应的 Watermark 是 5s， 时间戳为 12s 的事件的 Watermark 是 10s， 如果我们的窗口 1 是 1s~5s， 窗口 2 是 6s~10s， 那么时间戳为 7s 的事件到达时的 Watermarker 恰好触发窗口 1， 时间戳为 12s 的事件到达时的 Watermark 恰好触发窗口 2。<br>Watermark 就是触发前一窗口的“关窗时间”， 一旦触发关门那么以当前时刻为准在窗口范围内的所有所有数据都会收入窗中。<br>只要没有达到水位那么不管现实中的时间推进了多久都不会触发关窗。</p><h3 id="3-2-Watermark-的引入">3.2 Watermark 的引入</h3><p>watermark 的引入很简单， 对于乱序数据， 最常见的引用方式如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataStream.assignTimestampsAndWatermarks( <span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="type">Time</span>.milliseconds(<span class="number">1000</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">SensorReading</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">element.timestamp * <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure><p>Event Time 的使用一定要指定数据源中的时间戳。否则程序无法知道事件的事件时间是什么(数据源里的数据没有时间戳的话， 就只能使用 Processing Time 了)。我们看到上面的例子中创建了一个看起来有点复杂的类， 这个类实现的其实就是分配时间戳的接口。Flink 暴露了 TimestampAssigner 接口供我们实现， 使我们可以自定义如何从事件数据中抽取时间戳。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从调用时刻开始给env 创建的每一个stream 追加时间特性</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env</span><br><span class="line">.addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>)</span><br><span class="line">.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">MyAssigner</span>())</span><br></pre></td></tr></table></figure><p>MyAssigner 有两种类型</p><ul><li>AssignerWithPeriodicWatermarks</li><li>AssignerWithPunctuatedWatermarks</li></ul><p>以上两个接口都继承自 TimestampAssigner</p><h4 id="Assigner-with-periodic-watermarks">Assigner with periodic watermarks</h4><p>周期性的生成 watermark： 系统会周期性的将 watermark 插入到流中(水位线也是一种特殊的事件)。默认周期是 200 毫秒。可以使用ExecutionConfig.setAutoWatermarkInterval()方法进行设置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔 5 秒产生一个watermark</span></span><br><span class="line">env.getConfig.setAutoWatermarkInterval(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>产生 watermark 的逻辑： 每隔 5 秒钟， Flink 会调用<br>AssignerWithPeriodicWatermarks 的 getCurrentWatermark()方法。如果方法返回一个时间戳大于之前水位的时间戳， 新的 watermark 会被插入到流中。这个检查保证了水位线是单调递增的。如果方法返回的时间戳小于等于之前水位的时间戳，  则不会产生新的 watermark。<br><strong>例：自定义一个周期性的时间戳抽取</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicAssigner</span> <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"><span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span> <span class="comment">// 延时为1 分钟</span></span><br><span class="line"><span class="keyword">var</span> maxTs: <span class="type">Long</span> = <span class="type">Long</span>.<span class="type">MinValue</span> <span class="comment">// 观察到的最大时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Watermark</span>(maxTs - bound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>, previousTS: <span class="type">Long</span>) = &#123;</span><br><span class="line">maxTs = maxTs.max(r.timestamp)</span><br><span class="line">r.timestamp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种简单的特殊情况是， 如果我们事先得知数据流的时间戳是单调递增的， 也就是说没有乱序， 那我们可以使用 assignAscendingTimestamps， 这个方法会直接使用数据的时间戳生成 watermark。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> withTimestampsAndWatermarks = stream</span><br><span class="line">.assignAscendingTimestamps(e =&gt; e.timestamp)</span><br><span class="line"></span><br><span class="line">&gt;&gt; result:<span class="type">E</span>(<span class="number">1</span>), <span class="type">W</span>(<span class="number">1</span>), <span class="type">E</span>(<span class="number">2</span>), <span class="type">W</span>(<span class="number">2</span>), ...</span><br></pre></td></tr></table></figure><p>而对于乱序数据流， 如果我们能大致估算出数据流中的事件的最大延迟时间， 就可以使用如下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> withTimestampsAndWatermarks = stream.assignTimestampsAndWatermarks(</span><br><span class="line"><span class="keyword">new</span> <span class="type">SensorTimeAssigner</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorTimeAssigner</span> <span class="keyword">extends</span> <span class="title">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="params"><span class="type">Time</span>.seconds(5</span>)) </span>&#123;</span><br><span class="line"><span class="comment">// 抽取时间戳</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>): <span class="type">Long</span> = r.timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; relust:<span class="type">E</span>(<span class="number">10</span>), <span class="type">W</span>(<span class="number">0</span>), <span class="type">E</span>(<span class="number">8</span>), <span class="type">E</span>(<span class="number">7</span>), <span class="type">E</span>(<span class="number">11</span>), <span class="type">W</span>(<span class="number">1</span>), ...</span><br></pre></td></tr></table></figure><h4 id="Assigner-with-punctuated-watermarks">Assigner with punctuated watermarks</h4><p>间断式地生成 watermark。和周期性生成的方式不同，这种方式不是固定时间的， 而是可以根据需要对每条数据进行筛选和处理。直接上代码来举个例子， 我们只给sensor_1 的传感器的数据流插入 watermark：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PunctuatedAssigner</span> <span class="keyword">extends</span> <span class="title">AssignerWithPunctuatedWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"><span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkAndGetNextWatermark</span></span>(r: <span class="type">SensorReading</span>, extractedTS: <span class="type">Long</span>): <span class="type">Watermark</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (r.id == <span class="string">&quot;sensor_1&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Watermark</span>(extractedTS - bound)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>, previousTS: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">r.timestamp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-EventTime-在window-中的使用">4. EventTime 在window 中的使用</h2><h3 id="4-1-滚动窗口（TumblingEventTimeWindows）">4.1 滚动窗口（TumblingEventTimeWindows）</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 环 境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>) env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>,<span class="number">7777</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithTsDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = dstream.map&#123;</span><br><span class="line">text =&gt;</span><br><span class="line"><span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">String</span>] = text.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithEventTimeDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = textWithTsDstream.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)](<span class="type">Time</span>.milliseconds(<span class="number">1000</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: (<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)): <span class="type">Long</span> = &#123;</span><br><span class="line"><span class="keyword">return</span>element._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textKeyStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = textWithEventTimeDstream.keyBy(<span class="number">0</span>)</span><br><span class="line">textKeyStream.print(<span class="string">&quot;textkey:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = textKeyStream.window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> groupDstream: <span class="type">DataStream</span>[mutable.<span class="type">HashSet</span>[<span class="type">Long</span>]] = windowStream.fold(<span class="keyword">new</span> mutable.<span class="type">HashSet</span>[<span class="type">Long</span>]()) &#123;</span><br><span class="line"><span class="keyword">case</span> (set, (key, ts, count)) =&gt;</span><br><span class="line">set += ts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">groupDstream.print(<span class="string">&quot;window::::&quot;</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">env.execute()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是按照 Event Time 的时间窗口计算得出的，而无关系统的时间（包括输入的快慢）。</p><h3 id="4-2-滑动窗口（SlidingEventTimeWindows）">4.2 滑动窗口（SlidingEventTimeWindows）</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 环 境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>,<span class="number">7777</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithTsDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = dstream.map &#123;</span><br><span class="line">text =&gt;</span><br><span class="line"><span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">String</span>] = text.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithEventTimeDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = textWithTsDstream.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)](<span class="type">Time</span>.milliseconds(<span class="number">1000</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: (<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)): <span class="type">Long</span> = &#123;</span><br><span class="line"><span class="keyword">return</span> element._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textKeyStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = textWithEventTimeDstream.keyBy(<span class="number">0</span>)</span><br><span class="line">textKeyStream.print(<span class="string">&quot;textkey:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = textKeyStream.window(<span class="type">SlidingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">2</span>),<span class="type">Time</span>.millis econds(<span class="number">500</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> groupDstream: <span class="type">DataStream</span>[mutable.<span class="type">HashSet</span>[<span class="type">Long</span>]] = windowStream.fold(<span class="keyword">new</span> mutable.<span class="type">HashSet</span>[<span class="type">Long</span>]()) &#123; </span><br><span class="line"><span class="keyword">case</span> (set, (key, ts, count)) =&gt;</span><br><span class="line">set += ts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">groupDstream.print(<span class="string">&quot;window::::&quot;</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">env.execute()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-会话窗口（EventTimeSessionWindows）">4.3 会话窗口（EventTimeSessionWindows）</h3><p>相邻两次数据的 EventTime 的时间差超过指定的时间间隔就会触发执行。如果加入 Watermark，会在符合窗口触发的情况下进行延迟，到达延迟水位再进行窗口触发。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 环 境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>) env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>,<span class="number">7777</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithTsDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = dstream.map &#123;</span><br><span class="line">text =&gt;</span><br><span class="line"><span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">String</span>] = text.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithEventTimeDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = textWithTsDstream.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)](<span class="type">Time</span>.milliseconds(<span class="number">1000</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: (<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)): <span class="type">Long</span> = &#123;</span><br><span class="line"><span class="keyword">return</span>element._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textKeyStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = textWithEventTimeDstream.keyBy(<span class="number">0</span>)</span><br><span class="line">textKeyStream.print(<span class="string">&quot;textkey:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = textKeyStream.window(<span class="type">EventTimeSessionWindows</span>.withGap(<span class="type">Time</span>.milliseconds(<span class="number">500</span>)))</span><br><span class="line"></span><br><span class="line">windowStream.reduce(</span><br><span class="line">(text1,text2) =&gt; (text1._1,<span class="number">0</span>L,text1._3+text2._3)</span><br><span class="line">) .map(_._3).print(<span class="string">&quot;windows:::&quot;</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">env.execute()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、ProcessFunction-API（底层-API）">八、ProcessFunction API（底层 API）</h1><p>我们之前学习的<strong>转换算子</strong>是无法访问事件的时间戳信息和水位线信息的。而这  在一些应用场景下， 极为重要。例如 MapFunction 这样的 map 转换算子就无法访问时间戳或者当前事件的事件时间。<br>基于此， DataStream API 提供了一系列的 Low-Level 转换算子。可以<strong>访问时间戳、watermark 以及注册定时事件</strong>。还可以输出<strong>特定的一些事件</strong>，例如超时事件等。Process Function 用来构建事件驱动的应用以及实现自定义的业务逻辑(使用之前的window 函数和转换算子无法实现)。例如， Flink SQL 就是使用 Process Function 实现的。<br>Flink 提供了 8 个 Process Function：</p><ul><li>ProcessFunction</li><li>KeyedProcessFunction</li><li>CoProcessFunction</li><li>ProcessJoinFunction</li><li>BroadcastProcessFunction</li><li>KeyedBroadcastProcessFunction</li><li>ProcessWindowFunction</li><li>ProcessAllWindowFunction</li></ul><h2 id="1-KeyedProcessFunction">1. KeyedProcessFunction</h2><p>KeyedProcessFunction 用来操作 KeyedStream。KeyedProcessFunction 会处理流的每一个元素，输出为 0 个、1 个或者多个元素。所有的 Process Function 都继承自RichFunction 接口， 所以都有 open()、close()和 getRuntimeContext()等方法。而KeyedProcessFunction[KEY, IN, OUT] 还额外提供了两个方法：</p><ul><li>processElement(v: IN, ctx: Context, out: Collector[OUT]), 流中的每一个元素都会调用这个方法， 调用结果将会放在 Collector 数据类型中输出。Context 可以访问元素的时间戳，元素的 key，以及 TimerService 时间服务。Context 还可以将结果输出到别的流(side outputs)。</li><li>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])是一个回调函数。当之前注册的定时器触发时调用。参数 timestamp 为定时器所设定的触发的时间戳。Collector 为输出结果的集合。OnTimerContext 和processElement 的 Context 参数一样，提供了上下文的一些信息，例如定时器触发的时间信息(事件时间或者处理时间)。</li></ul><h2 id="2-TimerService-和-定时器（Timers）">2. TimerService 和 定时器（Timers）</h2><p>Context 和 OnTimerContext 所持有的 TimerService 对象拥有以下方法:</p><ul><li>currentProcessingTime(): Long 返回当前处理时间</li><li>currentWatermark(): Long 返回当前 watermark 的时间戳</li><li>registerProcessingTimeTimer(timestamp: Long): Unit 会注册当前 key 的 processing time 的定时器。当 processing time 到达定时时间时， 触发 timer</li><li>registerEventTimeTimer(timestamp: Long): Unit 会注册当前 key 的 event time 定时器。当水位线大于等于定时器注册的时间时，触发定时器执行回调函数</li><li>deleteProcessingTimeTimer(timestamp: Long): Unit 删除之前注册处理时间定时器。如果没有这个时间戳的定时器， 则不执行</li><li>deleteEventTimeTimer(timestamp: Long): Unit 删除之前注册的事件时间定时器， 如果没有此时间戳的定时器， 则不执行</li></ul><p>当定时器 timer 触发时， 会执行回调函数 onTimer()。注意定时器 timer 只能在keyed streams 上面使用。<br>下面举个例子说明 KeyedProcessFunction 如何操作 KeyedStream。</p><ul><li>需求： 监控温度传感器的温度值， 如果温度值在一秒钟之内(processing time)连续上升， 则报警。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> warnings = readings</span><br><span class="line">.keyBy(_.id)</span><br><span class="line">.process(<span class="keyword">new</span> <span class="type">TempIncreaseAlertFunction</span>)</span><br></pre></td></tr></table></figure><p>看一下 TempIncreaseAlertFunction 如何实现, 程序中使用了 ValueState 这样一个 状态变量</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempIncreaseAlertFunction</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存上一个传感器温度值</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> lastTemp: <span class="type">ValueState</span>[<span class="type">Double</span>] = getRuntimeContext.getState(</span><br><span class="line"><span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Double</span>](<span class="string">&quot;lastTemp&quot;</span>, <span class="type">Types</span>.of[<span class="type">Double</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存注册的定时器的时间戳</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> currentTimer: <span class="type">ValueState</span>[<span class="type">Long</span>] = getRuntimeContext.getState(</span><br><span class="line"><span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Long</span>](<span class="string">&quot;timer&quot;</span>, <span class="type">Types</span>.of[<span class="type">Long</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(r: <span class="type">SensorReading</span>,</span><br><span class="line">ctx: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>]#<span class="type">Context</span>,</span><br><span class="line">out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 取出上一次的温度</span></span><br><span class="line"><span class="keyword">val</span> prevTemp = lastTemp.value()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前温度更新到上一次的温度这个变量中</span></span><br><span class="line">lastTemp.update(r.temperature)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> curTimerTimestamp = currentTimer.value()</span><br><span class="line"><span class="keyword">if</span> (prevTemp == <span class="number">0.0</span> || r.temperature &lt; prevTemp) &#123;</span><br><span class="line"><span class="comment">// 温度下降或者是第一个温度值，删除定时器</span></span><br><span class="line">ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp)</span><br><span class="line"><span class="comment">// 清空状态变量</span></span><br><span class="line">currentTimer.clear()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 温度上升且我们并没有设置定时器</span></span><br><span class="line"><span class="keyword">val</span> timerTs = ctx.timerService().currentProcessingTime() + <span class="number">1000</span> ctx.timerService().registerProcessingTimeTimer(timerTs)</span><br><span class="line">currentTimer.update(timerTs)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onTimer</span></span>(ts: <span class="type">Long</span>,</span><br><span class="line">ctx: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>]#<span class="type">OnTimerContext</span>,</span><br><span class="line">out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">out.collect(<span class="string">&quot;传感器 id 为: &quot;</span> + ctx.getCurrentKey + <span class="string">&quot;的传感器温度值已经连续 1s 上升了。&quot;</span>)</span><br><span class="line">currentTimer.clear()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-侧输出流（SideOutput）">3. 侧输出流（SideOutput）</h2><p>大部分的 DataStream API 的算子的输出是单一输出，也就是某种数据类型的流。除了 split 算子， 可以将一条流分成多条流， 这些流的数据类型也都相同。process function 的 side outputs 功能可以产生多条流， 并且这些流的数据类型可以不一样。一个 side output 可以定义为 OutputTag[X]对象， X 是输出流的数据类型。process function 可以通过 Context 对象发射一个事件到一个或者多个 side outputs。<br>下面是一个示例程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> monitoredReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = readings.process(<span class="keyword">new</span> <span class="type">FreezingMonitor</span>)</span><br><span class="line"></span><br><span class="line">monitoredReadings</span><br><span class="line">.getSideOutput(<span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">&quot;freezing-alarms&quot;</span>))</span><br><span class="line">.print()</span><br><span class="line"></span><br><span class="line">readings.print()</span><br></pre></td></tr></table></figure><p>接下来我们实现 FreezingMonitor 函数，用来监控传感器温度值，将温度值低于32F 的温度输出到 side output</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreezingMonitor</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个侧输出标签</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> freezingAlarmOutput: <span class="type">OutputTag</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">&quot;freezing-alarms&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(r: <span class="type">SensorReading</span>,</span><br><span class="line">ctx: <span class="type">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 温度在32F 以下时，输出警告信息</span></span><br><span class="line"><span class="keyword">if</span> (r.temperature &lt; <span class="number">32.0</span>) &#123;</span><br><span class="line">ctx.output(freezingAlarmOutput, <span class="string">s&quot;Freezing Alarm for <span class="subst">$&#123;r.id&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有数据直接常规输出到主流</span></span><br><span class="line">out.collect(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-CoProcessFunction">4. CoProcessFunction</h2><p>对于两条输入流， DataStream API 提供了 CoProcessFunction 这样的 low-level 操作。CoProcessFunction 提供了操作每一个输入流的方法: processElement1()和processElement2()。<br>类似于 ProcessFunction， 这两种方法都通过 Context 对象来调用。这个 Context 对象可以访问事件数据， 定时器时间戳， TimerService， 以及 side outputs。<br>CoProcessFunction 也提供了 onTimer()回调函数。</p><h1 id="九、状态编程和容错机制">九、状态编程和容错机制</h1><p>流式计算分为无状态和有状态两种情况。无状态的计算观察每个独立事件， 并根据最后一个事件输出结果。例如， 流处理应用程序从传感器接收温度读数， 并在温度超过 90 度时发出警告。有状态的计算则会基于多个事件输出结果。以下是一些例子：</p><ul><li>所有类型的窗口。例如， 计算过去一小时的平均温度，就是有状态的计算</li><li>所有用于复杂事件处理的状态机。例如，若在一分钟内收到两个相差 20 度以上的温度读数， 则发出警告， 这是有状态的计算</li><li>流与流之间的所有关联操作， 以及流与静态表或动态表之间的关联操作， 都是有状态的计算</li></ul><p>下图展示了无状态流处理和有状态流处理的主要区别。无状态流处理分别接收每条数据记录(图中的黑条)，然后根据最新输入的数据生成输出数据(白条)；有状态流处理会维护状态(根据每条输入记录进行更新)， 并基于最新输入的记录和当前的状态值生成输出记录(灰条)<br><img src="https://img-blog.csdnimg.cn/20210519104814423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上图中输入数据由黑条表示。无状态流处理每次只转换一条输入记录， 并且仅根据最新的输入记录输出结果(白条)。有状态流处理维护所有已处理记录的状态值， 并根据每条新输入的记录更新状态，因此输出记录(灰条)反映的是综合考虑多个事件之后的结果。<br>尽管无状态的计算很重要， 但是流处理对有状态的计算更感兴趣。事实上， 正确地实现有状态的计算比实现无状态的计算难得多。旧的流处理系统并不支持有状 态的计算， 而新一代的流处理系统则将状态及其正确性视为重中之重。</p><h2 id="1-有状态的算子和应用程序">1. 有状态的算子和应用程序</h2><p>Flink 内置的很多算子，数据源 source，数据存储 sink 都是有状态的，流中的数据都是 buffer records，会保存一定的元素或者元数据。例如: ProcessWindowFunction 会缓存输入流的数据， ProcessFunction 会保存设置的定时器信息等等。<br>在 Flink 中， 状态始终与特定算子相关联。总的来说， 有两种类型的状态：</p><ul><li>算子状态（ operator state）</li><li>键控状态（ keyed state）</li></ul><h3 id="1-1-算子状态（operator-state）">1.1 算子状态（operator state）</h3><p>算子状态的作用范围限定为算子任务。这意味着由同一并行任务所处理的所有数据都可以访问到相同的状态，  状态对于同一任务而言是共享的。算子状态不能由相同或不同算子的另一个任务访问。<br><img src="https://img-blog.csdnimg.cn/20210519105207400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 为算子状态提供三种基本数据结构：</p><ul><li>列表状态（List state）<ul><li>将状态表示为一组数据的列表</li></ul></li><li>联合列表状态（Union list state）<ul><li>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保 存点（savepoint）启动应用程序时如何恢复</li></ul></li><li>广播状态（Broadcast state）<ul><li>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态</li></ul></li></ul><h3 id="1-2-键控状态（keyed-state）">1.2 键控状态（keyed state）</h3><p>键控状态是根据输入数据流中定义的键（key）来维护和访问的。Flink 为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个 key 对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的 key。因此，具有相同 key 的所有数据都会访问相同的状态。Keyed State 很类似于一个分布式的 key-value map 数据结构，只能用于 KeyedStream（ keyBy 算子处理之后）<br><img src="https://img-blog.csdnimg.cn/20210519105522865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 的 Keyed State 支持以下数据类型：</p><ul><li>ValueState[T]保存单个的值，值的类型为 T<ul><li>get 操作: ValueState.value()</li><li>set 操作: ValueState.update(value: T)</li></ul></li><li>ListState[T]保存一个列表，列表里的元素的数据类型为 T。基本操作如下：<ul><li>ListState.add(value: T)</li><li>ListState.addAll(values: java.util.List[T])</li><li>oListState.get() 返回 Iterable[T]</li><li>ListState.update(values: java.util.List[T])</li></ul></li><li>MapState[K, V]保存 Key-Value 对<ul><li>MapState.get(key: K)</li><li>MapState.put(key: K, value: V)</li><li>MapState.contains(key: K)</li><li>MapState.remove(key: K)</li></ul></li><li>ReducingState[T]</li><li>AggregatingState[I, O]</li></ul><p>State.clear()是清空操作</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sensorData: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> keyedData: <span class="type">KeyedStream</span>[<span class="type">SensorReading</span>, <span class="type">String</span>] = sensorData.keyBy(_.id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> alerts: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)] = keyedData</span><br><span class="line">.flatMap(<span class="keyword">new</span> <span class="type">TemperatureAlertFunction</span>(<span class="number">1.7</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureAlertFunction</span>(<span class="params">val threshold: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>[<span class="type">SensorReading</span>, (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)] </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> lastTempState: <span class="type">ValueState</span>[<span class="type">Double</span>] = _</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lastTempDescriptor = <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Double</span>](<span class="string">&quot;lastTemp&quot;</span>, classOf[<span class="type">Double</span>])</span><br><span class="line"></span><br><span class="line">lastTempState = getRuntimeContext.getState[<span class="type">Double</span>](lastTempDescriptor)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(reading: <span class="type">SensorReading</span>,</span><br><span class="line">out: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lastTemp = lastTempState.value()</span><br><span class="line"><span class="keyword">val</span> tempDiff = (reading.temperature - lastTemp).abs</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tempDiff &gt; threshold) &#123;</span><br><span class="line">out.collect((reading.id, reading.temperature, tempDiff))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.lastTempState.update(reading.temperature)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 RuntimeContext 注册 StateDescriptor。StateDescriptor 以状态 state 的名字和存储的数据类型为参数。<br>在 open()方法中创建 state 变量。注意复习之前的 RichFunction 相关知识。<br>接下来我们使用了 FlatMap with keyed ValueState 的快捷方式 flatMapWithState 实现以上需求：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> alerts: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)] = keyedSensorData</span><br><span class="line">.flatMapWithState[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>), <span class="type">Double</span>] &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (in: <span class="type">SensorReading</span>, <span class="type">None</span>) =&gt;</span><br><span class="line">(<span class="type">List</span>.empty, <span class="type">Some</span>(in.temperature))</span><br><span class="line"><span class="keyword">case</span> (r: <span class="type">SensorReading</span>, lastTemp: <span class="type">Some</span>[<span class="type">Double</span>]) =&gt;</span><br><span class="line"><span class="keyword">val</span> tempDiff = (r.temperature - lastTemp.get).abs</span><br><span class="line"><span class="keyword">if</span> (tempDiff &gt; <span class="number">1.7</span>) &#123;</span><br><span class="line">(<span class="type">List</span>((r.id, r.temperature, tempDiff)), <span class="type">Some</span>(r.temperature))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">(<span class="type">List</span>.empty, <span class="type">Some</span>(r.temperature))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-状态一致性">2. 状态一致性</h2><p>当在分布式系统中引入状态时， 自然也引入了一致性问题。一致性实际上是&quot; 正确性级别&quot;的另一种说法，也就是说在成功处理故障并恢复之后得到的结果，与没  有发生任何故障时得到的结果相比， 前者到底有多正确？ 举例来说， 假设要对最近一小时登录的用户计数。在系统经历故障之后， 计数结果是多少？ 如果有偏差， 是有漏掉的计数还是重复计数？</p><h3 id="2-1-一致性级别">2.1 一致性级别</h3><p>在流处理中， 一致性可以分为 3 个级别：</p><ul><li>at-most-once: 这其实是没有正确性保障的委婉说法——故障发生之后， 计数结果可能丢失。同样的还有 udp</li><li>at-least-once: 这表示计数结果可能大于正确值， 但绝不会小于正确值。也就是说， 计数程序在发生故障后可能多算， 但是绝不会少算</li><li>exactly-once: 这指的是系统保证在发生故障后得到的计数结果与正确值一致</li></ul><p>曾经， at-least-once 非常流行。第一代流处理器(如 Storm 和 Samza)刚问世时只保证 at-least-once， 原因有二：</p><ul><li>保证 exactly-once 的系统实现起来更复杂。这在基础架构层(决定什么代表正确， 以及 exactly-once 的范围是什么)和实现层都很有挑战性</li><li>流处理系统的早期用户愿意接受框架的局限性， 并在应用层想办法弥补(例如使应用程序具有幂等性， 或者用批量计算层再做一遍计算)</li></ul><p>最先保证 exactly-once 的系统(Storm Trident 和 Spark Streaming)在性能和表现力这两个方面付出了很大的代价。为了保证 exactly-once，这些系统无法单独地对每条记录运用应用逻辑， 而是同时处理多条(一批)记录， 保证对每一批的处理要么全部成功，要么全部失败。这就导致在得到结果前，必须等待一批记录处理结束。因此，  用户经常不得不使用两个流处理框架(一个用来保证 exactly-once， 另一个用来对每个元素做低延迟处理)， 结果使基础设施更加复杂。曾经， 用户不得不在保证exactly-once 与获得低延迟和效率之间权衡利弊。Flink 避免了这种权衡。<br>Flink 的一个重大价值在于，<strong>它既保证了 exactly-once， 也具有低延迟和高吞吐的处理能力</strong>。<br>从根本上说，Flink 通过使自身满足所有需求来避免权衡，它是业界的一次意义重大的技术飞跃。尽管这在外行看来很神奇， 但是一旦了解， 就会恍然大悟。</p><h3 id="2-2-端到端（end-to-end）状态一致性">2.2 端到端（end-to-end）状态一致性</h3><p>目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在 Flink 流处理器内部保证的； 而在真实应用中， 流处理应用除了流处理器以外还包含了数据源（ 例如 Kafka） 和输出到持久化系统。<br>端到端的一致性保证， 意味着结果的正确性贯穿了整个流处理应用的始终； 每一个组件都保证了它自己的一致性，  整个端到端的一致性级别取决于所有组件中一致性最弱的组件。具体可以划分如下：</p><ul><li>内部保证 —— 依赖 checkpoint</li><li>source 端 —— 需要外部源可重设数据的读取位置</li><li>sink 端 —— 需要保证从故障恢复时， 数据不会重复写入外部系统</li></ul><p>而对于 sink 端， 又有两种具体的实现方式： 幂等（ Idempotent） 写入和事务性（ Transactional） 写入。</p><ul><li>幂等写入<ul><li>所谓幂等操作，是说一个操作，可以重复执行很多次，但只导致一次结果更改，  也就是说， 后面再重复执行就不起作用了</li></ul></li><li>事务写入<ul><li>需要构建事务来写入外部系统，构建的事务对应着 checkpoint，等到 checkpoint 真正完成的时候， 才把所有对应的结果写入 sink 系统中</li></ul></li></ul><p>对于事务性写入， 具体又有两种实现方式： 预写日志（ WAL） 和两阶段提交（ 2PC）。DataStream API 提供了 GenericWriteAheadSink 模板类和 TwoPhaseCommitSinkFunction 接口， 可以方便地实现这两种方式的事务性写入。<br>不同 Source 和 Sink 的一致性保证可以用下表说明：<br><img src="https://img-blog.csdnimg.cn/20210519111516235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="3-检查点（checkpoint）">3. 检查点（checkpoint）</h2><p>Flink 具体如何保证 exactly-once 呢? 它使用一种被称为&quot;检查点&quot;（checkpoint）的特性，在出现故障时将系统重置回正确状态。下面通过简单的类比来解释检查点 的作用。<br>假设你和两位朋友正在数项链上有多少颗珠子，如下图所示。你捏住珠子，边数边拨，每拨过一颗珠子就给总数加一。你的朋友也这样数他们手中的珠子。当你分神忘记数到哪里时，怎么办呢? 如果项链上有很多珠子，你显然不想从头再数一 遍，尤其是当三人的速度不一样却又试图合作的时候，更是如此(比如想记录前一分钟三人一共数了多少颗珠子，回想一下一分钟滚动窗口)。<br><img src="https://img-blog.csdnimg.cn/20210519111950813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>于是，你想了一个更好的办法：在项链上每隔一段就松松地系上一根有色皮筋，将珠子分隔开；当珠子被拨动的时候，皮筋也可以被拨动； 然后，你安排一个助手， 让他在你和朋友拨到皮筋时记录总数。用这种方法，当有人数错时，就不必从头开始数。相反，你向其他人发出错误警示，然后你们都从上一根皮筋处开始重数，助手则会告诉每个人重数时的起始数值，例如在粉色皮筋处的数值是多少。<br>Flink 检查点的作用就类似于皮筋标记。数珠子这个类比的关键点是：对于指定的皮筋而言，珠子的相对位置是确定的;  这让皮筋成为重新计数的参考点。总状态(珠子的总数)在每颗珠子被拨动之后更新一次，助手则会保存与每根皮筋对应的检查点状态，如当遇到粉色皮筋时一共数了多少珠子，当遇到橙色皮筋时又是多少。当问题出现时，这种方法使得重新计数变得简单。</p><h3 id="3-1-Flink的检查点算法">3.1 Flink的检查点算法</h3><p>Flink 检查点的核心作用是确保状态正确，即使遇到程序中断，也要正确。记住 这一基本点之后，我们用一个例子来看检查点是如何运行的。Flink 为用户提供了用 来定义状态的工具。例如，以下这个 Scala 程序按照输入记录的第一个字段(一个字 符串)进行分组并维护第二个字段的计数状态。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = ... </span><br><span class="line"><span class="keyword">val</span> counts: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = stream</span><br><span class="line">.keyBy(record =&gt; record._1)</span><br><span class="line">.mapWithState((in: (<span class="type">String</span>, <span class="type">Int</span>), state: <span class="type">Option</span>[<span class="type">Int</span>])=&gt; </span><br><span class="line">state <span class="keyword">match</span> &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="type">Some</span>(c) =&gt; ( (in._1, c + in._2), <span class="type">Some</span>(c + in._2) ) </span><br><span class="line"><span class="keyword">case</span> <span class="type">None</span> =&gt; ( (in._1, in._2), <span class="type">Some</span>(in._2) )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该程序有两个算子: keyBy 算子用来将记录按照第一个元素(一个字符串)进行分 组，根据该 key 将数据进行重新分区，然后将记录再发送给下一个算子: 有状态的 map 算子(mapWithState)。map 算子在接收到每个元素后，将输入记录的第二个字段 的数据加到现有总数中，再将更新过的元素发射出去。下图表示程序的初始状态: 输 入流中的 6 条记录被检查点分割线(checkpoint barrier)隔开，所有的 map 算子状态均为 0(计数还未开始)。所有 key 为 a 的记录将被顶层的 map 算子处理，所有 key 为 b 的记录将被中间层的 map 算子处理，所有 key 为 c 的记录则将被底层的 map 算子处理。<br><img src="https://img-blog.csdnimg.cn/20210519112714781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="按 key 累加计数程序初始状态"><br>上图是程序的初始状态。注意，a、b、c 三组的初始计数状态都是 0，即三个圆 柱上的值。ckpt 表示检查点分割线（checkpoint barriers）。每条记录在处理顺序上 严格地遵守在检查点之前或之后的规定，例如[“b”,2]在检查点之前被处理，[“a”,2] 则在检查点之后被处理。<br>当该程序处理输入流中的 6 条记录时，涉及的操作遍布 3 个并行实例(节点、CPU 内核等)。那么，检查点该如何保证 exactly-once 呢?<br>检查点分割线和普通数据记录类似。它们由算子处理，但并不参与计算，而是 会触发与检查点相关的行为。当读取输入流的数据源(在本例中与 keyBy 算子内联) 遇到检查点屏障时，它将其在输入流中的位置保存到持久化存储中。如果输入流来 自消息传输系统(Kafka)，这个位置就是偏移量。Flink 的存储机制是插件化的，持久 化存储可以是分布式文件系统，如 HDFS。下图展示了这个过程（遇到 checkpoint barrier 时， 保存其在输入流中的位置）<br><img src="https://img-blog.csdnimg.cn/20210519113405164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当 Flink 数据源(在本例中与 keyBy 算子内联)遇到检查点分界线（barrier）时， 它会将其在输入流中的位置保存到持久化存储中。这让 Flink 可以根据该位置重启。<br>检查点像普通数据记录一样在算子之间流动。当 map 算子处理完前 3 条数据并 收到检查点分界线时，它们会将状态以异步的方式写入持久化存储，如下图所示（保存 map 算子状态， 也就是当前各个 key 的计数值）<br><img src="https://img-blog.csdnimg.cn/20210519113643798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>位于检查点之前的所有记录([“b”,2]、[“b”,3]和[“c”,1])被 map 算子处理之后的情 况。此时，持久化存储已经备份了检查点分界线在输入流中的位置(备份操作发生在 barrier 被输入算子处理的时候)。map 算子接着开始处理检查点分界线，并触发将状 态异步备份到稳定存储中这个动作。<br>当 map 算子的状态备份和检查点分界线的位置备份被确认之后，该检查点操作 就可以被标记为完成，如下图所示。我们在无须停止或者阻断计算的条件下，在一 个逻辑时间点(对应检查点屏障在输入流中的位置)为计算状态拍了快照。通过确保 备份的状态和位置指向同一个逻辑时间点，后文将解释如何基于备份恢复计算，从 而保证 exactly-once。值得注意的是，当没有出现故障时，Flink 检查点的开销极小， 检查点操作的速度由持久化存储的可用带宽决定。回顾数珠子的例子: 除了因为数 错而需要用到皮筋之外，皮筋会被很快地拨过。<br><img src="https://img-blog.csdnimg.cn/20210519113733345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>检查点操作完成，状态和位置均已备份到稳定存储中。输入流中的所有数据记 录都已处理完成。值得注意的是，备份的状态值与实际的状态值是不同的。备份反 映的是检查点的状态。<br>如果检查点操作失败，Flink 可以丢弃该检查点并继续正常执行，因为之后的某 一个检查点可能会成功。虽然恢复时间可能更长，但是对于状态的保证依旧很有力。 只有在一系列连续的检查点操作失败之后，Flink 才会抛出错误，因为这通常预示着 发生了严重且持久的错误。<br>现在来看看下图所示的情况：检查点操作已经完成，但故障紧随其后（故障紧跟检查点， 导致最底部的实例丢失）<br><img src="https://img-blog.csdnimg.cn/20210519113827989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在这种情况下（故障时的状态恢复），Flink 会重新拓扑(可能会获取新的执行资源)，将输入流倒回到 上一个检查点，然后恢复状态值并从该处开始继续计算。在本例中，[“a”,2]、[“a”,2] 和[“c”,2]这几条记录将被重播。<br>下图展示了这一重新处理过程。从上一个检查点开始重新计算，可以保证在剩 下的记录被处理之后，得到的 map 算子的状态值与没有发生故障时的状态值一致。<br><img src="https://img-blog.csdnimg.cn/20210519114227718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 将输入流倒回到上一个检查点屏障的位置，同时恢复 map 算子的状态值。 然后，Flink 从此处开始重新处理。这样做保证了在记录被处理之后，map 算子的状 态值与没有发生故障时的一致。<br>Flink 检查点算法的正式名称是异步分界线快照(asynchronous barrier snapshotting)。该算法大致基于 Chandy-Lamport 分布式快照算法。<br>检查点是 Flink 最有价值的创新之一，因为<strong>它使 Flink 可以保证 exactly-once， 并且不需要牺牲性能</strong>。</p><h3 id="3-2-Flink-Kafka-如何实现端到端的-exactly-once-语义">3.2 Flink+Kafka 如何实现端到端的 exactly-once 语义</h3><p>我们知道，端到端的状态一致性的实现，需要每一个组件都实现，对于 Flink + Kafka 的数据管道系统（Kafka 进、Kafka 出）而言，各组件怎样保证 exactly-once 语义呢？</p><ul><li>内部 —— 利用 checkpoint 机制，把状态存盘，发生故障的时候可以恢复，保证内部的状态一致性</li><li>source —— kafka consumer 作为 source，可以将偏移量保存下来，如果后续任务出现了故障，恢复的时候可以由连接器重置偏移量，重新消费数据，保证一致性</li><li>sink —— kafka producer 作为 sink，采用两阶段提交 sink，需要实现一个 TwoPhaseCommitSinkFunction</li></ul><p>内部的 checkpoint 机制我们已经有了了解，那 source 和 sink 具体又是怎样运行 的呢？接下来我们逐步做一个分析。<br>我们知道 Flink 由 JobManager 协调各个 TaskManager 进行 checkpoint 存储， checkpoint 保存在 StateBackend 中，默认 StateBackend 是内存级的，也可以改为文件级的进行持久化保存。<br><img src="https://img-blog.csdnimg.cn/20210519114544418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当 checkpoint 启动时，JobManager 会将检查点分界线（barrier）注入数据流； barrier 会在算子间传递下去。<br><img src="https://img-blog.csdnimg.cn/20210519114628309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>每个算子会对当前的状态做个快照，保存到状态后端。对于 source 任务而言， 就会把当前的 offset 作为状态保存起来。下次从 checkpoint 恢复时，source 任务可以重新提交偏移量，从上次保存的位置开始重新消费数据。<br><img src="https://img-blog.csdnimg.cn/20210519114708854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>每个内部的 transform 任务遇到 barrier 时，都会把状态存到 checkpoint 里。<br>sink 任务首先把数据写入外部 kafka，这些数据都属于预提交的事务（还不能被消费）；当遇到 barrier 时，把状态保存到状态后端，并开启新的预提交事务。<br><img src="https://img-blog.csdnimg.cn/20210519114806911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当所有算子任务的快照完成，也就是这次的 checkpoint 完成时，JobManager 会向所有任务发通知，确认这次 checkpoint 完成。<br>当 sink 任务收到确认通知，就会正式提交之前的事务，kafka 中未确认的数据 就改为“已确认”，数据就真正可以被消费了。<br><img src="https://img-blog.csdnimg.cn/20210519114847109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以我们看到，执行过程实际上是一个两段式提交，每个算子执行完成，会进 行“预提交”，直到执行完 sink 操作，会发起“确认提交”，如果执行失败，预提 交会放弃掉。<br>具体的两阶段提交步骤总结如下：</p><ul><li>第一条数据来了之后，开启一个 kafka 的事务（transaction），正常写入 kafka 分区日志但标记为未提交，这就是“预提交”</li><li>jobmanager 触发 checkpoint 操作，barrier 从 source 开始向下传递，遇到 barrier 的算子将状态存入状态后端，并通知 jobmanager</li><li>sink 连接器收到 barrier，保存当前状态，存入 checkpoint，通知 jobmanager，并开启下一阶段的事务，用于提交下个检查点的数据</li><li>jobmanager 收到所有任务的通知，发出确认信息，表示 checkpoint 完成</li><li>sink 任务收到 jobmanager 的确认信息，正式提交这段时间的数据</li><li>外部 kafka 关闭事务，提交的数据可以正常消费了</li></ul><p>所以我们也可以看到，如果宕机需要通过 StateBackend 进行恢复，只能恢复所有确认提交的操作。</p><h2 id="4-选择一个状态后端（state-backend）">4. 选择一个状态后端（state backend）</h2><ul><li><strong>MemoryStateBackend</strong><ul><li>内存级的状态后端，会将键控状态作为内存中的对象进行管理，将它们存储在 TaskManager 的 JVM 堆上；而将 checkpoint 存储在 JobManager 的内存中</li></ul></li><li><strong>FsStateBackend</strong><ul><li>将 checkpoint 存到远程的持久化文件系统（FileSystem）上。而对于本地状态，跟 MemoryStateBackend 一样，也会存在 TaskManager 的 JVM 堆上</li></ul></li><li><strong>RocksDBStateBackend</strong><ul><li>将所有状态序列化后，存入本地的 RocksDB 中存储</li></ul></li></ul><p><font color=red>注：</font>RocksDB 的支持并不直接包含在 flink 中，需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置状态后端为 FsStateBackend：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="keyword">val</span> checkpointPath: <span class="type">String</span> = ???</span><br><span class="line"><span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">RocksDBStateBackend</span>(checkpointPath)</span><br><span class="line"></span><br><span class="line">env.setStateBackend(backend)</span><br><span class="line"></span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> <span class="type">FsStateBackend</span>(<span class="string">&quot;file:///tmp/checkpoints&quot;</span>))</span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置重启策略</span></span><br><span class="line">env.setRestartStrategy(<span class="type">RestartStrategies</span>.fixedDelayRestart(<span class="number">60</span>, <span class="type">Time</span>.of(<span class="number">10</span>, <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>)))</span><br></pre></td></tr></table></figure><h2 id="4-Savepoint">4. Savepoint</h2><h3 id="4-1-Savepoint介绍">4.1 Savepoint介绍</h3><p>Savepoint：保存点，类似于以前玩游戏的时候,遇到难关了/遇到boss了,赶紧手动存个档,然后接着玩,如果失败了,赶紧从上次的存档中恢复,然后接着玩。<br><strong>在实际开发中,可能会遇到这样的情况：如要对集群进行停机维护/扩容</strong><br>那么这时候需要执行一次Savepoint也就是执行一次手动的Checkpoint/也就是手动的发一个barrier栅栏，那么这样的话，程序的所有状态都会被执行快照并保存，当维护/扩容完毕之后,可以从上一次Savepoint的目录中进行恢复！</p><h3 id="4-2-Savepoint-VS-Checkpoint">4.2 Savepoint VS Checkpoint</h3><p><img src="https://img-blog.csdnimg.cn/20210519143126143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>目标</strong><ul><li>从概念上讲，Savepoints和Checkpoints的不同之处类似于传统数据库中备份和恢复日志的不同。Checkpoints的作用是确保程序有潜在失败可能的情况下（如网络暂时异常），可以正常恢复。相反，Savepoints的作用是让用户手动触发备份后，通过重启来恢复程序</li></ul></li><li><strong>实现</strong><ul><li>Checkpoints和Savepoints在实现上有所不同。Checkpoints轻量并且快速，它可以利用底层状态存储的各种特性，来实现快速备份和恢复。例如，以RocksDB作为状态存储，状态将会以RocksDB的格式持久化而不是Flink原生的格式，同时利用RocksDB的特性实现了增量Checkpoints。这个特性加速了checkpointing的过程，也是Checkpointing机制中第一个更轻量的实现。相反，Savepoints更注重数据的可移植性，并且支持任何对任务的修改，同时这也让Savepoints的备份和恢复成本相对更高。</li></ul></li><li><strong>生命周期</strong><ul><li>Checkpoints本身是定时自动触发的。它们的维护、创建和删除都由Flink自身来操作，不需要任何用户的干预。相反，Savepoints的触发、删除和管理等操作都需要用户手动触发。</li></ul></li></ul><table><tr align=center><th>维度</th><th>Checkpoints</th><th>Savepoints</th></tr><tr align=center><td>目标</td><td>任务失败的恢复/故障转移机制</td><td>手动备份/重启/恢复任务</td></tr><tr align=center><td>实现</td><td>轻量快速</td><td>注重可移植性，成本较高</td></tr><tr align=center><td>生命周期</td><td>Flink自身控制</td><td>用户手动控制</td></tr></table><h3 id="4-3-Savepoint演示">4.3 Savepoint演示</h3><ol><li>启动yarn session<br>/export/server/flink/bin/yarn-session.sh -n 2 -tm 800 -s 1 -d</li><li>运行job-会自动执行Checkpoint<br>/export/server/flink/bin/flink run --class cn.itcast.checkpoint.CheckpointDemo01 /root/ckp.jar</li><li>手动创建savepoint–相当于手动做了一次Checkpoint<br>/export/server/flink/bin/flink savepoint702b872ef80f08854c946a544f2ee1a5 hdfs://node1:8020/flink-checkpoint/savepoint/</li><li>停止job<br>/export/server/flink/bin/flink cancel 702b872ef80f08854c946a544f2ee1a5</li><li>重新启动job,手动加载savepoint数据<br>/export/server/flink/bin/flink run -s hdfs://node1:8020/flink-checkpoint/savepoint/savepoint-702b87-0a11b997fa70 --class cn.itcast.checkpoint.CheckpointDemo01 /root/ckp.jar</li><li>停止yarn session<br>yarn application -kill application_1607782486484_0014</li></ol><h2 id="5-关于并行度">5. 关于并行度</h2><p>一个Flink程序由多个Operator组成(source、transformation和 sink)。<br>一个Operator由多个并行的Task(线程)来执行，一个Operator的并行Task(线程)数目就被称为该Operator(任务)的并行度(Parallel)<br>并行度可以有如下几种指定方式：</p><ol><li>Operator Level（算子级别）(可以使用)<br>一个算子、数据源和sink的并行度可以通过调用 setParallelism()方法来指定<br><img src="https://img-blog.csdnimg.cn/20210519145653361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>Execution Environment Level（Env级别）(可以使用)<br>执行环境(任务)的默认并行度可以通过调用setParallelism()方法指定。为了以并行度3来执行所有的算子、数据源和data sink， 可以通过如下的方式设置执行环境的并行度：<br>执行环境的并行度可以通过显式设置算子的并行度而被重写<br><img src="https://img-blog.csdnimg.cn/20210519145823848.png" alt="在这里插入图片描述"></li><li>Client Level（客户端级别,推荐使用）（可以使用）<br>并行度可以在客户端将job提交到Flink时设定<br>对于CLI客户端，可以通过-p参数指定并行度：<br>./bin/flink run -p 10 WordCount-java.jar</li><li>System Level（系统默认级别,尽量不使用）<br>在系统级可以通过设置flink-conf.yaml文件中的parallelism.default属性来指定所有执行环境的默认并行度<br><img src="https://img-blog.csdnimg.cn/20210519150030632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210519150138860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ul><li>Example1：<ul><li>在fink-conf.yaml中 taskmanager.numberOfTaskSlots 默认值为1，即每个Task Manager上只有一个Slot ，此处是3</li><li>Example1中，WordCount程序设置了并行度为1，意味着程序 Source、Reduce、Sink在一个Slot中，占用一个Slot</li></ul></li><li>Example2：<ul><li>通过设置并行度为2后，将占用2个Slot</li></ul></li><li>Example3：<ul><li>通过设置并行度为9，将占用9个Slot</li></ul></li><li>Example4：<ul><li>通过设置并行度为9，并且设置sink的并行度为1，则Source、Reduce将占用9个Slot，但是Sink只占用1个Slot</li></ul></li></ul><p><strong><font color=red>注：</font></strong></p><ul><li>并行度的优先级：算子级别 &gt; env级别 &gt; Client级别 &gt; 系统默认级别  (越靠前具体的代码并行度的优先级越高)</li><li>如果source不可以被并行执行，即使指定了并行度为多个，也不会生效</li><li>在实际生产中，我们推荐在算子级别显示指定各自的并行度，方便进行显示和精确的资源控制</li><li>slot是静态的概念，是指taskmanager具有的并发执行能力; parallelism是动态的概念，是指程序运行时实际使用的并发能力</li></ul><h1 id="十、Table-API-与SQL">十、Table API 与SQL</h1><p>Table API 是流处理和批处理通用的关系型 API，Table API 可以基于流输入或者批输入来运行而不需要进行任何修改。Table API 是 SQL 语言的超集并专门为 Apache Flink 设计的，Table API 是 Scala 和 Java 语言集成式的 API。与常规 SQL 语言中将查询指定为字符串不同，Table API 查询是以 Java 或 Scala 中的语言嵌入样式来定义的， 具有 IDE 支持如:自动完成和语法检测。</p><h2 id="1-Table-API-SQL的特点">1. Table API &amp; SQL的特点</h2><p>Flink之所以选择将 Table API &amp; SQL 作为未来的核心 API，是因为其具有一些非常重要的特点：<br><img src="https://img-blog.csdnimg.cn/20210519152722120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>声明式:属于设定式语言，用户只要表达清楚需求即可，不需要了解底层执行</li><li>高性能:可优化，内置多种查询优化器，这些查询优化器可为 SQL 翻译出最优执行计划</li><li>简单易学:易于理解，不同行业和领域的人都懂，学习成本较低</li><li>标准稳定:语义遵循SQL标准，非常稳定，在数据库 30 多年的历史中，SQL 本身变化较少</li><li>流批统一:可以做到API层面上流与批的统一，相同的SQL逻辑，既可流模式运行，也可批模式运行，Flink底层Runtime本身就是一个流与批统一的引擎</li></ol><h2 id="2-Table-API-SQL发展历程">2. Table API &amp; SQL发展历程</h2><h3 id="2-1-架构升级">2.1 架构升级</h3><p>自 2015 年开始，阿里巴巴开始调研开源流计算引擎，最终决定基于 Flink 打造新一代计算引擎，针对 Flink 存在的不足进行优化和改进，并且在 2019 年初将最终代码开源，也就是Blink。Blink 在原来的 Flink 基础上最显著的一个贡献就是 Flink SQL 的实现。随着版本的不断更新，API 也出现了很多不兼容的地方。<br>在 Flink 1.9 中，Table 模块迎来了核心架构的升级，引入了阿里巴巴Blink团队贡献的诸多功能<br><img src="https://img-blog.csdnimg.cn/20210519153027176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在Flink 1.9 之前，Flink API 层 一直分为DataStream API 和 DataSet API，Table API &amp; SQL 位于 DataStream API 和 DataSet API 之上。可以看处流处理和批处理有各自独立的api (流处理DataStream，批处理DataSet)。而且有不同的执行计划解析过程，codegen过程也完全不一样，完全没有流批一体的概念，面向用户不太友好。<br>在Flink1.9之后新的架构中，有两个查询处理器：Flink Query Processor，也称作Old Planner和Blink Query Processor，也称作Blink Planner。为了兼容老版本Table及SQL模块，插件化实现了Planner，Flink原有的Flink Planner不变，后期版本会被移除。新增加了Blink Planner，新的代码及特性会在Blink planner模块上实现。批或者流都是通过解析为Stream Transformation来实现的，不像Flink Planner，批是基于Dataset，流是基于DataStream。</p><h3 id="2-2-查询处理器的选择">2.2 查询处理器的选择</h3><p>查询处理器是 Planner 的具体实现，通过parser、optimizer、codegen(代码生成技术)等流程将 Table API &amp; SQL作业转换成 Flink Runtime 可识别的 Transformation DAG，最终由 Flink Runtime 进行作业的调度和执行。<br>Flink Query Processor查询处理器针对流计算和批处理作业有不同的分支处理，流计算作业底层的 API 是 DataStream API， 批处理作业底层的 API 是 DataSet API<br>Blink Query Processor查询处理器则实现流批作业接口的统一，底层的 API 都是Transformation，这就意味着我们和Dataset完全没有关系了<br>Flink1.11之后Blink Query Processor查询处理器已经是默认的了</p><ul><li>了解-Blink planner和Flink Planner具体区别如下：<ul><li>Blink将批处理作业视为流式处理的特殊情况。因此，表和数据集之间的转换也不受支持，批处理作业不会转换为数据集程序，而是转换为数据流程序，与流作业相同</li><li>Blink planner不支持Batch TableSource</li><li>old planner和Blink planner的FilterableSource实现不兼容</li><li>基于字符串的键值配置选项仅用于Blink planner</li><li>PlannerConfig在两个planners中的实现（CalciteConfig）是不同的</li><li>Blink planner将在TableEnvironment和StreamTableEnvironment上将多个汇优化为一个DAG。旧的计划者总是将每个水槽优化为一个新的DAG，其中所有DAG彼此独立</li><li>旧的计划期现在不支持目录统计，而Blink计划器支持</li></ul></li></ul><h3 id="2-3-注意">2.3 注意</h3><ul><li><strong>API 稳定性</strong><br><img src="https://img-blog.csdnimg.cn/20210519154342961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>性能对比</strong><ul><li>目前FlinkSQL性能不如SparkSQL，未来FlinkSQL可能会越来越好（下图是Hive、Spark、Flink的SQL执行速度对比）<br><img src="https://img-blog.csdnimg.cn/20210519154428147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h2 id="3-需要引入的pom依赖">3. 需要引入的pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-scala-bridge_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-简单了解TableAPI">4. 简单了解TableAPI</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment env.setParallelism(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> inputStream = env.readTextFile(<span class="string">&quot;..\\sensor.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dataStream = inputStream</span><br><span class="line">.map( data =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 基于env 创建 tableEnv</span></span><br><span class="line"><span class="keyword">val</span> settings: <span class="type">EnvironmentSettings</span> = <span class="type">EnvironmentSettings</span>.newInstance().useOldPlanner().inStreamingMode().build()</span><br><span class="line"><span class="keyword">val</span> tableEnv: <span class="type">StreamTableEnvironment</span> = <span class="type">StreamTableEnvironment</span>.create(env, settings)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一条流创建一张表</span></span><br><span class="line"><span class="keyword">val</span> dataTable: <span class="type">Table</span> = tableEnv.fromDataStream(dataStream)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从表里选取特定的数据</span></span><br><span class="line"><span class="keyword">val</span> selectedTable: <span class="type">Table</span> = dataTable.select(&#x27;id, &#x27;temperature).filter(<span class="string">&quot;id = &#x27;sensor_1&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> selectedStream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = selectedTable.toAppendStream[(<span class="type">String</span>, <span class="type">Double</span>)] </span><br><span class="line"></span><br><span class="line">selectedStream.print()</span><br><span class="line"></span><br><span class="line">env.execute(<span class="string">&quot;table test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-动态表">4.1 动态表</h3><p>如果流中的数据类型是 case class 可以直接根据 case class 的结构生成 table</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.fromDataStream(dataStream)</span><br></pre></td></tr></table></figure><p>或者根据字段顺序单独命名</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.fromDataStream(dataStream,’id,’timestamp........)</span><br></pre></td></tr></table></figure><p>最后的动态表可以转换为流进行输出</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.toAppendStream[(<span class="type">String</span>,<span class="type">String</span>)]</span><br></pre></td></tr></table></figure><h3 id="4-2-字段">4.2 字段</h3><p>用一个单引放到字段前面来标识字段名, 如 ‘name , ‘id ,’amount 等。</p><h2 id="5-TableAPI-的窗口聚合操作">5. TableAPI 的窗口聚合操作</h2><h3 id="5-1-案例演示">5.1 案例演示</h3><ul><li>统计每10 秒中每个传感器温度值的个数</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计每10 秒中每个传感器温度值的个数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> inputStream = env.readTextFile(<span class="string">&quot;..\\sensor.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> dataStream = inputStream</span><br><span class="line">.map( data =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125;)</span><br><span class="line">.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="type">Time</span>.seconds(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">SensorReading</span>): <span class="type">Long</span> = element.timestamp * <span class="number">1000</span>L</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于env 创建 tableEnv</span></span><br><span class="line"><span class="keyword">val</span> settings: <span class="type">EnvironmentSettings</span> = <span class="type">EnvironmentSettings</span>.newInstance().useOldPlanner().inStreamingMode().build()</span><br><span class="line"><span class="keyword">val</span> tableEnv: <span class="type">StreamTableEnvironment</span> = <span class="type">StreamTableEnvironment</span>.create(env, settings)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一条流创建一张表，按照字段去定义，并指定事件时间的时间字段</span></span><br><span class="line"><span class="keyword">val</span> dataTable: <span class="type">Table</span> = tableEnv.fromDataStream(dataStream, &#x27;id, &#x27;temperature, &#x27;ts.rowtime)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照时间开窗聚合统计</span></span><br><span class="line"><span class="keyword">val</span> resultTable: <span class="type">Table</span> = dataTable</span><br><span class="line">.window( <span class="type">Tumble</span> over <span class="number">10.</span>seconds on &#x27;ts as &#x27;tw )</span><br><span class="line">.groupBy(&#x27;id, &#x27;tw)</span><br><span class="line">.select(&#x27;id, &#x27;id.count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> selectedStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = resultTable.toRetractStream[(<span class="type">String</span>, <span class="type">Long</span>)]</span><br><span class="line"></span><br><span class="line">selectedStream.print()</span><br><span class="line">env.execute(<span class="string">&quot;table window test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-关于-group-by">5.2 关于 group by</h3><ol><li>如果了使用 groupby， table 转换为流的时候只能用 toRetractDstream</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = table</span><br><span class="line">.toRetractStream[(<span class="type">String</span>,<span class="type">Long</span>)]</span><br></pre></td></tr></table></figure><ol start="2"><li>toRetractDstream 得到的第一个 boolean 型字段标识 true 就是最新的数据(Insert)， false 表示过期老数据(Delete)</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = table</span><br><span class="line">.toRetractStream[(<span class="type">String</span>,<span class="type">Long</span>)]</span><br><span class="line">dataStream.filter(_._1).print()</span><br></pre></td></tr></table></figure><ol start="3"><li>如果使用的 api 包括时间窗口， 那么窗口的字段必须出现在 groupBy 中</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultTable: <span class="type">Table</span> = dataTable</span><br><span class="line">.window( <span class="type">Tumble</span> over <span class="number">10.</span>seconds on &#x27;ts as &#x27;tw )</span><br><span class="line">.groupBy(&#x27;id, &#x27;tw)</span><br><span class="line">.select(&#x27;id, &#x27;id.count)</span><br></pre></td></tr></table></figure><h3 id="5-3-关于时间窗口">5.3 关于时间窗口</h3><ol><li>用到时间窗口， 必须提前声明时间字段， 如果是 processTime 直接在创建动态表时进行追加就可以</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>dataTable: <span class="type">Table</span> = tableEnv.fromDataStream(dataStream, &#x27;id, &#x27;temperature, &#x27;ps.proctime)</span><br></pre></td></tr></table></figure><ol start="2"><li>如果是 EventTime 要在创建动态表时声明</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>dataTable: <span class="type">Table</span> = tableEnv.fromDataStream(dataStream, &#x27;id, &#x27;temperature, &#x27;ts.rowtime)</span><br></pre></td></tr></table></figure><ol start="3"><li>滚动窗口可以使用 Tumble over 10000.millis on 来表示</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultTable: <span class="type">Table</span> = dataTable</span><br><span class="line">.window( <span class="type">Tumble</span> over <span class="number">10.</span>seconds on &#x27;ts as &#x27;tw )</span><br><span class="line">.groupBy(&#x27;id, &#x27;tw)</span><br><span class="line">.select(&#x27;id, &#x27;id.count)</span><br></pre></td></tr></table></figure><h2 id="6-SQL-如何编写">6. SQL 如何编写</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计每10 秒中每个传感器温度值的个数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment env.setParallelism(<span class="number">1</span>)</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> inputStream = env.readTextFile(<span class="string">&quot;..\\sensor.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> dataStream = inputStream</span><br><span class="line">.map( data =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125;)</span><br><span class="line">.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="type">Time</span>.seconds(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">SensorReading</span>): <span class="type">Long</span> = element.timestamp * <span class="number">1000</span>L</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于env 创建 tableEnv</span></span><br><span class="line"><span class="keyword">val</span> settings: <span class="type">EnvironmentSettings</span> = <span class="type">EnvironmentSettings</span>.newInstance().useOldPlanner().inStreamingMode().build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tableEnv: <span class="type">StreamTableEnvironment</span> = <span class="type">StreamTableEnvironment</span>.create(env, settings)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一条流创建一张表，按照字段去定义，并指定事件时间的时间字段</span></span><br><span class="line"><span class="keyword">val</span>dataTable:<span class="type">Table</span>=tableEnv.fromDataStream(dataStream,&#x27;id, &#x27;temperature, &#x27;ts.rowtime)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接写sql 完成开窗统计</span></span><br><span class="line"><span class="keyword">val</span> resultSqlTable: <span class="type">Table</span> = tableEnv.sqlQuery(<span class="string">&quot;select id, count(id) from &quot;</span> + dataTable + <span class="string">&quot; group by id, tumble(ts, interval &#x27;15&#x27; second)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> selectedStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = resultSqlTable.toRetractStream[(<span class="type">String</span>, <span class="type">Long</span>)]</span><br><span class="line"></span><br><span class="line">selectedStream.print()</span><br><span class="line">env.execute(<span class="string">&quot;table window test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-相关概念">7. 相关概念</h2><h3 id="7-1-Dynamic-Tables-Continuous-Queries">7.1 Dynamic Tables &amp; Continuous Queries</h3><p>在Flink中，它把针对无界流的表称之为Dynamic Table（动态表），是Flink Table API和SQL的核心概念。顾名思义，它表示了Table是不断变化的。<br>我们可以这样来理解，当我们用Flink的API，建立一个表，其实把它理解为建立一个逻辑结构，这个逻辑结构需要映射到数据上去。Flink source源源不断的流入数据，就好比每次都往表上新增一条数据。表中有了数据，我们就可以使用SQL去查询了。要注意一下，流处理中的数据是只有新增的，所以看起来数据会源源不断地添加到表中。<br>动态表也是一种表，既然是表，就应该能够被查询。我们来回想一下原先我们查询表的场景：</p><ol><li>将SQL语句放入到mysql的终端执行</li><li>查看结果</li><li>再编写一条SQL语句</li><li>再放入到终端执行</li><li>再查看结果<br>…如此反复</li></ol><p>而针对动态表，Flink的source端肯定是源源不断地会有数据流入，然后我们基于这个数据流建立了一张表，再编写SQL语句查询数据，进行处理。这个SQL语句一定是不断地执行的。而不是只执行一次。注意：针对流处理的SQL绝对不会像批式处理一样，执行一次拿到结果就完了。而是会不停地执行，不断地查询获取结果处理。所以，官方给这种查询方式取了一个名字，叫Continuous Query，中文翻译过来叫连续查询。而且每一次查询出来的数据也是不断变化的。<br><img src="https://img-blog.csdnimg.cn/20210519162930496.png#pic_center" alt="在这里插入图片描述"><br>这是一个非常简单的示意图。该示意图描述了：我们通过建立动态表和连续查询来实现在无界流中的SQL操作。大家也可以看到，在Continuous上面有一个State，表示查询出来的结果会存储在State中，再下来Flink最终还是使用流来进行处理。<br>所以，我们可以理解为Flink的Table API和SQL，是一个逻辑模型，通过该逻辑模型可以让我们的数据处理变得更加简单。<br><img src="https://img-blog.csdnimg.cn/20210519163021191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210519163033602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="7-2-Table-to-Stream-Conversion">7.2 Table to Stream Conversion</h3><h4 id="7-2-1-表中的Update和Delete">7.2.1 表中的Update和Delete</h4><p>我们前面提到的表示不断地Append，表的数据是一直累加的，因为表示对接Source的，Source是不会有update的。但如果我们编写了一个SQL。这个SQL看起来是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">sum</span>(money) <span class="keyword">FROM</span> <span class="keyword">order</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>当执行一条SQL语句之后，这条语句的结果还是一个表，因为在Flink中执行的SQL是Continuous Query，这个表的数据是不断变化的。新创建的表存在Update的情况。仔细看下下面的示例，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条数据，张三,2000，执行这条SQL语句的结果是，张三,2000</span><br><span class="line">第二条数据，李四,1500，继续执行这条SQL语句，结果是，张三,2000 | 李四,1500</span><br><span class="line">第三条数据，张三,300，继续执行这条SQL语句，结果是，张三,2300 | 李四,1500</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>大家发现了吗，现在数据结果是有Update的。张三一开始是2000，但后面变成了2300。<br>那还有删除的情况吗？有的。看一下下面这条SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.`<span class="keyword">user</span>`, <span class="built_in">SUM</span>(t1.`money`) <span class="keyword">FROM</span> t_order t1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> T2.`<span class="keyword">user</span>`<span class="keyword">AS</span> TOTAL_MONEY <span class="keyword">FROM</span> t_order t2 <span class="keyword">WHERE</span> T2.`<span class="keyword">user</span>` <span class="operator">=</span> T1.`<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t2.`<span class="keyword">user</span>` <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(T2.`money`) <span class="operator">&gt;</span> <span class="number">3000</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.`<span class="keyword">user</span>`<span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.`<span class="keyword">user</span>`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条数据，张三,2000，执行这条SQL语句的结果是，张三,2000</span><br><span class="line">第二条数据，李四,1500，继续执行这条SQL语句，结果是，张三,2000 | 李四,1500</span><br><span class="line">第三条数据，张三,300，继续执行这条SQL语句，结果是，张三,2300 | 李四,1500</span><br><span class="line">第四条数据，张三,800，继续执行这条SQL语句，结果是，李四,1500</span><br></pre></td></tr></table></figure><p>因为张三的消费的金额已经超过了3000，所以SQL执行完后，张三是被处理掉了。从数据的角度来看，它不就是被删除了吗？</p><p>通过上面的两个示例，给大家演示了，在Flink SQL中，对接Source的表都是Append-only的，不断地增加。执行一些SQL生成的表，这个表可能是要UPDATE的、也可能是要INSERT的。</p><h4 id="7-2-2-对表的编码操作">7.2.2 对表的编码操作</h4><p>我们前面说到过，表是一种逻辑结构。而Flink中的核心还是Stream。所以，Table最终还是会以Stream方式来继续处理。如果是以Stream方式处理，最终Stream中的数据有可能会写入到其他的外部系统中，例如：将Stream中的数据写入到MySQL中。<br>我们前面也看到了，表是有可能会UPDATE和DELETE的。那么如果是输出到MySQL中，就要执行UPDATE和DELETE语句了。而DataStream我们在学习Flink的时候就学习过了，DataStream是不能更新、删除事件的。<br>如果对表的操作是INSERT，这很好办，直接转换输出就好，因为DataStream数据也是不断递增的。但如果一个TABLE中的数据被UPDATE了、或者被DELETE了，如果用流来表达呢？因为流不可变的特征，我们肯定要对这种能够进行UPDATE/DELETE的TABLE做特殊操作。<br>我们可以针对每一种操作，INSERT/UPDATE/DELETE都用一个或多个经过编码的事件来表示。<br>例如：针对UPDATE，我们用两个操作来表达，[DELETE] 数据+  [INSERT]数据。也就是先把之前的数据删除，然后再插入一条新的数据。针对DELETE，我们也可以对流中的数据进行编码，[DELETE]数据。</p><p>总体来说，我们通过对流数据进行编码，也可以告诉DataStream的下游，[DELETE]表示发出MySQL的DELETE操作，将数据删除。用 [INSERT]表示插入新的数据。</p><h4 id="7-2-3-将表转换为三种不同编码方式的流">7.2.3 将表转换为三种不同编码方式的流</h4><p>Flink中的Table API或者SQL支持三种不同的编码方式。分别是：</p><ul><li><p>Append-only流</p><ul><li>跟INSERT操作对应。这种编码类型的流针对的是只会不断新增的Dynamic Table。这种方式好处理，不需要进行特殊处理，源源不断地往流中发送事件即可</li></ul></li><li><p>Retract流</p><ul><li>这种流就和Append-only不太一样。上面的只能处理INSERT，如果表会发生DELETE或者UPDATE，Append-only编码方式的流就不合适了。Retract流有几种类型的事件类型：<ul><li>ADD MESSAGE：这种消息对应的就是INSERT操作</li><li>RETRACT MESSAGE：直译过来叫取消消息。这种消息对应的就是DELETE操作</li></ul></li><li>我们可以看到通过ADD MESSAGE和RETRACT MESSAGE可以很好的向外部系统表达删除和插入操作。那如何进行UPDATE呢？好办！RETRACT MESSAGE + ADD MESSAGE即可。先把之前的数据进行删除，然后插入一条新的。完美~<br><img src="https://img-blog.csdnimg.cn/20210519163916523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li><li><p>Upsert流</p><ul><li>前面我们看到的RETRACT编码方式的流，实现UPDATE是使用DELETE + INSERT模式的。大家想一下：在MySQL中我们更新数据的时候，肯定不会先DELETE掉一条数据，然后再插入一条数据，肯定是直接发出UPDATE语句执行更新。而Upsert编码方式的流，是能够支持Update的，这种效率更高。它同样有两种类型的消息：<ul><li>UPSERT MESSAGE：这种消息可以表示要对外部系统进行Update或者INSERT操作</li><li>DELETE MESSAGE：这种消息表示DELETE操作</li></ul></li><li>Upsert流是要求必须指定Primary Key的，因为Upsert操作是要有Key的。Upsert流针对UPDATE操作用一个UPSERT MESSAGE就可以描述，所以效率会更高<br><img src="https://img-blog.csdnimg.cn/20210519164013878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h1 id="十一、Flink-CEP-简介">十一、Flink CEP 简介</h1><h2 id="1-什么是复杂事件处理CEP">1.  什么是复杂事件处理CEP</h2><p>一个或多个由简单事件构成的事件流通过一定的规则匹配， 然后输出用户想得到的数据， 满足规则的复杂事件。<br><strong>特征：</strong></p><ul><li>目标<ul><li>从有序的简单事件流中发现一些高阶特征</li></ul></li><li>输入<ul><li>一个或多个由简单事件构成的事件流</li></ul></li><li>处理<ul><li>识别简单事件之间的内在联系， 多个符合一定规则的简单事件构成复杂事件</li></ul></li><li>输出<ul><li>满足规则的复杂事件</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210519165155380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CEP 用于分析低延迟、频繁产生的不同来源的事件流。CEP 可以帮助在复杂的、不相关的事件流中找出有意义的模式和复杂的关系，以接近实时或准实时的获得通知并阻止一些行为。<br>CEP 支持在流上进行模式匹配， 根据模式的条件不同， 分为连续的条件或不连续的条件；模式的条件允许有时间的限制，当在条件范围内没有达到满足的条件时，  会导致模式匹配超时。<br>看起来很简单， 但是它有很多不同的功能：</p><ul><li>输入的流数据， 尽快产生结果</li><li>在 2 个 event 流上， 基于时间进行聚合类的计算</li><li>提供实时/准实时的警告和通知</li><li>在多样的数据源中产生关联并分析模式</li><li>高吞吐、低延迟的处理</li></ul><p>市场上有多种 CEP 的解决方案， 例如 Spark、Samza、Beam 等， 但他们都没有提供专门的 library 支持。但是 Flink 提供了专门的 CEP library。</p><h2 id="2-Flink-CEP">2. Flink CEP</h2><p>Flink 为 CEP 提供了专门的 Flink CEP library， 它包含如下组件：</p><ul><li>Event Stream</li><li>pattern 定义</li><li>pattern 检测</li><li>生成 Alert</li></ul><p><img src="https://img-blog.csdnimg.cn/20210519165438959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先， 开发人员要在 DataStream 流上定义出模式条件， 之后 Flink CEP 引擎进行模式检测， 必要时生成告警。<br>为了使用 Flink CEP， 我们需要导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-cep_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-1-Event-Streams">2.1 Event Streams</h3><p>以登陆事件流为例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginEvent</span>(<span class="params">userId: <span class="type">String</span>, ip: <span class="type">String</span>, eventType: <span class="type">String</span>, eventTi me: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> loginEventStream = env.fromCollection(<span class="type">List</span>(</span><br><span class="line"><span class="type">LoginEvent</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="string">&quot;1558430842&quot;</span>),</span><br><span class="line"><span class="type">LoginEvent</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;192.168.0.2&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="string">&quot;1558430843&quot;</span>),</span><br><span class="line"><span class="type">LoginEvent</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;192.168.0.3&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="string">&quot;1558430844&quot;</span>),</span><br><span class="line"><span class="type">LoginEvent</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;192.168.10.10&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="string">&quot;1558430845&quot;</span>)</span><br><span class="line">)).assignAscendingTimestamps(_.eventTime.toLong)</span><br></pre></td></tr></table></figure><h3 id="2-2-Pattern-API">2.2 Pattern API</h3><p>每个 Pattern 都应该包含几个步骤，或者叫做 state。从一个 state 到另一个 state， 通常我们需要定义一些条件， 例如下列的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> loginFailPattern = <span class="type">Pattern</span>.begin[<span class="type">LoginEvent</span>](<span class="string">&quot;begin&quot;</span>)</span><br><span class="line">.where(_.eventType.equals(<span class="string">&quot;fail&quot;</span>))</span><br><span class="line">.next(<span class="string">&quot;next&quot;</span>)</span><br><span class="line">.where(_.eventType.equals(<span class="string">&quot;fail&quot;</span>))</span><br><span class="line">.within(<span class="type">Time</span>.seconds(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>每个 state 都应该有一个标示： 例如.begin<a href="%22begin%22">LoginEvent</a>中的&quot;begin&quot;<br>每个 state 都需要有一个唯一的名字， 而且需要一个 filter 来过滤条件， 这个过滤条件定义事件需要符合的条件， 例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.where(_.eventType.equals(<span class="string">&quot;fail&quot;</span>))</span><br></pre></td></tr></table></figure><p>我们也可以通过 subtype 来限制 event 的子类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start.subtype(<span class="type">SubEvent</span>.<span class="keyword">class</span>).where(...);</span><br></pre></td></tr></table></figure><p>事实上，你可以多次调用 subtype 和 where 方法；而且如果 where 条件是不相关 的，你可以通过 or 来指定一个单独的 filter 函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.where(...).or(...);</span><br></pre></td></tr></table></figure><p>之后，我们可以在此条件基础上，通过 next 或者 followedBy 方法切换到下一个 state，next 的意思是说上一步符合条件的元素之后紧挨着的元素；而 followedBy 并 不要求一定是挨着的元素。这两者分别称为严格近邻和非严格近邻。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strictNext = start.next(<span class="string">&quot;middle&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> nonStrictNext = start.followedBy(<span class="string">&quot;middle&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后，我们可以将所有的 Pattern 的条件限定在一定的时间范围内：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next.within(<span class="type">Time</span>.seconds(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>这个时间可以是 Processing Time，也可以是 Event Time。</p><h3 id="2-3-Pattern-检测">2.3 Pattern 检测</h3><p>通过一个 input DataStream 以及刚刚我们定义的 Pattern， 我们可以创建一个PatternStream：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> input = ...</span><br><span class="line"><span class="keyword">val</span> pattern = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> patternStream = <span class="type">CEP</span>.pattern(input, pattern)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> patternStream = <span class="type">CEP</span>.pattern(loginEventStream.keyBy(_.userId), loginFail <span class="type">Pattern</span>)</span><br></pre></td></tr></table></figure><p>一旦获得 PatternStream，我们就可以通过 select 或 flatSelect，从一个 Map 序列 找到我们需要的警告信息。</p><h3 id="2-4-select">2.4 select</h3><p>select 方法需要实现一个 PatternSelectFunction， 通过 select 方法来输出需要的警告。它接受一个 Map 对，包含 string/event，其中 key 为 state 的名字， event 则为真实的 Event。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> loginFailDataStream = patternStream</span><br><span class="line">.select((pattern: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">LoginEvent</span>]]) =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> first = pattern.getOrElse(<span class="string">&quot;begin&quot;</span>, <span class="literal">null</span>).iterator.next()</span><br><span class="line"><span class="keyword">val</span> second = pattern.getOrElse(<span class="string">&quot;next&quot;</span>, <span class="literal">null</span>).iterator.next()</span><br><span class="line"><span class="type">Warning</span>(first.userId, first.eventTime, second.eventTime, <span class="string">&quot;warning&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其返回值仅为 1 条记录。</p><h3 id="2-5-flatSelect">2.5 flatSelect</h3><p>通过实现 PatternFlatSelectFunction，实现与 select 相似的功能。唯一的区别就 是 flatSelect 方法可以返回多条记录，它通过一个 Collector[OUT]类型的参数来将要 输出的数据传递到下游。</p><h3 id="2-6-超时事件的处理">2.6 超时事件的处理</h3><p>通过 within 方法，我们的 parttern 规则将匹配的事件限定在一定的窗口范围内。 当有超过窗口时间之后到达的 event，我们可以通过在 select 或 flatSelect 中，实现 PatternTimeoutFunction 和 PatternFlatTimeoutFunction 来处理这种情况。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> patternStream: <span class="type">PatternStream</span>[<span class="type">Event</span>] = <span class="type">CEP</span>.pattern(input, pattern)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> outputTag = <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">&quot;side-output&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">SingleOutputStreamOperator</span>[<span class="type">ComplexEvent</span>] = patternStream.select(outputTag)&#123;</span><br><span class="line">(pattern: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Event</span>]], timestamp: <span class="type">Long</span>) =&gt; <span class="type">TimeoutEvent</span>()</span><br><span class="line">&#125; &#123;</span><br><span class="line">pattern: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Event</span>]] =&gt; <span class="type">ComplexEvent</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> timeoutResult: <span class="type">DataStream</span>&lt;<span class="type">TimeoutEvent</span>&gt; = result.getSideOutput(outputTa g)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据开发必备技能，Scala 零基础笔记</title>
      <link href="/2021/04/10/scala_1/"/>
      <url>/2021/04/10/scala_1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、scala的定义">一、scala的定义</h1><h2 id="语言特点">语言特点</h2><p><strong>Scala是一门以Java虚拟机（JVM）为运行环境并将<font color=red >面向对象</font>和<font color=red >函数式编程</font>的最佳特性结合在一起的<font color=red >静态类型编程语言</font>（静态语言需要提前编译的如：Java、c、c++等，动态语言如：js）</strong></p><ul><li><strong>Scala是一门<font color=red >多范式</font>的编程语言，支持面向对象和函数式编程（多范式，就是多种编程方法的意思。有面向过程、面向对象、泛型、函数式四种程序设计方法）</strong></li><li><strong>Scala源代码（.scala）会被编译成Java字节码（.class），然后运行于JVM之上，<font color=red >并可以调用现有的Java类库，实现两种语言的无缝对接</font></strong></li><li><strong>Scala单作为一门语言来看，非常的<font color=red >简洁高效</font></strong></li><li><strong>Scala在设计时，马丁·奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁·奥德斯基也加入了自己的思想，将<font color=red >函数式编程语言的特点融合到Java中</font>, 因此，对于学习过Java的同学，只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的掌握Scala这门语言</strong></li></ul><h2 id="环境搭建及插件安装">环境搭建及插件安装</h2><h3 id="1-环境搭建">1.环境搭建</h3><ul><li><strong>首先确保JDK1.8安装成功</strong></li><li><strong>下载对应的 Scala 安装文件并解压</strong></li><li><strong>配置Scala的环境变量</strong></li></ul><h3 id="2-插件安装">2.插件安装</h3><ul><li><strong>在线安装（推荐）</strong><ul><li>在搜索插件框里面输入 Scala-&gt;点击 Install-&gt;点击 ok-&gt;点击 apply</li></ul></li><li><strong>离线安装</strong><ul><li>将插件放在Scala的安装目录下（这里就不放资源了，有需要的小伙伴可上网下载，网上的这种资源一搜就有）</li><li>打开IDEA，点击左上角File-&gt;点击下拉框的Settings…-&gt;点击Plugins-&gt;点击右下角Install plugin from disk… ， 找到自己对应的插件存储路径，最后点击ok即可</li></ul></li></ul><h2 id="HelloWorld案例">HelloWorld案例</h2><ul><li><strong>打开 IDEA-&gt;点击左侧的 Flie-&gt;选择 New-&gt;选择 Project…</strong></li><li><strong>创建一个 Maven 工程，并点击 next</strong></li><li><strong>输入自定义的GroupId和ArtifactId，然后点击Next（<font color=red >工程存储路径一定不能有中文和空格</font>）</strong></li><li><strong>指定项目工作目录空间</strong></li><li><strong>Maven默认不支持Scala的开发，需要引入Scala的框架</strong><ul><li>在自己创建的项目上，右击键-&gt;Add Framework Support…-&gt;选择Scala-&gt;点击OK（如果是第一次引入需要选择自己的Scala安装目录，工具就会自动识别）</li></ul></li><li><strong>创建项目的源文件目录</strong><ul><li>右键点击main目录-&gt;New-&gt;点击Diretory-&gt;写个名字（比如 scala）</li><li>右键点击scala目录-&gt;Mark Directory as-&gt;选择Sources root，可以看到文件夹颜色发生了变化</li></ul></li><li><strong>在scala包下，创建包com.demo包名和Hello类名</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  object:关键字，声明一个单例对象（伴生对象）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      main方法：从外部可以直接调用执行的方法</span></span><br><span class="line"><span class="comment">      def 方法名称(参数名称 : 参数类型): 返回值类型 = &#123;方法体&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;hello word&quot;</span>)</span><br><span class="line">    <span class="type">System</span>.out.println(<span class="string">&quot;hello word&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello word</span><br><span class="line">hello word</span><br></pre></td></tr></table></figure><h1 id="二、变量和数据类型">二、变量和数据类型</h1><h2 id="注释">注释</h2><p><strong>Scala注释使用和Java完全一样</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文档注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="变量和常量">变量和常量</h2><p><strong>常量指在程序执行的过程中，其值不会被改变的变量</strong></p><ul><li><strong>基本语法</strong><ul><li>var 变量名 [: 变量类型] = 初始值<ul><li>var i : Int = 10</li></ul></li><li>val 常量名 [: 常量类型] = 初始值<ul><li>val j : Int = 20</li></ul></li><li><font color=red >Scala中能用常量的地方不用变量</font></li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//    声明一个变量的通用语法</span></span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">//    1)声明变量时，类型可以省略，编译器自动推导，即类型推导</span></span><br><span class="line">    <span class="keyword">var</span> a1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> b1 = <span class="number">20</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    2)类型确定后，就不能修改，说明Scala是强数据类型语言</span></span><br><span class="line">    <span class="keyword">var</span> a2 = <span class="number">15</span> <span class="comment">//a2类型为Int</span></span><br><span class="line"><span class="comment">//    a2 = &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    3）变量声明时，必须有初始值</span></span><br><span class="line"><span class="comment">//    var a3: Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    4)在声明/定义一个变量时，可以使用var或者val来修饰，var修饰的变量可改变，val修饰的变量不可改</span></span><br><span class="line">    a1 = <span class="number">12</span></span><br><span class="line"><span class="comment">//    b1 = 21</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alice = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;alice&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    alice = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    alice = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> bob = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;bob&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    bob.age = <span class="number">24</span></span><br><span class="line">    bob.printInfo()</span><br><span class="line"><span class="comment">//    bob = new Student(&quot;Bob&quot;, 20)</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bob 24 atguigu</span><br></pre></td></tr></table></figure><h2 id="标识符的命名规范">标识符的命名规范</h2><p><strong>Scala 对各种变量、方法、函数等命名时使用的字符序列称为标识符（凡是自己可以起名字的地方都叫标识符）</strong></p><ul><li>以字母或者下划线开头，后接字母、数字、下划线</li><li>以操作符开头，且只包含操作符（+ - * / # !等）</li><li>用反引号`…`包括的任意字符串，即使是 Scala 关键字（39 个）也可以</li></ul><h2 id="字符串输出">字符串输出</h2><ul><li><strong>基本语法</strong><ul><li>字符串，通过+号连接</li><li>printf 用法：字符串，通过%传值</li><li>字符串模板（插值字符串）：通过$获取变量值</li></ul></li><li><strong>案例实操</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    1)字符串，通过+号连接</span></span><br><span class="line">    <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;alice&quot;</span></span><br><span class="line">    <span class="keyword">val</span> age: <span class="type">Int</span> = <span class="number">18</span></span><br><span class="line">    println(age + <span class="string">&quot;岁的&quot;</span> + name)</span><br><span class="line"><span class="comment">//    *用于将一个字符串复制多次并拼接</span></span><br><span class="line">    println(name * <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    2)printf用法：字符串，通过%传值</span></span><br><span class="line">    printf(<span class="string">&quot;%d岁的%s在学习&quot;</span>, age, name)</span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line"><span class="comment">//    3)字符串模板（插值字符串）：通过$获取变量值</span></span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$&#123;age&#125;</span>岁的<span class="subst">$&#123;name&#125;</span>在学习&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> num: <span class="type">Double</span> = <span class="number">2.345</span></span><br><span class="line">    println(<span class="string">f&quot;The num is <span class="subst">$&#123;num&#125;</span>%2.2f&quot;</span>)   <span class="comment">//格式化模板字符串</span></span><br><span class="line">    println(<span class="string">raw&quot;The num is <span class="subst">$&#123;num&#125;</span>%2.2f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    三引号表示字符串，保持多行字符串的原格式输出</span></span><br><span class="line">    <span class="keyword">val</span> sql = <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">       |select *</span></span><br><span class="line"><span class="string">       |from</span></span><br><span class="line"><span class="string">       |  student</span></span><br><span class="line"><span class="string">       |where</span></span><br><span class="line"><span class="string">       |  name = $&#123;name&#125;</span></span><br><span class="line"><span class="string">       |and</span></span><br><span class="line"><span class="string">       |  age &gt; $&#123;age&#125;</span></span><br><span class="line"><span class="string">       |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin</span><br><span class="line">    println(sql)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">18岁的alice</span><br><span class="line">alicealicealice</span><br><span class="line">18岁的alice在学习</span><br><span class="line">18岁的alice在学习</span><br><span class="line">The num is 2.35</span><br><span class="line">The num is 2.345%2.2f</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from</span><br><span class="line">  student</span><br><span class="line">where</span><br><span class="line">  name = alice</span><br><span class="line">and</span><br><span class="line">  age &gt; 18</span><br></pre></td></tr></table></figure><h2 id="键盘输入">键盘输入</h2><p><strong>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取</strong></p><ul><li><strong>基本语法</strong><ul><li>StdIn.readLine()、StdIn.readShort()、StdIn.readDouble()</li></ul></li><li><strong>案例实操</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    输入信息</span></span><br><span class="line">    println(<span class="string">&quot;请输入您的姓名：&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> name: <span class="type">String</span> = <span class="type">StdIn</span>.readLine()</span><br><span class="line">    println(<span class="string">&quot;请输入您的年龄：&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> age: <span class="type">Int</span> = <span class="type">StdIn</span>.readInt()</span><br><span class="line"></span><br><span class="line"><span class="comment">//    控制台打印输出</span></span><br><span class="line">    println(<span class="string">s&quot;欢迎<span class="subst">$&#123;age&#125;</span>岁的<span class="subst">$&#123;name&#125;</span>来到直播间&quot;</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入您的姓名：</span><br><span class="line">张三</span><br><span class="line">请输入您的年龄：</span><br><span class="line">31</span><br><span class="line">欢迎31岁的张三来到直播间</span><br></pre></td></tr></table></figure><h2 id="文件的读写操作">文件的读写操作</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    1)从文件中读取数据</span></span><br><span class="line">    <span class="type">Source</span>.fromFile(<span class="string">&quot;src/main/resources/test.txt&quot;</span>).foreach(print)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    2）将数据写入文件</span></span><br><span class="line">    <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;src/main/resources/inputtest.txt&quot;</span>))</span><br><span class="line">    writer.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello scala</span><br><span class="line">okok</span><br></pre></td></tr></table></figure><h2 id="数据类型">数据类型</h2><ul><li><strong>Scala中一切数据都是对象，都是Any的子类</strong></li><li><strong>Scala中数据类型分为两大类：数值类型（AnyVal）、引用类型（AnyRef），<font color=red >不管是值类型还是引用类型都是对象</font></strong></li><li><strong>Scala数据类型仍然遵守，<font color=red >低精度的值类型向高精度值类型自动转换</font>（隐式转换）</strong></li><li><strong>Scala中的StringOps是对Java中的String增强</strong></li><li><strong>Unit：对应Java中的void，用于方法返回值的位置，表示方法没有返回值。<font color=red >Unit是 一个数据类型</font>，只有一个对象就是<font color=red >()</font>。Void不是数据类型，只是一个关键字</strong></li><li><strong><font color=red >Null是一个类型</font>，只有一个对象就 是null。<font color=red >它是所有引用类型（AnyRef）的子类</font></strong></li><li><strong><font color=red >Nothing是所有数据类型的子类</font>，主要用在一个函数没有明确返回值时使用，因为这样我们可以把抛出的返回值，返回给任何的变量或者函数</strong></li></ul><h3 id="1-整数类型（Byte、Short、Int、Long）">1.整数类型（Byte、Short、Int、Long）</h3><p><strong>Scala的整数类型就是用于存放整数值的，比如12，30，3456等</strong></p><table><tr align=center><th>数据类型</th><th>描述</th></tr><tr align=center><td>Byte[1]</td><td align=left>8位有符号补码整数,数值区间为 -128到127</td></tr><tr align=center><td>Short[2]</td><td align=left>16位有符号补码整数，数值区间为 -32768到32767</td></tr><tr align=center><td>Int[4]</td><td align=left>32位有符号补码整数，数值区间为 -2147483648到2147483647</td></tr><tr align=center><td>Long[8]</td><td align=left>64位有符号补码整数，数值区间为 -9223372036854775808 到 9223372036854775807 = 2 的(64-1)次方-1</td></tr></table><ul><li><strong>Scala各整数类型有固定的表示范围和字段长度，不受具体操作的影响，以保证<br>Scala 程序的可移植性</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> n1:<span class="type">Byte</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">var</span> n2:<span class="type">Byte</span> = <span class="number">-128</span></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// var n3:Byte = 128</span></span><br><span class="line"><span class="comment">// var n4:Byte = -129</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Scala 的整型，默认为Int型，声明Long型，须后加‘l’或‘L’</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">var</span> n5 = <span class="number">10</span></span><br><span class="line">println(n5)</span><br><span class="line"><span class="keyword">var</span> n6 = <span class="number">9223372036854775807</span>L</span><br><span class="line">println(n6)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">9223372036854775807</span><br></pre></td></tr></table></figure><ul><li><strong>Scala程序中变量常声明为Int型，除非不足以表示大数，才使用Long</strong></li></ul><h3 id="2-浮点类型（Float、Double）">2.浮点类型（Float、Double）</h3><p><strong>Scala的浮点类型可以表示一个小数，比如 123.4f，7.8，0.12 等等</strong></p><table><tr align=center><th>数据类型</th><th>描述</th></tr><tr align=center><td>Float [4]</td><td align=left>32位, IEEE 754 标准的单精度浮点数</td></tr><tr align=center><td>Double [8]</td><td align=left>64位 IEEE 754 标准的双精度浮点数</td></tr></table><ul><li><strong>Scala 的浮点型常量默认为 Double 型，声明 Float 型常量，须后加“f”或“F”</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 在开发中需要高精度小数时，请选择 Double</span></span><br><span class="line"><span class="keyword">var</span> n7 = <span class="number">2.2345678912</span>f</span><br><span class="line"><span class="keyword">var</span> n8 = <span class="number">2.2345678912</span></span><br><span class="line">println(<span class="string">&quot;n7=&quot;</span> + n7)</span><br><span class="line">println(<span class="string">&quot;n8=&quot;</span> + n8)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n7=2.2345679</span><br><span class="line">n8=2.2345678912</span><br></pre></td></tr></table></figure><h3 id="3-字符类型（Char）">3.字符类型（Char）</h3><p><strong>字符类型（Char）可以表示单个字符</strong></p><ul><li><strong>字符常量是用单引号 ’ ’ 括起来的单个字符</strong></li><li><strong>\t ：一个制表位，实现对齐的功能</strong></li><li><strong>\n ：换行符</strong></li><li><strong>\\ ：表示 \</strong></li><li><strong>\&quot; ：表示&quot;</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1）字符常量是用单引号 &#x27; &#x27; 括起来的单个字符。</span></span><br><span class="line">    <span class="keyword">var</span> c1: <span class="type">Char</span> = &#x27;a&#x27;</span><br><span class="line">    println(<span class="string">&quot;c1=&quot;</span> + c1)</span><br><span class="line">    <span class="comment">//注意：这里涉及自动类型提升，其实编译器可以自定判断是否超出范围，</span></span><br><span class="line">    <span class="comment">//不过 idea 提示报错</span></span><br><span class="line"><span class="comment">//    var c2:Char = &#x27;a&#x27; + 1</span></span><br><span class="line"><span class="comment">//    println(c2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2）\t ：一个制表位，实现对齐的功能</span></span><br><span class="line">    println(<span class="string">&quot;姓名\t 年龄&quot;</span>)</span><br><span class="line">    <span class="comment">//3）\n ：换行符</span></span><br><span class="line">    println(<span class="string">&quot;西门庆\n 潘金莲&quot;</span>)</span><br><span class="line">    <span class="comment">//4）\\ ：表示\</span></span><br><span class="line">    println(<span class="string">&quot;c:\\user\\local&quot;</span>)</span><br><span class="line">    <span class="comment">//5）\&quot; ：表示&quot;</span></span><br><span class="line">    println(<span class="string">&quot;同学们都说：\&quot;hello scala\&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c1=a</span><br><span class="line">姓名 年龄</span><br><span class="line">西门庆</span><br><span class="line"> 潘金莲</span><br><span class="line">c:\user\local</span><br><span class="line">同学们都说：&quot;hello scala&quot;</span><br></pre></td></tr></table></figure><h3 id="4-布尔类型（Boolean）">4.布尔类型（Boolean）</h3><ul><li><strong>布尔类型也叫Boolean类型，Boolean类型数据只允许取值true和false</strong></li><li><strong>Boolean类型占1个字节</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> isResult : <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> isResult2 : <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="5-Unit类型、Null类型和Nothing类型">5.Unit类型、Null类型和Nothing类型</h3><table><tr align=center><th>数据类型</th><th>描述</th></tr><tr align=center><td>Unit</td><td align=left>表示无值，和其他语言中 void 等同。用作不返回任何结果的方法的结果类型。Unit 只有一个实例值，写成()</td></tr><tr align=center><td>Null</td><td align=left>null , Null 类型只有一个实例值 null</td></tr><tr align=center><td>Nothing</td><td align=left>Nothing 类型在 Scala 的类层级最低端；它是任何其他类型的子类型。当一个函数，我们确定没有正常的返回值，可以用 Nothing 来指定返回类型，这样有一个好处，就是我们可以把返回的值（异常）赋给其它的函数或者变量（兼容性）</td></tr></table><ul><li><strong>Unit 类型用来标识过程，也就是没有明确返回值的函数</strong></li><li><strong>由此可见，Unit 类似于 Java 里的 void，Unit 只有一个实例——( )，这个实例也没有实质意义</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayOk</span> </span>: <span class="type">Unit</span> = &#123;<span class="comment">// unit 表示没有返回值，即 void</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">println(sayOk)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()</span><br></pre></td></tr></table></figure><ul><li><strong>Null 类只有一个实例对象，Null 类似于 Java 中的 null 引用。Null 可以赋值给任意引用类型（AnyRef），但是不能赋值给值类型（AnyVal）</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//null 可以赋值给任意引用类型（AnyRef），但是不能赋值给值类型</span></span><br><span class="line">（<span class="type">AnyVal</span>）</span><br><span class="line"> <span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="type">Cat</span>();</span><br><span class="line"> cat = <span class="literal">null</span> <span class="comment">// 正确</span></span><br><span class="line"> <span class="keyword">var</span> n1: <span class="type">Int</span> = <span class="literal">null</span> <span class="comment">// 错误</span></span><br><span class="line"> println(<span class="string">&quot;n1:&quot;</span> + n1)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Nothing，可以作为没有正常返回值的方法的返回类型，非常直观的告诉你这个方法不会正常返回，而且由于 Nothing 是其他任意类型的子类，他还能跟要求返回值的方法兼容</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>() : <span class="type">Nothing</span>=&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>()</span><br><span class="line">&#125;</span><br><span class="line">test</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换">类型转换</h2><h3 id="1-类型自动转换">1.类型自动转换</h3><p><strong>当 Scala 程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数值类型，这个就是自动类型转换（隐式转换）。数据类型按精度（容量）大小排序为：</strong><br><img src="https://img-blog.csdnimg.cn/2021033015285326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>自动提升原则：有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度大的那种数据类型，然后再进行计算</strong></li><li><strong>把精度大的数值类型赋值给精度小的数值类型时，就会报错，反之就会进行自动类型转换</strong></li><li><strong>（byte，short）和 char 之间不会相互自动转换</strong></li><li><strong>byte，short，char 这三者可以计算，在计算时首先转换为 int 类型</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1）自动提升原则：有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度大的那种数值类型，然后再进行计算</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span> + <span class="number">2.0</span></span><br><span class="line">println(n) <span class="comment">// n 就是 Double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2）把精度大的数值类型赋值给精度小的数值类型时，就会报错，反之就会进行自动类型转换</span></span><br><span class="line"><span class="keyword">var</span> n2 : <span class="type">Double</span>= <span class="number">1.0</span></span><br><span class="line"><span class="comment">//var n3 : Int = n2 //错误，原因不能把高精度的数据直接赋值和低精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3）（byte，short）和 char 之间不会相互自动转换</span></span><br><span class="line"><span class="keyword">var</span> n4 : <span class="type">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//var c1 : Char = n4 //错误</span></span><br><span class="line"><span class="keyword">var</span> n5:<span class="type">Int</span> = n4</span><br><span class="line"></span><br><span class="line"><span class="comment">//4）byte，short，char 他们三者可以计算，在计算时首先转换为 int类型</span></span><br><span class="line"><span class="keyword">var</span> n6 : <span class="type">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> c2 : <span class="type">Char</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// var n : Short = n6 + c2 //当 n6 + c2 结果类型就是 int</span></span><br><span class="line"><span class="comment">// var n7 : Short = 10 + 90 //错误</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br></pre></td></tr></table></figure><h3 id="2-强制类型转换">2.强制类型转换</h3><p><strong>自动类型转换的逆过程，将精度大的数值类型转换为精度小的数值类型。使用时要加上强制转函数，但可能造成精度降低或溢出</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1）将数据由高精度转换为低精度，就需要使用到强制转换</span></span><br><span class="line">    <span class="keyword">var</span> n1: <span class="type">Int</span> = <span class="number">2.5</span>.toInt <span class="comment">// 这个存在精度损失</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2）强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</span></span><br><span class="line">    <span class="keyword">var</span> r1: <span class="type">Int</span> = <span class="number">10</span> * <span class="number">3.5</span>.toInt + <span class="number">6</span> * <span class="number">1.5</span>.toInt <span class="comment">// 10 *3 + 6*1 = 36</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> r2: <span class="type">Int</span> = (<span class="number">10</span> * <span class="number">3.5</span> + <span class="number">6</span> * <span class="number">1.5</span>).toInt <span class="comment">// 44.0.toInt = 44</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;r1=&quot;</span> + r1 + <span class="string">&quot; r2=&quot;</span> + r2)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r1=36 r2=44</span><br></pre></td></tr></table></figure><h3 id="3-数值类型和String类型转换">3.数值类型和String类型转换</h3><p><strong>在程序开发中，经常需要将基本数值类型转成 String 类型，或者将 String 类型转成基本数值类型</strong></p><ul><li><strong>基本类型转 String 类型（语法：将基本类型的值+“” 即可）</strong></li><li><strong>String 类型转基本数值类型（语法：s1.toInt、s1.toFloat、s1.toDouble、s1.toByte、s1.toLong、s1.toShort）</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（1）基本类型转 String 类型（语法：将基本类型的值+&quot;&quot; 即可）</span></span><br><span class="line">    <span class="keyword">var</span> str1 : <span class="type">String</span> = <span class="literal">true</span> + <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> str2 : <span class="type">String</span> = <span class="number">4.5</span> + <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> str3 : <span class="type">String</span> = <span class="number">100</span> +<span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（2）String 类型转基本数值类型（语法：调用相关 API）</span></span><br><span class="line">    <span class="keyword">var</span> s1 : <span class="type">String</span> = <span class="string">&quot;12&quot;</span></span><br><span class="line">    <span class="keyword">var</span> n1 : <span class="type">Byte</span> = s1.toByte</span><br><span class="line">    <span class="keyword">var</span> n2 : <span class="type">Short</span> = s1.toShort</span><br><span class="line">    <span class="keyword">var</span> n3 : <span class="type">Int</span> = s1.toInt</span><br><span class="line">    <span class="keyword">var</span> n4 : <span class="type">Long</span> = s1.toLong</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red >注意事项：</font>在将 String 类型转成基本数值类型时，要确保 String 类型能够转成有效的数据，比如我们可以把&quot;123&quot;，转成一个整数，但是不能把&quot;hello&quot;转成一个整数</strong></p><h1 id="三、运算符">三、运算符</h1><h2 id="算术运算符">算术运算符</h2><table><tr align=center><th>运算符</th><th>运算</th><th>范例</th><th>结果</th></tr><tr align=center><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr align=center><td>-</td><td>负号</td><td>b=4; -b</td><td>-4</td></tr><tr align=center><td>+</td><td>加</td><td>5+5</td><td>10</td></tr><tr align=center><td>-</td><td>减</td><td>6-4</td><td>2</td></tr><tr align=center><td>*</td><td>乘</td><td>3*4</td><td>12</td></tr><tr align=center><td>/</td><td>除</td><td>5/5</td><td>1</td></tr><tr align=center><td>%</td><td>取模（取余）</td><td>7%5</td><td>2</td></tr><tr align=center><td>+</td><td>字符串相加</td><td>"He"+"llo"</td><td>"hello"</td></tr></table><h2 id="关系运算符">关系运算符</h2><table><tr align=center><th>运算符</th><th>运算</th><th>范例</th><th>结果</th></tr><tr align=center><td>==</td><td>相等于</td><td>4==3</td><td>false</td></tr><tr align=center><td>!=</td><td>不等于</td><td>4 != 3</td><td>true</td></tr><tr align=center><td><</td><td>小于</td><td>4<3</td><td>false</td></tr><tr align=center><td>></td><td>大于</td><td>4>3</td><td>true</td></tr><tr align=center><td><=</td><td>小于等于</td><td>4<=3</td><td>false</td></tr><tr align=center><td>>=</td><td>大于等于</td><td>4>=3</td><td>true</td></tr></table><ul><li><strong>Java</strong><ul><li>==比较两个变量本身的值，即两个对象在内存中的首地址</li><li>equals比较字符串中所包含的内容是否相同</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><ul><li><strong>Scala</strong><ul><li>==更类似于Java中equals</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> s1 = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">println(s1 == s2)</span><br><span class="line">println(s1.eq(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符">逻辑运算符</h2><p><strong>用于连接多个条件（一般来讲就是关系表达式），最终的结果也是一个Boolean值</strong><br><font color=#999AAA ><strong>设：变量A为true，B为false</strong></font></p><table><tr align=center><th>运算符</th><th>描述</th><th>实例</th></tr><tr align=center><td>&&</td><td>逻辑与</td><td>(A && B) 运算结果为 false</td></tr><tr align=center><td>||</td><td>逻辑或</td><td>(A || B) 运算结果为 true</td></tr><tr align=center><td>!</td><td>逻辑非</td><td>!(A && B) 运算结果为 true</td></tr></table><h2 id="赋值运算符">赋值运算符</h2><p><strong>赋值运算符就是将某个运算后的值，赋给指定的变量</strong></p><table><tr align=center><th>运算符</th><th align="left">描述</th><th align="left">实例</th></tr><tr align=center><td>=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td align="left">C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr align=center><td>+=</td><td align="left">相加后再赋值</td><td align="left">C += A 等于 C = C + A</td></tr><tr align=center><td>-=</td><td align="left">相减后再赋值</td><td align="left">C -= A 等于 C = C - A</td></tr><tr align=center><td>*=</td><td align="left">相乘后再赋值</td><td align="left">C *= A 等于 C = C * A</td></tr><tr align=center><td>/=</td><td align="left">相除后再赋值</td><td align="left">C /= A 等于 C = C / A</td></tr><tr align=center><td>%=</td><td align="left">求余后再赋值</td><td align="left">C %= A 等于 C = C % A</td></tr><tr align=center><td><<=</td><td align="left">左移后赋值</td><td align="left">C <<= 2 等于 C = C << 2</td></tr><tr align=center><td>>>=</td><td align="left">右移后赋值</td><td align="left">C >>= 2 等于 C = C >> 2</td></tr><tr align=center><td>&=</td><td align="left">按位与后赋值</td><td align="left">C &= 2 等于 C = C & 2</td></tr><tr align=center><td>^=</td><td align="left">按位异或后赋值</td><td align="left">C ^= 2 等于 C = C ^ 2</td></tr><tr align=center><td>|=</td><td align="left">按位或后赋值</td><td align="left">C |= 2 等于 C = C | 2</td></tr></table><p><font color=red><strong>注：</strong></font>Scala中没有++、–操作符，可以通过+=、-=来实现同样的效果</p><h2 id="位运算符">位运算符</h2><p><font color=#999AAA ><strong>设：表中变量a为60，b为13</strong></font></p><table><tr align=center><th>运算符</th><th align="left">描述</th><th align="left">实例</th></tr><tr align=center><td>&</td><td align="left">按位与运算符</td><td align="left">(a & b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr align=center><td>|</td><td align="left">按位或运算符</td><td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr align=center><td>^</td><td align="left">按位异或运算符</td><td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr align=center><td>~</td><td align="left">按位取反运算符</td><td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式</td></tr><tr align=center><td><<</td><td align="left">左移动运算符</td><td align="left">a << 2 输出结果 240 ，二进制解释： 0011 0000</td></tr><tr align=center><td>>></td><td align="left">右移动运算符</td><td align="left">a >> 2 输出结果 15 ，二进制解释： 0000 1111</td></tr><tr align=center><td>>>></td><td align="left">无符号右移</td><td align="left">a >>>2 输出结果 15, 二进制解释: 0000 1111</td></tr></table><h2 id="运算符的本质">运算符的本质</h2><p><strong>在Scala中其实是没有运算符的，所有运算符都是方法</strong></p><ul><li><strong>当调用对象的方法时，<font color=red>点.</font>可以省略</strong></li><li><strong>如果函数参数只有一个，或者没有参数，()可以省略</strong></li></ul><h1 id="四、if、for及while循环">四、if、for及while循环</h1><h2 id="if分支控制">if分支控制</h2><h3 id="1-单分支">1.单分支</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：当条件表达式为true时，就会执行{ }的代码</strong></p><ul><li><strong>案例</strong><ul><li>输入人的年龄，如果年龄小于 18 岁，则输出“未成年”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age:&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readShort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age:</span><br><span class="line">16</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure><h3 id="2-双分支">2.双分支</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">执行代码块 <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">执行代码块 <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>输入年龄，如果年龄小于 18 岁，则输出“未成年”，否则，输出“成年”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age:&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readShort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      println(<span class="string">&quot;成年&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age:</span><br><span class="line">20</span><br><span class="line">成年</span><br></pre></td></tr></table></figure><h3 id="3-多分支">3.多分支</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式 <span class="number">1</span>) &#123;</span><br><span class="line">执行代码块 <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式 <span class="number">2</span>) &#123;</span><br><span class="line">执行代码块 <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">执行代码块 n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例1</strong><ul><li>输入年龄，如果年龄小于 18 岁，则输出“未成年”，如果年龄大于等于 18 且小于等于 30，则输出“中年”，否则，输出“老年”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;=<span class="number">18</span> &amp;&amp; age&lt;<span class="number">30</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;中年&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      println(<span class="string">&quot;老年&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">45</span><br><span class="line">老年</span><br></pre></td></tr></table></figure><ul><li><strong>案例2</strong><ul><li>Scala 中 if-else 表达式其实是有返回值的，具体返回值取决于满足条件的代码体的最后一行内容</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">val</span> res :<span class="type">String</span> = <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      <span class="string">&quot;未成年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;=<span class="number">18</span> &amp;&amp; age&lt;<span class="number">30</span>)&#123;</span><br><span class="line">      <span class="string">&quot;中年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="string">&quot;老年&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">26</span><br><span class="line">中年</span><br></pre></td></tr></table></figure><ul><li><strong>案例3</strong><ul><li>Scala 中返回值类型不一致，取它们共同的祖先类型</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">val</span> res:<span class="type">Any</span> = <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      <span class="string">&quot;未成年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;=<span class="number">18</span> &amp;&amp; age&lt;<span class="number">30</span>)&#123;</span><br><span class="line">      <span class="string">&quot;中年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="number">120</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">66</span><br><span class="line">120</span><br></pre></td></tr></table></figure><ul><li><strong>案例4</strong><ul><li>可以用 if-else 实现Java中的三元运算符</li><li><font color=red>如果大括号{}内的逻辑代码只有一行，大括号可以省略，省略后，if 只对最近的一行逻辑代码起作用</font></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Java</span></span><br><span class="line"><span class="comment">//    int result = flag?1:0</span></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">val</span> res:<span class="type">Any</span> = <span class="keyword">if</span> (age &lt; <span class="number">18</span>) <span class="string">&quot;童年&quot;</span> <span class="keyword">else</span> <span class="string">&quot;成年&quot;</span></span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">23</span><br><span class="line">成年</span><br></pre></td></tr></table></figure><h3 id="4-嵌套分支">4.嵌套分支</h3><p><strong>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层，分支外面的分支结构称为外层分支（嵌套分支不要超过3层）</strong></p><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>如果输入的年龄小于 18，返回“未成年”，如果输入的年龄大于等于 18，需要再判断：如果年龄大于等于 18 且小于 30，返回“中年”，如果其他，返回“老年”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">val</span> res :<span class="type">String</span> = <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      <span class="string">&quot;未成年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(age&gt;=<span class="number">18</span> &amp;&amp; age&lt;<span class="number">30</span>)&#123;</span><br><span class="line">        <span class="string">&quot;中年&quot;</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="string">&quot;老年&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">99</span><br><span class="line">老年</span><br></pre></td></tr></table></figure><h2 id="for循环控制">for循环控制</h2><h3 id="1-范围数据循环（To）">1.范围数据循环（To）</h3><ul><li><strong>基本语法</strong><ul><li>i 表示循环的变量，&lt;-规定to</li><li>i 将会从1-3循环，前后闭合</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>)&#123;</span><br><span class="line">print(i + <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>输出 5 句 “编程怎么这么难”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">5</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;编程怎么这么难&quot;</span>+i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编程怎么这么难1</span><br><span class="line">编程怎么这么难2</span><br><span class="line">编程怎么这么难3</span><br><span class="line">编程怎么这么难4</span><br><span class="line">编程怎么这么难5</span><br></pre></td></tr></table></figure><h3 id="2-范围数据循环（Until）">2.范围数据循环（Until）</h3><ul><li><strong>基本语法</strong><ul><li>和前面的区别在于 i 是从 1 到 3-1</li><li>即前闭合后开的范围</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>)&#123;</span><br><span class="line">print(i + <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 </span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>输出 5 句 “编程怎么这么难”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">1</span> until <span class="number">6</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;编程怎么这么难&quot;</span> + i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编程怎么这么难1</span><br><span class="line">编程怎么这么难2</span><br><span class="line">编程怎么这么难3</span><br><span class="line">编程怎么这么难4</span><br><span class="line">编程怎么这么难5</span><br></pre></td></tr></table></figure><h3 id="3-循环守卫">3.循环守卫</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span> <span class="keyword">if</span> i != <span class="number">2</span>) &#123;</span><br><span class="line"> print(i + <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 </span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>循环守卫，即循环保护式（也称条件判断式守卫），保护式为 true 则进入循环体内部，为 false 则跳过，类似于 continue</li></ul></li><li><strong>案例</strong><ul><li>输出 1 到 5 中，不等于 3 的值</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">5</span> <span class="keyword">if</span> i != <span class="number">3</span>) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="4-循环步长">4.循环步长</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span> by <span class="number">2</span>) &#123;</span><br><span class="line">println(<span class="string">&quot;i=&quot;</span> + i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">i=3</span><br><span class="line">i=5</span><br><span class="line">i=7</span><br><span class="line">i=9</span><br></pre></td></tr></table></figure><p><strong>说明：by表示步长</strong></p><ul><li><strong>案例</strong><ul><li>输出 1 到 10 以内的所有奇数</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span> by <span class="number">2</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;i=&quot;</span> + i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">i=3</span><br><span class="line">i=5</span><br><span class="line">i=7</span><br><span class="line">i=9</span><br></pre></td></tr></table></figure><h3 id="5-嵌套循环">5.嵌套循环</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>; j &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot; i =&quot;</span> + i + <span class="string">&quot; j = &quot;</span> + j)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i =1 j = 1</span><br><span class="line">i =1 j = 2</span><br><span class="line">i =1 j = 3</span><br><span class="line">i =2 j = 1</span><br><span class="line">i =2 j = 2</span><br><span class="line">i =2 j = 3</span><br><span class="line">i =3 j = 1</span><br><span class="line">i =3 j = 2</span><br><span class="line">i =3 j = 3</span><br></pre></td></tr></table></figure><p><strong>说明：没有关键字，所以范围后一定要加 ; 来隔断逻辑</strong></p><ul><li><strong>与上面的代码等价</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (j &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line">println(<span class="string">&quot;i =&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-引入变量">6.引入变量</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>; j = <span class="number">4</span> - i) &#123;</span><br><span class="line">println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=1 j=3</span><br><span class="line">i=2 j=2</span><br><span class="line">i=3 j=1</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>for 推导式一行中有多个表达式时，所以要加 ; 来隔断逻辑</li><li>for 推导式有一个不成文的约定：当 for 推导式仅包含单一表达式时使用圆括号，当包含多个表达式时，一般每行一个表达式，并用花括号代替圆括号</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i &lt;- <span class="number">1</span> to <span class="number">3</span></span><br><span class="line">j = <span class="number">4</span> - i</span><br><span class="line">&#125; &#123;</span><br><span class="line">println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>等价于上面的代码</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">4</span> - i</span><br><span class="line">println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-循环返回值">7.循环返回值</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> res = <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i</span><br><span class="line">println(res)</span><br></pre></td></tr></table></figure><p><strong>说明：将遍历过程中处理的结果返回到一个新 Vector 集合中，使用 yield 关键字（开发中很少使用）</strong></p><ul><li><strong>案例</strong><ul><li>将原数据中所有值乘以 2，并把数据返回到一个新的集合中</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">for</span>(i &lt;<span class="number">-1</span> to <span class="number">10</span>) <span class="keyword">yield</span> &#123;</span><br><span class="line">      i * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)</span><br></pre></td></tr></table></figure><h3 id="8-倒叙打印">8.倒叙打印</h3><ul><li><strong>如果想倒序打印一组数据，可以用 reverse</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span> reverse)&#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="while和do…while循环控制">while和do…while循环控制</h2><h3 id="1-while循环控制">1.while循环控制</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (循环条件) &#123;</span><br><span class="line">循环体(语句) 循环变量迭代</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>循环条件是返回一个布尔值的表达式</li><li>while 循环是先判断再执行语句</li><li>与 for 语句不同，while 语句没有返回值，即整个 while 语句的结果是<font color=red>Unit 类型()</font></li><li>因为 while 中没有返回值，所以当要用该语句来计算并返回结果时，就不可避免的使用变量，而变量需要声明在while 循环的外部，那么就等同于循环的内部对外部的变量造成了影响，所以不推荐使用，而是推荐使用 for 循环</li></ul></li><li><strong>案例</strong><ul><li>输出 10 句 “努力搬砖，从我做起”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">println(<span class="string">&quot;努力搬砖，从我做起&quot;</span> + i)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">努力搬砖，从我做起0</span><br><span class="line">努力搬砖，从我做起1</span><br><span class="line">努力搬砖，从我做起2</span><br><span class="line">努力搬砖，从我做起3</span><br><span class="line">努力搬砖，从我做起4</span><br><span class="line">努力搬砖，从我做起5</span><br><span class="line">努力搬砖，从我做起6</span><br><span class="line">努力搬砖，从我做起7</span><br><span class="line">努力搬砖，从我做起8</span><br><span class="line">努力搬砖，从我做起9</span><br></pre></td></tr></table></figure><h3 id="2-do…while循环控制"><a href="http://2.do">2.do</a>…while循环控制</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体(语句)</span><br><span class="line">循环变量迭代</span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>循环条件是返回一个布尔值的表达式</li><li>do…while 循环是先执行，再判断</li></ul></li><li><strong>案例</strong><ul><li>输出 10 句 “活到老，搬到老”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">println(<span class="string">&quot;活到老，搬到老&quot;</span> + i)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">活到老，搬到老0</span><br><span class="line">活到老，搬到老1</span><br><span class="line">活到老，搬到老2</span><br><span class="line">活到老，搬到老3</span><br><span class="line">活到老，搬到老4</span><br><span class="line">活到老，搬到老5</span><br><span class="line">活到老，搬到老6</span><br><span class="line">活到老，搬到老7</span><br><span class="line">活到老，搬到老8</span><br><span class="line">活到老，搬到老9</span><br></pre></td></tr></table></figure><h3 id="3-循环中断">3.循环中断</h3><ul><li><strong>基本说明</strong><ul><li>Scala 内置控制结构特地去掉了 break 和 continue，是为了更好的适应函数式编程，推荐使用函数式的风格解决break 和continue 的功能，而不是一个关键字。Scala 中使用<font color=red>breakable 控制结构</font>来实现 break 和 continue 功能</li></ul></li><li><strong>案例1</strong><ul><li>采用异常的方式退出循环</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123; println(elem)</span><br><span class="line"><span class="keyword">if</span> (elem == <span class="number">5</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e =&gt;</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;正常结束循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">正常结束循环</span><br></pre></td></tr></table></figure><ul><li><strong>案例2</strong><ul><li>采用 Scala 自带的函数，退出循环</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="type">Breaks</span>.breakable(</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">      println(elem)</span><br><span class="line">      <span class="keyword">if</span> (elem == <span class="number">5</span>) <span class="type">Breaks</span>.<span class="keyword">break</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  println(<span class="string">&quot;正常结束循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">正常结束循环</span><br></pre></td></tr></table></figure><ul><li><strong>案例3</strong><ul><li>对break 进行省略</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  breakable &#123;</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">      println(elem)</span><br><span class="line">      <span class="keyword">if</span> (elem == <span class="number">5</span>) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;正常结束循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">正常结束循环</span><br></pre></td></tr></table></figure><ul><li><strong>案例4</strong><ul><li>循环遍历 10 以内的所有数据，奇数打印，偶数跳过（continue）</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line">  <span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elem % <span class="number">2</span> == <span class="number">1</span>) &#123; </span><br><span class="line">      println(elem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;continue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">continue</span><br><span class="line">3</span><br><span class="line">continue</span><br><span class="line">5</span><br><span class="line">continue</span><br><span class="line">7</span><br><span class="line">continue</span><br><span class="line">9</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><h3 id="4-多重循环">4.多重循环</h3><ul><li><strong>基本说明</strong><ul><li>将 一 个 循 环 放 在 另 一 个 循 环 体 内 ， 就 形 成 了 嵌 套 循 环 。 其 中 ，for，while，do…while均可以作为外层循环和内层循环</li><li>设外层循环次数为m 次，内层为 n 次，则内层循环体实际上需要执行<font color=red> m*n </font>次</li></ul></li><li><strong>案例</strong><ul><li>打印九九乘法表</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to i) &#123;</span><br><span class="line">      print(j + <span class="string">&quot;*&quot;</span> + i + <span class="string">&quot;=&quot;</span> + (i * j) + <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=22*2=4</span><br><span class="line">1*3=32*3=63*3=9</span><br><span class="line">1*4=42*4=83*4=124*4=16</span><br><span class="line">1*5=52*5=103*5=154*5=205*5=25</span><br><span class="line">1*6=62*6=123*6=184*6=245*6=306*6=36</span><br><span class="line">1*7=72*7=143*7=214*7=285*7=356*7=427*7=49</span><br><span class="line">1*8=82*8=163*8=244*8=325*8=406*8=487*8=568*8=64</span><br><span class="line">1*9=92*9=183*9=274*9=365*9=456*9=547*9=638*9=729*9=81</span><br></pre></td></tr></table></figure><h1 id="五、函数式编程">五、函数式编程</h1><ul><li><strong>面向对象编程</strong><ul><li>解决问题，分解对象，行为，属性，然后通过对象的关系以及行为的调用来解决问题</li><li>对象：用户</li><li>行为：登录、连接JDBC、读取数据库</li><li>属性：用户名、密码</li><li>Scala 语言是一个完全面向对象编程语言：<font color=red>万物皆对象</font></li><li><font color=red>对象的本质：对数据和行为的一个封装</font></li></ul></li><li><strong>函数式编程</strong><ul><li>解决问题时，将问题分解成一个一个的步骤，将每个步骤进行封装（函数），通过调用这些封装好的步骤，解决问题<ul><li>例：请求-&gt;用户名、密码-&gt;连接 JDBC-&gt;读取数据库</li></ul></li><li><font color=red>Scala 语言是一个完全函数式编程语言：万物皆函数</font></li><li><font color=red>函数的本质：函数可以当做一个值进行传递</font></li></ul></li><li><strong>Scala中函数式编程和面向对象编程完美的融合在一起了</strong></li></ul><h2 id="函数基础">函数基础</h2><h3 id="1-函数基本语法">1.函数基本语法</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span> </span>( x: <span class="type">Int</span> , y: <span class="type">Int</span>) : <span class="type">Int</span> = &#123;</span><br><span class="line">x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>def：定义函数的关键字</li><li>sum：函数名</li><li>x，y：参数名</li><li>Int：参数类型</li><li>Int：函数返回值类型</li><li>x + y：函数体</li></ul></li><li><strong>案例</strong><ul><li>定义一个函数，将传入的名称打印出来</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （1）函数定义</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// （2）函数调用</span></span><br><span class="line">  <span class="comment">// 函数名（参数）</span></span><br><span class="line">  f(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="2-函数与方法的区别">2.函数与方法的区别</h3><ul><li><strong>核心概念</strong><ul><li>为完成某一功能的程序语句的集合，称为函数</li><li>类中的函数称之方法</li></ul></li><li><strong>区别</strong><ul><li>Scala 可以在任何的语法结构中声明任何的语法</li><li>函数没有重载和重写的概念，而方法可以进行重载和重写</li><li>Scala 中函数可以嵌套定义</li></ul></li></ul><h3 id="3-函数的定义">3.函数的定义</h3><ul><li><strong>函数的定义</strong><ul><li>函数 1：无参，无返回值</li><li>函数 2：无参，有返回值</li><li>函数 3：有参，无返回值</li><li>函数 4：有参，有返回值</li><li>函数 5：多参，无返回值</li><li>函数 6：多参，有返回值</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数 1：无参，无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(<span class="string">&quot;无参，无返回值&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    test1()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数 2：无参，有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span></span>():<span class="type">String</span>=&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;无参，有返回值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(test2())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数 3：有参，无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test3</span></span>(s:<span class="type">String</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">      println(s)</span><br><span class="line">    &#125;</span><br><span class="line">    test3(<span class="string">&quot;jinlian&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数 4：有参，有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test4</span></span>(s:<span class="type">String</span>):<span class="type">String</span>=&#123;</span><br><span class="line">      <span class="keyword">return</span> s+<span class="string">&quot;有参，有返回值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(test4(<span class="string">&quot;hello &quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数 5：多参，无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test5</span></span>(name:<span class="type">String</span>, age:<span class="type">Int</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">      println(<span class="string">s&quot;<span class="subst">$name</span>, <span class="subst">$age</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    test5(<span class="string">&quot;dalang&quot;</span>,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无参，无返回值</span><br><span class="line">无参，有返回值</span><br><span class="line">jinlian</span><br><span class="line">hello 有参，有返回值</span><br><span class="line">dalang, 40</span><br></pre></td></tr></table></figure><h3 id="4-函数的参数">4.函数的参数</h3><ul><li><strong>案例</strong><ul><li>可变参数</li><li>如果参数列表中存在多个参数，那么可变参数一般放置在最后</li><li>参数默认值，一般将有默认值的参数放置在参数列表的后面</li><li>带名参数</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （1）可变参数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>( s : <span class="type">String</span>* ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有输入参数：输出 Array</span></span><br><span class="line">  test(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Scala&quot;</span>)</span><br><span class="line">  <span class="comment">// 无输入参数：输出 List()</span></span><br><span class="line">  test()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (2)如果参数列表中存在多个参数，那么可变参数一般放置在最后</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test2</span></span>( name : <span class="type">String</span>, s: <span class="type">String</span>* ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(name + <span class="string">&quot;,&quot;</span> + s)</span><br><span class="line">  &#125;</span><br><span class="line">  test2(<span class="string">&quot;jinlian&quot;</span>, <span class="string">&quot;dalang&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (3)参数默认值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test3</span></span>( name : <span class="type">String</span>, age : <span class="type">Int</span> = <span class="number">30</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$name</span>, <span class="subst">$age</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果参数传递了值，那么会覆盖默认值</span></span><br><span class="line">  test3(<span class="string">&quot;jinlian&quot;</span>, <span class="number">20</span>)</span><br><span class="line">  <span class="comment">// 如果参数有默认值，在调用的时候，可以省略这个参数</span></span><br><span class="line">  test3(<span class="string">&quot;dalang&quot;</span>)</span><br><span class="line">  <span class="comment">// 一般情况下，将有默认值的参数放置在参数列表的后面</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test4</span></span>( sex : <span class="type">String</span> = <span class="string">&quot;男&quot;</span>, name : <span class="type">String</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$name</span>, <span class="subst">$sex</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Scala 函数中参数传递是，从左到右</span></span><br><span class="line">  <span class="comment">//test4(&quot;wusong&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//（4）带名参数</span></span><br><span class="line">  test4(name=<span class="string">&quot;ximenqing&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WrappedArray(Hello, Scala)</span><br><span class="line">List()</span><br><span class="line">jinlian,WrappedArray(dalang)</span><br><span class="line">jinlian, 20</span><br><span class="line">dalang, 30</span><br><span class="line">ximenqing, 男</span><br></pre></td></tr></table></figure><h3 id="5-至简原则">5.至简原则</h3><ul><li><strong>函数至简原则：能省就省</strong><ul><li>return 可以省略，Scala 会使用函数体的最后一行代码作为返回值</li><li>如果函数体只有一行代码，可以省略花括号</li><li>返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）</li><li>如果有 return，则不能省略返回值类型，必须指定</li><li>如果函数明确声明 unit，那么即使函数体中使用 return 关键字也不起作用</li><li>Scala 如果期望是无返回值类型，可以省略等号</li><li>如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</li><li>如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</li><li>如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数标准写法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>( s : <span class="type">String</span> ): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> s + <span class="string">&quot; jinlian&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 至简原则:能省则省</span></span><br><span class="line">  <span class="comment">//（1） return 可以省略,Scala 会使用函数体的最后一行代码作为返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>( s : <span class="type">String</span> ): <span class="type">String</span> = &#123;</span><br><span class="line">    s + <span class="string">&quot; jinlian&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f1(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（2）如果函数体只有一行代码，可以省略花括号</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(s:<span class="type">String</span>):<span class="type">String</span> = s + <span class="string">&quot; jinlian&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//（3）返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>( s : <span class="type">String</span> ) = s + <span class="string">&quot; jinlian&quot;</span></span><br><span class="line">  println(f3(<span class="string">&quot;Hello3&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（4）如果有 return，则不能省略返回值类型，必须指定。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f4</span></span>() :<span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ximenqing4&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f4())</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（5）如果函数明确声明 unit，那么即使函数体中使用 return 关键字也不起作用</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;dalang5&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f5())</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（6）Scala 如果期望是无返回值类型,可以省略等号</span></span><br><span class="line">  <span class="comment">// 将无返回值的函数称之为过程</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f6</span></span>() &#123;</span><br><span class="line">    <span class="string">&quot;dalang6&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f6())</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（7）如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f7</span></span>() = <span class="string">&quot;dalang7&quot;</span></span><br><span class="line">  println(f7())</span><br><span class="line">  println(f7)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（8）如果函数没有参数列表，那么小括号可以省略,调用时小括号必须省略</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f8</span> </span>= <span class="string">&quot;dalang&quot;</span></span><br><span class="line">  <span class="comment">//println(f8())</span></span><br><span class="line">  println(f8)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//（9）如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f9</span> </span>= (x:<span class="type">String</span>)=&gt;&#123;println(<span class="string">&quot;wusong&quot;</span>)&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f10</span></span>(f:<span class="type">String</span>=&gt;<span class="type">Unit</span>) = &#123;</span><br><span class="line">    f(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  f10(f9)</span><br><span class="line">  println(f10((x:<span class="type">String</span>)=&gt;&#123;println(<span class="string">&quot;wusong&quot;</span>)&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello jinlian</span><br><span class="line">Hello jinlian</span><br><span class="line">Hello3 jinlian</span><br><span class="line">ximenqing4</span><br><span class="line">()</span><br><span class="line">()</span><br><span class="line">dalang7</span><br><span class="line">dalang7</span><br><span class="line">dalang</span><br><span class="line">wusong</span><br><span class="line">wusong</span><br><span class="line">()</span><br></pre></td></tr></table></figure><h2 id="函数进阶">函数进阶</h2><h3 id="1-高阶函数">1.高阶函数</h3><ul><li><strong>函数可以作为值进行传递</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//（1）调用 foo 函数，把返回值给变量 f</span></span><br><span class="line">  <span class="comment">//val f = foo()</span></span><br><span class="line">  <span class="keyword">val</span> f = foo</span><br><span class="line">  println(f)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//（2）在被调用函数 foo 后面加上 _，相当于把函数 foo 当成一个整体，传递给变量 f1</span></span><br><span class="line">  <span class="keyword">val</span> f1 = foo _</span><br><span class="line">  foo()</span><br><span class="line">  f1()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//（3）如果明确变量类型，那么不使用下划线也可以将函数作为整体传递给变量</span></span><br><span class="line">  <span class="keyword">var</span> f2:()=&gt;<span class="type">Int</span> = foo</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>():<span class="type">Int</span> = &#123;</span><br><span class="line">  println(<span class="string">&quot;foo...&quot;</span>)</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo...</span><br><span class="line">1</span><br><span class="line">foo...</span><br><span class="line">foo...</span><br></pre></td></tr></table></figure><ul><li><strong>函数可以作为参数进行传递</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （1）定义一个函数，函数参数还是一个函数签名；f 表示函数名称;(Int,Int)表示输入两个 Int 参数；Int 表示函数返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(f: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    f(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （2）定义一个函数，参数和返回值类型和 f1 的输入参数一致</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （3）将 add 函数作为参数传递给 f1 函数，如果能够推断出来不是调用，_可以省略</span></span><br><span class="line">  println(f1(add))</span><br><span class="line">  println(f1(add _))</span><br><span class="line">  <span class="comment">//可以传递匿名函数</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure><ul><li><strong>函数可以作为函数返回值返回</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>() = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>() = &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f2 _</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> f = f1()</span><br><span class="line">  <span class="comment">// 因为 f1 函数的返回值依然为函数，所以可以变量 f 可以作为函数继续调用</span></span><br><span class="line">  f()</span><br><span class="line">  <span class="comment">// 上面的代码可以简化为</span></span><br><span class="line">  f1()()</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-匿名函数">2.匿名函数</h3><ul><li><strong>说明</strong><ul><li>没有名字的函数就是匿名函数</li><li>(x:Int)=&gt;{函数体}</li><li>x：表示输入参数类型；Int：表示输入参数类型；函数体：表示具体代码逻辑</li></ul></li><li><strong>案例1</strong><ul><li>传递的函数有一个参数<ul><li><font color=red>传递匿名函数至简原则</font></li><li><font color=red>参数的类型可以省略，会根据形参进行自动的推导</font></li><li><font color=red>类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过 1 的永远不能省略圆括号</font></li><li><font color=red>匿名函数如果只有一行，则大括号也可以省略</font></li><li><font color=red>如果参数只出现一次，则参数省略且后面参数可以用_代替</font></li></ul></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// （1）定义一个函数：参数包含数据和逻辑函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">operation</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], op: <span class="type">Int</span> =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- arr) <span class="keyword">yield</span> op(elem)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （2）定义逻辑函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(ele: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    ele + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （3）标准函数调用</span></span><br><span class="line">  <span class="keyword">val</span> arr = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), op)</span><br><span class="line">  println(arr.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （4）采用匿名函数</span></span><br><span class="line">  <span class="keyword">val</span> arr1 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (ele: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">    ele + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  println(arr1.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （4.1）参数的类型可以省略，会根据形参进行自动的推导;</span></span><br><span class="line">  <span class="keyword">val</span> arr2 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (ele) =&gt; &#123;</span><br><span class="line">    ele + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  println(arr2.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （4.2）类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过 1 的永远不能省略圆括号。</span></span><br><span class="line">  <span class="keyword">val</span> arr3 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), ele =&gt; &#123;</span><br><span class="line">    ele + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  println(arr3.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// (4.3) 匿名函数如果只有一行，则大括号也可以省略</span></span><br><span class="line">  <span class="keyword">val</span> arr4 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), ele =&gt; ele + <span class="number">1</span>)</span><br><span class="line">  println(arr4.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//（4.4）如果参数只出现一次，则参数省略且后面参数可以用_代替</span></span><br><span class="line">  <span class="keyword">val</span> arr5 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), _ + <span class="number">1</span>)</span><br><span class="line">  println(arr5.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br></pre></td></tr></table></figure><ul><li><strong>案例2</strong><ul><li>传递的函数有两个参数</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculator</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    op(a, b)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// （1）标准版</span></span><br><span class="line">  println(calculator(<span class="number">2</span>, <span class="number">3</span>, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;x + y&#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （2）如果只有一行，则大括号也可以省略</span></span><br><span class="line">  println(calculator(<span class="number">2</span>, <span class="number">3</span>, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （3）参数的类型可以省略，会根据形参进行自动的推导;</span></span><br><span class="line">  println(calculator(<span class="number">2</span>, <span class="number">3</span>, (x , y) =&gt; x + y))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （4）如果参数只出现一次，则参数省略且后面参数可以用_代替</span></span><br><span class="line">  println(calculator(<span class="number">2</span>, <span class="number">3</span>, _ + _))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="3-高阶函数案例">3.高阶函数案例</h3><ul><li><strong>模拟 Map 映射、Filter 过滤、Reduce 聚合</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （1）map 映射</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], op: <span class="type">Int</span> =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- arr) <span class="keyword">yield</span> op(elem)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> arr = map(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (x: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">    x * x</span><br><span class="line">  &#125;)</span><br><span class="line">  println(arr.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （2）filter 过滤。有参数，且参数再后面只使用一次，则参数省略且后面参数用_表示</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(arr:<span class="type">Array</span>[<span class="type">Int</span>],op:<span class="type">Int</span> =&gt;<span class="type">Boolean</span>) =&#123;</span><br><span class="line">    <span class="keyword">var</span> arr1:<span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span>(elem &lt;- arr <span class="keyword">if</span> op(elem))&#123;</span><br><span class="line">      arr1.append(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    arr1.toArray</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> arr1 = filter(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), _ % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">  println(arr1.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （3）reduce 聚合。有多个参数，且每个参数再后面只使用一次，则参数省略且后面参数用_表示，第n 个_代表第n 个参数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">var</span> init: <span class="type">Int</span> = arr(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- <span class="number">1</span> until arr.length) &#123; </span><br><span class="line">      init = op(init, elem)</span><br><span class="line">    &#125;</span><br><span class="line">    init</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//val arr2 = reduce(Array(1, 2, 3, 4), (x, y) =&gt; x * y)</span></span><br><span class="line">  <span class="keyword">val</span> arr2 = reduce(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), _ * _)</span><br><span class="line">  println(arr2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,4,9,16</span><br><span class="line">1,3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="4-函数柯里化-闭包">4.函数柯里化&amp;闭包</h3><ul><li><strong>说明</strong><ul><li><font color=red>闭包：</font>如果一个函数，访问到了它的外部（局部）变量的值，那么这个函数和他所处的环境，称为闭包</li><li><font color=red>函数柯里化：</font>把一个参数列表的多个参数，变成多个参数列表</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>()=&#123;</span><br><span class="line">    <span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(b:<span class="type">Int</span>)=&#123;</span><br><span class="line">      a + b</span><br><span class="line">    &#125;</span><br><span class="line">    f2 _</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在调用时，f1 函数执行完毕后，局部变量 a 应该随着栈空间释放掉</span></span><br><span class="line">  <span class="keyword">val</span> f = f1()</span><br><span class="line">  <span class="comment">// 但是在此处，变量 a 其实并没有释放，而是包含在了 f2 函数的内部，形成了闭合的效果</span></span><br><span class="line">  println(f(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">  println(f1()(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数柯里化，其实就是将复杂的参数逻辑变得简单化,函数柯里化一定存在闭包</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>()(b:<span class="type">Int</span>)=&#123;</span><br><span class="line">    <span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">    a + b</span><br><span class="line">  &#125;</span><br><span class="line">  println(f3()(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">13</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h3 id="5-递归">5.递归</h3><ul><li><strong>说明</strong><ul><li>一个函数/方法在函数/方法体内又调用了本身，我们称之为递归调用</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阶乘</span></span><br><span class="line">  <span class="comment">// 递归算法</span></span><br><span class="line">  <span class="comment">// 1) 方法调用自身</span></span><br><span class="line">  <span class="comment">// 2) 方法必须要有跳出的逻辑</span></span><br><span class="line">  <span class="comment">// 3) 方法调用自身时，传递的参数应该有规律</span></span><br><span class="line">  <span class="comment">// 4) scala 中的递归必须声明函数返回值类型</span></span><br><span class="line">  println(test(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(i : <span class="type">Int</span>) : <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i * test(i - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120</span><br></pre></td></tr></table></figure><h3 id="6-控制抽象">6.控制抽象</h3><ul><li><strong>值调用：把计算后的值传递过去</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span> </span>= ()=&gt;&#123;</span><br><span class="line">    println(<span class="string">&quot;f...&quot;</span>)</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo(f())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: <span class="type">Int</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">  println(a)</span><br><span class="line">  println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f...</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><ul><li><strong>名调用：把代码传递过去</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span> </span>= ()=&gt;&#123;</span><br><span class="line">    println(<span class="string">&quot;f...&quot;</span>)</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo(f())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//def foo(a: Int):Unit = &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: =&gt;<span class="type">Int</span>):<span class="type">Unit</span> = &#123;<span class="comment">//注意这里变量 a 没有小括号了</span></span><br><span class="line">  println(a)</span><br><span class="line">  println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f...</span><br><span class="line">10</span><br><span class="line">f...</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong><font color=red>注：</font>Java 只有值调用；Scala 既有值调用，又有名调用</strong></p><ul><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// （1）传递代码块</span></span><br><span class="line">  foo(&#123;</span><br><span class="line">    println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// （2）小括号可以省略</span></span><br><span class="line">  foo&#123;</span><br><span class="line">    println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: =&gt;<span class="type">Unit</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">  println(a)</span><br><span class="line">  println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">()</span><br><span class="line">aaa</span><br><span class="line">()</span><br><span class="line">aaa</span><br><span class="line">()</span><br><span class="line">aaa</span><br><span class="line">()</span><br></pre></td></tr></table></figure><p><strong>自定义一个 While 循环</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> i:<span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">  myWhile(i &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i +=<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myWhile</span></span>(condition: =&gt;<span class="type">Boolean</span>)(op: =&gt;<span class="type">Unit</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition)&#123;</span><br><span class="line">    op</span><br><span class="line">    myWhile(condition)(op)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="7-惰性加载">7.惰性加载</h3><ul><li><strong>说明</strong><ul><li>当函数返回值被声明为 lazy 时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行。这种函数我们称之为惰性函数</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> res = sum(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line">  println(<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line">  println(<span class="string">&quot;res=&quot;</span> + res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n1: <span class="type">Int</span>, n2: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  println(<span class="string">&quot;sum 被执行。。。&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">sum 被执行。。。</span><br><span class="line">res=40</span><br></pre></td></tr></table></figure><p><strong><font color=red>注：</font>lazy 不能修饰 var 类型的变量</strong></p><h1 id="六、面向对象">六、面向对象</h1><h2 id="Scala包">Scala包</h2><ul><li><strong>基本语法</strong><ul><li>package 包 名</li></ul></li><li><strong>Scala包的三大作用（同Java相同）</strong><ul><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类</li><li>控制访问范围</li></ul></li></ul><h3 id="1-包的命名">1.包的命名</h3><ul><li><strong>命名规则</strong><ul><li>只能包含数字、字母、下划线、小圆点.，但不能用数字开头，也不要使用关键字</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.<span class="keyword">class</span>.exec1<span class="comment">//错误，因为 class 关键字</span></span><br><span class="line">demo<span class="number">.12</span>a<span class="comment">//错误，数字开头</span></span><br></pre></td></tr></table></figure><ul><li><strong>命名规范</strong><ul><li>一般是小写字母+小圆点</li><li>com.公司名.项目名.业务模块名</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.atguigu.oa.model</span><br><span class="line">com.atguigu.oa.controller</span><br><span class="line">com.sohu.bank.order</span><br></pre></td></tr></table></figure><h3 id="2-包语句">2.包语句</h3><ul><li><strong>说明</strong><ul><li>Scala 有两种包的管理风格，一种方式和 Java 的包管理风格相同，每个源文件一个包（包名和源文件所在路径不要求必须一致），包名用“.”进行分隔以表示包的层级关系，如com.atguigu.scala。另一种风格，通过嵌套的风格表示层级关系，如下</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span></span><br><span class="line">com&#123; <span class="keyword">package</span></span><br><span class="line">atguigu&#123;</span><br><span class="line"><span class="keyword">package</span> scala&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第二种风格有以下特点</strong><ul><li>一个源文件中可以声明多个 package</li><li>子包中的类可以直接访问父包中的内容，而无需导包</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.<span class="type">Inner</span> <span class="comment">//父包访问子包需要导包</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> out: <span class="type">String</span> = <span class="string">&quot;out&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="type">Inner</span>.in)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> atguigu &#123;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> in: <span class="type">String</span> = <span class="string">&quot;in&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="type">Outer</span>.out) <span class="comment">//子包访问父包无需导包</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> other &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-包对象">3.包对象</h3><p><strong>在 Scala 中可以为每个包定义一个同名的包对象，定义在包对象中的成员，作为其对应包下所有 class 和 object 的共享变量，可以被直接访问</strong></p><ul><li><strong>定义</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">com</span></span>&#123;</span><br><span class="line"><span class="keyword">val</span> shareValue=<span class="string">&quot;share&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shareMethod</span></span>()=&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>若使用 Java 的包管理风格，则包对象一般定义在其对应包下的 package.scala文件中，包对象名与包名保持一致</li><li>如采用嵌套方式管理包，则包对象可与包定义在同一文件中，但是要保证包对象与包声明在同一作用域中</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com &#123;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> out: <span class="type">String</span> = <span class="string">&quot;out&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(name)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">com</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;com&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-导包说明">4.导包说明</h3><ul><li><strong>Scala和 Java 一样，可以在顶部使用 import 导入，在这个文件中的所有类都可以使用</strong></li><li><strong>局部导入：</strong> 什么时候使用，什么时候导入</li><li><strong>通配符导入：</strong> import java.util._</li><li><strong>给类起名：</strong> import java.util.{ArrayList=&gt;JL}</li><li><strong>导入相同包的多个类：</strong> import java.util.{HashSet, ArrayList}</li><li><strong>屏蔽类：</strong> import java.util.{ArrayList =&gt;<em>,</em>}</li><li><strong>导入包的绝对路径：</strong> new _root_.java.util.HashMap</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java </span><br><span class="line">&#123; <span class="keyword">package</span> util </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong></li></ul><table><tr align=center><td align=left>import com.atguigu.Fruit</td><td align=left>引入 com.atguigu 包下Fruit（class 和 object）</td></tr><tr align=center><td align=left>import com.atguigu._</td><td align=left>引入 com.atguigu 下的所有成员</td></tr><tr align=center><td align=left>import com.atguigu.Fruit._</td><td align=left>引入 Fruit(object)的所有成员</td></tr><tr align=center><td align=left>import com.atguigu.{Fruit,Vegetable}</td><td align=left>引入 com.atguigu 下的Fruit 和 Vegetable</td></tr><tr align=center><td align=left>import com.atguigu.{Fruit=>Shuiguo}</td><td align=left>引入 com.atguigu 包下的 Fruit 并更名为 Shuiguo</td></tr><tr align=center><td align=left>import com.atguigu.{Fruit=>Shuiguo,_}</td><td align=left>引入 com.atguigu 包下的所有成员，并将 Fruit 更名为 Shuiguo</td></tr><tr align=center><td align=left>import com.atguigu.{Fruit=>_,_}</td><td align=left>引入 com.atguigu 包下屏蔽 Fruit 类</td></tr><tr align=center><td align=left>new _root_.java.util.HashMap</td><td align=left>引入的 Java 的绝对路径</td></tr></table><p><strong><font color=red>注：</font>Scala 中的三个默认导入分别是</strong></p><ul><li>import java.lang._</li><li>import scala._</li><li>import scala.Predef._</li></ul><h2 id="类和对象">类和对象</h2><p><strong>类：</strong> 可以看成一个模板<br><strong>对象：</strong> 表示具体的事物</p><h3 id="1-类的定义">1.类的定义</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> <span class="title">类名</span> </span>&#123;</span><br><span class="line">类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>Scala 语法中，类并不声明为 public，所有这些类都具有公有可见性（即默认就是public）</li><li>一个 Scala 源文件可以包含多个类</li></ul></li></ul><h3 id="2-属性">2.属性</h3><p><strong>属性是类的一个组成部分</strong></p><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="keyword">var</span>|<span class="keyword">val</span> 属性名称 [：类型] = 属性值</span><br></pre></td></tr></table></figure><p><font color=red><strong>注：</strong></font>Bean 属性（@BeanPropetry），可以自动生成规范的 setXxx/getXxx 方法</p><ul><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.beans.<span class="type">BeanProperty</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;bobo&quot;</span> <span class="comment">//定义属性</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = _ <span class="comment">// _表示给属性一个默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean 属性（@BeanProperty）</span></span><br><span class="line"><span class="meta">@BeanProperty</span> <span class="keyword">var</span> sex: <span class="type">String</span> = <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="comment">//val 修饰的属性不能赋默认值，必须显示指定</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">println(person.name)</span><br><span class="line"></span><br><span class="line">person.setSex(<span class="string">&quot;女&quot;</span>)</span><br><span class="line">println(person.getSex)</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bobo</span><br><span class="line">女</span><br></pre></td></tr></table></figure><h3 id="3-访问权限">3.访问权限</h3><ul><li><strong>说明</strong><ul><li>在 Java 中，访问权限分为：public，private，protected 和默认。在 Scala 中，可以通过类似的修饰符达到同样的效果，但是使用上有区别</li><li>（1）Scala 中属性和方法的默认访问权限为 public，但 Scala 中无 public 关键字</li><li>（2）private 为私有权限，只在类的内部和伴生对象中可用</li><li>（3）<font color=red>protected 为受保护权限，Scala 中受保护权限比 Java 中更严格，同类、子类可以访问，同包无法访问</font></li><li>（4）<font color=red>private[包名]增加包访问权限，包名下的其他类也可以使用</font></li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;bobo&quot;</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">18</span> </span><br><span class="line"><span class="keyword">private</span>[demo] <span class="keyword">var</span> sex: <span class="type">String</span> = <span class="string">&quot;男&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123; </span><br><span class="line">println(name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span> </span><br><span class="line">person.say()</span><br><span class="line">println(person.name)</span><br><span class="line">println(person.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">this</span>.age </span><br><span class="line"><span class="keyword">this</span>.sex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>: <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">new</span> <span class="type">Person</span>().sex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bobo</span><br><span class="line">bobo</span><br><span class="line">18</span><br></pre></td></tr></table></figure><h3 id="4-方法">4.方法</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数列表) [：返回值类型] = &#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n1:<span class="type">Int</span>, n2:<span class="type">Int</span>) : <span class="type">Int</span> = &#123; </span><br><span class="line">n1 + n2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>() </span><br><span class="line">println(person.sum(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="5-创建对象">5.创建对象</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> | <span class="keyword">var</span> 对象名 [：类型]= <span class="keyword">new</span> 类型()</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>val 修饰对象，不能改变对象的引用（即：内存地址），可以改变对象属性的值</li><li>var 修饰对象，可以修改对象的引用和修改对象的属性值</li><li>自动推导变量类型不能多态，所以多态需要显示声明</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;canglaoshi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//val 修饰对象，不能改变对象的引用（即：内存地址），可以改变对象属性的值</span></span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>() </span><br><span class="line">person.name = <span class="string">&quot;bobo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person = new Person()// 错误的</span></span><br><span class="line"></span><br><span class="line">println(person.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bobo</span><br></pre></td></tr></table></figure><h3 id="6-构造器">6.构造器</h3><p>和 Java 一样，Scala 构造对象也需要调用构造方法，并且可以有任意多个构造方法。<br>Scala 类的构造器包括：<strong>主构造器和辅助构造器</strong></p><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">类名</span>(<span class="params">形参列表</span>) </span>&#123;<span class="comment">// 主构造器</span></span><br><span class="line"><span class="comment">// 类 体</span></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">this</span></span>(形参列表) &#123;<span class="comment">// 辅助构造器</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">this</span></span>(形参列表) &#123;<span class="comment">//辅助构造器可以有多个</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>辅助构造器，函数的名称 this，可以有多个，编译器通过参数的个数及类型来区分</li><li>辅助构造方法不能直接构建对象，必须直接或者间接调用主构造方法</li><li><font color=red>构造器调用其他另外的构造器，要求被调用构造器必须提前声明</font></li></ul></li><li><strong>案例</strong><ul><li>如果主构造器无参数，小括号可省略，构建对象时调用的构造方法的小括号也可以省略</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）如果主构造器无参数，小括号可省略</span></span><br><span class="line"><span class="comment">//class Person ()&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = _</span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(age: <span class="type">Int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>()</span><br><span class="line"><span class="keyword">this</span>.age = age</span><br><span class="line">println(<span class="string">&quot;辅助构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(age: <span class="type">Int</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>(age)</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;主构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> person2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="number">18</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主构造器</span><br><span class="line">辅助构造器</span><br></pre></td></tr></table></figure><h3 id="7-构造器参数">7.构造器参数</h3><ul><li><strong>说明</strong><ul><li>Scala 类的主构造器函数的形参包括三种类型：未用任何修饰、var 修饰、val 修饰</li><li>（1）未用任何修饰符修饰，这个参数就是一个局部变量</li><li>（2）var 修饰参数，作为类的成员属性使用，可以修改</li><li>（3）val 修饰参数，作为类只读属性使用，不能修改</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, var age: <span class="type">Int</span>, val sex: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;bobo&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// （1）未用任何修饰符修饰，这个参数就是一个局部变量</span></span><br><span class="line"><span class="comment">// printf(person.name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）var 修饰参数，作为类的成员属性使用，可以修改</span></span><br><span class="line">person.age = <span class="number">19</span></span><br><span class="line">println(person.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）val 修饰参数，作为类的只读属性使用，不能修改</span></span><br><span class="line"><span class="comment">// person.sex = &quot;女&quot;</span></span><br><span class="line">println(person.sex)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19</span><br><span class="line">男</span><br></pre></td></tr></table></figure><h2 id="封装、继承和多态">封装、继承和多态</h2><h3 id="1-封装">1.封装</h3><p><strong>封装就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作（成员方法），才能对数据进行操作。Java 封装操作如下：</strong></p><ul><li><strong>将属性进行私有化</strong></li><li><strong>提供一个公共的 set 方法，用于对属性赋值</strong></li><li><strong>提供一个公共的 get 方法，用于获取属性的值</strong></li></ul><p><strong>Scala 中的 <font color=red>public </font>属性，底层实际为 private，并通过 get 方法（<font color=red>obj.field()</font>）和 set 方法（<font color=red>obj.field_=(value)</font>）对其进行操作。所以 Scala 并不推荐将属性设为 private，再为其设置public 的 get 和 set 方法的做法。但由于很多 Java 框架都利用反射调用 getXXX 和 setXXX 方法，有时候为了和这些框架兼容，也会为 Scala 的属性设置 getXXX 和 setXXX 方法（通过<font color=red>@BeanProperty </font>注解实现）</strong></p><h3 id="2-继承和多态">2.继承和多态</h3><ul><li><strong>基本语法</strong><ul><li>子类继承父类的属性和方法</li><li>scala 是单继承</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">子类名</span> <span class="keyword">extends</span> <span class="title">父类名</span> </span>&#123; 类体 &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>继承的调用顺序：父类构造器-&gt;子类构造器</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">nameParam: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = nameParam</span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(nameParam: <span class="type">String</span>, ageParam: <span class="type">Int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>(nameParam)</span><br><span class="line"><span class="keyword">this</span>.age = ageParam</span><br><span class="line">println(<span class="string">&quot;父类辅助构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;父类主构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span>(<span class="params">nameParam: <span class="type">String</span>, ageParam: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">nameParam, ageParam</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> empNo: <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(nameParam: <span class="type">String</span>, ageParam: <span class="type">Int</span>, empNoParam: <span class="type">Int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>(nameParam, ageParam)</span><br><span class="line"><span class="keyword">this</span>.empNo = empNoParam</span><br><span class="line">println(<span class="string">&quot;子类的辅助构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;子类主构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Emp</span>(<span class="string">&quot;z3&quot;</span>, <span class="number">11</span>,<span class="number">1001</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父类主构造器</span><br><span class="line">父类辅助构造器</span><br><span class="line">子类主构造器</span><br><span class="line">子类的辅助构造器</span><br></pre></td></tr></table></figure><ul><li><strong>动态绑定</strong><ul><li>Scala 中属性和方法都是动态绑定，而 Java 中只有方法为动态绑定</li></ul></li><li><strong>案例（对比Java与Scala的重写）</strong><ul><li>Scala</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;person&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;hello person&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;hello teacher&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> teacher: <span class="type">Teacher</span> = <span class="keyword">new</span> <span class="type">Teacher</span>()</span><br><span class="line">println(teacher.name)</span><br><span class="line">teacher.hello()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teacher1:<span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Teacher</span></span><br><span class="line">println(teacher1.name)</span><br><span class="line">teacher1.hello()</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">teacher</span><br><span class="line">hello teacher</span><br><span class="line">teacher</span><br><span class="line">hello teacher</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;person&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello person&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello teacher&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDynamic</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">teacher1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"></span><br><span class="line">System.out.println(teacher.name);</span><br><span class="line">teacher.hello();</span><br><span class="line"></span><br><span class="line">System.out.println(teacher1.name);</span><br><span class="line">teacher1.hello();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">teacher</span><br><span class="line">hello teacher</span><br><span class="line">person</span><br><span class="line">hello teacher</span><br></pre></td></tr></table></figure><h2 id="抽象类">抽象类</h2><h3 id="1-抽象属性和抽象方法">1.抽象属性和抽象方法</h3><ul><li><strong>基本语法</strong><ul><li><strong>定义抽象类：</strong> abstract class Person{} //通过 abstract 关键字标记抽象类</li><li><strong>定义抽象属性：</strong> val|var name:String //一个属性没有初始化，就是抽象属性</li><li><strong>定义抽象方法：</strong> def hello():String //只声明而没有实现的方法，就是抽象方法</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;hello teacher&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>继承&amp;重写</strong><ul><li>如果父类为抽象类，那么子类需要将抽象的属性和方法实现，否则子类也需声明为抽象类</li><li>重写非抽象方法需要用 override 修饰，重写抽象方法则可以不加 override</li><li>子类中调用父类的方法使用 super 关键字</li><li>子类对抽象属性进行实现，父类抽象属性可以用 var 修饰</li><li>子类对非抽象属性重写，父类非抽象属性只支持 val 类型，而不支持 var，<font color=red>因为 var 修饰的为可变变量，子类继承之后就可以直接使用，没有必要重写</font></li></ul></li></ul><h3 id="2-匿名子类">2.匿名子类</h3><ul><li><strong>说明</strong><ul><li>和 Java 一样，可以通过包含带有定义或重写的代码块的方式创建一个匿名的子类</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span> &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> = println(<span class="string">&quot;hello teacher&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例对象（伴生对象）">单例对象（伴生对象）</h2><p><strong>Scala语言是<font color=red>完全面向对象</font>的语言，所以并没有静态的操作（即在Scala中没有静态的概念）。但是为了能够和Java语言交互（因为Java中有静态概念），就产生了一种特殊的对象来<font color=red>模拟类对象</font>，该对象为<font color=red>单例对象</font>。若单例对象名与类名一致，则称该单例对象这个类的<font color=red>伴生对象</font>，这个类的所有“静态”内容都可以<font color=red>放置在它的伴生对象</font>中声明</strong></p><h3 id="1-单例对象语法">1.单例对象语法</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> country:<span class="type">String</span>=<span class="string">&quot;China&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>单例对象采用<font color=red>object </font>关键字声明</li><li>单例对象对应的类称之为<font color=red>伴生类</font>，伴生对象的名称应该和伴生类名一致</li><li>单例对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）伴生对象采用 object 关键字声明</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> country: <span class="type">String</span> = <span class="string">&quot;China&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）伴生对象对应的类称之为伴生类，伴生对象的名称应该和伴生类名一致</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;bobo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（3）伴生对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问</span></span><br><span class="line">println(<span class="type">Person</span>.country)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-apply方法">2.apply方法</h3><ul><li><strong>说明</strong><ul><li>通过<font color=red>伴生对象</font>的 <font color=red>apply </font>方法，实现不使用 new 方法创建对象</li><li>如果想让主构造器变成私有的，可以在()之前加上 private</li><li>apply 方法可以重载</li><li>Scala 中<font color=red> obj(arg)</font>的语句实际是在调用该对象的<font color=red> apply </font>方法，即 obj.apply(arg)。用以统一面向对象编程和函数式编程的风格</li><li>当使用 new 关键字构建对象时，调用的其实是类的构造方法，当直接使用类名构建对象时，调用的其实时伴生对象的 apply 方法</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）通过伴生对象的 apply 方法，实现不使用 new 关键字创建对象</span></span><br><span class="line"><span class="keyword">val</span> p1 = <span class="type">Person</span>() </span><br><span class="line">println(<span class="string">&quot;p1.name=&quot;</span> + p1.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p2 = <span class="type">Person</span>(<span class="string">&quot;bobo&quot;</span>) </span><br><span class="line">println(<span class="string">&quot;p2.name=&quot;</span> + p2.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）如果想让主构造器变成私有的，可以在()之前加上 private </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">private</span>(<span class="params">cName: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = cName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Person</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;apply 空参被调用&quot;</span>) </span><br><span class="line"><span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Person</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;apply 有参被调用&quot;</span>) </span><br><span class="line"><span class="keyword">new</span> <span class="type">Person</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：也可以创建其它类型对象，并不一定是伴生类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply 空参被调用</span><br><span class="line">p1.name=xx</span><br><span class="line">apply 有参被调用</span><br><span class="line">p2.name=bobo</span><br></pre></td></tr></table></figure><h2 id="特质">特质</h2><p><strong><font color=red>Scala 语言中，采用特质 trait（特征）来代替接口的概念</font>，也就是说，多个类具有相同的特质（特征）时，就可以将这个特质（特征）独立出来，采用关键字 trait 声明<br>Scala 中的 trait 中即<font color=red>可以有抽象属性和方法，也可以有具体的属性和方法，一个类可以混入（mixin）多个特质</font>。这种感觉<font color=red>类似于 Java 中的抽象类</font><br>Scala 引入 trait 特征，第一可以替代 Java 的接口，第二个也是对单继承机制的一种补充</strong></p><h3 id="1-特质声明">1.特质声明</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">特质名</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">主体</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明属性</span></span><br><span class="line"><span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象属性</span></span><br><span class="line"><span class="keyword">var</span> age:<span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span></span>():<span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-特质基本语法">2.特质基本语法</h3><p><strong>一个类具有某种特质（特征），就意味着这个类满足了这个特质（特征）的所有要素， 所以在使用时，也采用了<font color=red>extends 关键字</font>，如果有多个特质或存在父类，那么需要采用<font color=red>with 关键字</font>连接</strong></p><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有父类：<span class="class"><span class="keyword">class</span><span class="title">类名</span> <span class="keyword">extends</span><span class="title">特质</span> 1<span class="keyword">with</span><span class="title">特质</span> 2<span class="keyword">with</span><span class="title">特质</span> 3 <span class="title">…</span></span></span><br><span class="line">有父类：<span class="class"><span class="keyword">class</span><span class="title">类名</span><span class="keyword">extends</span><span class="title">父类</span><span class="keyword">with</span><span class="title">特质</span> 1<span class="keyword">with</span><span class="title">特质</span> 2<span class="keyword">with</span>  <span class="title">特质</span> 3<span class="title">…</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>类和特质的关系：使用继承的关系</li><li>当一个类去继承特质时，第一个连接词是 extends，后面是with</li><li>如果一个类在同时继承特质和父类时，应当把父类写在 extends 后</li></ul></li><li><strong>案例</strong><ul><li>特质可以同时拥有抽象方法和具体方法</li><li>一个类可以混入（mixin）多个特质</li><li>所有的 Java 接口都可以当做Scala 特质使用</li><li><strong>动态混入</strong>：可灵活的扩展类的功能<ul><li><font color=red>动态混入：创建对象时混入 trait，而无需使类混入该 trait</font></li><li>如果混入的 trait 中有未实现的方法，则需要实现</li></ul></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）特质可以同时拥有抽象方法和具体方法</span></span><br><span class="line"><span class="comment">// 声明属性</span></span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象属性</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SexTrait</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> sex: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//（2）一个类可以实现/继承多个特质</span></span><br><span class="line"><span class="comment">//（3）所有的 Java 接口都可以当做 Scala 特质使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">PersonTrait</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;say&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> age: <span class="type">Int</span> = _</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span></span><br><span class="line"></span><br><span class="line">teacher.say()</span><br><span class="line">teacher.eat()</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）动态混入：可灵活的扩展类的功能</span></span><br><span class="line"><span class="keyword">val</span> t2 = <span class="keyword">new</span> <span class="type">Teacher</span> <span class="keyword">with</span> <span class="type">SexTrait</span> &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> sex: <span class="type">String</span> = <span class="string">&quot;男&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用混入 trait 的属性</span></span><br><span class="line">println(t2.sex)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">say</span><br><span class="line">eat</span><br><span class="line">男</span><br></pre></td></tr></table></figure><h3 id="3-特质叠加">3.特质叠加</h3><p><strong>由于一个类可以混入（mixin）多个 trait，且 trait 中可以有具体的属性和方法，若混入的特质中具有相同的方法（方法名，参数列表，返回值均相同），必然会出现继承冲突问题。<br>冲突分为以下两种：</strong></p><ul><li>一个类（Sub）混入的两个 trait（TraitA，TraitB）中具有相同的具体方法，且两个 trait 之间没有任何关系，解决这类冲突问题，直接在类（Sub）中重写冲突方法<br><img src="https://img-blog.csdnimg.cn/2021040715005761.png" alt="在这里插入图片描述"></li><li>一个类（Sub）混入的两个 trait（TraitA，TraitB）中具有相同的具体方法，且两个 trait 继承自相同的 trait（TraitC），及所谓的“钻石问题”，解决这类冲突问题，Scala 采用了特质叠加的策略<br><img src="https://img-blog.csdnimg.cn/20210407150151294.png" alt="在这里插入图片描述"></li><li><strong>案例</strong><ul><li>所谓的特质叠加，就是将混入的多个 trait 中的冲突方法叠加起来</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123; </span><br><span class="line"><span class="string">&quot;ball&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123; </span><br><span class="line"><span class="string">&quot;blue-&quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Category</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123; </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line"><span class="string">&quot;foot-&quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBall</span> <span class="keyword">extends</span> <span class="title">Category</span> <span class="keyword">with</span> <span class="title">Color</span> </span>&#123; </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line"><span class="string">&quot;my ball is a &quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line">println(<span class="keyword">new</span> <span class="type">MyBall</span>().describe())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my ball is a blue-foot-ball</span><br></pre></td></tr></table></figure><h3 id="4-特质叠加执行顺序">4.特质叠加执行顺序</h3><p>上面案例中的 super.describe()调用的是父 trait 中的方法吗？<br><strong>当一个类混入多个特质的时候，scala 会对所有的特质及其父特质按照一定的顺序进行排序，而此案例中的 super.describe()调用的实际上是排好序后的下一个特质中的 describe() 方法。排序规则如下：</strong><br><img src="https://img-blog.csdnimg.cn/2021040909110545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>结论</strong><ul><li>案例中的 super，不是表示其父特质对象，而是表示上述叠加顺序中的下一个特质，即，<font color=red>MyClass 中的 super 指代 Color，Color 中的 super 指代 Category，Category 中的 super指代 Ball</font></li><li>如果想要调用某个指定的混入特质中的方法，可以增加约束：super[]，例如super[Category].describe()</li></ul></li></ul><h3 id="5-特质自身类型">5.特质自身类型</h3><ul><li><strong>说明</strong><ul><li>自身类型可实现依赖注入的功能</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(user: <span class="type">User</span>) = &#123;</span><br><span class="line">    println(<span class="string">&quot;insert into database :&quot;</span> + user.name)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">APP</span> </span>&#123;</span><br><span class="line">  _: <span class="type">Dao</span> =&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">login</span></span>(user: <span class="type">User</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;login :&quot;</span> + user.name)</span><br><span class="line">    insert(user)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">APP</span> <span class="keyword">with</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    login(<span class="keyword">new</span> <span class="type">User</span>(<span class="string">&quot;bobo&quot;</span>, <span class="number">11</span>))</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login :bobo</span><br><span class="line">insert into database :bobo</span><br></pre></td></tr></table></figure><h3 id="6-特质和抽象类的区别">6.特质和抽象类的区别</h3><ul><li><strong>优先使用特质：一个类扩展多个特质是很方便的，但却只能扩展一个抽象类</strong></li><li><strong>如果你需要构造函数参数，使用抽象类。因为抽象类可以定义<font color=red>带参数</font>的构造函数，而特质不行（有无参构造）</strong></li></ul><h2 id="扩展">扩展</h2><h3 id="1-类型转换和检查">1.类型转换和检查</h3><ul><li><strong>说明</strong><ul><li>obj.isInstanceOf[T]：判断 obj 是不是T 类型</li><li>obj.asInstanceOf[T]：将 obj 强转成 T 类型</li><li>classOf 获取对象的类名</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）判断对象是否为某个类型的实例</span></span><br><span class="line"><span class="keyword">val</span> bool: <span class="type">Boolean</span> = person.isInstanceOf[<span class="type">Person</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( bool ) &#123;</span><br><span class="line"><span class="comment">//（2）将对象转换为某个类型的实例</span></span><br><span class="line"><span class="keyword">val</span> p1: <span class="type">Person</span> = person.asInstanceOf[<span class="type">Person</span>] </span><br><span class="line">println(p1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）获取类的信息</span></span><br><span class="line"><span class="keyword">val</span> pClass: <span class="type">Class</span>[<span class="type">Person</span>] = classOf[<span class="type">Person</span>] </span><br><span class="line">println(pClass)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.demo.Person@16c0663d</span><br><span class="line">class com.demo.Person</span><br></pre></td></tr></table></figure><h3 id="2-枚举类和应用类">2.枚举类和应用类</h3><ul><li><strong>说明</strong><ul><li>枚举类：需要继承 Enumeration</li><li>应用类：需要继承App</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="type">Color</span>.<span class="type">RED</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">RED</span> = <span class="type">Value</span>(<span class="number">1</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">YELLOW</span> = <span class="type">Value</span>(<span class="number">2</span>, <span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">BLUE</span> = <span class="type">Value</span>(<span class="number">3</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用类</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test20</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">&quot;xxxxxxxxxxx&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">red</span><br></pre></td></tr></table></figure><h3 id="3-Type定义新类型">3.Type定义新类型</h3><ul><li><strong>说明</strong><ul><li>使用 type 关键字可以定义新的数据数据类型名称，本质上就是类型的一个别名</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; <span class="class"><span class="keyword">type</span> <span class="title">S=String</span></span></span><br><span class="line">    <span class="keyword">var</span> v:<span class="type">S</span>=<span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>():<span class="type">S</span>=<span class="string">&quot;xyz&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、集合">七、集合</h1><h2 id="集合简介">集合简介</h2><ul><li><strong>Scala的集合有三大类：序列Seq、集合Set、映射Map，所有的集合都扩展自Iterable特质</strong></li><li><strong>对于几乎所有的集合类，Scala 都同时提供了<font color=red>可变</font>和<font color=red>不可变</font>的版本，分别位于以下两个包</strong><ul><li>不可变集合：scala.collection.immutable</li><li>可变集合： scala.collection.mutable</li></ul></li><li><strong>Scala 不可变集合，就是指该集合对象不可修改，每次修改就会返回一个新对象，而<br>不会对原对象进行修改。类似于 java 中的 String 对象</strong></li><li><strong>可变集合，就是这个集合可以直接对原对象进行修改，而不会返回新的对象。类似<br>于 java 中 StringBuilder 对象</strong></li></ul><p><strong><font color=red>注：</font>建议在操作集合时，不可变用符号，可变用方法</strong></p><h3 id="1-不可变集合继承图">1.不可变集合继承图</h3><p><img src="https://img-blog.csdnimg.cn/20210409095846298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>Set、Map 是 Java 中也有的集合</strong></li><li><strong>Seq 是 Java 没有的，我们发现 List 归属到 Seq 了，因此这里的 List 就和 Java 不是同一个概念了</strong></li><li><strong>前面的 for 循环有一个 1 to 3，就是 IndexedSeq 下的 Range</strong></li><li><strong>String 也是属于 IndexedSeq</strong></li><li><strong>经典的数据结构比如 Queue 和 Stack 被归属到 LinearSeq(线性序列)</strong></li><li><strong>Scala 中的 Map 体系有一个 SortedMap，说明 Scala 的 Map 可以支持排序</strong></li><li><strong>IndexedSeq 和 LinearSeq 的区别：</strong><ul><li>IndexedSeq 是通过索引来查找和定位，因此速度快，比如 String 就是一个索引集合，通过索引即可定位</li><li>LinearSeq 是线型的，即有头尾的概念，这种数据结构一般是通过遍历来查找</li></ul></li></ul><h2 id="2-可变集合继承图">2.可变集合继承图</h2><p><img src="https://img-blog.csdnimg.cn/20210409100309773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="数组">数组</h2><h3 id="1-不可变数组">1.不可变数组</h3><ul><li><strong>定义数组（方式一）</strong><ul><li>new 是关键字</li><li>[Int]是指定可以存放的数据类型，如果希望存放任意数据类型，则指定 Any</li><li>(10)，表示数组的大小，确定后就不可以变化</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr1 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArray</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）数组定义</span></span><br><span class="line"><span class="keyword">val</span> arr01 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">println(arr01.length) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）数组赋值</span></span><br><span class="line"><span class="comment">//（2.1）修改某个元素的值</span></span><br><span class="line">arr01(<span class="number">3</span>) = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2.2）采用方法的形式给数组赋值</span></span><br><span class="line">arr01.update(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历数组</span></span><br><span class="line"><span class="comment">//（3.1）查看数组</span></span><br><span class="line">println(arr01.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.2）普通遍历</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.3）简化遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printx</span></span>(elem:<span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(elem)</span><br><span class="line">&#125;</span><br><span class="line">arr01.foreach(printx)</span><br><span class="line"><span class="comment">// arr01.foreach((x)=&gt;&#123;println(x)&#125;)</span></span><br><span class="line"><span class="comment">// arr01.foreach(println(_))</span></span><br><span class="line">arr01.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）增加元素（由于创建的是不可变数组，增加元素，其实是产生新的数组）</span></span><br><span class="line">println(arr01)</span><br><span class="line"><span class="keyword">val</span> ints: <span class="type">Array</span>[<span class="type">Int</span>] = arr01 :+ <span class="number">5</span></span><br><span class="line">println(ints)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1,0,0,10</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br><span class="line">[I@1cd072a9</span><br><span class="line">[I@2812cbfa</span><br></pre></td></tr></table></figure><ul><li><strong>定义数组（方式二）</strong><ul><li>在定义数组时，直接赋初始值</li><li>使用 apply 方法创建数组对象</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArray</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">var</span> arr02 = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;bobo&quot;</span>)</span><br><span class="line">println(arr02.length)</span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr02) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">bobo</span><br></pre></td></tr></table></figure><h3 id="2-可变数组">2.可变数组</h3><ul><li><strong>定义可变数组</strong><ul><li>[Any]存放任意数据类型</li><li>(3, 2, 5)初始化好的三个元素</li><li>ArrayBuffer 需要引入 scala.collection.mutable.ArrayBuffer</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr01 = <span class="type">ArrayBuffer</span>[<span class="type">Any</span>](<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong><ul><li>ArrayBuffer 是有序的集合</li><li>增加元素使用的是 append 方法()，支持可变参数</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArrayBuffer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）创建并初始赋值可变数组</span></span><br><span class="line"><span class="keyword">val</span> arr01 = <span class="type">ArrayBuffer</span>[<span class="type">Any</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">println(arr01.length) <span class="comment">// 3</span></span><br><span class="line">println(<span class="string">&quot;arr01.hash=&quot;</span> + arr01.hashCode())</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）增加元素</span></span><br><span class="line"><span class="comment">//（3.1）追加数据</span></span><br><span class="line">arr01.+=(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.2）向数组最后追加数据</span></span><br><span class="line">arr01.append(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.3）向指定的位置插入数据</span></span><br><span class="line">arr01.insert(<span class="number">0</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">println(<span class="string">&quot;arr01.hash=&quot;</span> + arr01.hashCode())</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）修改元素</span></span><br><span class="line">arr01(<span class="number">1</span>) = <span class="number">9</span> <span class="comment">//修改第 2 个元素的值</span></span><br><span class="line">println(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">println(arr01.length) <span class="comment">// 5</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">arr01.hash=387518613</span><br><span class="line">arr01.hash=-253706129</span><br><span class="line">--------------------------</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="3-不可变数组与可变数组的转换">3.不可变数组与可变数组的转换</h3><ul><li><strong>说明</strong><ul><li>arr2.toArray 返回结果才是一个不可变数组，arr2 本身没有变化</li><li>arr1.toBuffer 返回结果才是一个可变数组，arr1 本身没有变化</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1.toBuffer <span class="comment">//不可变数组转可变数组</span></span><br><span class="line">arr2.toArray <span class="comment">//可变数组转不可变数组</span></span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArrayBuffer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）创建一个空的可变数组</span></span><br><span class="line"><span class="keyword">val</span> arr2 = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）追加值</span></span><br><span class="line">arr2.append(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">println(arr2) <span class="comment">// 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）ArrayBuffer ==&gt; Array</span></span><br><span class="line"><span class="comment">//（3.1）arr2.toArray 返回的结果是一个新的定长数组集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.2）arr2 它没有变化</span></span><br><span class="line"><span class="keyword">val</span> newArr = arr2.toArray</span><br><span class="line">println(newArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）Array ===&gt; ArrayBuffer</span></span><br><span class="line"><span class="comment">//（4.1）newArr.toBuffer 返回一个变长数组 newArr2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（4.2）newArr 没有任何变化，依然是定长数组</span></span><br><span class="line"><span class="keyword">val</span> newArr2 = newArr.toBuffer</span><br><span class="line">newArr2.append(<span class="number">123</span>)</span><br><span class="line">println(newArr2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBuffer(1, 2, 3)</span><br><span class="line">[I@6e8dacdf</span><br><span class="line">ArrayBuffer(1, 2, 3, 123)</span><br></pre></td></tr></table></figure><h3 id="4-多维数组">4.多维数组</h3><ul><li><strong>定义</strong><ul><li>二维数组中有三个一维数组，每个一维数组中有四个元素</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>.ofDim[<span class="type">Double</span>](<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）创建了一个二维数组, 有三个元素，每个元素是，含有 4 个元素一维数组()</span></span><br><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">arr(<span class="number">1</span>)(<span class="number">2</span>) = <span class="number">88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr) &#123; <span class="comment">//i 就是一维数组</span></span><br><span class="line"><span class="keyword">for</span> (j &lt;- i) &#123;</span><br><span class="line">print(j + <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 </span><br><span class="line">0 0 88 0 </span><br><span class="line">0 0 0 0 </span><br></pre></td></tr></table></figure><h2 id="列表List">列表List</h2><h3 id="1-不可变List">1.不可变List</h3><ul><li><strong>说明</strong><ul><li>List 默认为不可变集合</li><li>数据有顺序，可重复</li><li>集合间合并：将一个整体拆成一个一个的个体，称为扁平化</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//List 默认为不可变集合</span></span><br><span class="line"><span class="comment">//创建一个 List（数据有顺序，可重复）</span></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//空集合 Nil</span></span><br><span class="line"><span class="keyword">val</span> list5 = <span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="number">4</span>::<span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//List 增加数据</span></span><br><span class="line"><span class="comment">//（1）::的运算规则从右向左</span></span><br><span class="line"><span class="comment">//val list1 = 5::list</span></span><br><span class="line"><span class="keyword">val</span> list1 = <span class="number">7</span>::<span class="number">6</span>::<span class="number">5</span>::list</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）添加到第一个元素位置</span></span><br><span class="line"><span class="keyword">val</span> list2 = list.+:(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合间合并：将一个整体拆成一个一个的个体，称为扁平化</span></span><br><span class="line"><span class="keyword">val</span> list3 = <span class="type">List</span>(<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line"><span class="comment">//val list4 = list3::list1</span></span><br><span class="line"><span class="keyword">val</span> list4 = list3:::list1</span><br><span class="line"></span><br><span class="line"><span class="comment">//取指定数据</span></span><br><span class="line">println(list(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 List</span></span><br><span class="line"><span class="comment">//list.foreach(println)</span></span><br><span class="line"><span class="comment">//list1.foreach(println)</span></span><br><span class="line"><span class="comment">//list3.foreach(println)</span></span><br><span class="line"><span class="comment">//list4.foreach(println)</span></span><br><span class="line">list5.foreach(println)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="2-可变ListBuffer">2.可变ListBuffer</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）创建一个可变集合</span></span><br><span class="line"><span class="keyword">val</span> buffer = <span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）向集合中添加数据</span></span><br><span class="line">buffer.+=(<span class="number">5</span>)</span><br><span class="line">buffer.append(<span class="number">6</span>)</span><br><span class="line">buffer.insert(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）打印集合数据</span></span><br><span class="line">buffer.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）修改数据</span></span><br><span class="line">buffer(<span class="number">1</span>) = <span class="number">6</span></span><br><span class="line">buffer.update(<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（5）删除数据</span></span><br><span class="line">buffer.-(<span class="number">5</span>)</span><br><span class="line">buffer.-=(<span class="number">5</span>)</span><br><span class="line">buffer.remove(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="Set集合">Set集合</h2><p><strong>默认情况下，Scala 使用的是不可变集合，如果要使用可变集合，需要引用scala.collection.mutable.Set 包</strong></p><h3 id="1-不可变Set">1.不可变Set</h3><ul><li><strong>说明</strong><ul><li>Set 默认是不可变集合，数据无序</li><li>数据不可重复</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）Set 默认是不可变集合，数据无序</span></span><br><span class="line"><span class="keyword">val</span> set = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）数据不可重复</span></span><br><span class="line"><span class="keyword">val</span> set1 = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(x&lt;-set1)&#123;</span><br><span class="line">println(x)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="2-可变-mutable-Set">2.可变 mutable.Set</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）创建可变集合</span></span><br><span class="line"><span class="keyword">val</span> set = mutable.<span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）集合添加元素</span></span><br><span class="line">set += <span class="number">8</span></span><br><span class="line"><span class="comment">//（3）向集合中添加元素，返回一个新的 Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ints = set.+(<span class="number">9</span>)</span><br><span class="line">println(ints)</span><br><span class="line">println(<span class="string">&quot;set2=&quot;</span> + set)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）删除数据</span></span><br><span class="line">set-=(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">set.foreach(println)</span><br><span class="line">println(set.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set(9, 1, 5, 2, 6, 3, 4, 8)</span><br><span class="line">set2=Set(1, 5, 2, 6, 3, 4, 8)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">1,2,6,3,4,8</span><br></pre></td></tr></table></figure><h2 id="Map集合">Map集合</h2><p><strong>Scala 中的 Map 和 Java 类似，也是一个散列表，它存储的内容也是键值对（key-value）映射</strong></p><h3 id="1-不可变Map">1.不可变Map</h3><ul><li><strong>说明</strong><ul><li>如果 key 不存在，返回 0</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建不可变集合 Map</span></span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>( <span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问数据</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- map.keys) &#123;</span><br><span class="line"><span class="comment">// 使用 get 访问 map 集合的数据，会返回特殊类型 Option(选项):有值（Some），无值(None)</span></span><br><span class="line">println(elem + <span class="string">&quot;=&quot;</span> + map.get(elem).get)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 key 不存在，返回 0</span></span><br><span class="line">println(map.get(<span class="string">&quot;d&quot;</span>).getOrElse(<span class="number">0</span>))</span><br><span class="line">println(map.getOrElse(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">map.foreach((kv)=&gt;&#123;println(kv)&#125;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">(a,1)</span><br><span class="line">(b,2)</span><br><span class="line">(c,3)</span><br></pre></td></tr></table></figure><h3 id="2-可变Map">2.可变Map</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建可变集合</span></span><br><span class="line"><span class="keyword">val</span> map = mutable.<span class="type">Map</span>( <span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">//向集合增加数据</span></span><br><span class="line">map.+=(<span class="string">&quot;d&quot;</span>-&gt;<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 4 添加到集合，并把集合中原值 1 返回</span></span><br><span class="line"><span class="keyword">val</span> maybeInt: <span class="type">Option</span>[<span class="type">Int</span>] = map.put(<span class="string">&quot;a&quot;</span>, <span class="number">4</span>)</span><br><span class="line">println(maybeInt.getOrElse(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">map.-=(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改数据</span></span><br><span class="line">map.update(<span class="string">&quot;d&quot;</span>,<span class="number">5</span>)</span><br><span class="line">map(<span class="string">&quot;d&quot;</span>) = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">map.foreach((kv)=&gt;&#123;println(kv)&#125;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">(d,5)</span><br><span class="line">(a,4)</span><br></pre></td></tr></table></figure><h2 id="元组">元组</h2><ul><li><strong>说明</strong><ul><li>元组也是可以理解为一个容器，可以存放各种相同或不同类型的数据。说的简单点，就是将多个无关的数据封装为一个整体，称为元组</li></ul></li><li><strong>演示</strong><ul><li>Map 中的键值对其实就是元组,只不过元组的元素个数为 2，称之为对偶</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTuple</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）声明元组的方式：(元素 1，元素 2，元素 3)</span></span><br><span class="line"><span class="keyword">val</span> tuple: (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Boolean</span>) = (<span class="number">40</span>,<span class="string">&quot;bobo&quot;</span>,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）访问元组</span></span><br><span class="line"><span class="comment">//（2.1）通过元素的顺序进行访问，调用方式：_顺序号</span></span><br><span class="line">println(tuple._1)</span><br><span class="line">println(tuple._2)</span><br><span class="line">println(tuple._3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2.2）通过索引访问数据</span></span><br><span class="line">println(tuple.productElement(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2.3）通过迭代器访问数据</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- tuple.productIterator) &#123;</span><br><span class="line">println(elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）Map 中的键值对其实就是元组,只不过元组的元素个数为 2，称之为对偶</span></span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> map1 = <span class="type">Map</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>), (<span class="string">&quot;b&quot;</span>,<span class="number">2</span>), (<span class="string">&quot;c&quot;</span>,<span class="number">3</span>))</span><br><span class="line">map.foreach(tuple=&gt;&#123;println(tuple._1 + <span class="string">&quot;=&quot;</span> + tuple._2)&#125;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">40</span><br><span class="line">bobo</span><br><span class="line">true</span><br><span class="line">40</span><br><span class="line">40</span><br><span class="line">bobo</span><br><span class="line">true</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br></pre></td></tr></table></figure><h2 id="集合常用函数">集合常用函数</h2><h3 id="1-基本属性和常用操作">1.基本属性和常用操作</h3><ul><li><strong>需求</strong><ul><li>获取集合长度</li><li>获取集合大小</li><li>循环遍历</li><li>迭代器</li><li>生成字符串</li><li>是否包含</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）获取集合长度</span></span><br><span class="line">println(list.length)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）获取集合大小,等同于 length</span></span><br><span class="line">println(list.size)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）循环遍历</span></span><br><span class="line">list.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）迭代器</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- list.itera tor) &#123;</span><br><span class="line">println(elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（5）生成字符串</span></span><br><span class="line">println(list.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//（6）是否包含</span></span><br><span class="line">println(list.contains(<span class="number">3</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-衍生集合">2.衍生集合</h3><ul><li><strong>需求</strong><ul><li>获取集合的头</li><li>获取集合的尾（不是头的就是尾）</li><li>集合最后一个数据</li><li>集合初始数据（不包含最后一个）</li><li>反转</li><li>取前（后）n 个元素</li><li>去掉前（后）n 个元素</li><li>并集</li><li>交集</li><li>差集</li><li>拉链</li><li>滑窗</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">val</span> list2: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合的头</span></span><br><span class="line">println(list1.head)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合的尾（不是头的就是尾）</span></span><br><span class="line">println(list1.tail)</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合最后一个数据</span></span><br><span class="line">println(list1.last)</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合初始数据（不包含最后一个）</span></span><br><span class="line">println(list1.init)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转</span></span><br><span class="line">println(list1.reverse)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取前（后）n 个元素</span></span><br><span class="line">println(list1.take(<span class="number">3</span>))</span><br><span class="line">println(list1.takeRight(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//去掉前（后）n 个元素</span></span><br><span class="line">println(list1.drop(<span class="number">3</span>))</span><br><span class="line">println(list1.dropRight(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">println(list1.union(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line">println(list1.intersect(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line">println(list1.diff(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉链 注:如果两个集合的元素个数不相等，那么会将同等数量的数据进行拉链，多余的数据省略不用</span></span><br><span class="line">println(list1.zip(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//滑窗</span></span><br><span class="line">list1.sliding(<span class="number">2</span>, <span class="number">5</span>).foreach(println)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">List(2, 3, 4, 5, 6, 7)</span><br><span class="line">7</span><br><span class="line">List(1, 2, 3, 4, 5, 6)</span><br><span class="line">List(7, 6, 5, 4, 3, 2, 1)</span><br><span class="line">List(1, 2, 3)</span><br><span class="line">List(5, 6, 7)</span><br><span class="line">List(4, 5, 6, 7)</span><br><span class="line">List(1, 2, 3, 4)</span><br><span class="line">List(1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 8, 9, 10)</span><br><span class="line">List(4, 5, 6, 7)</span><br><span class="line">List(1, 2, 3)</span><br><span class="line">List((1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10))</span><br><span class="line">List(1, 2)</span><br><span class="line">List(6, 7)</span><br></pre></td></tr></table></figure><h3 id="3-集合计算简单函数">3.集合计算简单函数</h3><ul><li><strong>需求</strong><ul><li>求和</li><li>求乘积</li><li>最大值</li><li>最小值</li><li>排序</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-7</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">println(list.sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">//求乘积</span></span><br><span class="line">println(list.product)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值</span></span><br><span class="line">println(list.max)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">println(list.min)</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">// （1）按照元素大小排序</span></span><br><span class="line">println(list.sortBy(x =&gt; x))</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）按照元素的绝对值大小排序</span></span><br><span class="line">println(list.sortBy(x =&gt; x.abs))</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）按元素大小升序排序</span></span><br><span class="line">println(list.sortWith((x, y) =&gt; x &lt; y))</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）按元素大小降序排序</span></span><br><span class="line">println(list.sortWith((x, y) =&gt; x &gt; y))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">5040</span><br><span class="line">6</span><br><span class="line">-7</span><br><span class="line">List(-7, -3, 1, 2, 4, 5, 6)</span><br><span class="line">List(1, 2, -3, 4, 5, 6, -7)</span><br><span class="line">List(-7, -3, 1, 2, 4, 5, 6)</span><br><span class="line">List(6, 5, 4, 2, 1, -3, -7)</span><br></pre></td></tr></table></figure><ul><li><strong>sorted</strong><ul><li>对一个集合进行自然排序，通过传递隐式的 Ordering</li></ul></li><li><strong>sortBy</strong><ul><li>对一个属性或多个属性进行排序，通过它的类型</li></ul></li><li><strong>sortWith</strong><ul><li>基于函数的排序，通过一个 comparator 函数，实现自定义排序的逻辑</li></ul></li></ul><h3 id="4-集合计算高级函数">4.集合计算高级函数</h3><ul><li><strong>需求</strong><ul><li>过滤<ul><li>遍历一个集合并从中获取满足指定条件的元素组成一个新的集合</li></ul></li><li>转化/映射（map）<ul><li>将集合中的每一个元素映射到某一个函数</li></ul></li><li>扁平化</li><li>扁平化+映射 （flatMap 相当于先进行 map 操作，在进行 flatten 操作集合中的每个元素的子元素映射到某个函数并返回新集合）</li><li>分组(group)<ul><li>按照指定的规则对集合的元素进行分组</li></ul></li><li>简化（归约）</li><li>折叠</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">val</span> nestedList: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="type">List</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line"><span class="keyword">val</span> wordList: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello atguigu&quot;</span>, <span class="string">&quot;hello scala&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤</span></span><br><span class="line">println(list.filter(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化/映射</span></span><br><span class="line">println(list.map(x =&gt; x + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//扁平化</span></span><br><span class="line">println(nestedList.flatten)</span><br><span class="line"></span><br><span class="line"><span class="comment">//扁平化+映射 注：flatMap 相当于先进行 map 操作，在进行 flatten操作</span></span><br><span class="line">println(wordList.flatMap(x =&gt; x.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line">println(list.groupBy(x =&gt; x % <span class="number">2</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List(2, 4, 6, 8)</span><br><span class="line">List(2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br><span class="line">List(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line">List(hello, world, hello, atguigu, hello, scala)</span><br><span class="line">Map(1 -&gt; List(1, 3, 5, 7, 9), 0 -&gt; List(2, 4, 6, 8))</span><br></pre></td></tr></table></figure><ul><li><strong>Reduce 方法</strong><ul><li>Reduce 简化（归约） ：通过指定的逻辑将集合中的数据进行聚合，从而减少数据，最终获取结果</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestReduce</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据两两结合，实现运算规则</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="type">Int</span> = list.reduce( (x,y) =&gt; x-y )</span><br><span class="line">println(<span class="string">&quot;i = &quot;</span> + i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从源码的角度，reduce 底层调用的其实就是 reduceLeft</span></span><br><span class="line"><span class="comment">//val i1 = list.reduceLeft((x,y) =&gt; x-y)</span></span><br><span class="line"><span class="comment">// ((4-3)-2-1) = -2</span></span><br><span class="line"><span class="keyword">val</span> i2 = list.reduceRight((x,y) =&gt; x-y)</span><br><span class="line">println(i2)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = -8</span><br><span class="line">-2</span><br></pre></td></tr></table></figure><ul><li><strong>Fold 方法</strong><ul><li>Fold 折叠：化简的一种特殊情况</li></ul></li><li><strong>演示1</strong><ul><li>fold 基本使用</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFold</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fold 方法使用了函数柯里化，存在两个参数列表</span></span><br><span class="line"><span class="comment">// 第一个参数列表为 ： 零值（初始值）</span></span><br><span class="line"><span class="comment">// 第二个参数列表为： 简化规则</span></span><br><span class="line"><span class="comment">// fold 底层其实为 foldLeft</span></span><br><span class="line"><span class="keyword">val</span> i = list.foldLeft(<span class="number">1</span>)((x,y)=&gt;x-y)</span><br><span class="line"><span class="keyword">val</span> i1 = list.foldRight(<span class="number">10</span>)((x,y)=&gt;x-y)</span><br><span class="line">println(i)</span><br><span class="line">println(i1)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-9</span><br><span class="line">8</span><br></pre></td></tr></table></figure><ul><li><strong>演示2</strong><ul><li>两个集合合并</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFold</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 两个 Map 的数据合并</span></span><br><span class="line"><span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> map2 = mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">4</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">5</span>, <span class="string">&quot;d&quot;</span>-&gt;<span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> map3: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map2.foldLeft(map1) &#123;</span><br><span class="line">(map, kv) =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> k = kv._1</span><br><span class="line"><span class="keyword">val</span> v = kv._2</span><br><span class="line">map(k) = map.getOrElse(k, <span class="number">0</span>) + v</span><br><span class="line">map</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">println(map3)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map(b -&gt; 7, d -&gt; 6, a -&gt; 5, c -&gt; 3)</span><br></pre></td></tr></table></figure><h3 id="5-普通wordcount案例">5.普通wordcount案例</h3><ul><li><strong>需求</strong><ul><li>单词计数：将集合中出现的相同的单词，进行计数，取计数排名前三的结果</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestWordCount</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单词计数：将集合中出现的相同的单词，进行计数，取计数排名前三的结果</span></span><br><span class="line"><span class="keyword">val</span> stringList = <span class="type">List</span>(<span class="string">&quot;Hello Scala Hbase kafka&quot;</span>, <span class="string">&quot;Hello Scala Hbase&quot;</span>, <span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) 将每一个字符串转换成一个一个单词</span></span><br><span class="line"><span class="keyword">val</span> wordList: <span class="type">List</span>[<span class="type">String</span>] = stringList.flatMap(str=&gt;str.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="comment">//println(wordList)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 将相同的单词放置在一起</span></span><br><span class="line"><span class="keyword">val</span> wordToWordsMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">String</span>]] = wordList.groupBy(word=&gt;word)</span><br><span class="line"><span class="comment">//println(wordToWordsMap)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 对相同的单词进行计数</span></span><br><span class="line"><span class="comment">// (word, list) =&gt; (word, count)</span></span><br><span class="line"><span class="keyword">val</span> wordToCountMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = wordToWordsMap.map(tuple=&gt;(tuple._1, tuple._2.size))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) 对计数完成后的结果进行排序（降序）</span></span><br><span class="line"><span class="keyword">val</span> sortList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToCountMap.toList.sortWith &#123;</span><br><span class="line">(left, right) =&gt; &#123;</span><br><span class="line">left._2 &gt; right._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5) 对排序后的结果取前 3 名</span></span><br><span class="line"><span class="keyword">val</span> resultList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = sortList.take(<span class="number">3</span>)</span><br><span class="line">println(resultList)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List((Hello,4), (Scala,3), (Hbase,2))</span><br></pre></td></tr></table></figure><h3 id="6-复杂wordcount案例">6.复杂wordcount案例</h3><ul><li><strong>方式一（不通用）</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestWordCount</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tupleList = <span class="type">List</span>((<span class="string">&quot;Hello Scala Spark World &quot;</span>, <span class="number">4</span>), (<span class="string">&quot;Hello Scala Spark&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;Hello Scala&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> stringList: <span class="type">List</span>[<span class="type">String</span>] = tupleList.map(t=&gt;(t._1 + <span class="string">&quot; &quot;</span>) * t._2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//val words: List[String] = stringList.flatMap(s=&gt;s.split(&quot; &quot;))</span></span><br><span class="line"><span class="keyword">val</span> words: <span class="type">List</span>[<span class="type">String</span>] = stringList.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 map 中，如果传进来什么就返回什么，不要用_省略</span></span><br><span class="line"><span class="keyword">val</span> groupMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">String</span>]] = words.groupBy(word=&gt;word)</span><br><span class="line"><span class="comment">//val groupMap: Map[String, List[String]] = words.groupBy(_)</span></span><br><span class="line"><span class="comment">// (word, list) =&gt; (word, count)</span></span><br><span class="line"><span class="keyword">val</span> wordToCount: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = groupMap.map(t=&gt;(t._1, t._2.size))</span><br><span class="line"><span class="keyword">val</span> wordCountList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToCount.toList.sortWith &#123;</span><br><span class="line">(left, right) =&gt; &#123;</span><br><span class="line">left._2 &gt; right._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;.take(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//tupleList.map(t=&gt;(t._1 + &quot; &quot;) * t._2).flatMap(_.split(&quot; &quot;)).groupBy(word=&gt;word).map(t=&gt;(t._1, t._2.size))</span></span><br><span class="line">println(wordCountList)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List((Hello,10), (Scala,9), (Spark,7))</span><br></pre></td></tr></table></figure><ul><li><strong>方式二</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestWordCount</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> tuples = <span class="type">List</span>((<span class="string">&quot;Hello Scala Spark World&quot;</span>, <span class="number">4</span>), (<span class="string">&quot;Hello Scala Spark&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;Hello Scala&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// (Hello,4),(Scala,4),(Spark,4),(World,4)</span></span><br><span class="line"><span class="comment">// (Hello,3),(Scala,3),(Spark,3)</span></span><br><span class="line"><span class="comment">// (Hello,2),(Scala,2)</span></span><br><span class="line"><span class="comment">// (Hello,1)</span></span><br><span class="line"><span class="keyword">val</span> wordToCountList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = tuples.flatMap &#123;</span><br><span class="line">t =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> strings: <span class="type">Array</span>[<span class="type">String</span>] = t._1.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">strings.map(word =&gt; (word, t._2))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello, List((Hello,4), (Hello,3), (Hello,2), (Hello,1))</span></span><br><span class="line"><span class="comment">// Scala, List((Scala,4), (Scala,3), (Scala,2)</span></span><br><span class="line"><span class="comment">// Spark, List((Spark,4), (Spark,3)</span></span><br><span class="line"><span class="comment">// Word, List((Word,4))</span></span><br><span class="line"><span class="keyword">val</span> wordToTupleMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = wordToCountList.groupBy(t=&gt;t._1)</span><br><span class="line"><span class="keyword">val</span> stringToInts: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">Int</span>]] = wordToTupleMap.mapValues &#123;</span><br><span class="line">datas =&gt; datas.map(t =&gt; t._2)</span><br><span class="line">&#125;</span><br><span class="line">stringToInts</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">val wordToCountMap: Map[String, List[Int]] = wordToTupleMap.map &#123;</span></span><br><span class="line"><span class="comment">t =&gt; &#123;</span></span><br><span class="line"><span class="comment">(t._1, t._2.map(t1 =&gt; t1._2))</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">val wordToTotalCountMap: Map[String, Int] = wordToCountMap.map(t=&gt;(t._1, t._2.sum))</span></span><br><span class="line"><span class="comment">println(wordToTotalCountMap)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-队列">8.队列</h3><ul><li><strong>说明</strong><ul><li>Scala 也提供了队列（Queue）的数据结构，队列的特点就是先进先出。进队和出队的方法分别为 enqueue 和 dequeue</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestQueue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> que = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">String</span>]()</span><br><span class="line">que.enqueue(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line">println(que.dequeue())</span><br><span class="line">println(que.dequeue())</span><br><span class="line">println(que.dequeue())</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h3 id="9-并行集合">9.并行集合</h3><ul><li><strong>说明</strong><ul><li>Scala 为了充分使用<font color=red>多核 CPU</font>，提供了并行集合（有别于前面的串行集合），用于多核环境的并行计算</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestPar</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result1 = (<span class="number">0</span> to <span class="number">100</span>).map&#123;</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="type">Thread</span>.currentThread.getName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> result2 = (<span class="number">0</span> to <span class="number">100</span>).par.map&#123;</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="type">Thread</span>.currentThread.getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(result1)</span><br><span class="line">println(result2)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector(main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main)</span><br><span class="line">ParVector(scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-14, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14)</span><br></pre></td></tr></table></figure><h1 id="八、模式匹配">八、模式匹配</h1><p><strong>Scala 中的模式匹配类似于 Java 中的 switch 语法，补充了更多的功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span> :</span><br><span class="line">System.out.println(<span class="string">&quot;10&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span> : </span><br><span class="line">System.out.println(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> : </span><br><span class="line">System.out.println(<span class="string">&quot;other number&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本语法">基本语法</h2><p><strong>模式匹配语法中，采用 match 关键字声明，每个分支采用 case 关键字进行声明，当需要匹配时，会从第一个 case 分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有 case 都不匹配，那么会执行 case _分支，类似于 Java 中 default 语句</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchCase</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> operator: <span class="type">Char</span> = &#x27;d&#x27;</span><br><span class="line"><span class="keyword">var</span> result = operator <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &#x27;+&#x27; =&gt; a + b</span><br><span class="line"><span class="keyword">case</span> &#x27;-&#x27; =&gt; a - b</span><br><span class="line"><span class="keyword">case</span> &#x27;*&#x27; =&gt; a * b</span><br><span class="line"><span class="keyword">case</span> &#x27;/&#x27; =&gt; a / b</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;illegal&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(result)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">illegal</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>如果所有 case 都不匹配，那么会执行 case _ 分支，类似于 Java 中 default 语句，若此时没有 case _ 分支，那么会抛出 MatchError</li><li>每个 case 中，不需要使用 break 语句，自动中断 case</li><li>match case 语句可以匹配任何类型，而不只是字面量</li><li>=&gt; 后面的代码块，直到下一个 case 语句之前的代码是<font color=red>作为一个整体执行</font>，可以使用{}括起来，也可以不括</li></ul></li></ul><h2 id="模式守卫">模式守卫</h2><ul><li><strong>说明</strong><ul><li>如果想要表达匹配某个范围的数据，就需要在模式匹配中增加条件守卫</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchGuard</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Int</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i: <span class="type">Int</span> <span class="keyword">if</span> i &gt;= <span class="number">0</span> =&gt; i</span><br><span class="line"><span class="keyword">case</span> j: <span class="type">Int</span> <span class="keyword">if</span> j &lt; <span class="number">0</span> =&gt; -j</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;type illegal&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(abs(<span class="number">-5</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="模式匹配类型">模式匹配类型</h2><h3 id="1-匹配常量">1.匹配常量</h3><ul><li><strong>说明</strong><ul><li>Scala 中，模式匹配可以匹配所有的字面量，包括字符串，字符，数字，布尔值等等</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchVal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(describe(<span class="number">6</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> =&gt; <span class="string">&quot;Int five&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> =&gt; <span class="string">&quot;String hello&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="string">&quot;Boolean true&quot;</span></span><br><span class="line"><span class="keyword">case</span> &#x27;+&#x27; =&gt; <span class="string">&quot;Char +&quot;</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String hello</span><br></pre></td></tr></table></figure><h3 id="2-匹配类型">2.匹配类型</h3><ul><li><strong>说明</strong><ul><li>需要进行类型判断时，可以使用前文所学的 isInstanceOf[T]和 asInstanceOf[T]，也可使用模式匹配实现同样的功能</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i: <span class="type">Int</span> =&gt; <span class="string">&quot;Int&quot;</span></span><br><span class="line"><span class="keyword">case</span> s: <span class="type">String</span> =&gt; <span class="string">&quot;String hello&quot;</span></span><br><span class="line"><span class="keyword">case</span> m: <span class="type">List</span>[_] =&gt; <span class="string">&quot;List&quot;</span></span><br><span class="line"><span class="keyword">case</span> c: <span class="type">Array</span>[<span class="type">Int</span>] =&gt; <span class="string">&quot;Array[Int]&quot;</span></span><br><span class="line"><span class="keyword">case</span> someThing =&gt; <span class="string">&quot;something else &quot;</span> + someThing</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//泛型擦除</span></span><br><span class="line">println(describe(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)))</span><br><span class="line"><span class="comment">//数组例外，可保留泛型</span></span><br><span class="line">println(describe(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)))</span><br><span class="line">println(describe(<span class="type">Array</span>(<span class="string">&quot;abc&quot;</span>)))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List</span><br><span class="line">Array[Int]</span><br><span class="line">something else [Ljava.lang.String;@7cf10a6f</span><br></pre></td></tr></table></figure><h3 id="3-匹配数组">3.匹配数组</h3><ul><li><strong>说明</strong><ul><li>scala 模式匹配可以对集合进行精确的匹配，例如匹配只有两个元素的、且第一个元素为 0 的数组</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">for</span> (arr &lt;- <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="type">Array</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">90</span>))) &#123; <span class="comment">// 对一个数组集合进行遍历</span></span><br><span class="line"><span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="string">&quot;0&quot;</span> <span class="comment">//匹配 Array(0) 这个数组</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Array</span>(x, y) =&gt; x + <span class="string">&quot;,&quot;</span> + y <span class="comment">//匹配有两个元素的数组，然后将将元素值赋给对应的 x,y</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">&quot;以 0 开头的数组&quot;</span> <span class="comment">//匹配以 0 开头和数组</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;result = &quot;</span> + result)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = 0</span><br><span class="line">result = 1,0</span><br><span class="line">result = 以 0 开头的数组</span><br><span class="line">result = something else</span><br><span class="line">result = something else</span><br><span class="line">result = hello,90</span><br></pre></td></tr></table></figure><h3 id="4-匹配列表">4.匹配列表</h3><ul><li><strong>方式一</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//list 是一个存放 List 集合的数组</span></span><br><span class="line"><span class="comment">//请思考，如果要匹配 List(88) 这样的只含有一个元素的列表,并原值返回.应该怎么写</span></span><br><span class="line"><span class="keyword">for</span> (list &lt;- <span class="type">Array</span>(<span class="type">List</span>(<span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">88</span>))) &#123;</span><br><span class="line"><span class="keyword">val</span> result = list <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>) =&gt; <span class="string">&quot;0&quot;</span> <span class="comment">//匹配 List(0)</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">List</span>(x, y) =&gt; x + <span class="string">&quot;,&quot;</span> + y <span class="comment">//匹配有两个元素的 List</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>, _*) =&gt; <span class="string">&quot;0 ...&quot;</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1,0</span><br><span class="line">0 ...</span><br><span class="line">something else</span><br><span class="line">something else</span><br></pre></td></tr></table></figure><ul><li><strong>方式二</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">list <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> first :: second :: rest =&gt; println(first + <span class="string">&quot;-&quot;</span> + second + <span class="string">&quot;-&quot;</span> + rest)</span><br><span class="line"><span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;something else&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-2-List(5, 6, 7)</span><br></pre></td></tr></table></figure><h3 id="5-匹配元组">5.匹配元组</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchTuple</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//对一个元组集合进行遍历</span></span><br><span class="line"><span class="keyword">for</span> (tuple &lt;- <span class="type">Array</span>((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))) &#123;</span><br><span class="line"><span class="keyword">val</span> result = tuple <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">&quot;0 ...&quot;</span> <span class="comment">//是第一个元素是 0 的元组</span></span><br><span class="line"><span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; <span class="string">&quot;&quot;</span> + y + <span class="string">&quot;0&quot;</span> <span class="comment">// 匹配后一个元素是 0 的对偶元组</span></span><br><span class="line"><span class="keyword">case</span> (a, b) =&gt; <span class="string">&quot;&quot;</span> + a + <span class="string">&quot; &quot;</span> + b</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span> <span class="comment">//默认</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 ...</span><br><span class="line">10</span><br><span class="line">1 1</span><br><span class="line">something else</span><br></pre></td></tr></table></figure><ul><li><strong>扩展案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的模式匹配 1 打印元组第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">println(elem._1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ((word,count) &lt;- <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">println(word)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ((word,_) &lt;- <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">println(word)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ((<span class="string">&quot;a&quot;</span>,count) &lt;- <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">println(count)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的模式匹配 2 给元组元素命名</span></span><br><span class="line"><span class="keyword">var</span> (id,name,age): (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Int</span>) = (<span class="number">100</span>, <span class="string">&quot;zs&quot;</span>, <span class="number">20</span>)</span><br><span class="line">println((id,name,age))</span><br><span class="line">println(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的模式匹配 3 遍历集合中的元组，给 count * 2</span></span><br><span class="line"><span class="keyword">var</span> list: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">//println(list.map(t =&gt; (t._1, t._2 * 2)))</span></span><br><span class="line">println(</span><br><span class="line">list.map&#123;</span><br><span class="line"><span class="keyword">case</span> (word,count)=&gt;(word,count*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> list1 = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, (<span class="string">&quot;a&quot;</span>, <span class="number">1</span>)), (<span class="string">&quot;b&quot;</span>, (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>)), (<span class="string">&quot;c&quot;</span>, (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">println(</span><br><span class="line">list1.map&#123;</span><br><span class="line"><span class="keyword">case</span> (groupkey,(word,count))=&gt;(word,count*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">1</span><br><span class="line">--------------</span><br><span class="line">(100,zs,20)</span><br><span class="line">--------------</span><br><span class="line">List((a,2), (b,4), (c,6))</span><br><span class="line">List((a,2), (b,4), (c,6))</span><br></pre></td></tr></table></figure><h3 id="6-匹配对象及样例类">6.匹配对象及样例类</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>): <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>(name, age)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(user: <span class="type">User</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = &#123;</span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line"><span class="type">None</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="type">Some</span>(user.name, user.age)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchUnapply</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> user: <span class="type">User</span> = <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> result = user <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>) =&gt; <span class="string">&quot;yes&quot;</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;no&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure><ul><li><strong>小结</strong><ul><li>val user = User(“zhangsan”,11)，该语句在执行时，实际调用的是 User 伴生对象中的apply 方法，因此不用 new 关键字就能构造出相应的对象</li><li>当将 User(“zhangsan”, 11)写在 case 后时[case User(“zhangsan”, 11) =&gt; “yes”]，会默认调用 unapply 方法(对象提取器)，<font color=red>user 作为 unapply 方法的参数</font>，unapply 方法将 user 对象的 name 和 age 属性提取出来，与 User(“zhangsan”, 11)中的属性值进行匹配</li><li>case 中对象的 unapply 方法(提取器)返回 Some，且所有属性均一致，才算匹配成功,属性不一致，或返回 None，则匹配失败</li><li>若只提取对象的一个属性，则提取器为 <font color=red>unapply</font>(obj:Obj):<font color=red>Option[</font>T<font color=red>]</font><br>若提取对象的多个属性，则提取器为 <font color=red>unapply</font>(obj:Obj):<font color=red>Option[</font>(T1,T2,T3…)<font color=red>]</font><br>若提取对象的可变个属性，则提取器为<font color=red> unapplySeq</font>(obj:Obj):<font color=red>Option[</font>Seq[T]<font color=red>]</font></li></ul></li><li><strong>样例类</strong><ul><li><strong>语法</strong></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>样例类仍然是类，和普通类相比，只是其自动生成了伴生对象，并且伴生对象中<br>自动提供了一些常用的方法，如 apply、unapply、toString、equals、hashCode 和 copy</li><li>样例类是为模式匹配而优化的类，因为其默认提供了 unapply 方法，因此，样例<br>类可以直接使用模式匹配，而无需自己实现 unapply 方法</li><li>构造器中的每一个参数都成为 val，除非它被显式地声明为 var（不建议这样做）</li></ul></li><li><strong>演示</strong><ul><li>上述匹配对象的案例使用样例类会节省大量代码</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchUnapply</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> user: <span class="type">User</span> = <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> result = user <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>) =&gt; <span class="string">&quot;yes&quot;</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;no&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure><h3 id="4-变量声明中的模式匹配">4.变量声明中的模式匹配</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchVariable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">println(<span class="string">s&quot;x=<span class="subst">$x</span>,y=<span class="subst">$y</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(first, second, _*) = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">println(<span class="string">s&quot;first=<span class="subst">$first</span>,second=<span class="subst">$second</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> <span class="type">Person</span>(name, age) = <span class="type">Person1</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">16</span>)</span><br><span class="line">println(<span class="string">s&quot;name=<span class="subst">$name</span>,age=<span class="subst">$age</span>&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=1,y=2</span><br><span class="line">first=1,second=7</span><br><span class="line">name=zhangsan,age=16</span><br></pre></td></tr></table></figure><h3 id="5-for-表达式中的模式匹配">5.for 表达式中的模式匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchFor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;A&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;B&quot;</span> -&gt; <span class="number">0</span>, <span class="string">&quot;C&quot;</span> -&gt; <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map) &#123; <span class="comment">//直接将 map 中的 k-v 遍历出来</span></span><br><span class="line">println(k + <span class="string">&quot; -&gt; &quot;</span> + v) <span class="comment">//3 个</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="comment">//遍历 value=0 的 k-v ,如果 v 不是 0,过滤</span></span><br><span class="line"><span class="keyword">for</span> ((k, <span class="number">0</span>) &lt;- map) &#123;</span><br><span class="line">println(k + <span class="string">&quot; --&gt; &quot;</span> + <span class="number">0</span>) <span class="comment">// B-&gt;0</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="comment">//if v == 0 是一个过滤的条件</span></span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map <span class="keyword">if</span> v &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">println(k + <span class="string">&quot; ---&gt; &quot;</span> + v) <span class="comment">// A-&gt;1 和 c-&gt;33</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 0</span><br><span class="line">C -&gt; 3</span><br><span class="line">----------------------</span><br><span class="line">B --&gt; 0</span><br><span class="line">----------------------</span><br><span class="line">A ---&gt; 1</span><br><span class="line">C ---&gt; 3</span><br></pre></td></tr></table></figure><h3 id="6-偏函数中的模式匹配">6.偏函数中的模式匹配</h3><p><strong>偏函数也是函数的一种，通过偏函数我们可以方便的对输入参数做更精确的检查。例如该偏函数的输入类型为 List[Int]，而我们需要的是第一个元素是 0 的集合，这就是通过模式匹配实现的</strong></p><ul><li><strong>偏函数定义</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> second: <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line"><span class="keyword">case</span> x :: y :: _ =&gt; <span class="type">Some</span>(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210410114442398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注</strong>：该偏函数的功能是返回输入的 List 集合的第二个元素</p><ul><li><strong>偏函数原理</strong><ul><li>上述代码会被 scala 编译器翻译成以下代码，与普通函数相比，只是多了一个用于参数检查的函数——isDefinedAt，其返回值类型为 Boolean</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> second = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]] &#123;</span><br><span class="line"><span class="comment">//检查输入参数是否合格</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = list <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x :: y :: _ =&gt; <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行函数逻辑</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Option</span>[<span class="type">Int</span>] = list <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x :: y :: _ =&gt; <span class="type">Some</span>(y)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>偏函数使用</strong><ul><li>偏函数不能像 second(List(1,2,3))这样直接使用，因为这样会直接调用 apply 方法，而应该调用 applyOrElse 方法，如下面的代码</li><li>applyOrElse 方法的逻辑为 if (ifDefinedAt(list)) apply(list) else default。如果输入参数满足条件，即 isDefinedAt 返回 true，则执行 apply 方法，否则执行 defalut 方法，default 方法为参数不满足要求的处理逻辑</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">second.applyOrElse(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), (_: <span class="type">List</span>[<span class="type">Int</span>]) =&gt; <span class="type">None</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>将 List(1,2,3,4,5,6,“test”)中的 Int 类型的元素加一，并去掉字符串</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list1 = list.map &#123;</span><br><span class="line">a =&gt;</span><br><span class="line">a <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i + <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> s: <span class="type">String</span> =&gt;s + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">println(list1.filter(a=&gt;a.isInstanceOf[<span class="type">Int</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(2, 3, 4, 5, 6, 7)</span><br></pre></td></tr></table></figure><ul><li><strong>偏函数实现</strong><ul><li>方法一</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;test&quot;</span>).filter(_.isInstanceOf[<span class="type">Int</span>]).map(_.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span>).foreach(println)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;test&quot;</span>).collect &#123; <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">1</span> &#125;.foreach(println)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="九、异常">九、异常</h1><h2 id="Java异常处理">Java异常处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">&#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line"><span class="comment">// catch 时，需要将范围小的写到前面</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意事项</strong><ul><li>Java 语言按照 try—catch—finally 的方式来处理异常</li><li>不管有没有异常捕获，都会执行 finally，因此通常可以在 finally 代码块中释放资<br>源</li><li>可以有多个 catch，分别捕获对应的异常，这时需要把范围小的异常类写在前面，把范围大的异常类写在后面，否则编译错误</li></ul></li></ul><h2 id="Scala异常处理">Scala异常处理</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> n= <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">&#125;<span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ex: <span class="type">ArithmeticException</span>=&gt;&#123;</span><br><span class="line"><span class="comment">// 发生算术异常</span></span><br><span class="line">println(<span class="string">&quot;发生算术异常&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ex: <span class="type">Exception</span>=&gt;&#123;</span><br><span class="line"><span class="comment">// 对异常处理</span></span><br><span class="line">println(<span class="string">&quot;发生了异常 1&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;发生了异常 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">println(<span class="string">&quot;finally&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们将可疑代码封装在 try 块中。在 try 块之后使用了一个 catch 处理程序来捕获异<br>常；如果发生任何异常，catch 处理程序将处理它，程序将不会异常终止</li><li>Scala 的异常的工作机制和 Java 一样，但是<font color=red> Scala 没有“checked（编译期）”异常</font>， 即 Scala 没有编译异常这个概念，异常都是在运行的时候捕获处理</li><li>异常捕捉的机制与其他语言中一样，如果有异常发生，catch 子句是按次序捕捉的。<br>因此，在 catch 子句中，越具体的异常越要靠前，越普遍的异常越靠后，如果把越普遍的异常写在前，把具体的异常写在后，在 Scala 中也不会报错，但这样是非常不好的编程风格</li><li>finally 子句用于执行不管是正常处理还是有异常发生时都需要执行的步骤，一般用<br>于对象的清理工作，这点和 Java 一样</li><li>用 throw 关键字，抛出一个异常对象。所有<font color=red>异常都是 Throwable 的子类型。throw 表达式是有类型的，就是 Nothing</font>，因为 Nothing 是所有类型的子类型，所以 throw 表达式可以用在需要类型的地方</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>():<span class="type">Nothing</span> = &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;不对&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java 提供了 throws 关键字来声明异常。可以使用方法定义声明异常。它向调用者函<br>数提供了此方法可能引发此异常的信息。它有助于调用函数处理并将该代码包含在 try-catch块中，以避免程序异常终止。在 Scala 中，可以使用 throws 注解来声明异常</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">f11()</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@throws</span>(classOf[<span class="type">NumberFormatException</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f11</span></span>()=&#123;</span><br><span class="line"><span class="string">&quot;abc&quot;</span>.toInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十、隐式转换">十、隐式转换</h1><p><strong><font color=red>当编译器第一次编译失败的时候，会在当前的环境中查找能让代码编译通过的方法，用于将类型进行转换，实现二次编译</font></strong></p><h2 id="隐式函数">隐式函数</h2><ul><li><strong>说明</strong><ul><li>隐式转换可以在不需改任何代码的情况下，扩展某个类的功能</li></ul></li><li><strong>演示</strong><ul><li>通过隐式转化为 Int 类型增加方法</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRichInt</span>(<span class="params">val self: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMax</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (self &lt; i) i <span class="keyword">else</span> self</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMin</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (self &lt; i) self <span class="keyword">else</span> i</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicitFunction</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用 implicit 关键字声明的函数称之为隐式函数</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convert</span></span>(arg: <span class="type">Int</span>): <span class="type">MyRichInt</span> = &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">MyRichInt</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 当想调用对象功能时，如果编译错误，那么编译器会尝试在当前作用域范围内查找能调用对应功能的转换规则，这个调用过程是由编译器完成的，所以称之为隐式转换。也称之为自动转换</span></span><br><span class="line">println(<span class="number">2.</span>myMax(<span class="number">6</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="隐式参数">隐式参数</h2><p><strong>普通方法或者函数中的参数可以通过<font color=red> implicit </font>关键字声明为隐式参数，调用该方法时，就可以传入该参数，编译器会在相应的作用域寻找符合条件的隐式值</strong></p><ul><li><strong>说明</strong><ul><li>同一个作用域中，相同类型的隐式值只能有一个</li><li>编译器按照隐式参数的类型去寻找对应类型的隐式值，与隐式值的名称无关</li><li>隐式参数优先于默认参数</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicitParameter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(<span class="keyword">implicit</span> arg: <span class="type">String</span>=<span class="string">&quot;good bey world!&quot;</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">hello</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure><h2 id="隐式类">隐式类</h2><p><strong>在 Scala2.10 后提供了隐式类，可以使用 <font color=red>implicit </font>声明类，隐式类的非常强大，同样可以扩展类的功能，在集合中隐式类会发挥重要的作用</strong></p><ul><li><strong>说明</strong><ul><li>其所带的构造参数有且只能有一个</li><li>隐式类必须被定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是 <font color=red>顶级</font>的</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicitClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRichInt</span>(<span class="params">arg: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMax</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (arg &lt; i) i <span class="keyword">else</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMin</span></span>(i: <span class="type">Int</span>) = &#123;</span><br><span class="line"><span class="keyword">if</span> (arg &lt; i) arg <span class="keyword">else</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="number">1.</span>myMax(<span class="number">3</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="隐式解析机制">隐式解析机制</h2><ul><li><strong>说明</strong><ul><li>首先会在当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象） <font color=red>（一般情况下） </font></li><li>如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与<font color=red>该类型相关联的全部伴生对象 </font>以及<font color=red>该类型所在包的包对象 </font></li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.chapter10.<span class="type">Scala05_Transform4</span>.<span class="type">Teacher</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生模块，</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTransform</span> <span class="keyword">extends</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）首先会在当前代码作用域下查找隐式实体</span></span><br><span class="line"><span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span>()</span><br><span class="line">teacher.eat()</span><br><span class="line">teacher.say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;eat...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line"><span class="comment">// 隐式类 : 类型 1 =&gt; 类型 2</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">Person5</span>(<span class="params">user:<span class="type">Teacher</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;say...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十一、泛型">十一、泛型</h1><h2 id="协变和逆变">协变和逆变</h2><ul><li><strong>语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">T</span>]</span>&#123; <span class="comment">//协变</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[-<span class="type">T</span>]</span>&#123; <span class="comment">//逆变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[<span class="type">T</span>] <span class="comment">//不变</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>协变：Son 是 Father 的<font color=red>子类</font>，则 MyList[Son] 也作为 MyList[Father]的<font color=red>“子类”</font></li><li>逆变：Son 是 Father 的<font color=red>子类</font>，则 MyList[Son]作为 MyList[Father]的<font color=red>“父类”</font></li><li>不变：Son 是 Father 的<font color=red>子类</font>，则 MyList[Father]与 MyList[Son]<font color=red>“无父子关系”</font></li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型模板</span></span><br><span class="line"><span class="comment">//class MyList&lt;T&gt;&#123;&#125;</span></span><br><span class="line"><span class="comment">//不变</span></span><br><span class="line"><span class="comment">//class MyList[T]&#123;&#125;</span></span><br><span class="line"><span class="comment">//协变</span></span><br><span class="line"><span class="comment">//class MyList[+T]&#123;&#125;</span></span><br><span class="line"><span class="comment">//逆变</span></span><br><span class="line"><span class="comment">//class MyList[-T]&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubChild</span> <span class="keyword">extends</span> <span class="title">Child</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala_TestGeneric</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//var s:MyList[Child] = new MyList[SubChild]</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型上下限">泛型上下限</h2><ul><li><strong>语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="type">PersonList</span>[<span class="type">T</span> &lt;: <span class="type">Person</span>]&#123; <span class="comment">//泛型上限</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Class</span> <span class="type">PersonList</span>[<span class="type">T</span> &gt;: <span class="type">Person</span>]&#123; <span class="comment">//泛型下限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>泛型的上下限的作用是对传入的泛型进行限定</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubChild</span> <span class="keyword">extends</span> <span class="title">Child</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala_TestGeneric</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//test(classOf[SubChild])</span></span><br><span class="line"><span class="comment">//test[Child](new SubChild)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型通配符之上限</span></span><br><span class="line"><span class="comment">//def test[A &lt;: Child](a:Class[A]): Unit =&#123;</span></span><br><span class="line"><span class="comment">// println(a)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//泛型通配符之下限</span></span><br><span class="line"><span class="comment">//def test[A &gt;: Child](a:Class[A]): Unit =&#123;</span></span><br><span class="line"><span class="comment">// println(a)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//泛型通配符之下限 形式扩展</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>[<span class="type">A</span> &gt;: <span class="type">Child</span>](a:<span class="type">A</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">println(a.getClass.getName)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下文限定">上下文限定</h2><ul><li><strong>语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>[<span class="type">A</span> : <span class="type">B</span>](a: <span class="type">A</span>) = println(a) <span class="comment">//等同于 def f[A](a:A)(implicit arg:B[A])=println(a)</span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>上下文限定是将泛型和隐式转换的结合产物，以下两者功能相同，使用上下文限定[A : Ordering]之后，方法内无法使用隐式参数名调用隐式参数，需要通过 <font color=red>implicitly[Ordering[A]]</font>获取隐式变量，如果此时无法查找到对应类型的隐式变量，会发生出错误</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> y = implicitly[<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">val</span> z = implicitly[<span class="type">Double</span>]</span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>[<span class="type">A</span>:<span class="type">Ordering</span>](a:<span class="type">A</span>,b:<span class="type">A</span>) =implicitly[<span class="type">Ordering</span>[<span class="type">A</span>]].compare(a,b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>[<span class="type">A</span>](a: <span class="type">A</span>, b: <span class="type">A</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">A</span>]) = ord.compare(a, b)</span><br></pre></td></tr></table></figure><h1 id="十二、IDEA快捷键">十二、IDEA快捷键</h1><ul><li>快速生成程序入口：main</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入 main-&gt;回车</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动补全变量：.var</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入 <span class="number">1.</span><span class="keyword">var</span>-&gt;回车</span><br><span class="line"><span class="keyword">val</span> i: <span class="type">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>快速打印：.sout</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入 <span class="number">1.</span>sout-&gt;回车</span><br><span class="line">println(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>快速生成 for 循环：遍历对象.for</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入 <span class="number">1</span> to <span class="number">3.</span><span class="keyword">for</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看当前文件的结构：Ctrl + F12</li><li>格式化当前代码：Ctrl + Shift + L</li><li>自动为当前代码补全变量声明：Ctrl + Shift + V<br><img src="https://img-blog.csdnimg.cn/20210410144515501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210410144525572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210410144534672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210410144542691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 离线安装 pymysql（适用于所有库）</title>
      <link href="/2021/03/29/python_5/"/>
      <url>/2021/03/29/python_5/</url>
      
        <content type="html"><![CDATA[<p><strong>首先获取到想要的库的包，我这里安装的是pymysql，从下面链接下载的资源</strong><br><a href="https://pypi.doubanio.com/simple/pymysql/">https://pypi.doubanio.com/simple/pymysql/</a><br><strong>然后把包上传到服务器，解压到当前目录（PyMySQL-1.0.2.tar是你的包名）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf PyMySQL-1.0.2.tar</span><br></pre></td></tr></table></figure><p><strong>进入到解压后的目录，执行安装命令（python3指安装的目录，如果python3执行失败，可能是环境变量没有配置，改成绝对路径执行即可，linux配置python环境变量我的另一篇文章有写：<a href="https://blog.csdn.net/weixin_44758876/article/details/115221146">https://blog.csdn.net/weixin_44758876/article/details/115221146</a>）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><p><strong>到这里就安装成功了，import pymysql不报错就代表没有问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>suse12 sp4，sp5 镜像资源分享</title>
      <link href="/2021/03/26/resource_1/"/>
      <url>/2021/03/26/resource_1/</url>
      
        <content type="html"><![CDATA[<p><strong>之前在网上找suse12的资源，结果发现他们连这点积分都赚，很是无语，这里分享sp4和sp5的镜像资源，博主也是花钱买来的，免费分享给大家，觉得有帮助的点个关注就行</strong><br><br><br><strong>SLE-12-SP4-Server-DVD-x86_64-GM-DVD.iso百度云永久资源：</strong><br>链接：<a href="https://pan.baidu.com/s/11OdnRMavXGslTcEy1YKcVQ">https://pan.baidu.com/s/11OdnRMavXGslTcEy1YKcVQ</a><br>提取码：h5z0<br><br><br><strong>SLE-12-SP5-Server-DVD-x86_64-GM-DVD.iso百度云永久资源：</strong><br>链接：<a href="https://pan.baidu.com/s/1zjKmNqhZjR_k-ghxhrgUSQ">https://pan.baidu.com/s/1zjKmNqhZjR_k-ghxhrgUSQ</a><br>提取码：1351</p>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SUSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装 Python3 教程</title>
      <link href="/2021/03/25/python_4/"/>
      <url>/2021/03/25/python_4/</url>
      
        <content type="html"><![CDATA[<p><strong>我这里用的是CentOS7.2系统以及python3.9.2版本</strong><br><strong>首先在python官网下载安装包放在服务器上，我这里就不放链接了</strong></p><p><img src="https://img-blog.csdnimg.cn/20210325230309910.png" alt="在这里插入图片描述"><br><strong>使用命令把安装包解压到当前目录</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python-3.9.2.tgz</span><br></pre></td></tr></table></figure><p><strong>下载需要的依赖包</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br></pre></td></tr></table></figure><p><strong>创建安装目录</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/python3</span><br></pre></td></tr></table></figure><p><strong>编译安装，依次执行下面三个命令（注意/data/python3是我们的安装目录，和我的安装目录不一样的话别忘了修改命令）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/data/python3</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong>建立软连接（这里的/data/python3是安装目录）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /data/python3 /usr/bin/python3</span><br></pre></td></tr></table></figure><p><strong>配置环境变量，修改/etc/profile文件</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p><strong>增加以下内容（/data/python3是python的安装目录）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PYTHON_HOME=/data/python3</span><br><span class="line">export PATH=$PATH:$PYTHON_HOME/bin:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p><strong>source一下/etc/profile文件</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><strong>到这里python就安装完成了，可以用python3 -V查看版本</strong></p><p><img src="https://img-blog.csdnimg.cn/2021032523183498.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>耗时两周，纯手敲 python 入门级基础笔记</title>
      <link href="/2021/03/23/python_3/"/>
      <url>/2021/03/23/python_3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、输出函数及转义字符">一、输出函数及转义字符</h1><h2 id="输出函数">输出函数</h2><p><strong>和java一样，使用print函数控制输出，输出字符串示例:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><p><strong>也可以输出含有运算符的表达式，会直接打印表达式结果：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3</span> + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="转义字符">转义字符</h2><p><font color=#999AAA><strong>反斜杠+想要实现的转义功能首字母既为转义字符</strong></font><br><strong>当字符串中包含反斜杠、单引号、双引号时等有特殊作用的字符时，必须使用反斜杠对这些字符进行转义：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反斜杠：\\</span><br><span class="line">单引号：\&#x27;</span><br><span class="line">双引号：\&quot;</span><br></pre></td></tr></table></figure><p><strong>当字符串中包含换行、回车、水平制表符或退格等无法直接表示的特殊字符时，也可以使用转义字符：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">换行：\n</span><br><span class="line">回车：\r</span><br><span class="line">水平制表符：\t</span><br><span class="line">退格：\b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\nworld&quot;</span>)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\tworld&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\rworld&quot;</span>)   <span class="comment">#world将hello进行了覆盖</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\bworld&quot;</span>)   <span class="comment">#\b是退一个格，将o退没了</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">helloworld</span><br><span class="line">world</span><br><span class="line">hellworld</span><br></pre></td></tr></table></figure><p><font color=red><strong>原字符</strong></font><strong>：不希望字符串中的转义字符起作用，在字符串前面加上r或R</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;hello\nworld&quot;</span>)   </span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello\nworld</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意事项</strong></font><strong>：最后一个字符不能是反斜线</strong></p><h1 id="二、变量">二、变量</h1><h2 id="变量的定义与赋值">变量的定义与赋值</h2><h3 id="1-定义一个变量">1.定义一个变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;变量&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(word)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量</span><br></pre></td></tr></table></figure><h3 id="2-变量的多次赋值">2.变量的多次赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">李四</span><br></pre></td></tr></table></figure><h2 id="常用的数据类型">常用的数据类型</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">整数类型-&gt;int-&gt;97</span><br><span class="line">浮点类型-&gt;float-&gt;3.1415</span><br><span class="line">布尔类型-&gt;bool-&gt;True,False</span><br><span class="line">字符串类型-&gt;str-&gt;&#x27;人生苦短&#x27;</span><br></pre></td></tr></table></figure><h3 id="1-整数类型">1.整数类型</h3><p><strong>整数可以表示正数、负数和零，也可以表示为二进制、十进制、八进制、十六进制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="number">90</span></span><br><span class="line">n2 = -<span class="number">76</span></span><br><span class="line">n3 = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(n1,<span class="built_in">type</span>(n1))</span><br><span class="line"><span class="built_in">print</span>(n2,<span class="built_in">type</span>(n2))</span><br><span class="line"><span class="built_in">print</span>(n3,<span class="built_in">type</span>(n3))</span><br><span class="line"><span class="comment">#整数可以表示为二进制、十进制、八进制、十六进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十进制&#x27;</span>,<span class="number">118</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;二进制&#x27;</span>,<span class="number">0b1010111</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;八进制&#x27;</span>,<span class="number">0o176</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十六进制&#x27;</span>,<span class="number">0x1EAF</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">90 &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">-76 &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">0 &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">十进制 118</span><br><span class="line">二进制 87</span><br><span class="line">八进制 126</span><br><span class="line">十六进制 7855</span><br></pre></td></tr></table></figure><p><strong>整数的不同进制表示方式：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">十进制-&gt;默认的进制</span><br><span class="line">二进制-&gt;以0b开头</span><br><span class="line">八进制-&gt;以0o开头</span><br><span class="line">十六进制-&gt;以0x开头</span><br></pre></td></tr></table></figure><h3 id="2-浮点类型">2.浮点类型</h3><p><strong>浮点数由整数部分和小数部分组成</strong></p><h4 id="浮点数存储不精确性">浮点数存储不精确性</h4><p><strong>使用浮点数进行计算时，可能会出现小数位数不确定的情况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415</span></span><br><span class="line"><span class="built_in">print</span>(a,<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.1</span> + <span class="number">2.2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.1415 &lt;class &#x27;float&#x27;&gt;</span><br><span class="line">3.3000000000000003</span><br></pre></td></tr></table></figure><p><strong>导入模块decimal</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="string">&#x27;1.1&#x27;</span>) + Decimal(<span class="string">&#x27;2.2&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.3</span><br></pre></td></tr></table></figure><h3 id="3-布尔类型">3.布尔类型</h3><p><strong>用来表示真或假的值，True表示真，False表示假</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1 = <span class="literal">True</span></span><br><span class="line">f2 = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(f1,<span class="built_in">type</span>(f1))</span><br><span class="line"><span class="built_in">print</span>(f2,<span class="built_in">type</span>(f2))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True &lt;class &#x27;bool&#x27;&gt;</span><br><span class="line">False &lt;class &#x27;bool&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>布尔值可以转化为整数，True表示1，False表示0</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span> + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="4-字符串类型">4.字符串类型</h3><p><strong>字符串又称为不可变的字符序列，可以用单引号、双引号、三引号来定义，单引号和双引号定义的字符串必须在一行，三引号定义的字符串可以分布在连续的多行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这是一个段落</span></span><br><span class="line"><span class="string">    可以由多行组成</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(word)</span><br><span class="line"><span class="built_in">print</span>(sentence)</span><br><span class="line"><span class="built_in">print</span>(paragraph)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串 &lt;class &#x27;str&#x27;&gt;</span><br><span class="line">这是一个句子 &lt;class &#x27;str&#x27;&gt;</span><br><span class="line"></span><br><span class="line">    这是一个段落</span><br><span class="line">    可以由多行组成</span><br><span class="line"> &lt;class &#x27;str&#x27;&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="数据类型转换">数据类型转换</h2><p><strong>将不同数据类型的数据拼接在一起时会报错</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name),<span class="built_in">type</span>(age))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我叫&#x27;</span> + name + <span class="string">&#x27;,今年&#x27;</span> + age + <span class="string">&#x27;岁&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 128, in &lt;module&gt;</span><br><span class="line">    print(&#x27;我叫&#x27; + name + &#x27;,今年&#x27; + age + &#x27;岁&#x27;)</span><br><span class="line">TypeError: can only concatenate str (not &quot;int&quot;) to str</span><br><span class="line">&lt;class &#x27;str&#x27;&gt; &lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>使用函数将int转换成str类型不会报错</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name),<span class="built_in">type</span>(age))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我叫&#x27;</span> + name + <span class="string">&#x27;,今年&#x27;</span> + <span class="built_in">str</span>(age) + <span class="string">&#x27;岁&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;str&#x27;&gt; &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">我叫张三,今年20岁</span><br></pre></td></tr></table></figure><table>    <tr align="center">        <th>函数名</th>        <th>作用</th>        <th>注意事项</th>        <th>举例</th>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">str()</td>        <td rowspan="2" bgcolor="white">将其他数据类型转换成字符串</td>        <td rowspan="2" bgcolor="white">也可用引号转换</td>        <td bgcolor="white">str(123)</td>    </tr>    <tr align="center">    <td>'123'</td>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">int()</td>        <td rowspan="2" bgcolor="white">将其他数据类型转换成整数</td>        <td bgcolor="white">文字类和小数类字符串，无法转化成整数</td>        <td bgcolor="white">int('123')</td>    </tr>    <tr align="center">    <td bgcolor="white">浮点数转化成整数：抹零取整</td>    <td>int(9.8)</td>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">float()</td>        <td rowspan="2" bgcolor="white">将其他数据类型转换成浮点数</td>        <td bgcolor="white">文字类无法转成整数</td>        <td bgcolor="white">float(‘9.9’)</td>    </tr>    <tr align="center">    <td>整数转成浮点数，末尾为.0</td>    <td>float(9)</td>    </tr></table><h2 id="进阶学习">进阶学习</h2><p><strong>结合%s%d打印变量，%s代表字符串，%d代表数字</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这是%d&quot;</span>%a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这是%s&quot;</span>%b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d和%s&quot;</span>%(a,b))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是123</span><br><span class="line">这是abc</span><br><span class="line">123和abc</span><br></pre></td></tr></table></figure><p><strong>结合下标打印字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;beijing&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:<span class="number">3</span>])     <span class="comment">#[起始位置:结束为止:步进值]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:<span class="built_in">len</span>(<span class="built_in">str</span>):<span class="number">2</span>])<span class="comment">#len()表示字符串的长度</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beijing</span><br><span class="line">bei</span><br><span class="line">beijing</span><br><span class="line">beiji</span><br><span class="line">biig</span><br></pre></td></tr></table></figure><p><strong>拼接字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;beijing&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:])      <span class="comment">#beijing</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">5</span>])      <span class="comment">#beiji</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&quot;,你好&quot;</span>)  <span class="comment">#beijing,你好</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">3</span>)       <span class="comment">#beijingbeijingbeijing</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beijing</span><br><span class="line">beiji</span><br><span class="line">beijing,你好</span><br><span class="line">beijingbeijingbeijing</span><br></pre></td></tr></table></figure><h1 id="三、运算符">三、运算符</h1><h2 id="input-函数的使用">input()函数的使用</h2><p><strong>接收来自用户的输入，输入的值类型为str，也可以使用=对输入的值进行存储</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">present = <span class="built_in">input</span>(<span class="string">&#x27;想要什么礼物呢？&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(present)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">想要什么礼物呢？钱</span><br><span class="line">钱</span><br></pre></td></tr></table></figure><h2 id="常用运算符">常用运算符</h2><h3 id="1-算术运算符">1.算术运算符</h3><table><thead><tr><th style="text-align:center">算术运算符</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">标准算术运算符</td><td style="text-align:center">加（+）、减（-）、乘（*）、除（/）、整除（//）</td></tr><tr><td style="text-align:center">取余运算符</td><td style="text-align:center">%</td></tr><tr><td style="text-align:center">幂运算符</td><td style="text-align:center">**</td></tr></tbody></table><table>    <tr align="center">        <th>运算符</th>        <th>表示</th>        <th>例子</th>        <th>结果</th>    </tr>    <tr align="center">        <td bgcolor="white">+</td>        <td bgcolor="white">加</td>        <td bgcolor="white">1+1</td>        <td bgcolor="white">2</td>    </tr>    <tr align="center">        <td bgcolor="white">-</td>        <td bgcolor="white">减</td>        <td bgcolor="white">1-1</td>        <td bgcolor="white">0</td>    </tr>    <tr align="center">        <td bgcolor="white">*</td>        <td bgcolor="white">乘</td>        <td bgcolor="white">2*4</td>        <td bgcolor="white">8</td>    </tr>    <tr align="center">        <td bgcolor="white">/</td>        <td bgcolor="white">除</td>        <td bgcolor="white">1/2</td>        <td bgcolor="white">0.5</td>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">%</td>        <td bgcolor="white">取余（一正一负要公式）</td>        <td bgcolor="white">9%4</td>        <td bgcolor="white">1</td>    </tr>    <tr align="center">    <td>余数=被除数-除数*商</td>    <td>9%-4<br>9-(-4)*(-3)</td>    <td>-3</td>    </tr>    <tr align="center">        <td bgcolor="white">**</td>        <td bgcolor="white">幂运算</td>        <td bgcolor="white">2**3</td>        <td bgcolor="white">8</td>    </tr>    <tr align="center">        <td rowspan="3" bgcolor="white">//</td>        <td rowspan="3" bgcolor="white">整数（一正一负向下取整）</td>        <td bgcolor="white">11//2</td>        <td bgcolor="white">5</td>    </tr>    <tr align="center">    <td bgcolor="white">9//-4</td>    <td bgcolor="white">-3</td>    </tr>    <tr align="center">    <td bgcolor="white">-9//4</td>    <td bgcolor="white">-3</td>    </tr></table><h3 id="2-赋值运算符">2.赋值运算符</h3><p><strong>赋值运算符的执行顺序为从右向左，支持链式赋值（a=b=c=20）、参数赋值（+=，-=，*=，/=，//=，%=），以及系列解包赋值（a,b,c=20,30,40）</strong></p><h3 id="3-比较运算符">3.比较运算符</h3><p><strong>比较运算符有大于（&gt;）、小于（&lt;）、大于或等于（&gt;=）、小于或等于（&lt;=）、不等于（!=）以及对象value的比较（==），还有is和is not这种比较对象id的比较运算符</strong></p><h3 id="4-布尔运算符">4.布尔运算符</h3><table>    <tr>        <th>运算符</th>        <th colspan="2">运算数</th>        <th>运算结果</th>        <th>备注</th>    </tr>    <tr align="center">        <td rowspan="4" bgcolor="white">and</td>        <td bgcolor="white">True</td>        <td bgcolor="white">True</td>        <td bgcolor="white">True</td>        <td rowspan="4" bgcolor="white">当两个运算数都为True时，运算结果才为True</td>    </tr>    <tr align="center">    <td bgcolor="white">True</td>    <td bgcolor="white">False</td>    <td rowspan="3" bgcolor="white">False</td>    </tr>     <tr align="center">    <td bgcolor="white">False</td>    <td bgcolor="white">True</td>    </tr>    <tr align="center">    <td bgcolor="white">False</td>    <td bgcolor="white">False</td>    </tr>    <tr align="center">        <td rowspan="4" bgcolor="white">or</td>        <td bgcolor="white">True</td>        <td bgcolor="white">True</td>        <td rowspan="3" bgcolor="white">True</td>        <td rowspan="4" bgcolor="white">只要有一个运算数为True，运算结果就为True</td>    </tr>    <tr align="center">    <td bgcolor="white">True</td>    <td bgcolor="white">False</td>    </tr>    <tr align="center">    <td bgcolor="white">False</td>    <td bgcolor="white">True</td>    </tr>    <tr align="center">    <td bgcolor="white">False</td>    <td bgcolor="white">False</td>    <td bgcolor="white">False</td>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">not</td>        <td colspan="2" bgcolor="white">True</td>        <td bgcolor="white">False</td>        <td bgcolor="white">如果运算数为True，运算结果为False</td>    </tr>    <tr align="center">    <td colspan="2" bgcolor="white">False</td>    <td bgcolor="white">True</td>    <td bgcolor="white">如果运算数为False，运算结果为True</td>    </tr>    <tr align="center">    <td rowspan="2" bgcolor="white">in</td>    <td colspan="2" bgcolor="white">'e' in 'hello'</td>    <td bgcolor="white">True</td>    <td bgcolor="white">如果字符串中包含指定字符，运算结果为True</td>    </tr>    <tr align="center">    <td colspan="2" bgcolor="white">'i' in 'hello'</td>    <td bgcolor="white">False</td>    <td bgcolor="white">如果字符串中不包含指定字符，运算结果为False</td>    </tr>    <tr align="center">    <td rowspan="2" bgcolor="white">not in</td>    <td colspan="2" bgcolor="white">'e' not in 'hello'</td>    <td bgcolor="white">False</td>    <td bgcolor="white">如果字符串中包含指定字符，运算结果为False</td>    </tr>    <tr align="center">    <td colspan="2" bgcolor="white">'i' in 'hello'</td>    <td bgcolor="white">True</td>    <td bgcolor="white">如果字符串中不包含指定字符，运算结果为True</td>    </tr></table><h3 id="5-位运算符">5.位运算符</h3><table><tr><th>运算符</th>        <th>备注</th></tr><tr align="center"><td>位与&</td>        <td>对应数位都是1，结果数位才是1，否则为0</td></tr><tr align="center"><td>位或 |</td>        <td>对应数位都是0，结果数位才是0，否则为1</td></tr><tr align="center"><td>左移位运算符 <<</td>        <td>高位溢出舍弃，低位补0</td></tr><tr align="center"><td>右移位运算符 >></td>        <td>低位溢出舍弃，高位补0</td></tr></table><h2 id="运算符的优先级">运算符的优先级</h2><p><strong>括号()&gt;算术运算符&gt;位运算符&gt;比较运算符&gt;布尔运算符&gt;赋值运算符</strong></p><h1 id="四、if判断以及for、while循环">四、if判断以及for、while循环</h1><h2 id="if条件判断">if条件判断</h2><p><strong>判断符合条件既执行语句：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;符合&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不符合&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">符合</span><br></pre></td></tr></table></figure><h3 id="1-案例">1.案例</h3><p><strong>结合input()函数实现查询成绩系统：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的成绩：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span> <span class="keyword">and</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为B&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span> <span class="keyword">and</span> score &lt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为C&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span> <span class="keyword">and</span> score &lt;= <span class="number">70</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为D&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为E&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入你的成绩：89</span><br><span class="line">本次考试，等级为B</span><br></pre></td></tr></table></figure><h3 id="2-pass语句">2.pass语句</h3><p><strong>语句什么都不做，只是一个占位符，用在语法上需要语句的地方（一般在还没想好代码怎么写，先搭建语法结构的时候使用），可以和if语句的条件执行体、for-in语句的循环体以及定义函数时的函数体一起使用</strong></p><h3 id="3-range函数的使用">3.range函数的使用</h3><p><strong>range()函数用于生成一个整数序列，返回值是一个迭代器对象。</strong><br><strong>创建range对象的三种方式：</strong></p><table><tr><td>range(stop)</td>        <td>创建一个[0,stop)之间的整数序列，步长为1</td></tr><tr><td>range(start,stop)</td>        <td>创建一个[start,stop)之间的整数序列，步长为1</td></tr><tr><td>range(start,stop,step)</td>        <td>创建一个[start,stop)之间的整数序列，步长为step</td></tr></table><p><strong>优点：不管range对象表示的整数序列有多长，所有range对象占用的内存空间都是相同的，因为仅仅需要存储start，stop和step，只有当用到range对象时，才会去计算序列中的相关元素</strong></p><h2 id="for循环">for循环</h2><p><strong>循环5次：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>以3递增打印从0到10：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>负数同样也可以递增：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>,-<span class="number">100</span>,-<span class="number">30</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-10</span><br><span class="line">-40</span><br><span class="line">-70</span><br></pre></td></tr></table></figure><p><strong>也可以循环打印字符串：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;beijing&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(x,end=<span class="string">&quot;\t&quot;</span>)<span class="comment">#end表示以什么为结尾，默认为\n</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beijing</span><br></pre></td></tr></table></figure><h2 id="while循环">while循环</h2><p><strong>循环5次：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前是第%d次执行循环&quot;</span>%(i+<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i=%d&quot;</span>%i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当前是第1次执行循环</span><br><span class="line">i=0</span><br><span class="line">当前是第2次执行循环</span><br><span class="line">i=1</span><br><span class="line">当前是第3次执行循环</span><br><span class="line">i=2</span><br><span class="line">当前是第4次执行循环</span><br><span class="line">i=3</span><br><span class="line">当前是第5次执行循环</span><br><span class="line">i=4</span><br></pre></td></tr></table></figure><h3 id="1-案例-2">1.案例</h3><p><strong>1-100求和：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">sum</span> += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1-100求和结果:%d&quot;</span>%<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-100求和结果:5050</span><br></pre></td></tr></table></figure><h3 id="2-while和else结合使用">2.while和else结合使用</h3><p><strong>while也可以和else结合使用：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span> :</span><br><span class="line">    <span class="built_in">print</span>(count,<span class="string">&quot;小于5&quot;</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(count,<span class="string">&quot;大于或等于5&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 小于5</span><br><span class="line">1 小于5</span><br><span class="line">2 小于5</span><br><span class="line">3 小于5</span><br><span class="line">4 小于5</span><br><span class="line">5 大于或等于5</span><br></pre></td></tr></table></figure><h2 id="break和continue">break和continue</h2><h3 id="1-break">1.break</h3><p><strong>使用break结束此次循环：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span> :</span><br><span class="line">    i = i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> :</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">------------------------------</span><br><span class="line">1</span><br><span class="line">------------------------------</span><br><span class="line">2</span><br><span class="line">------------------------------</span><br><span class="line">3</span><br><span class="line">------------------------------</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="2-continue">2.continue</h3><p><strong>使用continue跳过当前循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span> :</span><br><span class="line">    i = i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">------------------------------</span><br><span class="line">1</span><br><span class="line">------------------------------</span><br><span class="line">2</span><br><span class="line">------------------------------</span><br><span class="line">3</span><br><span class="line">------------------------------</span><br><span class="line">4</span><br><span class="line">------------------------------</span><br><span class="line">6</span><br><span class="line">------------------------------</span><br><span class="line">7</span><br><span class="line">------------------------------</span><br><span class="line">8</span><br><span class="line">------------------------------</span><br><span class="line">9</span><br><span class="line">------------------------------</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="九九乘法表的实现">九九乘法表的实现</h2><p><strong>经典案例：九九乘法表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span> :</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> x &lt;= j :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d*%d=%d&quot;</span>%(i,x,i*x),end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">2*1=22*2=4</span><br><span class="line">3*1=33*2=63*3=9</span><br><span class="line">4*1=44*2=84*3=124*4=16</span><br><span class="line">5*1=55*2=105*3=155*4=205*5=25</span><br><span class="line">6*1=66*2=126*3=186*4=246*5=306*6=36</span><br><span class="line">7*1=77*2=147*3=217*4=287*5=357*6=427*7=49</span><br><span class="line">8*1=88*2=168*3=248*4=328*5=408*6=488*7=568*8=64</span><br><span class="line">9*1=99*2=189*3=279*4=369*5=459*6=549*7=639*8=729*9=81</span><br></pre></td></tr></table></figure><h1 id="五、列表">五、列表</h1><h2 id="列表的定义">列表的定义</h2><p><strong>列表相当于其他语言中的数组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist = []   <span class="comment">#定义一个空的列表</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namelist = [<span class="string">&quot;李&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;张&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(namelist[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(namelist[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(namelist[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br></pre></td></tr></table></figure><h2 id="列表的创建">列表的创建</h2><p><strong>使用中括号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst=[<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>使用内置函数list()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst=<span class="built_in">list</span>([<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="列表的特点">列表的特点</h2><ul><li><strong>列表元素按顺序有序排序</strong></li><li><strong>索引映射唯一一个数据</strong></li><li><strong>列表可以存储重复数据</strong></li><li><strong>任意数据类型混存</strong></li><li><strong>根据需要动态分配和回收内存</strong></li></ul><p><strong>存储混合类型：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist = []   <span class="comment">#定义一个空的列表</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testlist = [<span class="number">1</span>,<span class="string">&quot;测试&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(testlist[<span class="number">0</span>]))<span class="comment">#type()能辨别字符串的类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(testlist[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>结合循环打印列表元素：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namelist = [<span class="string">&quot;李&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;张&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> namelist :</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="built_in">len</span>(namelist) :</span><br><span class="line">    <span class="built_in">print</span>(namelist[i])</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br><span class="line">------------------------------</span><br><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br></pre></td></tr></table></figure><p><strong>多维列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#a = [[],[],[]]      #三个元素的空列表，每个元素都是一个空列表</span></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4]]</span><br><span class="line">[1, 2]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="增删改查">增删改查</h2><h3 id="1-增">1.增</h3><p><font color=#999AAA><strong>列表增加元素使用extend或append方法</strong></font><br><strong>extend:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namelist = [<span class="string">&quot;李&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;张&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----增加前数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> namelist :</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line">namelist.append(<span class="built_in">input</span>(<span class="string">&quot;请输入添加的姓：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----增加后数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> namelist :</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-----增加前数据-----</span><br><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br><span class="line">请输入添加的姓：魏</span><br><span class="line">-----增加后数据-----</span><br><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br><span class="line">魏</span><br></pre></td></tr></table></figure><p><strong>append：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a.append(b)     <span class="comment">#将列表当作一个元素，加入到另一列表中</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, 4]]</span><br></pre></td></tr></table></figure><h3 id="2-删">2.删</h3><p><font color=#999AAA><strong>删除列表的元素</strong></font><br><strong>del、pop、remove均可：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----删除前数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"><span class="comment">#del a[1]    #删除指定下标的数据</span></span><br><span class="line"><span class="comment">#a.pop()      #弹出末尾最后一个元素</span></span><br><span class="line">a.remove(<span class="number">2</span>)   <span class="comment">#直接删除指定内容的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----删除后数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----删除前数据-----</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">-----删除后数据-----</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="3-改">3.改</h3><p><strong>修改列表元素：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----修改前数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">5</span>    <span class="comment">#修改指定下标的元素内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----修改后数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----修改前数据-----</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">-----修改后数据-----</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="4-查">4.查</h3><p><font color=#999AAA><strong>查询指定元素：</strong></font><br><strong>in或not in：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你要查找的数字：&quot;</span>)) <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入你要查找的数字：3</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p><strong>查找指定下标范围的元素，并返回对应元素的下标：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(a.index(<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(a.index(4,1,3))   #找不到会报错     范围区间：左闭右开   [1,3)</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="列表常用方法">列表常用方法</h2><p><strong>统计：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(a.count(<span class="number">2</span>))   <span class="comment">#统计某个元素出现过几次</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>将所有元素反转：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.reverse()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 5, 2, 3, 4, 1]</span><br></pre></td></tr></table></figure><p><strong>升序：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><p><strong>降序：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><h2 id="列表生成式">列表生成式</h2><p><strong>[i*i for i in range(1,10)]</strong><br><font color=red><strong>注意事项</strong></font><strong>：i表示列表元素的表达式（通常包含自定义变量），for-in中的i表示自定义变量，range(1,10)表示可迭代对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst=[i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line">lst2=[i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)]</span><br><span class="line"><span class="built_in">print</span>(lst2)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure><h2 id="案例">案例</h2><p><strong>8个老师随机分到三个学校里：</strong><br><font color=#999AAA><strong>随机数用random.randint()方法生成，需要import random：</strong></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">offices = [[],[],[]]</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;G&quot;</span>,<span class="string">&quot;H&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names :</span><br><span class="line">    index = random.randint(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">    offices[index].append(name)</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> office <span class="keyword">in</span> offices :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;办公室%d的人数为：%d&quot;</span>%(i,<span class="built_in">len</span>(office)))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> office :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span>%name,end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">办公室1的人数为：5</span><br><span class="line">ABDFH</span><br><span class="line">办公室2的人数为：2</span><br><span class="line">EG</span><br><span class="line">办公室3的人数为：1</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p><strong>购物车：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">products = [[<span class="string">&quot;iphone&quot;</span>,<span class="number">6888</span>],[<span class="string">&quot;MacPro&quot;</span>,<span class="number">14800</span>],[<span class="string">&quot;小米6&quot;</span>,<span class="number">2499</span>],[<span class="string">&quot;Coffee&quot;</span>,<span class="number">31</span>],[<span class="string">&quot;Book&quot;</span>,<span class="number">60</span>],[<span class="string">&quot;Nike&quot;</span>,<span class="number">699</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------\t商品列表\t------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> product <span class="keyword">in</span> products :</span><br><span class="line">    <span class="built_in">print</span>(products.index(product),end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(product[<span class="number">0</span>],end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(product[<span class="number">1</span>])</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">cars = []</span><br><span class="line"><span class="keyword">while</span> num != <span class="string">&quot;q&quot;</span> :</span><br><span class="line">    num = <span class="built_in">input</span>(<span class="string">&quot;请输入您要购买商品的编号：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> num == <span class="string">&quot;q&quot;</span> :</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cars.append(products[<span class="built_in">int</span>(num)])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;您购物车的商品有：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> car <span class="keyword">in</span> cars :</span><br><span class="line">    <span class="built_in">print</span>(car)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">------商品列表------</span><br><span class="line">0iphone6888</span><br><span class="line">1MacPro14800</span><br><span class="line">2小米62499</span><br><span class="line">3Coffee31</span><br><span class="line">4Book60</span><br><span class="line">5Nike699</span><br><span class="line">请输入您要购买商品的编号：1</span><br><span class="line">请输入您要购买商品的编号：4</span><br><span class="line">请输入您要购买商品的编号：3</span><br><span class="line">请输入您要购买商品的编号：0</span><br><span class="line">请输入您要购买商品的编号：q</span><br><span class="line">您购物车的商品有：</span><br><span class="line">[&#x27;MacPro&#x27;, 14800]</span><br><span class="line">[&#x27;Book&#x27;, 60]</span><br><span class="line">[&#x27;Coffee&#x27;, 31]</span><br><span class="line">[&#x27;iphone&#x27;, 6888]</span><br></pre></td></tr></table></figure><p><strong>使用enumerate()枚举函数可以同时拿到列表中的下标和元素：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">enumerate</span>(mylist))    <span class="comment">#&lt;enumerate object at 0x000001F711412C00&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(mylist):</span><br><span class="line">    <span class="built_in">print</span>(i,x)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;enumerate object at 0x000001C3B09A8E00&gt;</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br><span class="line">4 e</span><br></pre></td></tr></table></figure><p><strong>可以使用枚举函数优化上面的购物车案例</strong></p><h1 id="六、字典">六、字典</h1><h2 id="字典的定义">字典的定义</h2><p><strong>字典的实现原理与查字典类似，查字典是先根据部首或拼音查找对应的页码，Python中的字典是根据key查找value所在的位置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure><h2 id="字典的创建">字典的创建</h2><p><strong>使用花括号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores=&#123;<span class="string">&#x27;张三&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;李四&#x27;</span>:<span class="number">98</span>,<span class="string">&#x27;王五&#x27;</span>:<span class="number">45</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>使用内置函数dict():</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>(name=<span class="string">&#x27;张三&#x27;</span>,age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="字典的特点">字典的特点</h2><ul><li><strong>字典中的所有元素都是一个key-value对，key不允许重复，value可以重复</strong></li><li><strong>字典中的元素是无序的</strong></li><li><strong>字典中的key必须是不可变对象</strong></li><li><strong>字典也可以根据需要动态地伸缩</strong></li><li><strong>字典会浪费较大的内存，是一种使用空间换时间的数据结构</strong></li></ul><h2 id="增删改查-2">增删改查</h2><h3 id="1-增-2">1.增</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">info[<span class="string">&quot;id&quot;</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(info[<span class="string">&quot;id&quot;</span>])   <span class="comment">#1</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="2-删-2">2.删</h3><p><strong>del：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除前：%s&quot;</span>%info[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="keyword">del</span> info[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除后：%s&quot;</span>%info[<span class="string">&quot;name&quot;</span>])    <span class="comment">#删除了指定键值对后，再次访问会报错</span></span><br><span class="line"><span class="keyword">del</span> info</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除后：%s&quot;</span>%info)    <span class="comment">#删除字典后再访问，报错</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyError: &#x27;name&#x27;</span><br><span class="line">NameError: name &#x27;info&#x27; is not defined</span><br></pre></td></tr></table></figure><p><strong>clear：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;清空前：%s&quot;</span>%info)    <span class="comment">#清空前：&#123;&#x27;name&#x27;: &#x27;吴彦祖&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br><span class="line"></span><br><span class="line">info.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;清空后：%s&quot;</span>%info)    <span class="comment">#清空后：&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清空前：&#123;&#x27;name&#x27;: &#x27;吴彦祖&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">清空后：&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-改-2">3.改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">info[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(info[<span class="string">&quot;age&quot;</span>])  <span class="comment">#20</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="4-查-2">4.查</h3><p><strong>通过get()方法或直接[中括号]获取value</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(info[<span class="string">&#x27;id&#x27;</span>])<span class="comment">#获取key为id的value</span></span><br><span class="line"><span class="built_in">print</span>(info.get(<span class="string">&quot;name&quot;</span>))<span class="comment">#获取key为name的value</span></span><br><span class="line"><span class="built_in">print</span>(info.keys())  <span class="comment">#得到所有键（列表）</span></span><br><span class="line"><span class="built_in">print</span>(info.values())    <span class="comment">#得到所有的值（列表）</span></span><br><span class="line"><span class="built_in">print</span>(info.items())     <span class="comment">#得到所有的项（列表），每个键值对是一个元组</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">吴彦祖</span><br><span class="line">dict_keys([&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;])</span><br><span class="line">dict_values([&#x27;1&#x27;, &#x27;吴彦祖&#x27;, 18])</span><br><span class="line">dict_items([(&#x27;id&#x27;, &#x27;1&#x27;), (&#x27;name&#x27;, &#x27;吴彦祖&#x27;), (&#x27;age&#x27;, 18)])</span><br></pre></td></tr></table></figure><p><strong>遍历所有的键</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> info.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">name</span><br><span class="line">age</span><br></pre></td></tr></table></figure><p><strong>遍历所有的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> info.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">吴彦祖</span><br><span class="line">18</span><br></pre></td></tr></table></figure><p><strong>遍历所有的键值对</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> info.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;key=%s,value=%s&quot;</span>%(key,value))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key=id,value=1</span><br><span class="line">key=name,value=吴彦祖</span><br><span class="line">key=age,value=18</span><br></pre></td></tr></table></figure><p><strong>访问字典不存在的key时：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="comment">#print(info[&quot;gender&quot;])   #直接访问   报错</span></span><br><span class="line"><span class="built_in">print</span>(info.get(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(info.get(<span class="string">&quot;gender&quot;</span>))   <span class="comment">#使用get方法没有找到对应的键，默认返回None</span></span><br><span class="line"><span class="built_in">print</span>(info.get(<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;m&quot;</span>))   <span class="comment">#m   没找到的时候，可以设定默认值</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18</span><br><span class="line">None</span><br><span class="line">m</span><br></pre></td></tr></table></figure><h2 id="字典生成式">字典生成式</h2><p><strong>内置函数zip()，用于将可迭代的对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;Fruits&#x27;</span>,<span class="string">&#x27;Books&#x27;</span>,<span class="string">&#x27;Others&#x27;</span>]</span><br><span class="line">b=[<span class="number">96</span>,<span class="number">78</span>,<span class="number">85</span>]</span><br><span class="line">lst=<span class="built_in">zip</span>(a,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(lst))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&#x27;Fruits&#x27;, 96), (&#x27;Books&#x27;, 78), (&#x27;Others&#x27;, 85)]</span><br></pre></td></tr></table></figure><h1 id="七、元组">七、元组</h1><h2 id="元组的定义">元组的定义</h2><p><strong>Python内置的数据结构之一，是一个不可变序列</strong></p><ul><li><strong>不可变序列：字符串、元组</strong><ul><li><strong>不可变序列：没有增、删、改的操作</strong></li></ul></li><li><strong>可变序列：列表、字典</strong><ul><li><strong>可变序列：可以对序列执行增、删、改操作，对象地址不发生改变</strong></li></ul></li></ul><h2 id="元组的创建">元组的创建</h2><p><strong>直接使用小括号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1=()   <span class="comment">#创建空的元组</span></span><br><span class="line">t2=(<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>使用内置函数tuple()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup1=<span class="built_in">tuple</span>(<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>只包含一个元素的元组需要使用逗号和小括号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1=(<span class="number">10</span>,)</span><br></pre></td></tr></table></figure><h2 id="元组为不可变序列的原因">元组为不可变序列的原因</h2><p><strong>在多任务环境下，同时操作对象时不需要加锁</strong><br><font color=red><strong>注意事项：</strong></font><br><strong>如果元组中对象本身是不可变对象，则不能再引用其他对象</strong><br><strong>如果元组中的对象是可变对象，则可变对象的引用不允许改变，但数据可以改变</strong></p><h2 id="增删改查-3">增删改查</h2><h3 id="1-增（连接）">1.增（连接）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>)</span><br><span class="line">tup2 = (<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>)</span><br><span class="line"></span><br><span class="line">tup = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(12, 34, 56, &#x27;abc&#x27;, &#x27;def&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-删-3">2.删</h3><p><strong>del，删除会删掉整个元组：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1)     <span class="comment">#(12, 34, 56)</span></span><br><span class="line"><span class="keyword">del</span> tup1        <span class="comment">#删除了整个元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除后：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1)     <span class="comment">#报错</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: name &#x27;tup1&#x27; is not defined</span><br></pre></td></tr></table></figure><h3 id="3-改（元组不允许修改）">3.改（元组不允许修改）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>)</span><br><span class="line">tup1[<span class="number">0</span>] = <span class="number">10</span>    <span class="comment">#报错，不允许修改</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure><h3 id="4-查-3">4.查</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="number">2000</span>,<span class="number">2001</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(tup1[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">0</span>:<span class="number">2</span>])    <span class="comment">#(&#x27;abc&#x27;, &#x27;def&#x27;)     左闭右开</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">2001</span><br><span class="line">def</span><br><span class="line">(&#x27;abc&#x27;, &#x27;def&#x27;)</span><br></pre></td></tr></table></figure><p><font color=red><strong>注：元组没有生成式</strong></font></p><h1 id="八、集合">八、集合</h1><h2 id="集合的定义">集合的定义</h2><p><strong>与列表、字典一样都属于可变类型的序列，集合是没有value的字典</strong></p><h2 id="集合的创建">集合的创建</h2><p><strong>直接使用大括号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>使用内置函数set()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="string">&#x27;python&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>())</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;0, 1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;&#x27;o&#x27;, &#x27;y&#x27;, &#x27;p&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;t&#x27;&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">set()</span><br></pre></td></tr></table></figure><h2 id="集合的相关操作">集合的相关操作</h2><h3 id="1-判断操作">1.判断操作</h3><p><strong>in</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">in</span> s)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">60</span> <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>not in</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> s)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">60</span> <span class="keyword">not</span> <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="2-新增操作">2.新增操作</h3><p><strong>通过add()方法，一次添加一个元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.add&#123;<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;50, 20, 40, 10, 60, 30&#125;</span><br></pre></td></tr></table></figure><p><strong>通过update()方法，至少添加一个元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.update(&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;50, 20, 100, 40, 10, 300, 30, 200&#125;</span><br></pre></td></tr></table></figure><h3 id="3-删除操作">3.删除操作</h3><p><strong>通过remove()方法，一次删除一个指定元素，如果指定的元素不存在就抛出KeyError</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.remove(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 133, in &lt;module&gt;</span><br><span class="line">    s.remove(100)</span><br><span class="line">KeyError: 100</span><br></pre></td></tr></table></figure><p><strong>通过discard()方法，一次删除一个指定元素，如果指定的元素不存在不抛异常</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.discard(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;50, 20, 40, 10, 30&#125;</span><br></pre></td></tr></table></figure><p><strong>通过pop()方法，一次只删除一个任意元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.pop()</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;20, 40, 10, 30&#125;</span><br></pre></td></tr></table></figure><p><strong>通过clear()方法，清空集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.clear()</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set()</span><br></pre></td></tr></table></figure><h2 id="集合间的关系">集合间的关系</h2><p><strong>可以用运算符==或!=来判断两个集合是否相等</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">30</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1==s2)</span><br><span class="line"><span class="built_in">print</span>(s1!=s2)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>通过issubset方法判断一个集合是否是另一个集合的子集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>&#125;</span><br><span class="line">s3=&#123;<span class="number">10</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2.issubset(s1))</span><br><span class="line"><span class="built_in">print</span>(s3.issubset(s1))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>通过issuperset方法判断一个集合是否是另一个集合的超集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>&#125;</span><br><span class="line">s3=&#123;<span class="number">10</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.issuperset(s2))</span><br><span class="line"><span class="built_in">print</span>(s1.issuperset(s3))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>通过isdisjoint判断两个集合是否有交集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s3=&#123;<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.isdisjoint(s2))<span class="comment">#有交集返回False</span></span><br><span class="line"><span class="built_in">print</span>(s1.isdisjoint(s3))<span class="comment">#无交集返回True</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="集合的数学操作">集合的数学操作</h2><h3 id="1-交集">1.交集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.intersection(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2)<span class="comment">#intersection()与 &amp; 等价，交集操作</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;20, 30&#125;</span><br><span class="line">&#123;20, 30&#125;</span><br></pre></td></tr></table></figure><h3 id="2-并集">2.并集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.union(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 | s2)<span class="comment">#union与 | 等价，并集操作</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;40, 10, 50, 20, 60, 30&#125;</span><br><span class="line">&#123;40, 10, 50, 20, 60, 30&#125;</span><br></pre></td></tr></table></figure><h3 id="3-差集">3.差集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.difference(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 - s2)<span class="comment">#difference与 - 等价，差集操作</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;10&#125;</span><br><span class="line">&#123;10&#125;</span><br></pre></td></tr></table></figure><h3 id="4-对称差集">4.对称差集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_difference(s2))</span><br><span class="line"><span class="built_in">print</span>(s1^s2)<span class="comment">#symmetric_difference与 ^ 等价，对称差集操作</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;50, 40, 10, 60&#125;</span><br><span class="line">&#123;50, 40, 10, 60&#125;</span><br></pre></td></tr></table></figure><h2 id="集合生成式">集合生成式</h2><p><strong>{i*i for i in range(num)}</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0, 1, 4, 9, 16, 25&#125;</span><br></pre></td></tr></table></figure><h1 id="九、列表、字典、元组、集合总结">九、列表、字典、元组、集合总结</h1><table><tr><th>数据结构</th><th>是否可变</th><th>是否重复</th><th>是否有序</th><th>定义符号</th></tr><tr><td bgcolor="white" align="center">列表（list）</td><td bgcolor="white" align="center">可变</td><td bgcolor="white" align="center">可重复</td><td bgcolor="white" align="center">有序</td><td bgcolor="white" align="center">[]</td></tr><tr><td align="center">元组（tuple）</td><td align="center">不可变</td><td align="center">可重复</td><td align="center">有序</td><td align="center">()</td></tr><tr><td rowspan="2" bgcolor="white" align="center">字典（dict）</td><td rowspan="2" bgcolor="white" align="center">可变</td><td bgcolor="white" align="center">key不可重复</td><td rowspan="2" bgcolor="white" align="center">无序</td><td rowspan="2" bgcolor="white" align="center">{key:value}</td></tr><tr><td align="center">value可重复</td></tr><tr><td bgcolor="white" align="center">集合（set）</td><td bgcolor="white" align="center">可变</td><td bgcolor="white" align="center">不可重复</td><td bgcolor="white" align="center">无序</td><td bgcolor="white" align="center">{}</td></tr></table><h1 id="十、字符串（进阶）">十、字符串（进阶）</h1><p><strong>Python中字符串是基本数据类型，是一个不可变的字符序列</strong></p><h2 id="字符串驻留机制">字符串驻留机制</h2><p><strong>仅保留一份相同且不可变字符串的方法，不同的值被存放在字符串的驻留池中，Python的驻留机制对相同的字符串只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;python&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;python&#x27;</span></span><br><span class="line">c=<span class="string">&#x27;python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a,<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(b,<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(c,<span class="built_in">id</span>(c))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python 2785734751984</span><br><span class="line">python 2785734751984</span><br><span class="line">python 2785734751984</span><br></pre></td></tr></table></figure><h2 id="驻留模式的几种情况（交互模式）">驻留模式的几种情况（交互模式）</h2><ul><li><strong>字符串的长度为0或1时</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0</span></span><br><span class="line">b=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line">a1=<span class="string">&#x27;%&#x27;</span></span><br><span class="line">b1=<span class="string">&#x27;%&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> b1)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure><ul><li><strong>符合标识符的字符串</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;abc%&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;abc%&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a==b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line">a1=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">b1=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> b1)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><ul><li><strong>字符串只在编译时进行驻留，而非运行时</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;ab&#x27;</span> + <span class="string">&#x27;c&#x27;</span></span><br><span class="line">c=<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> c)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><ul><li><strong>[-5,256]之间的整数数字</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=-<span class="number">5</span></span><br><span class="line">b=-<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line">a1 = -<span class="number">6</span></span><br><span class="line">b1 = -<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> b1)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>可以通过sys.intern方法强制驻留</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = -<span class="number">6</span></span><br><span class="line">b = -<span class="number">6</span></span><br><span class="line">a = sys.intern(b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure><p><font color=red><strong>注：</strong></font><strong>PyCharm对字符串进行了优化处理，所以上面的效果在PyCharm中无法演示</strong></p><h2 id="驻留机制的优缺点">驻留机制的优缺点</h2><ul><li><strong>当需要值相同的字符串时，可以直接从字符串池里拿来使用，避免频繁的创建和销毁，提升效率和节约内存，因此拼接字符串和修改字符串是会比较影响性能的</strong></li><li><strong>在需要进行字符串拼接时建议使用str类型的join方法，而非“+”，因为json()方法是先计算出所有字符中的长度，然后再拷贝，只new一次对象，效率要比“+”效率高</strong></li></ul><h2 id="字符串的常用操作">字符串的常用操作</h2><h3 id="1-查询操作">1.查询操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="4" bgcolor="white">查询方法</td><td bgcolor="white">index()</td><td bgcolor="white" align="left">查找子串substr第一次出现的位置，如果查找的子串不存在时，则抛出ValueError</td></tr><tr align="center"><td>rindex()</td><td align="left">查找子串substr最后一次出现的位置，如果查找的子串不存在时，则抛出ValueError</td></tr><tr align="center"><td bgcolor="white">find()</td><td bgcolor="white" align="left">查找子串substr第一次出现的位置，如果查找的子串不存在时，则返回-1</td></tr><tr align="center"><td>rfind()</td><td align="left">查找子串substr最后一次出现的位置，如果查找的子串不存在时，则返回-1</td></tr></table><h3 id="2-大小写转换">2.大小写转换</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="5" bgcolor="white">大小写转换</td><td bgcolor="white">upper()</td><td bgcolor="white" align="left">把字符串中所有字符都转成大写字符</td></tr><tr align="center"><td>lower()</td><td align="left">把字符串中所有字符都转成小写字符</td></tr><tr align="center"><td bgcolor="white">swapcase()</td><td bgcolor="white" align="left">把字符串中所有大写字母转成小写字母，把所有小写字母都转成大写字母</td></tr><tr align="center"><td>capitalize()</td><td align="left">把第一个字符转换为大写，其余字符转换为小写</td></tr><tr align="center"><td bgcolor="white">title()</td><td bgcolor="white" align="left">把每个单词的第一个字符转换为大写，把每个单词的剩余字符转换为小写</td></tr></table><h3 id="3-内容对齐操作">3.内容对齐操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="4" bgcolor="white">字符串对齐</td><td bgcolor="white">center()</td><td bgcolor="white" align="left">居中对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串</td></tr><tr align="center"><td>ljust()</td><td align="left">左对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串</td></tr><tr align="center"><td bgcolor="white">rjust()</td><td bgcolor="white" align="left">右对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串</td></tr><tr align="center"><td>zfill()</td><td align="left">右对齐，左边用0填充，该方法只接收一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串的长度，返回字符串本身</td></tr></table><h3 id="4-劈分操作">4.劈分操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="6" bgcolor="white">字符串的劈分</td><td rowspan="3" bgcolor="white">split()</td><td bgcolor="white" align="left">从字符串的左边开始劈分，默认的劈分字符是空格字符串，返回的值都是一个列表</td></tr><tr align="center"><td align="left">以通过参数sep指定劈分字符串的劈分符</td></tr><tr align="center"><td bgcolor="white" align="left">通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分之后，剩余的子串会单独做为一部分</td></tr><tr align="center"><td rowspan="3">rsplit()</td><td align="left">从字符串的右边开始劈分，默认的劈分字符是空格字符串，返回的值都是一个列表</td></tr><tr align="center"><td bgcolor="white" align="left">以通过参数sep指定劈分字符串的劈分符</td></tr><tr align="center"><td align="left">通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分之后，剩余的子串会单独做为一部分</td></tr></table><h3 id="5-判断字符串操作">5.判断字符串操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="6" bgcolor="white">判断字符串的方法</td><td bgcolor="white">isidentifier()</td><td bgcolor="white" align="left">判断指定的字符串是不是合法的标识符</td></tr><tr align="center"><td>isspace()</td><td align="left">判断指定的字符串是否全部由空白字符组成（回车、换行、水平制表符）</td></tr><tr align="center"><td bgcolor="white">isalpha()</td><td bgcolor="white" align="left">判断指定的字符串是否全部由字母组成</td></tr><tr align="center"><td>isdecimal()</td><td align="left">判断指定字符串是否全部由十进制的数字组成</td></tr><tr align="center"><td bgcolor="white">isnumeric()</td><td bgcolor="white" align="left">判断指定的字符串是否全部由数字组成</td></tr><tr align="center"><td>isalnum()</td><td align="left">判断指定字符串是否全部由字母和数字组成</td></tr></table><h3 id="6-替换与合并操作">6.替换与合并操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td bgcolor="white">字符串替换</td><td bgcolor="white">replace()</td><td bgcolor="white" align="left">第1个参数指定被替换的子串，第2个参数指定替换子串的字符串，该方法返回替换后得到的字符串，替换前的字符串不发生变化，调用该方法时可以通过第3个参数指定最大替换次数</td></tr><tr align="center"><td>字符串的合并</td><td>join()</td><td align="left">将列表或元组中的字符串合并成一个字符串</td></tr></table><h3 id="7-比较操作">7.比较操作</h3><ul><li><strong>运算符：</strong>&gt;、&gt;=、&lt;、&lt;=、==、!=</li><li><strong>比较规则：</strong> 首先比较两个字符串中的第一个字符串，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较</li><li><strong>比较原理：</strong> 两个字符进行比较时，比较的是其ordinal value（原始值），调用内置函数ord可以得到指定字符的ordinal value。与内置函数ord对应的是内置函数chr，调用内置函数chr时指定的ordinal value可以得到其对应的字符</li></ul><h3 id="8-切片操作">8.切片操作</h3><ul><li><strong>字符串是不可变类型</strong></li><li>不具备增、删、改等操作</li><li>切片操作将产生新的对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;python,hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>:<span class="number">1</span>])   <span class="comment">#从1开始截到5（不包含5），步长为1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::<span class="number">2</span>])     <span class="comment">#默认从0开始，没有写结束，默认到字符串的最后一个元素，步长为2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::-<span class="number">1</span>])    <span class="comment">#默认从字符串的最后一个元素开始，到字符串的第一个元素结束，因为步长为负数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">6</span>::<span class="number">1</span>])   <span class="comment">#从索引为-6开始，到字符串的最后一个元素，步长为1</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ytho</span><br><span class="line">pto,el</span><br><span class="line">olleh,nohtyp</span><br><span class="line">,hello</span><br></pre></td></tr></table></figure><h3 id="9-格式化字符串">9.格式化字符串</h3><ul><li><strong>%作占位符</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫：%s，今年66岁了&quot;</span>%name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫：%s，今年%d岁了&quot;</span>%(name,age))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的名字叫：张三，今年66岁了</span><br><span class="line">我的名字叫：张三，今年66岁了</span><br></pre></td></tr></table></figure><ul><li><strong>{}作占位符</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫：&#123;0&#125;，今年&#123;1&#125;岁了，&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(name,age))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的名字叫：张三，今年66岁了，张三</span><br></pre></td></tr></table></figure><h3 id="10-字符串的编码与解码">10.字符串的编码与解码</h3><ul><li><strong>编码：</strong> 将字符串转换为二进制数据（bytes）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;海内存知己&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;GBK&#x27;</span>))   <span class="comment">#在GBK这种编码格式中，一个中文占两个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)) <span class="comment">#在UTF-8这种编码格式中，一个中文占三个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;\xba\xa3\xc4\xda\xb4\xe6\xd6\xaa\xbc\xba&#x27;</span><br><span class="line">b&#x27;\xe6\xb5\xb7\xe5\x86\x85\xe5\xad\x98\xe7\x9f\xa5\xe5\xb7\xb1&#x27;</span><br></pre></td></tr></table></figure><ul><li><strong>解码：</strong> 将bytes类型的数据转换成字符串类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;海内存知己&#x27;</span></span><br><span class="line">byte = <span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(byte.decode(encoding=<span class="string">&#x27;GBK&#x27;</span>))</span><br><span class="line"></span><br><span class="line">byte = <span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(byte.decode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">海内存知己</span><br><span class="line">海内存知己</span><br></pre></td></tr></table></figure><h1 id="十一、函数">十一、函数</h1><h2 id="函数的创建和调用">函数的创建和调用</h2><p><strong>函数就是执行特定任务以完成特定功能一段代码</strong></p><ul><li><strong>为什么要使用函数</strong><ul><li>复用代码</li><li>隐藏实现细节</li><li>提高可维护性</li><li>提高可读性便于调试</li></ul></li></ul><p><strong>函数的创建及调用:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数的创建</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------人生苦短-------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#函数的调用</span></span><br><span class="line">printinfo()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-------人生苦短-------</span><br></pre></td></tr></table></figure><h2 id="函数的参数传递">函数的参数传递</h2><ul><li><strong>位置实参</strong><ul><li><strong>根据形参对应的位置进行实参传递</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b</span>):<span class="comment">#a，b称为形式参数，简称形参，形参的位置是在函数的定义处</span></span><br><span class="line">    c=a+b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">result=calc(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">#1,2称为实际参数，简称实参，实参的位置在函数的调用处</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><ul><li><strong>关键字实参</strong><ul><li><strong>根据形参名称进行实参传递</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b</span>):<span class="comment">#a，b称为形式参数，简称形参，形参的位置是在函数的定义处</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    c=a+b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">result=calc(b=<span class="number">1</span>,a=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><ul><li><strong>个数可变的位置形参</strong><ul><li><strong>定义函数时，可能无法事先确定传递的位置实参的个数时，使用可变的位置参数</strong></li><li><strong>使用*定义个数可变的位置形参</strong></li><li><strong>结果为一个元组</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">fun(<span class="number">10</span>)</span><br><span class="line">fun(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(10,)</span><br><span class="line">(10, 20, 30)</span><br></pre></td></tr></table></figure><ul><li><strong>个数可变的关键字形参</strong><ul><li><strong>定义函数时，无法事先确定传递的关键字实参的个数时，使用可变的关键字形参</strong></li><li><strong>使用**定义个数可变的关键字形参</strong></li><li><strong>结果为一个字典</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">**args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">fun(a=<span class="number">10</span>)</span><br><span class="line">fun(a=<span class="number">10</span>,b=<span class="number">20</span>,c=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;a&#x27;: 10&#125;</span><br><span class="line">&#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 20, &#x27;c&#x27;: 30&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的返回值">函数的返回值</h2><ul><li><strong>如果函数没有返回值，return可以省略不写</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li><strong>函数的返回值如果是一个，只返回一个类型</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fun())</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li><strong>函数的返回值如果是多个，返回的结果为元组</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">num</span>):</span><br><span class="line">    odd=[]      <span class="comment">#存奇数</span></span><br><span class="line">    even=[]     <span class="comment">#存偶数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>:</span><br><span class="line">            odd.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            even.append(i)</span><br><span class="line">    <span class="keyword">return</span> odd,even</span><br><span class="line">lst=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(fun(lst))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([1, 3, 5, 7, 9], [2, 4, 6, 8, 0])</span><br></pre></td></tr></table></figure><p><strong>函数定义默认值传参</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b=<span class="number">10</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line">fun(<span class="number">100</span>)<span class="comment">#只传一个参数，b采用默认值</span></span><br><span class="line">fun(<span class="number">10</span>,<span class="number">20</span>)<span class="comment">#20将替换10</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 10</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure><h2 id="函数的参数总结">函数的参数总结</h2><table><tr><th>序号</th><th>参数的类型</th><th>函数的定义</th><th>函数的调用</th><th>备注</th></tr><tr align="center"><td rowspan="2" bgcolor="white">1</td><td bgcolor="white">位置实参</td><td bgcolor="white"></td><td bgcolor="white">√</td><td bgcolor="white"></td></tr><tr align="center"><td>将序列的每个元素都转换为位置实参</td><td></td><td>√</td><td>使用*</td></tr><tr align="center"><td rowspan="2" bgcolor="white">2</td><td bgcolor="white">关键字实参</td><td bgcolor="white"></td><td bgcolor="white">√</td><td bgcolor="white"></td></tr><tr align="center"><td>将字典中的每个键值对都转换为关键字实参</td><td></td><td>√</td><td>使用**</td></tr><tr align="center"><td bgcolor="white">3</td><td bgcolor="white">默认值形参</td><td bgcolor="white">√</td><td bgcolor="white"></td><td bgcolor="white"></td></tr><tr align="center"><td>4</td><td>关键字形参</td><td>√</td><td></td><td>使用*</td></tr><tr align="center"><td bgcolor="white">5</td><td bgcolor="white">个数可变的位置形参</td><td bgcolor="white">√</td><td bgcolor="white"></td><td bgcolor="white">使用*</td></tr><tr align="center"><td>6</td><td>个数可变的关键字形参</td><td>√</td><td></td><td>使用**</td></tr></table><h2 id="变量的作用域">变量的作用域</h2><ul><li><strong>程序代码能访问该变量的区域</strong></li><li><strong>根据变量的有效范围可分为</strong><ul><li><strong>局部变量</strong><ul><li>在函数内定义并使用的变量，只在函数内部有效，局部变量使用global声明，这个变量就会成全局变量</li></ul></li><li><strong>全局变量</strong><ul><li>函数体外定义的变量，可做用于函数体外</li></ul></li></ul></li></ul><h2 id="递归函数">递归函数</h2><ul><li><strong>递归函数</strong><ul><li>如果在一个函数的函数体颞部调用了该函数本身，这个函数就称为递归函数</li></ul></li><li><strong>递归的组成</strong><ul><li>递归调用与递归终止条件</li></ul></li><li><strong>递归的调用过程</strong><ul><li>每递归调用一次函数，都会在栈内存分配一个栈帧</li><li>每执行完一次函数，都会释放相应的空间</li></ul></li><li><strong>递归的优缺点</strong><ul><li>缺点：占用内存多，效率低下</li><li>优点：思路和代码简单</li></ul></li></ul><h1 id="十二、异常处理">十二、异常处理</h1><h2 id="捕获异常">捕获异常</h2><ul><li><strong>try…except…结构捕获异常</strong><ul><li>Python提供的异常处理机制，可以在异常出现时及时捕获，然后内部“消化”，让程序继续运行</li></ul></li></ul><p><strong>发生异常：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">result=n1/n2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：2</span><br><span class="line">请输入另一个整数：jkl</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 133, in &lt;module&gt;</span><br><span class="line">    n2=int(input(&#x27;请输入另一个整数：&#x27;))</span><br><span class="line">ValueError: invalid literal for int() with base 10: &#x27;jkl&#x27;</span><br></pre></td></tr></table></figure><p><strong>捕获异常：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">    n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">    result=n1/n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：5</span><br><span class="line">请输入另一个整数：dsf</span><br><span class="line">输入错误</span><br></pre></td></tr></table></figure><ul><li><strong>多个except结构</strong><ul><li>捕获异常的顺序按照先子类后父类的顺序</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">    n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">    result=n1/n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">except</span> (ValueError,Exception):<span class="comment">#将可能产生的素有异常类型，都放到下面的小括号里</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：6</span><br><span class="line">请输入另一个整数：rew</span><br><span class="line">输入错误</span><br></pre></td></tr></table></figure><p><strong>打印异常：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">    n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">    result=n1/n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">except</span> (ValueError,Exception) <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：3</span><br><span class="line">请输入另一个整数：bfg</span><br><span class="line">输入错误</span><br><span class="line">invalid literal for int() with base 10: &#x27;bfg&#x27;</span><br></pre></td></tr></table></figure><ul><li><strong>try…except…else结构</strong><ul><li>如果try块中没有抛出异常，则执行else块，如果try中抛出异常，则执行except块</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">   n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">   result=n1/n2</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;产生错误了&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br></pre></td></tr></table></figure><ul><li><strong>try…except…else…finally结构</strong><ul><li>finally块无论是否发生异常都会被执行，能常用来释放try块中申请的资源</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">   n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">   result=n1/n2</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;产生错误了&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;程序结束&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>使用Exception捕获异常：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">    n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">    result=n1/n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">except</span> Exception:<span class="comment">#Exception可以承接任何异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：5</span><br><span class="line">请输入另一个整数：dsf</span><br><span class="line">输入错误</span><br></pre></td></tr></table></figure><h2 id="Python中常见的异常类型">Python中常见的异常类型</h2><table><tr><th>序号</th><th>异常类型</th><th>描述</th></tr><tr align="center"><td>1</td><td>ZeroDivisionError</td><td>除（或取模）零（所有数据类型）</td></tr><tr align="center"><td>2</td><td>IndexError</td><td>序列中没有此索引</td></tr><tr align="center"><td>3</td><td>KeyError</td><td>映射中没有这个键</td></tr><tr align="center"><td>4</td><td>NameError</td><td>未声明/初始化对象（没有属性）</td></tr><tr align="center"><td>5</td><td>SyntaxError</td><td>Python语法错误</td></tr><tr align="center"><td>6</td><td>ValueError</td><td>传入无效的参数</td></tr></table><h2 id="traceback模块">traceback模块</h2><ul><li><strong>使用traceback模块打印异常信息</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------&#x27;</span>)</span><br><span class="line">    num = <span class="number">10</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 135, in &lt;module&gt;</span><br><span class="line">    num = 10/0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><h1 id="十三、类、对象、方法">十三、类、对象、方法</h1><h2 id="编程的两大思想">编程的两大思想</h2><table><tr><th></th><th>面向过程</th><th>面向对象</th></tr><tr align="center"><td>区别</td><td align='left'>事物比较简单，可以用线性的思维去解决</td><td align='left'>事物比较复杂，使用简单的线性思维无法解决</td></tr><tr align="center"><td>共同点</td><td colspan="2" align='left'>面向过程和面向对象都是解决实际问题的一种思维方式</td></tr><tr align="center"><td></td><td colspan="2" align='left'>二者相辅相成，并不是对立<br>解决复杂问题，通过面向对象方式便于我们从宏观上把握事物之间复杂的关系、方便我们分析整个系统；具体到微观操作，仍然使用面向过程方式来处理</td></tr></table><h2 id="类与对象">类与对象</h2><ul><li><strong>类</strong><ul><li>类是多个类似事物组成的群体的统称。能够帮助我们快速理解和判断事物的性质</li></ul></li><li><strong>对象</strong><ul><li>100、99、520都是int类之下包含的相似的不同个例，这个个例专业术语称为实例或对象</li></ul></li></ul><h3 id="1-类的创建">1.类的创建</h3><ul><li><strong>类的组成</strong><ul><li>类属性：类中方法外的变量称为类属性，被该类的所有对象所共享</li><li>实例方法</li><li>静态方法：使用@staticmethod修饰的方法，可以通过类名直接访问</li><li>类方法：使用@classmethod修饰的方法，可以通过类名直接访问</li></ul></li><li><strong>类的语法</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):  <span class="comment">#name，age为实例属性</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    native_place = <span class="string">&quot;吉林&quot;</span>     <span class="comment">#类属性</span></span><br><span class="line">    <span class="comment">#实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我的名字叫：&#x27;</span>,self.name,<span class="string">&#x27;年龄是：&#x27;</span>,self.age)</span><br><span class="line">    <span class="comment">#类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cm</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类方法&#x27;</span>)</span><br><span class="line">    <span class="comment">#静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-对象的创建">2.对象的创建</h3><ul><li><strong>对象的创建又称为类的实例化，有了实例就可以调用类中的内容</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu1 = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>)</span><br><span class="line">stu1.info()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的名字叫： 张三 年龄是： 26</span><br><span class="line">张三</span><br></pre></td></tr></table></figure><h3 id="3-类属性、类方法、静态方法的使用">3.类属性、类方法、静态方法的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Student.native_place)</span><br><span class="line">Student.native_place = <span class="string">&#x27;北京&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Student.native_place)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">吉林</span><br><span class="line">北京</span><br></pre></td></tr></table></figure><h3 id="4-动态绑定属性和方法">4.动态绑定属性和方法</h3><ul><li><strong>Python是动态语言，在创建对象之后，可以动态地绑定属性和方法</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是一个函数&#x27;</span>)</span><br><span class="line">stu1 = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">24</span>)</span><br><span class="line">stu1.gender=<span class="string">&#x27;男&#x27;</span>     <span class="comment">#动态绑定属性</span></span><br><span class="line"><span class="built_in">print</span>(stu1.name,stu1.age,stu1.gender)</span><br><span class="line">stu1.show = show()   <span class="comment">#动态绑定方法</span></span><br><span class="line">stu1.show</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">张三 24 男</span><br><span class="line">我是一个函数</span><br></pre></td></tr></table></figure><h2 id="面向对象的三大特征">面向对象的三大特征</h2><h3 id="1-封装">1.封装</h3><ul><li><strong>封装：</strong> 提高程序的安全性<ul><li>将数据（属性）和行为（方法）包装到类对象中。在方法内部对属性进行操作，在类对象的外部调用方法。这样，无需关心方法内部的具体实现细节，从而隔离了复杂度</li><li>在Python中没有专门修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个“_”</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.__age)</span><br><span class="line">stu1 = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">24</span>)</span><br><span class="line">stu1.show()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="built_in">print</span>(stu1.__age)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">张三 24</span><br><span class="line">张三</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 143, in &lt;module&gt;</span><br><span class="line">    print(stu1.__age)</span><br><span class="line">AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__age&#x27;</span><br></pre></td></tr></table></figure><h3 id="2-继承">2.继承</h3><ul><li><strong>继承：</strong> 提高代码的复用性<ul><li>如果一个类没有继承任何类，则默认继承object</li><li>Python支持多继承</li><li>定义子类时，必须在其构造函数中调用父类的构造函数</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"><span class="comment">#定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,score</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.score=score</span><br><span class="line">stu = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;1000&#x27;</span>)</span><br><span class="line">stu.info()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">张三 21</span><br></pre></td></tr></table></figure><h4 id="（1）方法重写">（1）方法重写</h4><ul><li><strong>方法重写</strong><ul><li>如果子类对继承自父类的某个属性或方法不满意，可以在子类中对其（方法体）进行重新编写</li><li>子类重写后的方法中可以通过super().xxx()调用父类中被重写的方法</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"><span class="comment">#定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,score</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.score=score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().info()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;学号：&#x27;</span>,self.score)</span><br><span class="line">stu = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;1000&#x27;</span>)</span><br><span class="line">stu.info()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">张三 21</span><br><span class="line">学号： 1000</span><br></pre></td></tr></table></figure><h4 id="（2）object类">（2）object类</h4><ul><li><strong>object类</strong><ul><li>object类是所有类的父类，因此所有类都有object类的属性和方法。</li><li>内置函数dir()可以查看指定对象所有属性</li><li>Object有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数str()经常用于print()方法，帮我们查看对象的信息，所以我们经常会对__str__()进行重写</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我的名字是&#123;0&#125;,今年&#123;1&#125;岁&#x27;</span>.<span class="built_in">format</span>(self.name,self.age)</span><br><span class="line">stu = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(stu)      <span class="comment">#默认调用__str__()这样的方法</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的名字是张三,今年21岁</span><br></pre></td></tr></table></figure><h3 id="3-多态">3.多态</h3><ul><li><strong>多态：</strong> 提高程序的可扩展性和可维护性<ul><li>多态就是“具有多种形态”，即便不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型，动态决定调用哪个对象中的方法</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物要吃东西&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗吃肉&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猫吃鱼&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人吃五谷杂粮&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.eat()</span><br><span class="line">fun(Dog())</span><br><span class="line">fun(Cat())</span><br><span class="line">fun(Person())</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">狗吃肉</span><br><span class="line">猫吃鱼</span><br><span class="line">人吃五谷杂粮</span><br></pre></td></tr></table></figure><h4 id="静态语言和动态语言关于多态的区别">静态语言和动态语言关于多态的区别</h4><ul><li>静态语言实现多态的三个必要条件<ul><li>继承</li><li>方法重写</li><li>父类引用指向子类对象</li></ul></li><li>动态语言的多态崇尚“鸭子类型”，当看到一只鸟走起来像鸭子、游泳起来像鸭子、收起来也像鸭子，那么这只鸟就可以被称为鸭子。在鸭子类型中，不需要关心对象是什么类型，到底是不是鸭子，只关心对象的行为。</li></ul><h2 id="特殊方法和特殊属性">特殊方法和特殊属性</h2><table><tr><th></th><th>名称</th><th>描述</th></tr><tr align="center"><td bgcolor="white">特殊属性</td><td bgcolor="white">__dict__</td><td bgcolor="white">获得类对象或实例对象所绑定的所有属性和方法的字典</td></tr><tr align="center"><td rowspan="4">特殊方法</td><td>__len__()</td><td>通过重写__len__()方法，让内置函数len()的参数可以是自定义类型</td></tr><tr align="center"><td bgcolor="white">__add__()</td><td bgcolor="white">通过重写__add__()方法，可使用自定义对象具有“+”功能</td></tr><tr align="center"><td>__new__()</td><td>用于创建对象</td></tr><tr align="center"><td bgcolor="white">__init__()</td><td bgcolor="white">对创建的对象进行初始化</td></tr></table><h2 id="类的浅拷贝和深拷贝">类的浅拷贝和深拷贝</h2><ul><li><strong>变量的赋值操作</strong><ul><li>只是形成两个变量，实际上还是指向同一个对象</li></ul></li><li><strong>浅拷贝</strong><ul><li>Python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个子对象</li></ul></li><li><strong>深拷贝</strong><ul><li>使用copy模块的deepcopy函数，递归拷贝对象中包含的子对象，源对象和拷贝对象所有的子对象也不相同</li></ul></li></ul><h1 id="十四、模块、包">十四、模块、包</h1><h2 id="模块的定义">模块的定义</h2><ul><li><strong>模块英文为Modules</strong></li><li><strong>模块与函数的关系</strong><ul><li>一个模块中可以包含N多个函数</li></ul></li><li><strong>在Python中一个扩展名为.py的文件就是一个模块</strong></li><li><strong>使用模块的好处</strong><ul><li>方便其他程序和脚本的导入并使用</li><li>避免函数名和变量名冲突</li><li>提高代码的可维护性</li><li>提高代码的可重用性</li></ul></li></ul><h3 id="1-导入模块">1.导入模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名称 [<span class="keyword">as</span> 别名]</span><br><span class="line"><span class="keyword">from</span> 模块名称 <span class="keyword">import</span> 函数/变量/类</span><br></pre></td></tr></table></figure><h3 id="2-以主程序方式运行">2.以主程序方式运行</h3><ul><li>在每个模块的定义中都包括一个记录模块名称的变量__name__，程序可以检查该变量，以确定他们在哪个模块中执行。如果一个模块不是被导入到其他程序中执行，那么它可能在解释器的顶级模块中执行。顶级模块的__name__变量的值为__main__</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ = <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="包的定义">包的定义</h2><ul><li><strong>包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下</strong></li><li><strong>作用：</strong><ul><li>代码规避</li><li>避免模块名称冲突</li></ul></li><li><strong>包与目录的区别</strong><ul><li>包含__init__.py文件的目录称为包</li><li>目录里通常不包含__init__.py文件</li></ul></li><li><strong>包的导入</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br></pre></td></tr></table></figure><h2 id="常用的内置模块">常用的内置模块</h2><table><tr><th>模块名</th><th>描述</th></tr><tr align="center"><td>sys</td><td align="left">与Pthon解释器及其环境操作相关的标准库</td></tr><tr align="center"><td>time</td><td align="left">提供与时间相关的各种函数的标准库</td></tr><tr align="center"><td>os</td><td align="left">提供了访问操作系统服务功能的标准库</td></tr><tr align="center"><td>calendar</td><td align="left">提供与日期相关的各种函数的标准库</td></tr><tr align="center"><td>urllib</td><td align="left">用于读取来自网上（服务器）的数据标准库</td></tr><tr align="center"><td>json</td><td align="left">用于使用JSON序列化和反序列化对象</td></tr><tr align="center"><td>re</td><td align="left">用于在字符串中执行正则表达式匹配和替换</td></tr><tr align="center"><td>math</td><td align="left">提供标准算术运算函数的标准库</td></tr><tr align="center"><td>decimal</td><td align="left">用于进行精确控制运算精度、有效数位和四舍五入操作的十进制运算</td></tr><tr align="center"><td>logging</td><td align="left">提供了灵活的记录事件、错误、警告和调试信息等目录信息的功能</td></tr></table><h1 id="十五、文件的操作">十五、文件的操作</h1><h2 id="编码格式">编码格式</h2><ul><li><strong>常见的编码格式</strong><ul><li>Python的解释器使用的是Unicode（内存）</li><li>.py文件在磁盘上使用UTF-8存储（外存）</li></ul></li></ul><h2 id="文件的读写">文件的读写</h2><ul><li><strong>文件的读写俗称“IO操作”</strong></li><li><strong>内置函数open()创建文件对象</strong></li><li><strong>语法规则</strong><ul><li>file：被创建的文件对象</li><li>open()：创建文件对象的函数</li><li>filename：要创建或打开的文件名称</li><li>mode：打开模式默认为只读</li><li>encoding：默认文本文件中字符的编写格式为gbk</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(filename [,mode,encoding])</span><br></pre></td></tr></table></figure><p><strong>打开文件：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开文件   w模式（写模式，文件不存在会新建）</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.write(<span class="string">&quot;hello python&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.close()   <span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure><p><strong>读文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读文件    read方法读取指定的字符，开始时定位在文件头部，每执行一次向后移动指定字符数</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">5</span>))    <span class="comment">#hello</span></span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">5</span>))    <span class="comment"># pyth</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p><strong>一次性读取全部文件内容为列表并遍历：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">content = f.readlines()     <span class="comment">#一次性读取全部文件为列表，每行一个字符串元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(content)    <span class="comment">#[&#x27;hello python\n&#x27;, &#x27;hello python\n&#x27;, &#x27;hello python&#x27;]</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> content:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d:%s&quot;</span>%(i,temp))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;hello python--1\n&#x27;, &#x27;hello python--2\n&#x27;, &#x27;hello python--3&#x27;]</span><br><span class="line">1:hello python--1</span><br><span class="line"></span><br><span class="line">2:hello python--2</span><br><span class="line"></span><br><span class="line">3:hello python--3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-常用的文件打开模式">1.常用的文件打开模式</h3><table><tr><th>打开模式</th><th>描述</th></tr><tr align="center"><td>r</td><td align="left">以只读模式打开文件，文件的指针将会放在文件开头</td></tr><tr align="center"><td>w</td><td align="left">以只写模式打开文件，如果文件不存在则创建，如果文件存在，则覆盖原有内容，文件指针在文件的开头</td></tr><tr align="center"><td>a</td><td align="left">以追加模式打开文件，如果文件不存在则创建，文件指针在文件开头，如果文件存在，则在文件末尾追加内容，文件指针在原文件末尾</td></tr><tr align="center"><td>b</td><td align="left">以二进制方式打开文件，不能单独使用，需要与其它模式一起使用，如rb或wb</td></tr><tr align="center"><td>+</td><td align="left">以读写模式打开文件，不能单独使用，需要与其他模式一起使用，如a+</td></tr></table><h3 id="2-文件对象的常用方法">2.文件对象的常用方法</h3><table><tr><th>方法名</th><th>说明</th></tr><tr align="center"><td>read([size])</td><td align="left">从文件中读取size个字节或字符的内容返回。若省略[size]，则读取到文件末尾，即一次读取文件所有内容</td></tr><tr align="center"><td>redline()</td><td align="left">从文本中读取一行内容</td></tr><tr align="center"><td>readlines()</td><td align="left">把文本文件中每一行都作为独立的字符串对象，并将这些对象放入列表返回</td></tr><tr align="center"><td>write(str)</td><td align="left">将字符串str内容写入文件</td></tr><tr align="center"><td>writelines(s_list)</td><td align="left">将字符串列表s_list写入文本文件，不添加换行符</td></tr><tr align="center"><td>seek(offset[,whence])</td><td align="left">把文件指针移动到新的位置，offset表示相对于whence的位置：<br>offset：为正往结束方向移动，为负往开始方向移动<br>whence不同的值代表不同含义：<br>0：从文件头开始计算（默认值）<br>1：从当前位置开始计算<br>2：从文件末尾开始计算</td></tr><tr align="center"><td>tell()</td><td align="left">返回文件指针的当前位置</td></tr><tr align="center"><td>flush()</td><td align="left">把缓冲区的内容写入文件，但不关闭文件</td></tr><tr align="center"><td>close()</td><td align="left">把缓冲区的内容写入文件，同时关闭文件，释放文件对象相关资源</td></tr></table><h3 id="3-案例">3.案例</h3><p><strong>间隔两秒打印文件一行内容：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            content = f.readline()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(content) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件关闭&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello python--1</span><br><span class="line"></span><br><span class="line">hello python--2</span><br><span class="line"></span><br><span class="line">hello python--3</span><br><span class="line">文件关闭</span><br></pre></td></tr></table></figure><p><strong>案例：复制文件内容到另一文件并捕获可能出现的异常</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    inputfile = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    outputfile = <span class="built_in">open</span>(<span class="string">&quot;copy.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            content = inputfile.readline()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(content) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            outputfile.write(content)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;复制完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;写入文件失败&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        outputfile.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读取文件失败&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    inputfile.close()</span><br></pre></td></tr></table></figure><h2 id="with语句（上下文管理器）">with语句（上下文管理器）</h2><ul><li><strong>with语句可以自动管理上下文资源，不论什么原因挑出with块，都能确保文件正常的关闭，以此来达到释放资源的目的</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test1.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        content = file.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(content) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello python--1</span><br><span class="line"></span><br><span class="line">hello python--2</span><br><span class="line"></span><br><span class="line">hello python--3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="目录的操作">目录的操作</h2><ul><li><strong>os模块是Python内置的与操作系统功能和文件系统相关的模块，该模块中的语句的执行结果通常与操作系统有关，在不同的操作系统上运行，得到的结果可能不一样</strong></li><li><strong>os模块与os.path模块用于对目录或文件进行操作</strong></li></ul><p><strong>可以直接调用可执行文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#打开QQ</span></span><br><span class="line">os.startfile(<span class="string">&#x27;C:\Software\Tencent\QQ\Bin\QQScLauncher.exe&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-os模块操作目录相关函数">1.os模块操作目录相关函数</h3><table><tr><th>函数</th><th>说明</th></tr><tr align="center"><td align="left">getcwd()</td><td align="left">返回当前的工作目录</td></tr><tr align="center"><td align="left">listdir(path)</td><td align="left">返回指定路径下的文件和目录信息</td></tr><tr align="center"><td align="left">mkdir(path[,mode])</td><td align="left">创建目录</td></tr><tr align="center"><td align="left">makedirs(path1/path2...[,mode])</td><td align="left">创建多级目录</td></tr><tr align="center"><td align="left">rmdir(path)</td><td align="left">删除目录</td></tr><tr align="center"><td align="left">removedirs(path1/path2......)</td><td align="left">删除多级目录</td></tr><tr align="center"><td align="left">chdir(path)</td><td align="left">将path设置为当前工作目录</td></tr></table><h3 id="2-os-path模块操作目录相关函数">2.os.path模块操作目录相关函数</h3><table><tr><th>函数</th><th>说明</th></tr><tr><td align="left">abspath(path)</td><td align="left">用于获取文件或目录的绝对路径</td></tr><tr><td align="left">exists(path)</td><td align="left">用于判断文件或目录是否存在，如果存在返回True，否则返回False</td></tr><tr><td align="left">join(path,name)</td><td align="left">将目录与目录或者文件名拼接起来</td></tr><tr><td align="left">splitext()</td><td align="left">分离文件名和扩展名</td></tr><tr><td align="left">basename(path)</td><td align="left">从一个目录中提取文件名</td></tr><tr><td align="left">dirname(path)</td><td align="left">从一个路径中提取文件路径，不包括文件名</td></tr><tr><td align="left">isdir(path)</td><td align="left">用于判断是否为路径</td></tr></table><br>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 磁盘 mount 普通挂载及 lvm 挂载、lvm 磁盘扩容</title>
      <link href="/2021/03/16/linux_1/"/>
      <url>/2021/03/16/linux_1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-mount普通挂载">1. mount普通挂载</h1><p><strong>fdisk -l查看当前硬盘信息</strong><br><img src="https://img-blog.csdnimg.cn/20210316103131901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>fdisk /dev/sdb为硬盘创建分区，依次输入n，p，1，w，其中n分别表示创建一个新分区，p表示分区类型为主分区，1表示分区编号是1，w表示保存</strong><br><img src="https://img-blog.csdnimg.cn/20210316104230199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>mkfs.ext4 /dev/sdb1格式化分区，1为上一步的分区编号</strong><br><img src="https://img-blog.csdnimg.cn/2021031610474375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>mount /dev/sdb1 /data，将分区挂载到/data目录下，通过df -h可以看到挂载成功</strong><br><img src="https://img-blog.csdnimg.cn/20210316104920917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>目前挂载只是临时的，系统重启后需要重新挂载，如果希望下次启动时能自动挂载，输入vim /etc/fstab，增加下面的配置，/dev/sdb1是分区，/data是挂载此分区的目录，ext4是磁盘格式</strong><br><img src="https://img-blog.csdnimg.cn/20210316105414418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-lvm磁盘挂载">2. lvm磁盘挂载</h1><p><strong>fdisk -l查看当前硬盘信息</strong><br><img src="https://img-blog.csdnimg.cn/20210316134022383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>fdisk /dev/sdb为硬盘创建分区，依次输入n，p，1，t，8e，w，其中n分别表示创建一个新分区，p表示分区类型为主分区，1表示分区编号是1，t表示修改id标记，8e表示改为lvm，w表示保存</strong><br><img src="https://img-blog.csdnimg.cn/20210316134522282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>yum install lvm2安装lvm所需命令</strong><br><strong>pvcreate /dev/sdb1创建物理卷（PV），pvdisplay查看所有物理卷</strong><br><img src="https://img-blog.csdnimg.cn/2021031613511437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>vgcreate myvg1 /dev/sdb1创建卷组（VG），vgdisplay查看所有卷组</strong><br><img src="https://img-blog.csdnimg.cn/20210316135335597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>lvcreate -l +100%VG -n mylv1 myvg1创建逻辑卷（LV），将vg所有空间分配给lv，也可用lvcreate -L 2G -n mylv1 myvg1分配指定大小空间，lvdisplay查看所有逻辑卷</strong><br><img src="https://img-blog.csdnimg.cn/20210316135843568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>mkfs.xfs /dev/myvg1/mylv1格式化逻辑分区</strong><br><img src="https://img-blog.csdnimg.cn/20210316135950788.png" alt="在这里插入图片描述"><br><strong>mount /dev/myvg1/mylv1 /data挂载到/data目录下，通过df -h查看挂载成功</strong><br><img src="https://img-blog.csdnimg.cn/20210316140210353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>vim /etc/fstab添加/dev/myvg1/mylv1 /data xfs defaults 0 0实现自动挂载</strong><br><img src="https://img-blog.csdnimg.cn/20210316140448472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="3-lvm磁盘扩容">3. lvm磁盘扩容</h1><p><strong>fdisk -l查看新添加的磁盘</strong><br><img src="https://img-blog.csdnimg.cn/2021031614092251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>fdisk /dev/sdc为硬盘创建分区，依次输入n，p，1，t，8e，w，其中n分别表示创建一个新分区，p表示分区类型为主分区，1表示分区编号是1，t表示修改id标记，8e表示改为lvm，w表示保存</strong><br><img src="https://img-blog.csdnimg.cn/20210316141041484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>pvcreate /dev/sdc1创建物理卷（PV），pvdisplay查看所有物理卷</strong><br><img src="https://img-blog.csdnimg.cn/20210316141212838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>vgextend myvg1 /dev/sdc1将/dev/sdc1加入到myvg1，vgdisplay查看所有卷组</strong><br><img src="https://img-blog.csdnimg.cn/20210316141504685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>lvextend -l +100%FREE /dev/myvg1/mylv1将卷组剩余所有空间都给mylv1使用（也可以使用lvextend -L +1G -n /dev/myvg1/mylv1分配指定大小空间），xfs_growfs /dev/myvg1/mylv1使扩容生效，df -h查看成功扩容</strong><br><img src="https://img-blog.csdnimg.cn/20210316142416781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之将 mysql 数据转发给第三方 udp 网络端口</title>
      <link href="/2021/03/12/python_2/"/>
      <url>/2021/03/12/python_2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA ><strong>最近客户要把所有安全厂商的系统日志统一收录监管，我们的系统日志存放在mysql中，所以得写个脚本取数据发送到他们的网络端口</strong></font></p><h1 id="代码实现">代码实现</h1><p><strong>大体思路为取前五分钟的数据发送到第三方udp端口，每五分钟发送一次，代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql,socket,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立数据库的连接信息</span></span><br><span class="line">host = <span class="string">&quot;10.7.2.20&quot;</span>  <span class="comment"># 数据库的ip地址</span></span><br><span class="line">user = <span class="string">&quot;root&quot;</span>  <span class="comment"># 数据库的账号</span></span><br><span class="line">password = <span class="string">&quot;123456&quot;</span>  <span class="comment"># 数据库的密码</span></span><br><span class="line">port = <span class="number">3306</span>  <span class="comment"># mysql数据库通用端口号</span></span><br><span class="line">OUTPUTIP = <span class="string">&quot;192.168.44.111&quot;</span> <span class="comment">#目的ip</span></span><br><span class="line">OUTPUTPORT = <span class="number">6666</span>    <span class="comment">#目的端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    mysql = pymysql.connect(host=host, user=user, password=password, port=port)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#新建查询页面</span></span><br><span class="line">    cursor = mysql.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#sql</span></span><br><span class="line">    sql =  <span class="string">&#x27;select * from rs_datainsight.rs_admin_log where from_unixtime(createtime,\&#x27;%Y-%m-%d %H:%i:%s\&#x27;) between date_format(date_add(now(), interval - 5 minute),\&#x27;%Y-%m-%d %H:%i:%s\&#x27;) and date_format(now(),\&#x27;%Y-%m-%d %H:%i:%s\&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行sql</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回结果</span></span><br><span class="line">    <span class="comment"># result = cursor.fetchone() #返回单条数据</span></span><br><span class="line">    results = cursor.fetchall() <span class="comment">#返回多条数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="comment">#print(result)</span></span><br><span class="line">        <span class="comment">#发送到第三方端口</span></span><br><span class="line">        s.sendto(<span class="built_in">str</span>(result).encode(<span class="string">&quot;utf-8&quot;</span>),(OUTPUTIP,OUTPUTPORT))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#关闭查询</span></span><br><span class="line">    cursor.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#关闭数据库</span></span><br><span class="line">    mysql.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        main()</span><br><span class="line">        time.sleep(<span class="number">300</span>)     <span class="comment">#睡眠五分钟</span></span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure><p><strong>代码比较简单，就不多做叙述了，同时将脚本加入到任务执行计划里</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * /data/python3/bin/python3 /data/mysql2udp.py</span><br></pre></td></tr></table></figure><p><strong>每五分钟执行一次，保证脚本因为外界因素挂掉之后能够重启</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP </tag>
            
            <tag> Python </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之将 logstash 数据按天保存在本地服务器并加密压缩</title>
      <link href="/2021/03/12/python_1/"/>
      <url>/2021/03/12/python_1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  最近客户方提出了要将日志另外备份一份并进行加密压缩，今天用这篇文章来总结一下。原本的架构是logstash通过udp端口将数据发送到我们的系统，现在客户想在中间将数据取出来做一份备份，并把每天的数据加密压缩。<br>功能分两个脚本来实现，话不多说，直接进入正题。</p><h1 id="脚本一：接收数据并按天保存在本地">脚本一：接收数据并按天保存在本地</h1><p>  先把数据取出来，在logstash中添加output插件，发送到本地888端口，数据为json格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">udp &#123;</span><br><span class="line">            host =&gt; &quot;10.7.2.20&quot;</span><br><span class="line">            port =&gt; &quot;888&quot;</span><br><span class="line">            codec =&gt; json</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>  可以在本地用nc监听888端口查看网络是否阻塞，这里就不做演示了。<br>  之后先编写接收udp端口数据的代码，一步一步来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br></pre></td></tr></table></figure><p>  收到数据后，发现来一条数据后就断开连接，就在前面加一个循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br></pre></td></tr></table></figure><p>  这样就能一直收到发送方的数据了，然后把数据存在本地文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,os</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line"><span class="comment">#print(data.decode(&quot;utf-8&quot;))</span></span><br><span class="line"><span class="comment">#/data/test.txt为存放日志的文件路径，a+表示追加内容</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/data/test.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"><span class="comment">#收到的数据没有换行，在每一条数据后面添加换行符</span></span><br><span class="line">        f.write(data.decode(<span class="string">&quot;utf-8&quot;</span>)+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.close()</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br></pre></td></tr></table></figure><p>  测试之后，完美运行，下面就是完善代码了，前面说过日志要按天来存储，并且日志还分为不同的类型，所以存放路径就分为每种类型日志下面有各自每天的日志备份，日志样例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@timestamp&quot;:&quot;2021-03-11T09:24:03.668Z&quot;,&quot;hostipv6&quot;:&quot;fe80::c360:92ba:aede:5c36&quot;,&quot;hostipv4&quot;:&quot;192.168.44.111&quot;,&quot;ecs&quot;:&#123;&quot;version&quot;:&quot;1.0.0&quot;&#125;,&quot;@version&quot;:&quot;1&quot;,&quot;message&quot;:&quot;Mar 11 17:24:01 localhost CROND[104204]: (root) CMD (/usr/local/bin/php /data/rdiweb/public/di_admin.php Autotask &gt;&gt; /tmp/111.log 2&gt;&amp;1 &amp;)&quot;,&quot;host&quot;:&#123;&quot;name&quot;:&quot;localhost.localdomain&quot;,&quot;containerized&quot;:false,&quot;os&quot;:&#123;&quot;kernel&quot;:&quot;3.10.0-693.el7.x86_64&quot;,&quot;family&quot;:&quot;redhat&quot;,&quot;name&quot;:&quot;CentOS Linux&quot;,&quot;codename&quot;:&quot;Core&quot;,&quot;version&quot;:&quot;7 (Core)&quot;,&quot;platform&quot;:&quot;centos&quot;&#125;,&quot;ip&quot;:[&quot;192.168.44.111&quot;,&quot;fe80::c360:92ba:aede:5c36&quot;],&quot;id&quot;:&quot;251f075008fe4214825ef8910e29bf29&quot;,&quot;mac&quot;:[&quot;00:0c:29:64:b2:af&quot;],&quot;hostname&quot;:&quot;localhost.localdomain&quot;,&quot;architecture&quot;:&quot;x86_64&quot;&#125;,&quot;input&quot;:&#123;&quot;type&quot;:&quot;log&quot;&#125;,&quot;agent&quot;:&#123;&quot;ephemeral_id&quot;:&quot;25d88d8c-994c-49c9-afa3-78867740c45a&quot;,&quot;version&quot;:&quot;7.2.0&quot;,&quot;type&quot;:&quot;filebeat&quot;,&quot;hostname&quot;:&quot;localhost.localdomain&quot;,&quot;id&quot;:&quot;7936b07b-99db-458a-b7ed-3df7e348ef96&quot;&#125;,&quot;log&quot;:&#123;&quot;file&quot;:&#123;&quot;path&quot;:&quot;/var/log/cron&quot;&#125;,&quot;offset&quot;:111834&#125;,&quot;appname&quot;:&quot;cron&quot;,&quot;tags&quot;:[&quot;cron&quot;,&quot;beats_input_codec_plain_applied&quot;]&#125;</span><br></pre></td></tr></table></figure><p>  可以看到从logstash收到的json日志是由tags字段来分日志类型的，比如bashhistory、cron、secure等等日志，而message为原始日志，所以我们只需要取得tags字段来分类型，并把message存在文件里即可，这里我是用正则来提取的值，因为数据的格式不规则，用json解析可能会报错，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,os,re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">path</span>):</span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取原始日志</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getmessage</span>(<span class="params">data</span>):</span><br><span class="line">        rule = <span class="string">&quot;\&quot;message\&quot;:\&quot;(.*?)\&quot;,\&quot;&quot;</span></span><br><span class="line">        message = re.findall(rule, data)</span><br><span class="line">        <span class="keyword">return</span> message[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取日志类型</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gettype</span>(<span class="params">data</span>):</span><br><span class="line">        rule = <span class="string">&quot;\&quot;tags\&quot;:\[\&quot;(.*?)\&quot;,&quot;</span></span><br><span class="line">        message = re.findall(rule, data)</span><br><span class="line">        <span class="keyword">return</span> message[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line"><span class="comment">#print(data.decode(&quot;utf-8&quot;))</span></span><br><span class="line"><span class="comment">#获取当前日期</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        time = time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="comment">#提取日志类型</span></span><br><span class="line">        <span class="built_in">type</span> = gettype(data)</span><br><span class="line">        <span class="comment">#提取日志</span></span><br><span class="line">        message = getmessage(data)</span><br><span class="line"><span class="comment">#path为存放日志的文件路径，type为日志类型，time为当天日期，a+表示追加内容</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;%s/%s/%s.txt&quot;</span>%(path,<span class="built_in">type</span>,time),<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"><span class="comment">#收到的数据没有换行，在每一条数据后面添加换行符</span></span><br><span class="line">        f.write(data.decode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.close()</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 日志存放目录</span></span><br><span class="line">    path = <span class="string">&quot;/data/data&quot;</span></span><br><span class="line">    main(path)</span><br></pre></td></tr></table></figure><p>  运行效果如图：<br><img src="https://img-blog.csdnimg.cn/2021031215392113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>  可以看到日志按照类型放在不同文件夹下，并按日期分为不同的文件，代码到这里就差不多了，但是还差一些需要完善的地方，比如来的是空数据，列表会下标越界，包括后续如果客户方要接入新的日志，找不到对应的路径也会报错，总不能每次都能手动创建日志类型的文件夹吧，话不多说，完整的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,os,re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">path</span>):</span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取原始日志</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getmessage</span>(<span class="params">data</span>):</span><br><span class="line">        rule = <span class="string">&quot;\&quot;message\&quot;:\&quot;(.*?)\&quot;,\&quot;&quot;</span></span><br><span class="line">        message = re.findall(rule, data)</span><br><span class="line">        <span class="keyword">return</span> message[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取日志类型</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gettype</span>(<span class="params">data</span>):</span><br><span class="line">        rule = <span class="string">&quot;\&quot;tags\&quot;:\[\&quot;(.*?)\&quot;,&quot;</span></span><br><span class="line">        message = re.findall(rule, data)</span><br><span class="line">        <span class="keyword">return</span> message[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    <span class="comment"># 判断数据是否为空，为空跳过当前循环，防止下标越界</span></span><br><span class="line">        <span class="keyword">if</span> data.isspace():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line"><span class="comment">#print(data.decode(&quot;utf-8&quot;))</span></span><br><span class="line"><span class="comment">#获取当前日期</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        time = time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="comment">#提取日志类型</span></span><br><span class="line">        <span class="built_in">type</span> = gettype(data)</span><br><span class="line">        <span class="comment">#提取日志</span></span><br><span class="line">        message = getmessage(data)</span><br><span class="line">        <span class="comment"># 判断子目录是否存在，如果不存在即创建</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">&quot;%s/%s&quot;</span>%(path,<span class="built_in">type</span>)) == <span class="literal">False</span>:</span><br><span class="line">            os.makedirs(<span class="string">&quot;%s/%s&quot;</span>%(path,<span class="built_in">type</span>))</span><br><span class="line"><span class="comment">#path为存放日志的文件路径，type为日志类型，time为当天日期，a+表示追加内容</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;%s/%s/%s.txt&quot;</span>%(path,<span class="built_in">type</span>,time),<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"><span class="comment">#收到的数据没有换行，在每一条数据后面添加换行符</span></span><br><span class="line">        f.write(data.decode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.close()</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 日志存放目录</span></span><br><span class="line">    path = <span class="string">&quot;/data/data&quot;</span></span><br><span class="line">    main(path)</span><br></pre></td></tr></table></figure><h1 id="脚本二：将本地文件进行加密压缩">脚本二：将本地文件进行加密压缩</h1><p>  上一个脚本已经完美的把日志备份在了本地服务器，那么接下来就是将日志进行加密压缩，这个脚本相对上一个来说还是很简单的。<br>  用python压缩文件还是很简单的，比较费事的是如何加密压缩，因为pyhon自带的zipfile库不支持加密，所以这里只能使用linux压缩文件的命令行来进行处理了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zipDir</span>(<span class="params">path,outpath,password</span>):</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="comment"># 一定要有返回值，否则压缩失败；</span></span><br><span class="line">    status = os.popen(<span class="string">&quot;zip -jP %s %s %s&quot;</span>%(password,outpath,path))</span><br><span class="line">    <span class="comment"># 等待子进程完成</span></span><br><span class="line">    os.wait()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 日志存放路径</span></span><br><span class="line">    path = <span class="string">&quot;/data/secure&quot;</span></span><br><span class="line">    <span class="comment"># 压缩密码</span></span><br><span class="line">    password = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    <span class="comment"># 获取昨天日期</span></span><br><span class="line">    yesterday = (date.today() + timedelta(days=-<span class="number">1</span>)).strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">    zipDir(<span class="string">&quot;%s/%s.txt&quot;</span> %(path[<span class="number">0</span>],yesterday), <span class="string">&quot;%s/%s.zip&quot;</span> %(path,yesterday), password)</span><br></pre></td></tr></table></figure><p>  到这里文件就完美加密压缩了，可是现在的代码只能压缩一种日志类型下的文件，不能将所有日志类型全部压缩，并且压缩后的日志文件没有删除，浪费了服务器的磁盘空间，于是又花费了一些时间将代码完善，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zipDir</span>(<span class="params">path,outpath,password</span>):</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="comment"># 一定要有返回值，否则压缩失败；</span></span><br><span class="line">    status = os.popen(<span class="string">&quot;zip -jP %s %s %s&quot;</span>%(password,outpath,path))</span><br><span class="line">    <span class="comment"># 等待子进程完成</span></span><br><span class="line">    os.wait()</span><br><span class="line">    <span class="comment"># 删除压缩后的文件</span></span><br><span class="line">    os.remove(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 日志存放路径</span></span><br><span class="line">    paths = <span class="string">&quot;/data/data&quot;</span></span><br><span class="line">    <span class="comment"># 压缩密码</span></span><br><span class="line">    password = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    num = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 循环不同类型日志目录</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> os.walk(paths):</span><br><span class="line">        <span class="comment"># 跳过主目录</span></span><br><span class="line">        <span class="keyword">if</span> num:</span><br><span class="line">            num = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 获取昨天日期</span></span><br><span class="line">        yesterday = (date.today() + timedelta(days=-<span class="number">1</span>)).strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">        zipDir(<span class="string">&quot;%s/%s.txt&quot;</span> %(path[<span class="number">0</span>],yesterday), <span class="string">&quot;%s/%s.zip&quot;</span> %(path[<span class="number">0</span>],yesterday), password)</span><br></pre></td></tr></table></figure><p>  可以看到上面的代码遍历了目录，并且删除了压缩后的日志文件，和上一个脚本一样，哪怕后续加入了新的日志类型，脚本也不需要再改动了，运行效果如下：<br><img src="https://img-blog.csdnimg.cn/20210312160228444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  之后把脚本加入到linux任务执行计划里，每天晚上2点压缩前一天的文件即可。<br>  root用户下执行ctontab -e命令，将下面执行脚本的命令添加在文件末尾即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 2 * * * /data/python3/bin/python3 /data/file2zip.py</span><br></pre></td></tr></table></figure><p>  /data/python3/bin/python3是python安装的路径，注意这里一定要写绝对路径，否则可能会执行失败，/data/file2zip.py是脚本的路径和文件名，00 2 * * *是指每天2:00运行脚本<br>  同样上一个脚本也要加入到任务执行计划中，这样服务器挂掉或者重启之后脚本也能重启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * /data/python3/bin/python3 /data/logstash2file.py</span><br></pre></td></tr></table></figure><p>  这里每五分钟执行一次即可。</p><h1 id="总结">总结</h1><p>  这个需求相对来说没到很难的程度，只是要全面考虑到怎么应对不同的生产环境。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Logstash </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
