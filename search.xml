<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 爬虫基础之 urllib 库的深入使用详解</title>
      <link href="/2022/08/30/reptile_1/"/>
      <url>/2022/08/30/reptile_1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-urllib库的使用">1. urllib库的使用</h1><h2 id="1-1-获取数据">1.1 获取数据</h2><p>  爬虫的定义我这里就不多说了，直接进入正题，如何利用<code>urllib</code>库去使用爬虫。模拟浏览器向服务器发送请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;http://www.某du.com&#x27;</span>)</span><br></pre></td></tr></table></figure><p>  下面的方法能获取响应的页面源码，但是需要注意的是<code>read()</code>返回的是字节形式的二进制数据，所以需要<code>decode()</code>解码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>  返回的<code>reponse</code>的类型为<code>HTTPResponse</code>，该返回值常用的方法如下：</p><ul><li><strong>read()</strong> ：字节形式读取二进制数据，<code>read(Number)</code>返回指定字节的数据；</li><li><strong>readline()</strong> ：读取一行；</li><li><strong>readlines()</strong> ：一行一行读取所有；</li><li><strong>getcode()</strong> ：获取响应状态码；</li><li><strong>geturl()</strong> ：获取请求的URL；</li><li><strong>getheaders()</strong> ：获取headers；</li></ul><h2 id="1-2-下载">1.2 下载</h2><p>  除了获取数据，我们也能通过爬虫下载网页资源：</p><ul><li>下载网页：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlretrieve(<span class="string">&#x27;http://www.某du.com&#x27;</span>,<span class="string">&#x27;baidu.html&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>下载图片：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlretrieve(<span class="string">&#x27;https://xxxxx.cdn.bcebos.com/pic/fcfaaf51f3deb48f8f9616a7fd1f3a292cf578cf?x-bce-process=image/resize,m_lfit,h_500,limit_1/format,f_auto&#x27;</span>,<span class="string">&#x27;迪丽热巴.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>下载视频：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlretrieve(<span class="string">&#x27;https://vd2.xxxxxxxx.com/mda-magpzuurpki42hbv/v1-cae/sc/mda-magpzuurpki42hbv.mp4?v_from_s=hkapp-haokan-hbe&amp;auth_key=1661150989-0-0-5951edef259d3b8ceac0327beca694ac&amp;bcevod_channel=searchbox_feed&amp;pd=1&amp;cd=0&amp;pt=3&amp;logid=1189836669&amp;vid=12518682849229018276&amp;abtest=103579_1-103742_4&amp;klogid=1189836669&#x27;</span>,<span class="string">&#x27;迪丽热巴.mp4&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-请求对象request的定制">2. 请求对象request的定制</h1><blockquote><p><strong>User-Agent，中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本，浏览器内核、浏览器渲染引擎、浏览器语言、浏览器插件等</strong></p></blockquote><p>  URL 的组成有以下几个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http/httpswwww.某du.com80/443swd=迪丽热巴#</span><br><span class="line">协议主机端口号路径参数锚点</span><br></pre></td></tr></table></figure><p>  上面的例子我们是请求的<code>http</code>接口，能够正常爬取，但是请求<code>https</code>某度网址，会遇到<code>UA</code>反爬，也是很常见的一种反爬机制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com&#x27;</span></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/61ec838df1da40768026e08d52e440f9.png#pic_center" alt="在这里插入图片描述"></p><p>  所以在发送请求时，要带上我们的<code>UA</code>，<code>UA</code>的获取方法如下：</p><p><img src="https://img-blog.csdnimg.cn/543aca0fee964b35803f1d67dcc9d123.png#pic_center" alt="在这里插入图片描述"><br>  带上<code>UA</code>爬虫代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com&#x27;</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>  因为<code>urlopen()</code>方法不支持字典变量，所以我们可以将信息放入定制的<code>Request</code>对象中，再将<code>Request</code>对象放入<code>urlopen()</code>中。这里需要注意的是，<code>Request()</code>方法的参数必须使用关键字传参，查看<code>Request</code>源码，可以发现，第二个参数是<code>data=None</code>，所以不指定的话，默认会认为传入的<code>UA</code>是<code>data</code>参数：</p><p><img src="https://img-blog.csdnimg.cn/7fa42a5a989f440e87de55c361dabd7c.png#pic_center" alt="在这里插入图片描述"></p><h1 id="3-编解码">3. 编解码</h1><blockquote><p><strong>编码集的演变：由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc‐kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。<br>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</strong></p></blockquote><h2 id="3-1-get请求">3.1 get请求</h2><h3 id="3-1-1-quote">3.1.1 quote()</h3><p>  上面说了 URL 的组成和<code>UA</code>的作用，那么现在有一个需求：获取<code>https://www.某du.com/s?wd=迪丽热巴</code>的网页源码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com/s?wd=迪丽热巴&#x27;</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>  直接运行上面的代码，会发现报错：</p><p><img src="https://img-blog.csdnimg.cn/3c0a4978b000456f924614abf9b54397.png#pic_center" alt="在这里插入图片描述"><br>  这是因为编码的问题，我们需要将<code>迪丽热巴</code>四个字变成<code>unicode</code>编码的格式，而这需要依赖<code>urllib.parse</code>的<code>quote()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">name = urllib.parse.quote(<span class="string">&#x27;迪丽热巴&#x27;</span>)</span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com/s?wd=&#x27;</span> + name</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h3 id="3-1-2-urlencode">3.1.2 urlencode()</h3><p>  既然有将一个参数变成<code>unicode</code>编码格式的方法，那么肯定有将多个参数同时变为<code>unicode</code>编码格式的方法，毕竟我们平时用的接口不可能只有一个参数，这个方法就是<code>urlencode()</code>，它的参数类型是字典，应用场景：URL 同时有多个参数时，将多个参数变成<code>unicode</code>编码的格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span> : <span class="string">&#x27;迪丽热巴&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sex&#x27;</span> : <span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">a = urllib.parse.urlencode(data)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>  运行结果如下，将多个参数同时转为了<code>unicode</code>编码格式并用<code>&amp;</code>分割：</p><p><img src="https://img-blog.csdnimg.cn/1cf0a9b4c89f41a0af9fd79d688b86b3.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3-2-post请求">3.2 post请求</h2><p>  上面说的案例都是<code>get</code>请求接口，但其实我们遇到的更多的还是<code>post</code>请求接口，在请求时要带上参数值，以某度翻译为例，找到发送单词请求数据的 URL：</p><p><img src="https://img-blog.csdnimg.cn/8ee72c85d4b84760adf3b9f6b93ea64d.png#pic_center" alt="在这里插入图片描述"><br>  请求地址为<code>https://fanyi.某du.com/sug</code>，且以<code>post</code>方式发送。携带的参数为<code>&#123;kw:copy&#125;</code>，返回的数据为一组<code>json</code>数据，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://fanyi.某du.com/sug&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;kw&#x27;</span> : <span class="string">&#x27;copy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post请求的参数必须进行编码，编码后必须调用encode()</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong></p><ul><li><code>get</code>请求方式的参数必须编码，参数是拼接到 URL 后面，编码之后不需要调用<code>encode()</code>方法；</li><li><code>post</code>请求方式的参数必须编码，参数是放在请求对象定制的方法中，编码之后需要调用<code>encode()</code>方法；</li></ul><h2 id="3-3-案例：某度详细翻译">3.3 案例：某度详细翻译</h2><p>  前面的案例用过了某度翻译的<code>post</code>的接口，但其实某度翻译还有一个某度详细翻译的接口，返回的数据更加详细：</p><p><img src="https://img-blog.csdnimg.cn/8dce122e647c402f944de43e30ac1218.png#pic_center" alt="在这里插入图片描述"><br>  该接口需要的参数如下：</p><p><img src="https://img-blog.csdnimg.cn/ce1b08d764d8456d894ee209edea159b.png#pic_center" alt="在这里插入图片描述"><br>  爬虫代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://fanyi.某du.com/v2transapi?from=en&amp;to=zh&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;zh&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;simple_means_flag&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;479144.240793&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;68566c3678a1d2d18424ef21037ad1cd&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;common&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post请求的参数必须进行编码，编码后必须调用encode()</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 请求对象的定制</span></span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line"><span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="comment"># 获取响应的数据</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>  运行代码，遇到报错：</p><p><img src="https://img-blog.csdnimg.cn/2211079b1ba8467781063cf59c13d1ed.png#pic_center" alt="在这里插入图片描述"><br>  这是因为请求头中的数据没有全部放到<code>headers</code>中：</p><p><img src="https://img-blog.csdnimg.cn/ee3b495d8f2a42309f06deab8ae57c22.png#pic_center" alt="在这里插入图片描述"><br>  将请求头的数据全部放入<code>headers</code>即可，这里我使用的<code>Sublime Text</code>修改的数据格式，否则手动改还是有些费事：</p><p><img src="https://img-blog.csdnimg.cn/3b2de1a4a30045299ac3148938eae1a3.png#pic_center" alt="在这里插入图片描述"><br>  加入请求头数据后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://fanyi.某du.com/v2transapi?from=en&amp;to=zh&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;zh&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;simple_means_flag&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;479144.240793&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;68566c3678a1d2d18424ef21037ad1cd&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;common&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>:<span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Acs-Token&#x27;</span>:<span class="string">&#x27;1661151781547_1661235691501_0f9CZMIZ5F98s+p/e4nt/8nbrZ+AlxwEaULsxFVtWLyXY5q1G9TLC9A94gcj+3pNbT9maF1j+iqywD1ReX5S2xJ4XVhHgh2AoNNoG3kKPIvkKt1xg5LC/q465CS7LldtxQiHZH7aVD3hI98PAkb/BP/WJL94eJnMUR5z3TWWHWHznmhHc3DBZphXD7bvfieuSSSTrSfQJKh1gZAAED7Qd+FkTJPyTmx71HOYgDoKXgL8at5CVbstnRlGybS6HKSaJ+q9fAy8R9pup4Op9+6xuNh2sFR9axAE+92cP8gcQLqUd7B745Bv7Bbjv1odwUqbFJUcsLMyu1qH0yi46MQlbQ==&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>:<span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Length&#x27;</span>:<span class="string">&#x27;116&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;BIDUPSID=EDEDD8AC90775AB7BB2E2A9BA887CB6A; PSTM=1643847626; BAIDUID=EDEDD8AC90775AB76211B82417CB627A:FG=1; __yjs_duid=1_3f010fc33690405f6d48831d8577999f1644021279727; FANYI_WORD_SWITCH=1; REALTIME_TRANS_SWITCH=1; HISTORY_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; APPGUIDE_10_0_2=1; BDUSS=VhuaU9TRWVWZmY2ZjhvTURUWkxsYnV6VGNrdDhuVnpLeGdiU3BWazZlYk5RQmRqRVFBQUFBJCQAAAAAAAAAAAEAAAA5xXOd0KHQob70z8LKvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2z72LNs-9iV; BDUSS_BFESS=VhuaU9TRWVWZmY2ZjhvTURUWkxsYnV6VGNrdDhuVnpLeGdiU3BWazZlYk5RQmRqRVFBQUFBJCQAAAAAAAAAAAEAAAA5xXOd0KHQob70z8LKvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2z72LNs-9iV; ZFY=fiXfZrdJz5x8NkMm:AiKmd1ufNDjZkiFrzNjDBw7nRpY:C; BAIDUID_BFESS=EDEDD8AC90775AB76211B82417CB627A:FG=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; ariaDefaultTheme=undefined; RT=&quot;z=1&amp;dm=baidu.com&amp;si=1ehud9ig578&amp;ss=l74cz1z6&amp;sl=k&amp;tt=co6&amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&amp;ld=d781&amp;ul=f7iu&amp;hd=f7jy&quot;; BA_HECTOR=2l2kal8180842k0k842ga5kc1hg8dvk16; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1660717558,1660788138,1661134918,1661223741; PSINO=1; H_PS_PSSID=36559_36463_36641_36982_36885_34812_36917_36779_37137_26350_37089_37194; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1661235691&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>:<span class="string">&#x27;https://fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://fanyi.baidu.com/?aldtype=16047&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua&#x27;</span>:<span class="string">&#x27;&quot;Chromium&quot;;v=&quot;104&quot;, &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;104&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>:<span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>:<span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>:<span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>:<span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>:<span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>:<span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post请求的参数必须进行编码，编码后必须调用encode()</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 请求对象的定制</span></span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line"><span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="comment"># 获取响应的数据</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>  执行后发现还是报错：</p><p><img src="https://img-blog.csdnimg.cn/2622c1e1a3d24e229ca9ffb4ee1b5c51.png#pic_center" alt="在这里插入图片描述"><br>  这是因为接收的编码格式不支持<code>utf-8</code>，将<code>'Accept-Encoding':'gzip, deflate, br'</code>注释即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">url = <span class="string">&#x27;https://fanyi.某du.com/v2transapi?from=en&amp;to=zh&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;zh&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;simple_means_flag&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sign&#x27;</span>: <span class="string">&#x27;479144.240793&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;68566c3678a1d2d18424ef21037ad1cd&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;common&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;Accept-Encoding&#x27;:&#x27;gzip, deflate, br&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Acs-Token&#x27;</span>:<span class="string">&#x27;1661151781547_1661235691501_0f9CZMIZ5F98s+p/e4nt/8nbrZ+AlxwEaULsxFVtWLyXY5q1G9TLC9A94gcj+3pNbT9maF1j+iqywD1ReX5S2xJ4XVhHgh2AoNNoG3kKPIvkKt1xg5LC/q465CS7LldtxQiHZH7aVD3hI98PAkb/BP/WJL94eJnMUR5z3TWWHWHznmhHc3DBZphXD7bvfieuSSSTrSfQJKh1gZAAED7Qd+FkTJPyTmx71HOYgDoKXgL8at5CVbstnRlGybS6HKSaJ+q9fAy8R9pup4Op9+6xuNh2sFR9axAE+92cP8gcQLqUd7B745Bv7Bbjv1odwUqbFJUcsLMyu1qH0yi46MQlbQ==&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>:<span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Length&#x27;</span>:<span class="string">&#x27;116&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;BIDUPSID=EDEDD8AC90775AB7BB2E2A9BA887CB6A; PSTM=1643847626; BAIDUID=EDEDD8AC90775AB76211B82417CB627A:FG=1; __yjs_duid=1_3f010fc33690405f6d48831d8577999f1644021279727; FANYI_WORD_SWITCH=1; REALTIME_TRANS_SWITCH=1; HISTORY_SWITCH=1; SOUND_SPD_SWITCH=1; SOUND_PREFER_SWITCH=1; APPGUIDE_10_0_2=1; BDUSS=VhuaU9TRWVWZmY2ZjhvTURUWkxsYnV6VGNrdDhuVnpLeGdiU3BWazZlYk5RQmRqRVFBQUFBJCQAAAAAAAAAAAEAAAA5xXOd0KHQob70z8LKvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2z72LNs-9iV; BDUSS_BFESS=VhuaU9TRWVWZmY2ZjhvTURUWkxsYnV6VGNrdDhuVnpLeGdiU3BWazZlYk5RQmRqRVFBQUFBJCQAAAAAAAAAAAEAAAA5xXOd0KHQob70z8LKvwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2z72LNs-9iV; ZFY=fiXfZrdJz5x8NkMm:AiKmd1ufNDjZkiFrzNjDBw7nRpY:C; BAIDUID_BFESS=EDEDD8AC90775AB76211B82417CB627A:FG=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; ariaDefaultTheme=undefined; RT=&quot;z=1&amp;dm=baidu.com&amp;si=1ehud9ig578&amp;ss=l74cz1z6&amp;sl=k&amp;tt=co6&amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&amp;ld=d781&amp;ul=f7iu&amp;hd=f7jy&quot;; BA_HECTOR=2l2kal8180842k0k842ga5kc1hg8dvk16; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0; delPer=0; Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1660717558,1660788138,1661134918,1661223741; PSINO=1; H_PS_PSSID=36559_36463_36641_36982_36885_34812_36917_36779_37137_26350_37089_37194; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1661235691&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>:<span class="string">&#x27;https://fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://fanyi.baidu.com/?aldtype=16047&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua&#x27;</span>:<span class="string">&#x27;&quot;Chromium&quot;;v=&quot;104&quot;, &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;104&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>:<span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>:<span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>:<span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>:<span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>:<span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>:<span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># post请求的参数必须进行编码，编码后必须调用encode()</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 请求对象的定制</span></span><br><span class="line">request = urllib.request.Request(url=url, data=data, headers=headers)</span><br><span class="line"><span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="comment"># 获取响应的数据</span></span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">obj = json.loads(content)</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure><p>  需要注意的是，在整个请求标头中，最重要的就是<code>cookie</code>，事实上将请求标头中除去<code>cookie</code>外所有的行全部注释，爬虫也能正常运行。</p><blockquote><p><strong>cookie 一般是登录后产生（post），用来保持登录状态的，一般登录一次，下一次访问该网站下的其他网址时就不需要登录了，这就是由于cookie的作用。cookie 就是给无状态的 HTTP/HTTPS 协议添加了一种保持之前状态的功能，这样下次处理信息的时候就不用重新获取信息了。<br>cookie 还可以来判断是否是爬虫程序，因为一般的爬虫程序中并不会携带 cookie，有些比较严格的网站，不登录也需要携带 cookie 访问，也就是说 cookie 的应用场景并不仅仅只有登录后才需要。</strong></p></blockquote><h1 id="4-Ajax">4. Ajax</h1><blockquote><p><strong>Ajax 即 “Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指⼀种创建交互式网页应用的网页开发技术。用于创建快速动态网页，在无需重新加载整个网页的情况下，能够更新部分网页的技术。</strong><br><strong>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某个部分进行更新，而传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个页面。</strong></p></blockquote><h2 id="4-1-Ajax的get请求">4.1 Ajax的get请求</h2><p>  以爬取某瓣网电影前十页数据为案例，某瓣网的分页就是用<code>Ajax</code>实现的。先完成一个小目标，爬取第一页数据，找到某瓣网数据接口：</p><p><img src="https://img-blog.csdnimg.cn/0709326ec6a24a4fb6c10f402c8024b1.png#pic_center" alt="在这里插入图片描述"><br>  爬取首页数据并写入到文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20&#x27;</span></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;douban.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file.write(content)</span><br></pre></td></tr></table></figure><p>  查看文件内容，快捷键<code>ctrl+alt+L</code>自动对齐，已爬取到第一页的数据：</p><p><img src="https://img-blog.csdnimg.cn/f7e72165a07746de9d36ea5a3a993a59.png#pic_center" alt="在这里插入图片描述"><br>  下面就是爬取前十页的数据了。通过观察，找到下面三个接口，这三个接口是豆瓣网电影前三页的接口，可以明显看到这三个接口的规律，接口是根据<code>start=(page-1)*20</code>来区分页数的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20</span><br><span class="line">https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=20&amp;limit=20</span><br><span class="line">https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=40&amp;limit=20</span><br></pre></td></tr></table></figure><p>  知道了接口规律，那么接下来就是爬取前十页数据了，代码已封装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回request对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_request</span>(<span class="params">page</span>):</span><br><span class="line">    base_url = <span class="string">&#x27;https://movie.某ban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;start&#x27;</span>: (page - <span class="number">1</span>) * <span class="number">20</span>,</span><br><span class="line">        <span class="string">&#x27;limit&#x27;</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将data转换为unicode编码格式</span></span><br><span class="line">    data = urllib.parse.urlencode(data)</span><br><span class="line">    url = base_url + data</span><br><span class="line">    <span class="comment"># 定制request</span></span><br><span class="line">    request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取响应数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">page, content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;douban_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span>  file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始页码：&#x27;</span>))</span><br><span class="line">    end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束页码：&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">        request = create_request(page)</span><br><span class="line">        content = get_content(request)</span><br><span class="line">        down_load(page, content)</span><br></pre></td></tr></table></figure><p>  运行代码可以得到对应页面的数据文件，效果我就不放了。</p><h2 id="4-2-Ajax的post请求">4.2 Ajax的post请求</h2><p>  下面以爬取某德基餐厅信息的案例来演示，如何爬取<code>Ajax</code>的<code>post</code>请求。先登录某德基官网，找到对应的<code>post</code>接口。（图片违规，不让我放上来。。。。。。。）<br>  然后通过对比前三页接口的不同，找到不同页码接口之间的规律：</p><p><img src="https://img-blog.csdnimg.cn/8640788300ea4e79a414fe24d307b957.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4199a65f97234d908ac5716dcf8165d9.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/eaa886b1d3ab4a24bc437d84336f4de0.png#pic_center" alt="在这里插入图片描述"><br>  可以明显发现，该接口是通过<code>pageIndex</code>参数控制页码，<code>pageSize</code>控制每页的数量，<code>cname</code>控制地区。下面就直接放代码了，难点不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回request对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_request</span>(<span class="params">page</span>):</span><br><span class="line">    base_url = <span class="string">&#x27;http://www.某fc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;cname&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pid&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pageIndex&#x27;</span>: page,</span><br><span class="line">        <span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将data转换为unicode编码格式，post接口需要用encode()编码</span></span><br><span class="line">    data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 定制请求对象</span></span><br><span class="line">    request = urllib.request.Request(url=base_url, data=data, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取响应数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">page, content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;某fc_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始页码：&#x27;</span>))</span><br><span class="line">    end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束页码：&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">        request = create_request(page)</span><br><span class="line">        content = get_content(request)</span><br><span class="line">        down_load(page, content)</span><br></pre></td></tr></table></figure><h1 id="5-捕获异常">5. 捕获异常</h1><p>  如果我们想让自己的爬虫代码更加健壮的话，也是需要捕获异常的，这里就介绍两个异常类，<code>HTTPError</code>和<code>URLError</code>，<code>HTTPError</code>类是<code>URLError</code>类的子类。<br>  当然实际平时爬虫的使用中，捕获异常使用的并不多，所以我这里就不做过多的介绍了，直接拿上一个某德基的代码改一下放这里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回request对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_request</span>(<span class="params">page</span>):</span><br><span class="line">    base_url = <span class="string">&#x27;http://www.某fc.com.cn/kfccda/ashx/GetStoreList.ashx?op=cname&#x27;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;cname&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pid&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pageIndex&#x27;</span>: page,</span><br><span class="line">        <span class="string">&#x27;pageSize&#x27;</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 将data转换为unicode编码格式，post接口需要用encode()编码</span></span><br><span class="line">    data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 定制请求对象</span></span><br><span class="line">    request = urllib.request.Request(url=base_url, data=data, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取响应数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 模拟浏览器向服务器发送请求</span></span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件到本地</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">down_load</span>(<span class="params">page, content</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;某fc_&#x27;</span> + <span class="built_in">str</span>(page) + <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入起始页码：&#x27;</span>))</span><br><span class="line">        end_page = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入结束页码：&#x27;</span>))</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(start_page, end_page + <span class="number">1</span>):</span><br><span class="line">            request = create_request(page)</span><br><span class="line">            content = get_content(request)</span><br><span class="line">            down_load(page, content)</span><br><span class="line">    <span class="keyword">except</span> urllib.error.HTTPError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;系统正在升级&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> urllib.error.URLError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;您访问的域名不存在&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="6-cookie登录">6. cookie登录</h1><p>  在很多网站中，和上面案例中的网站有一个不一样的地方，就是未登录状态和登录状态所展示出来的数据是不一样的，这里就讲一下，如果想采集登录之后才展示出来的数据，应该怎么去写代码。这里就以某博<code>https://某bo.cn/</code>为例，采集个人主页的信息，首先按照上面讲过的代码进行尝试（因为涉及个人隐私，所以代码中的链接 uid 和后续的 cookie 我都会做随机修改处理，各位以自己的为准即可）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://某bo.cn/6328349562/info&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>  运行代码会发现编码不对：</p><p><img src="https://img-blog.csdnimg.cn/895ef61125804162b2917a0b79b1e2a8.png#pic_center" alt="在这里插入图片描述"><br>  而查看个人信息网页的源代码，编码格式确实是<code>utf-8</code>，之所以编码不对是因为我们没有登录信息，请求个人信息主页时会自动跳转到登录页面，而登录页面的编码格式却是<code>gb2312</code>，这也是一个小的爬虫手段，所以我们只需要改一下编码格式为<code>gb2312</code>即可。可是随之而来的问题是，我们这样获取的是登录页面的信息，而我们实际想要的是个人信息主页，应该怎么去绕过登录页面直接到达个人信息主页呢，这就需要一个重要的东西，就是<code>cookie</code>，在个人信息主页，打开检查，点击网络的<code>info</code>，将请求头的东西都复制出来：</p><p><img src="https://img-blog.csdnimg.cn/fb2d4676c7854df5851b88ca9dd27fef.jpeg#pic_center" alt="在这里插入图片描述"><br>  前面带有冒号的可以不要，放入代码的<code>headers</code>中，可以用前面说过的正则方法，方便快捷。注意编码格式需要改回<code>utf-8</code>，因为这里不需要再去登录页了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://某bo.cn/6347449799/info&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;accept&#x27;</span>:<span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;accept-encoding&#x27;:&#x27;gzip, deflate, br&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;accept-language&#x27;</span>:<span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cache-control&#x27;</span>:<span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cookie&#x27;</span>:<span class="string">&#x27;_T_WM=f1c3ebd01cf7dde23704b362ixs82v8q; SUB=_2A25OA26gDeRhGeBN71UV9CfLwjWIHXVtDHLorDV6PUNbktANLUjfkmdQ7XiRIiAWGcim-RPUJFDBLv9yPaBCUSFB; SUBP=0033WrSXqPxfM725Ws9jqgMF26451P9D9WFzL6FUia2PJzLiF9NnWlEC5JpX5KzhUgL.Foq0ShNESD.N2K.2dKCoIE7LxK-L1KBLB-qLxKBLB.BLBKWaUJYLxKBLBonL12BLxKqL1MDUVG6Efeh2centt; SSOLoginState=1661038641; ALF=1664046284; MLOGIN=1; M_WEIBOCN_PARAMS=luicode%3D20084629&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;referer&#x27;</span>:<span class="string">&#x27;https://weibo.cn/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua&#x27;</span>:<span class="string">&#x27;&quot;Chromium&quot;;v=&quot;104&quot;, &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;104&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>:<span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>:<span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-fetch-dest&#x27;</span>:<span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-fetch-mode&#x27;</span>:<span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-fetch-site&#x27;</span>:<span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-fetch-user&#x27;</span>:<span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><p>  如此便可获取到个人主页的信息，效果图我就不放了，懒。</p><h1 id="7-Handler处理器">7. Handler处理器</h1><p>  随着业务逻辑逐渐复杂，请求对象的定制已经满足不了我们的需求，长期爬取一个网站，会被网站识别为爬虫，对我们的设备进行封 IP 操作，所以我们就需要动态<code>cookie</code>和代理来解决这个问题，而代理就是以<code>Handler</code>为基础，这里还是先用百度的简单案例，讲一下如何使用<code>Handler</code>处理器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"><span class="comment"># 获取handler对象</span></span><br><span class="line">handler = urllib.request.HTTPHandler()</span><br><span class="line"><span class="comment"># 获取opener对象</span></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"><span class="comment"># 调用open方法</span></span><br><span class="line">response = opener.<span class="built_in">open</span>(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><h1 id="8-代理的基本使用">8. 代理的基本使用</h1><p>  当我们使用爬虫长期、高频的访问某个网站，就会被识别为爬虫，封禁设备 IP，从而导致无法访问该网站，而代理，就是为了隐藏我们的真实 IP，防止被封禁。当然代理不仅仅是这一个用途，像我们打游戏时开的加速器就是代理，访问外网的资源也需要使用代理，以及一些私密单位的内部资源都需要代理来进行访问，代理也能用来提高访问速度，通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。<br>  那么下面我就来演示一下，如何用代理爬取网站信息。首先我们上某度网站，某度<code>ip</code>，可以直接显示出我们的本机<code>ip</code>：</p><p><img src="https://img-blog.csdnimg.cn/59b4986709cc4f889549bc04de53d276.png#pic_center" alt="在这里插入图片描述"><br>  我们先使用之前请求对象定制的方法，来爬取该网站信息看是否能正常获取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.某du.com/s?wd=ip&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;代理.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(content)</span><br></pre></td></tr></table></figure><p>  打开<code>代理.html</code>文件，可以看到和我们正常访问一模一样。<br>  然后换成<code>Hanlder</code>处理器，使用代理访问，我这里用的是<code>快代理</code>网站的免费代理，连接不太稳定，可能换几个代理才有一个能用的：</p><p><img src="https://img-blog.csdnimg.cn/6f487c24ae1546b586f9a265b5078166.png#pic_center" alt="在这里插入图片描述"><br>  代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.某du.com/s?wd=ip&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span> : <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"><span class="comment"># response = urllib.request.urlopen(request)</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;223.82.60.202:8060&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 获取handler对象</span></span><br><span class="line">handler = urllib.request.ProxyHandler(proxies=proxies)</span><br><span class="line"><span class="comment"># 获取opener对象</span></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"><span class="comment"># 调用open方法</span></span><br><span class="line">response = opener.<span class="built_in">open</span>(request)</span><br><span class="line">content = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;代理.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(content)</span><br></pre></td></tr></table></figure><p>  效果图如下：</p><p><img src="https://img-blog.csdnimg.cn/5cac1e1a3da04b3aafeeb83aea0b86a6.png#pic_center" alt="在这里插入图片描述"><br>  当然在我们实际生产中，只用一个代理也是不现实的，也会面临被封<code>ip</code>的风险，所有就有了<code>代理池</code>的概念。</p><blockquote><p><strong>代理池就是由代理IP组成的池子, 它可以提供多个稳定可用的代理IP。</strong></p></blockquote><p>  我们在做爬虫的时候, 最常见一种反爬手段就是<code>ip</code>反爬，也就是当同一个<code>ip</code>高频的访问这个网站次数过多，就会限制这个<code>ip</code>访问。所以就需要使用代理来隐藏我们的真实<code>ip</code>，同时为了保证我们的代理能长期稳定的使用，就需要随机使用代理池里的代理地址，最简单的代理池实现方式就是将代理地址都放到一个列表里，创建一个随机数，每次请求都随机的从代理池中取一个代理使用，我这里就不贴代码了，就是一个很简单的功能。<br>  这篇博客就说这些简单的爬虫基础吧，已经万字长文了，后面再更新深入的爬虫相关知识。</p><h1 id="参考文献">参考文献</h1><p>  【1】<a href="https://www.bilibili.com/video/BV1Db4y1m7Ho?p=51">https://www.bilibili.com/video/BV1Db4y1m7Ho?p=51</a><br>  【2】<a href="https://blog.csdn.net/itcast_cn/article/details/123678415">https://blog.csdn.net/itcast_cn/article/details/123678415</a><br>  【3】<a href="https://www.runoob.com/python3/python-urllib.html">https://www.runoob.com/python3/python-urllib.html</a><br>  【4】<a href="https://blog.csdn.net/m0_46473590/article/details/118328217">https://blog.csdn.net/m0_46473590/article/details/118328217</a><br>  【5】<a href="https://blog.csdn.net/Y_peak/article/details/120068358">https://blog.csdn.net/Y_peak/article/details/120068358</a><br>  【6】<a href="https://www.weixueyuan.net/a/739.html">https://www.weixueyuan.net/a/739.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法》（八）- 串详解</title>
      <link href="/2021/11/02/algorithm_8/"/>
      <url>/2021/11/02/algorithm_8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p><h1 id="1-串的定义">1. 串的定义</h1><p>  早先的计算机在被发明时，主要作用是做一些科学和工程的计算工作， 也就是现在我们理解的计算器，只不过它比小小计算器功能更强大、速度更快一些。 后来发现，在计算机上作非数值处理的工作越来越多，使得我们不得不需要引入对字符的处理。于是就有了字符串的概念。<br>  比如我们现在常用的搜索引擎，当我们在文本框中输入 “数据” 时，它已经把我们想要的 “数据分析” 列在下面了。显然这里网站作了一个字符串查找匹配的工作，如下图所示。<br><img src="https://img-blog.csdnimg.cn/547cf6184ce94be6b15ade12234dd7d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  今天我们就是来研究 “串” 这样的数据结构。先来看定义。</p><blockquote><p><strong>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。</strong></p></blockquote><p>  <font color=#6495ED><strong>一般记为 s=“a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>……a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>” (n&gt;0)</strong></font>， 其中，<code>s</code>是串的名称，用双引号（也可以用单引号）括起来的字符序列是串的值，注意引号不属于串的内容。a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (1≤i≤n) 可以是字母、数字或其他字符，<code>i</code>就是该字符在串中的位置。<font color=#6495ED><strong>串中的字符数目n称为串的长度</strong></font>，定义中谈到 “有限” 是指长度<code>n</code>是一个有限的数值。<font color=#6495ED><strong>零个字符的串称为空串（null string）</strong></font>，它的长度为零，可以直接用两双引号 ““”” 表示，也可以用希腊字母 “∅” 来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。<br>  还有一些概念需要解释。<br>  空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。<br>  子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。<br>  子串在主串中的位置就是子串的第一个字符在主串中的序号。<br>  开头提到的 “over”、“end”、“Iie” 其实可以认为是 “ bover”、“friend&quot; 、“believe” 这些单词字符串的子串。<br><br></p><h1 id="2-串的比较">2. 串的比较</h1><p>  两个数字，很容易比较大小。2 比 1 大，这完全正确，可是两个字符串如何比较？比如 “silly”、“stupid” 这样的同样表达 “愚蠢的” 的单词字符串，它们在计算机中的大小其实取决于它们挨个字母的前后顺序。它们的第一个字母都是 “s”，我们认为不存在大小差异，而第二个字母，由于 “i” 字母比 “t” 字母要靠前，所以 “i” &lt; “t” ，于是我们说 “silly” &lt; “stupid”。<br>  事实上，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。<br>  计算机中的常用字符是使用标准的<code>ASCII</code>编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展<code>ASCII</code>码由 8 位二进制数表示一个字符， 总共可以表示 256 个字符，这已经足够满足以英语为主的语言和特殊符号进行输入、存储、输出等操作的字符需要了。可是，单我们国家就有除汉族外的满、回、藏、蒙古、维吾尔等多个少数民族文字，换作全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了<code>Unicode</code>编码，比较常用的是由 16 位的二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和<code>ASCII</code>码兼容，<code>Unicode</code>的前 256 个字符与<code>ASCII</code>码完全相同。<br>  所以如果我们要在C语言中比较两个串是否相等，必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等。即给定两个串：s=“a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>……a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>”，t=“b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>……b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>” ，当且仅当 n=m，且 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，……，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时，我们认为<code>s=t</code>。<br>  那么对于两个串不相等时，如何判定它们的大小呢。我们这样定义：<br>  <font color=#6495ED><strong>给定两个串：s=“a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>……a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>”，t=“b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>……b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>” ，当满足以下条件之一时，s&lt;t。</strong></font></p><ol><li><font color=#6495ED><strong>n&lt;m，且 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（i=1，2，……，n）。</strong></font><br>例如当 s= “hap”，t “happy”，就有<code>s&lt;t</code>。 因为<code>t</code>比<code>s</code>多出了两个字母。</li><li><font color=#6495ED><strong>存在某个 k≤min (m, n)，使得 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (i=1，2，……，k-1)，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4861em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&lt;b<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4861em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</strong></font><br>例如当 s=“happen”，t=“happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母（k值），字母<code>e</code>的<code>ASCII</code>码是 101，而字母<code>y</code>的<code>ASCII</code>码是 121，显然<code>e&lt;y</code>，所以<code>s&lt;t</code>。</li></ol><p>  再说一个字符申比较的应用。<br>  我们的英语词典，通常都是上万个单词的有序排列。就大小而言，前面的单词比后面的要小。你在查找单词的过程，其实就是在比较字符串大小的过程。<br><br></p><h1 id="3-串的抽象数据类型">3. 串的抽象数据类型</h1><p>  串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符，哪怕串中的字符是 “123” 这样的数字组成，或者 “2010-10-10” 这样的日期组成，它们都只能理解为长度为 3 和长度为 10 的字符串，每个元素都是字符而已。<br>  因此，对于串的基本操作与线性表是有很大差别的。线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ADT 串(<span class="built_in">string</span>)</span><br><span class="line">Data</span><br><span class="line">串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="title function_">StrAssign</span><span class="params">(T,*chars)</span>：生成一个其值等于字符串常量chars的串T。</span><br><span class="line"><span class="title function_">StrCopy</span><span class="params">(T,S)</span>：串S存在，由串S复制得串T。</span><br><span class="line"><span class="title function_">ClearString</span><span class="params">(S)</span>：事S存在，将串清空。</span><br><span class="line"><span class="title function_">StringEmpty</span><span class="params">(S)</span>：若串S为空，返回<span class="literal">true</span>,否则返回<span class="literal">false</span>。</span><br><span class="line"><span class="title function_">StrLength</span><span class="params">(S)</span>：返回串S的元素个数，即串的长度。</span><br><span class="line"><span class="title function_">StrCompare</span><span class="params">(S,T)</span>：若S&gt;T,返回值&gt;0，若S=T,返回<span class="number">0</span>,若S&lt;T,返回值&lt;<span class="number">0</span>。</span><br><span class="line">Concat(T,S1,S2)：用个返回由S1和S2联接而成的新串。</span><br><span class="line">Substring(Sub,S,pos,len)：串S存在，<span class="number">1</span>≤pos≤StrLength(S)，</span><br><span class="line">且<span class="number">0</span>≤len≤StrLength(S)-pos+<span class="number">1</span>,用Sub返</span><br><span class="line">回事S的第pos个字符起长度为len的子串。</span><br><span class="line">Index(S,T,pos)：串S和T存在，T是非空串，<span class="number">1</span>≤pos≤StrLength(S)。</span><br><span class="line">若主串S中存在和事T值相同的子串，则返回它在主串S中</span><br><span class="line">第pos个字符之后第一次出现的位置，否则返回<span class="number">0</span>。</span><br><span class="line">Replace(S,T,V)：串S、T和V存在，T是非空串。用V替换主串S中出现的所有</span><br><span class="line">与T相等的不重叠的子串。</span><br><span class="line">StrInsert(S,pos,T)：串S和T存在，<span class="number">1</span>≤pos≤StrLength(S)+<span class="number">1</span>。</span><br><span class="line">在串S的第pos个字符之前插入串T。</span><br><span class="line">StrDelete(S,pos,len)：串S存在，<span class="number">1</span>≤poss≤StrLength(S)-len+<span class="number">1</span>。</span><br><span class="line">从串S中删除第pos个字符起长度为len的子串。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>  对于不同的高级语言，其实对串的基本操作会有不同的定义方法，所以同学们在用某个语言操作字符串时，需要先查看它的参考手册关于字符串的基本操作有哪些。不过还好，不同语言除方法名称外，操作实质都是相类似的。比如<code>C#</code>中，字符串操作就还有<code>ToLower</code>转小写、<code>ToUpper</code>转大写、<code>IndexOf</code>从左查找子串位置（操作名有修改）、<code>LastIndexOf</code>从右查找子串位置、<code>Trim</code>去除两边空格等比较方便的操作，它们其实就是前面这些基本操作的扩展函数。<br>  我们来看一个操作<code>Index</code>的实现算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* T为非空串。若主串S中第pos个字符之后存在与T相等的子串，*/</span></span><br><span class="line"><span class="comment">/* 则返回第一个这样的子串在S中的位置，否则返回0 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String S, String T, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n,m,i;</span><br><span class="line">String sub;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">n = StrLength(s);<span class="comment">/* 得到主串S的长度 */</span></span><br><span class="line">m = StrLength(T);<span class="comment">/* 得到子串T的长度 */</span></span><br><span class="line">i = pos;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n-m+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SubString(sub,S,i,m);<span class="comment">/* 取主串第i个位置 */</span></span><br><span class="line"><span class="comment">/* 长度与T相等子串给sub */</span></span><br><span class="line"><span class="keyword">if</span> (StrCompare(sub,T) != <span class="number">0</span>)<span class="comment">/* 如果两串不相等 */</span></span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/* 如果两串相等 */</span></span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">/* 则返回1值 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/* 若无子串与T相等，返回0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当中用到了<code>StrLength</code>、<code>SubString</code>、<code>StrCompare</code>等基本操作来实现。<br><br></p><h1 id="4-串的存储结构">4. 串的存储结构</h1><p>  串的存储结构与线性表相同，分为两种。</p><h2 id="4-1-串的顺序存储结构">4.1 串的顺序存储结构</h2><p>  <font color=#6495ED><strong>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。</strong></font>按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。<br>  既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的 0 下标位置，有的书中也会定义存储在数组的最后一个下标位置。但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如 “\0&quot; 来表示串值的终结，这个时候，你要想知道此时的串长度，就需要遍历计算一下才知道了， 其实这还是需要占用一个空间，何必呢。<br><img src="https://img-blog.csdnimg.cn/8924588a95c54591ba5edfd761cbf0dd.png#pic_center" alt="在这里插入图片描述"><br>  刚才讲的串的顺序存储方式其实是有问题的，因为字符串的操作，比如两串的连接<code>Concat</code>、新串的插入<code>StrInsert</code>，以及字符串的替换<code>Replace</code>，都有可能使得串序列的长度超过了数组的长度<code>MaxSize</code>。<br>  于是对于串的顺序存储，有一些变化， 串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做 “堆&quot;。 这个堆可由<code>C</code>语言的动态分配函数<code>malloc()</code>和<code>free()</code>来管理。</p><h2 id="4-2-串的链式存储结构">4.2 串的链式存储结构</h2><p>  对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用 “#” 或其他非串值字符补全，如下图所示。<br><img src="https://img-blog.csdnimg.cn/e59c3b993b8e4f27b6448ee54a611fc4.png#pic_center" alt="在这里插入图片描述"><br>  当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。<br>  但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。<br><br></p><h1 id="5-朴素的模式匹配算法">5. 朴素的模式匹配算法</h1><p>  试试看。想找一个单词在一篇文章（相当于一个大字符串）中的定位问题。这种<font color=#6495ED><strong>子串的定位操作通常称做串的模式匹配</strong></font>，应该算是串中最重要的操作之一。<br>  假设我们要从下面的主串 S=“goodgoogle” 中， 找到 T=“google” 这个子串的位置。我们通常需要下面的步骤。</p><ol><li>主串<code>S</code>第一位开始，<code>S</code>与<code>T</code>前三个字母都匹配成功，但<code>S</code>第四个字母是<code>d</code>而<code>T</code>的是<code>g</code>。第一位匹配失败。如下图所示，其中竖直连线表示相等，闪电状弯折连线表示不等。<br><img src="https://img-blog.csdnimg.cn/05a601284a1f4cb3be93fc96453eb0f7.png" alt="在这里插入图片描述"></li><li>主串<code>S</code>第二位开始，主串<code>S</code>首字母是<code>O</code>，要匹配的<code>T</code>首字母是<code>g</code>，匹配失败，如下图所示。<br><img src="https://img-blog.csdnimg.cn/f7b477b08dff4c78912c20db907e8f9c.png" alt="在这里插入图片描述"></li><li>主串<code>S</code>第三位开始，主串<code>S</code>首字母是<code>O</code>，要匹配的<code>T</code>首字母是<code>g</code>，匹配失败，如下图所示。<br><img src="https://img-blog.csdnimg.cn/d435ce355f7e43d59c93c9349ff2fc11.png" alt="在这里插入图片描述"></li><li>主串<code>S</code>第四位开始，主串<code>S</code>首字母是<code>d</code>，要匹配的<code>T</code>首字母是<code>g</code>，匹配失败，如下图所示。<br><img src="https://img-blog.csdnimg.cn/d3ba223ee1f3452db311c9c1a57c55f6.png" alt="在这里插入图片描述"></li><li>主串<code>S</code>第五位开始，<code>S</code>与<code>T</code>，6 个字母全匹配，匹配成功，如下图所示。<br><img src="https://img-blog.csdnimg.cn/82c43fc38c134580a06537fde4a097ac.png" alt="在这里插入图片描述"></li></ol><p>  简单的说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做<code>T</code>的长度的小循环，直到匹配成功或全部遍历完成为止。<br>  前面我们已经用串的其他操作实现了模式匹配的算法<code>Index</code>。 现在考虑不用串的其他操作，而是只用基本的数组来实现同样的算法。注意我们假设主串<code>S</code>和要匹配的子串<code>T</code>的长度存在<code>S[0]</code>与<code>T[0]</code>中。实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回子串T在串TS中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span></span><br><span class="line"><span class="comment">/* T非空，1≤pos≤StrLength(s)。*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String s, String T, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = pos;<span class="comment">/* i用于主串S中当前位置下标，若pos不为1*/</span></span><br><span class="line"><span class="comment">/* 则从pos位置开始匹配 */</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;<span class="comment">/* j用于子串T中当前位置下标值 */</span></span><br><span class="line"><span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>])<span class="comment">/* 若i小于S长度且j小于T的长度时循环 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j])<span class="comment">/* 两字母相等则继续 */</span></span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/* 指针后退重新开始匹配 */</span></span><br><span class="line">&#123;</span><br><span class="line">i = i-j+<span class="number">2</span>;<span class="comment">/* i退回到上次匹配首位的下一位 */</span></span><br><span class="line">j = <span class="number">1</span>;<span class="comment">/* j退回到子串T的首位 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  分析一下， 最好的情况是什么？那就是一开始就区配成功， 比 “googlegood” 中去找 “google”，时间复杂度为<strong>O(1)</strong>。 稍差一些， 如果像刚才例子中第二、三、四位一样，每次都是首字母就不匹配，那么对<code>T</code>串的循环就不必进行了，比如 “abcdefgoogle” 中去找 “google”。那么时间复杂度为<strong>O(n+m)</strong>，其中<code>n</code>为主串长度，<code>m</code>为要匹配的子串长度。根据等概率原则，平均是<code>(n+m)/2</code>次查找，时间复杂度为<strong>O(n+m)</strong>。<br>  那么最坏的情况又是什么？就是每次不成功的匹配都发生在串<code>T</code>的最后一个字符。举一个很极端的例子。主串为 S= “0000000000000000000000000000000000000000000000000”，而要匹配的子串为 T=“0000000001”，前者是有 49 个 “0&quot; 和 1 个 “1” 的主串，后者是 9 个 “0&quot; 和 1 个 “1” 的子串。在匹配时，每次都得将<code>T</code>中字符循环到最后一位才发现：哦，原来它们是不匹配的。这样等于<code>T</code>串需要在<code>S</code>串的前 40 个位置都需要判断 10 次，并得出不匹配的结论，如下图所示。<br><img src="https://img-blog.csdnimg.cn/747f26b4eb1045a1a2370e911e4b5a98.png#pic_center" alt="在这里插入图片描述"><br>  直到最后第 41 个位置，因为全部匹配相等，所以不需要再继续进行下去，如下图所示。如果最终没有可匹配的予串，比如是 T=“0000000002”，到了第 41 位置判断不匹配后同样不需要继续比对下去。因此最坏情况的时间复杂度为<strong>O((n-m+1)*m)</strong>。<br><img src="https://img-blog.csdnimg.cn/61c62295c7ca46f483feb9cc1f3dbcc2.png#pic_center" alt="在这里插入图片描述"><br>  在实际运用中，对于计算机来说，处理的都是二进位的 0 和 1 的串，一个字符的<code>ASCII</code>码也可以看成是 8 位的二进位 01 串，当然，汉字等所有的字符也都可以看成是多个 0 和 1 串。再比如像计算机图形也可以理解为是由许许多多个 0 和 1 的串组成。所以在计算机的运算当中，模式匹配操作可说是随处可见，而刚才的这个算法，就显得太低效了。<br><br></p><h1 id="6-KMP模式匹配算法">6. KMP模式匹配算法</h1><p>在很多年前我们的科学家们，觉得像这种有多个 0 和 1 重复字符的字符串，却需要挨个遍历的算法是非常糟糕的事情。于是有三位前辈，D.E.Knuth、J.H.Morris 和 V.R.Pratt（其中 Knuth 和 Pratt 共同研究，Morris 独立研究）发表<font color=#6495ED><strong>一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特—莫里斯—普拉特算法，简称KMP算法。</strong></font></p><h2 id="6-1-KMP模式匹配算法原理">6.1 KMP模式匹配算法原理</h2><p>  为了能讲清楚<code>KMP算法</code>，我们不直接讲代码，那样很容易造成理解困难，还是从这个算法的研究角度来理解为什么它比朴素算法要好。<br>  如果主串 S=“abcdefgab”，其实还可以更长一些， 我们就省略掉只保留前 9 位，我们要匹配的 T=“abcdex”，那么如果用前面的朴素算法的话，前 5 个字母，两个串完全相等，直到第 6 个字母，“f” 与 “x” 不等，如下图的①所示。<br><img src="https://img-blog.csdnimg.cn/524c82d3ff5e4bb78b0ef35bd3b7656c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  接下来，按照朴素模式匹配算法，应该是如上图的流程②③④⑤⑥。即主串<code>S</code>中当<code>i=2、3、4、5、6</code>时，首字符与子串<code>T</code>的首字符均不等。<br>  似乎这也是理所当然，原来的算法就是这样设计的。可仔细观察发现。对于要匹配的子串<code>T</code>来说，“abcdex” 首字母 “a” 与后面的串 “bcdex” 中任意一个字符都不相等。也就是说，既然 “a” 不与自已后面的子串中任何一字符相等， 那么对于上图的①来说，前五位字符分别相等，意味着子串<code>T</code>的首字符 “a” 不可能与<code>S</code>串的第 2 位到第 5 位的字符相等。在上图中，②③④⑤的判断都是多余。<br>  注意这里是理解KMP算法的关键。如果我们知道<code>T</code>串中首字符 “a” 与<code>T</code>中后面的字符均不相等（注意这是前提，如何判断后面再讲）。而<code>T</code>串的第二位的 “b” 与<code>S</code>串中第二位的 “b” 在上图的①中已经判断是相等的，那么也就意味着，<code>T</code>串中首字符 “a&quot; 与<code>S</code>串中的第二位 “b” 是不需要判断也知道它们是不可能相等了，这样上图的②这一步判断是可以省略的，如下图所示。<br><img src="https://img-blog.csdnimg.cn/e943c1185f76435a8e5ed8afc74d1603.png#pic_center" alt="在这里插入图片描述"><br>  同样道理，在我们知道<code>T</code>串中首字符 “a” 与<code>T</code>中后面的字符均不相等的前提下，<code>T</code>串的 “a” 与<code>S</code>串后面的 “c”、“d”、“e” 也都可以在①之后就可以确定是不相等的，所以这个算法当中②③④⑤没有必要，只保留①⑥即可，如下图所示。<br><img src="https://img-blog.csdnimg.cn/28ddc40525f744249d7756850687c93f.png#pic_center" alt="在这里插入图片描述"><br>  之所以保留⑥中的判断是因为在①中<code>T[6]≠S[6]</code>，尽管我们已经知道<code>T[1]≠T[6]</code>，但也不能断定<code>T[1]</code>一定不等于<code>S[6]</code>，因此需要保留⑥这步。<br>  有人就会问，如果<code>T</code>串后面也含有首字符 “a” 的字符怎么办呢？<br>  我们来看下面一个例子，假设 S=“abcabcabc&quot;，T=“abcabx” 。对于开始的判断，前 5 个字符完全相等，第 6 个字符不等，如下图的①。此时，根据刚才的经验，<code>T</code>的首字符 “a” 与<code>T</code>的第二位字符 “b”、第三位字符 “c” 均不等，所以不需要做判断，下图的朴素算法步骤②③都是多余。<br><img src="https://img-blog.csdnimg.cn/c418666bd64146ac90ec9b859856ff01.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  因为<code>T</code>的首位 “a” 与<code>T</code>第四位的 “a” 相等，第二位的 “b” 与第五位的 “b” 相等。而在①时，第四位的 “a” 与第五位的 “b” 已经与主串<code>S</code>中的相应位置比较过了，是相等的， 因此可以断定，<code>T</code>的首字符 “a”。第二位的字符 “b” 与<code>S</code>的第四位字符和第五位字符也不需要比较了，肯定也是相等的——之前比较过了，还判断什么，所以④⑤这两个比较得出字符相等的步骤也可以省略。<br>  也就是说，对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。如下图所示，省略掉右图的<code>T</code>串前两位 “a” 与 “b” 同<code>S</code>串中的 4、5 位置字符匹配操作。<br><img src="https://img-blog.csdnimg.cn/105d65f417e04112849f521e5d15a571.png#pic_center" alt="在这里插入图片描述"><br>  对比这两个例子，我们会发现在①时，我们的<code>i</code>值，也就是主串当前位置的下标是 6，②③④⑤，<code>i</code>值是 2、3、4、5，到了⑥，<code>i</code>值才又回到了 6。即我们在朴素的模式匹配算法中，主串的<code>i</code>值是不断地回溯来完成的。而我们的分析发现，这种回溯其实是可以不需要的——正所谓好马不吃回头草，我们的<code>KMP模式匹配算法</code>就是为了让这没必要的回溯不发生。<br>  既然<code>i</code>值不回溯，也就是不可以变小，那么要考虑的变化就是<code>j</code>值了。通过观察也可发现，我们屡屡提到了<code>T</code>串的首字符与自身后面字符的比较，发现如果有相等字符，<code>j</code>值的变化就会不相同。也就是说，这个<code>j</code>值的变化与主串其实没什么关系，关键就取决于<code>T串</code>的结构中是否有重复的问题。<br>  比如下图中，由于 T=“abcdex”，当中没有任何重复的字符，所以<code>j</code>就由 6 变成了 1。而上图中，由于 T=“abcabx”，前缀的 “ab” 与最后 “x” 之前串的后缀 “ab” 是相等的。因此<code>j</code>就由 6 变成了 3。因此，我们可以得出规律，<code>j</code>值的多少取决于<font color=#6495ED><strong>当前字符之前的串的前后缀的相似度。</strong></font><br><img src="https://img-blog.csdnimg.cn/28ddc40525f744249d7756850687c93f.png#pic_center" alt="在这里插入图片描述"><br>  也就是说，我们<font color=#6495ED><strong>在需要查找字符串前，先对要查找的字符串做一个分析，这样可以大大减少我们查找的难度，提高查找的速度。</strong></font><br>  我们把<code>T</code>串各个位置的<code>j</code>值的变化定义为一个数组<code>next</code>，那么<code>next</code>的长度就是<code>T</code>串的长度。于是我们可以得到下面的函数定义：<br><img src="https://img-blog.csdnimg.cn/af701146560348b0bc10c1457a8bb26c.png#pic_center" alt="在这里插入图片描述"></p><h2 id="6-2-next数组值的推导">6.2 next数组值的推导</h2><p>  具体如何推导出一个串的next数组值呢，我们来看一些例子。</p><ol><li>T=“abcdex” （如下表所示）<br><img src="https://img-blog.csdnimg.cn/f2368178ea2d4296bf6c7a725390be8e.png" alt="在这里插入图片描述"><br>①当<code>j=1</code>时，<code>next[1]=0</code>；<br>②当<code>j=2</code>时，<code>i</code>由 1 到<code>i-1</code>就只有字符 “a&quot;，属于其他情况<code>next[2]=1</code>；<br>③当<code>j=3</code>时，<code>i</code>由 1 到<code>j-1</code>串是 “ab”，显然 “a” 与 “b” 不相等，属其他情况，<code>next[3]=1</code>；<br>④以后同理，所以最终此<code>T</code>串的<code>next[j]</code>为 011111。</li><li>T=“abcabx” （如下表所示）<br><img src="https://img-blog.csdnimg.cn/72c3b1af381443ecadf20d861d3c0f48.png" alt="在这里插入图片描述"><br>①当<code>j=1</code>时，<code>next[1]=0</code>；<br>②当<code>j=2</code>时，同上例说明，<code>next[2]=1</code>；<br>③当<code>j=3</code>时， 同上，<code>next[3]=1</code>；<br>④当<code>j=4</code>时，同上，<code>next[4]=1</code>；<br>⑤当<code>j=5</code>时，此时<code>j</code>由 1 到<code>j-1</code>的串是 “abca”，前缀字符 “a” 与后缀字符 “a” 相等（前缀用下划线表示，后缀用斜体表示），因此可推算出<code>k</code>值为 2（由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>´</mtext><mi>p</mi><msub><mrow></mrow><mn>1</mn></msub><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mi>p</mi><msub><mrow></mrow><mi>k</mi></msub><msub><mrow></mrow><mo>−</mo></msub><msub><mrow></mrow><mn>1</mn></msub><mtext>´</mtext><mo>=</mo><mtext>´</mtext><mi>p</mi><msub><mrow></mrow><mi>j</mi></msub><msub><mrow></mrow><mo>−</mo></msub><msub><mrow></mrow><mi>k</mi></msub><msub><mrow></mrow><mo>+</mo></msub><msub><mrow></mrow><mn>1</mn></msub><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mi>p</mi><msub><mrow></mrow><mi>j</mi></msub><msub><mrow></mrow><mo>−</mo></msub><msub><mrow></mrow><mn>1</mn></msub><mtext>´</mtext></mrow><annotation encoding="application/x-tex">´p{_1}···p{_k}{_-}{_1}´=´p{_j}{_-}{_k}{_+}{_1}···p{_j}{_-}{_1}´</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6528em;vertical-align:-0.2083em;"></span><span class="mord">´</span><span class="mord mathnormal">p</span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord">´</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7306em;vertical-align:-0.2861em;"></span><span class="mord">´</span><span class="mord mathnormal">p</span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mpunct">⋅⋅⋅</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord">´</span></span></span></span>，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><msub><mi>p</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">p_1=p_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>） 因此<code>next[5]=2</code>；<br>⑥当<code>j=6</code>时，<code>j</code>由 1 到<code>j-1</code>的串是 “abcab”，由于前缀字符 “ab” 与后缀 “ab” 相等，所以<code>next[6]=3</code>。</li></ol><p>  我们可以根据经验得到如果前后缀一个字符相等，<code>k</code>值是 2，两个字符<code>k</code>值是 3，<code>n</code>个相等<code>k</code>值就是<code>n+1</code>。</p><ol start="3"><li>T=“ababaaaba”（如下表所示）<br><img src="https://img-blog.csdnimg.cn/967898bed42f484e8fdc58bc66dfb124.png" alt="在这里插入图片描述"><br>①当<code>j=1</code>时，<code>next[1]=0</code>；<br>②当<code>j=2</code>时，同上<code>next[2]=1</code>；<br>③当<code>j=3</code>时，同上<code>next[3]=1</code>；<br>④当<code>j=4</code>时，<code>j</code>由 1 到<code>j-1</code>的串是 “aba”，前缀字符 “a” 与后缀字符 “a” 相等，<code>next[4]=2</code>；<br>⑤当<code>j=5</code>时，<code>j</code>由 1 到<code>j-1</code>的串是 “abab”，由于前缀字符 “ab” 与后缀 “ab” 相等，所以<code>next[5]=3</code>；<br>⑥当<code>j=6</code>时，<code>j</code>由 1 到<code>j-1</code>的串是 “ababa”，由于前缀字符 “aba” 与后缀 “aba” 相等，所以<code>next[6]=4</code>；<br>⑦当<code>j=7</code>时，<code>j</code>由 1 到<code>j-1</code>的串是 “ababa”，由于前缀字符 “ab” 与后缀 “aa” 并不相等，只有 “a” 相等，所以<code>next[7]=2</code>；<br>⑧当<code>j=8</code>时，<code>j</code>由 1 到<code>j-1</code>的串是 “ababaa”，只有 “a&quot; 相等，所以<code>next[8]=2</code>；<br>⑨当<code>j=9</code>时，<code>i</code>由 1 到<code>j-1</code>的串是 “ababaab”，由于前缀字符 “ab” 与后缀 “ab” 相等，所以<code>next[9]=3</code>。</li><li>T=“aaaaaab”（如下表所示）<br><img src="https://img-blog.csdnimg.cn/425136ac23ea41f9968f6a7772084de3.png" alt="在这里插入图片描述"><br>①当<code>j=1</code>时，<code>next[1]=0</code>；<br>②当<code>j=2</code>时，同上<code>next[2]=1</code>；<br>③当<code>j=3</code>时，<code>j</code>由 1 到<code>j-1</code>的串是 “a”，前缀字符 “a” 与后缀字符 “a” 相等，<code>next[3]=2</code>；<br>④当<code>j=4</code>时, <code>j</code>由 1 到<code>j-1</code>的串是 “aa”，由于前缀字符 “aa” 与后缀 “aa” 相等，所以<code>next[4]=3</code>；<br>⑤ <strong>······</strong><br>⑥当<code>j=9</code>时，<code>j</code>由 1 到<code>j-1</code>的串是 “aaaaaaaa”，由于前缀字符 “aaaaaaa” 与后缀 “aaaaaaa” 相等，所以<code>next[9]=8</code>。</li></ol><h2 id="6-3-KMP模式匹配算法实现">6.3 KMP模式匹配算法实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过计算返回子串T的next数组。*/</span></span><br><span class="line"><span class="type">void</span> get_ <span class="title function_">next</span><span class="params">(String T, <span class="type">int</span> *next)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,k;</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;T[<span class="number">0</span>])<span class="comment">/* 此处T[0]表示串T的长度 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span> || T[i]==T[k])</span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++k;</span><br><span class="line">next[i] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k = next[k];<span class="comment">/* 若字符不相同，则k值回溯 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面这段代码的目的就是为了计算出当前要匹配的串<code>T</code>的<code>next</code>数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。*/</span></span><br><span class="line"><span class="comment">/* T非空，1≤pos≤StrLength(S)。*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(String s, String T, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = pos;<span class="comment">/* i用于主串S当前位置下标值，从pos位置开始匹配 */</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;<span class="comment">/* j用于子串T中当前位置下标值 */</span></span><br><span class="line"><span class="type">int</span> next[<span class="number">255</span>];<span class="comment">/* ★★★定义一next数组 */</span></span><br><span class="line">get_ <span class="title function_">next</span><span class="params">(T, next)</span>;<span class="comment">/* ★★★对串T作分析，得到next数组 */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>])<span class="comment">/* 当i小于S的长度且j小于T的长度时，循环继续 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">0</span> || S[i] == T[j])<span class="comment">/* 两字母相等则继续，与朴素算法增加了j=0的判断 */</span></span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">/* 指针后退重新开始匹配 */</span></span><br><span class="line">&#123;</span><br><span class="line">j= next[j];<span class="comment">/* ★★★j退回合适的位置，i值不变 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面这段代码的<code>while</code>循环是真正在匹配查找。<br>  加<code>★★★</code>的为相对于朴素匹配算法增加的代码，改动不算大，关键就是去掉了<code>i</code>值回溯的部分。对于<code>get_next</code>函数来说，若<code>T</code>的长度为<code>m</code>，因只涉及到简单的单循环，其时间复杂度为<strong>O(m)</strong>，而由于<code>i</code>值的不回溯，使得<code>index_KMP</code>算法效率得到了提高，<code>while</code>循环的时间复杂度为<strong>O(n)</strong>。 因此，整个算法的时间复杂度为<strong>O(n+m)</strong>。相较于朴素模式匹配算法的 <strong>O((n-m+1)*m)</strong> 来说，是要好一些。<br>  这里也需要强调，<code>KMP算法</code>仅当模式与主串之间存在许多 “部分匹配” 的情况下才体现出它的优势，否则两者差异并不明显。</p><h2 id="6-4-KMP模式匹配算法的改进">6.4 KMP模式匹配算法的改进</h2><p>  后来有人发现，KMP还是有缺陷的。比如，如果我们的主串 S=“aaaabcde”，子串 T=“aaaaax”，其<code>next</code>数组值分别为 012345，在开始时，当<code>i=5</code>、<code> j=5</code>时，我们发现 “b” 与 “a” 不相等，如下图的①，因此<code>j=next[5]=4</code>，如下图中的②，此时 “b” 与第 4 位置的 “a” 依然不等，<code>j=next[4]=3</code>，如下图中的③，后依次是④⑤，直到<code>j=next[1]=0</code>时，根据算法，此时<code>i++</code>、<code>j++</code>，得到<code>i=6</code>、<code>j=1</code>，如下图中的⑥。<br><img src="https://img-blog.csdnimg.cn/b11544dd470f4a96a3dee76673dbb996.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  我们发现，当中的②③④⑤步骤，其实是多余的判断。由于<code>T</code>串的第二、三、四、五位置的字符都与首位的 “a” 相等，那么可以用首位<code>next[1]</code>的值去取代与它相等的字符后续<code>next[j]</code>的值，这是个很好的办法。因此我们对求<code>next()</code>函数进行了改良。<br>  假设取代的数组为<code>nextval</code>，增加了<code>★★★</code>部分，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 求模式串T的next函数修正值并存入数组nextval */</span></span><br><span class="line"><span class="type">void</span> get_ <span class="title function_">next</span><span class="params">(String T, <span class="type">int</span> *next)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,k;</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;T[<span class="number">0</span>])<span class="comment">/* 此处T[0]表示串T的长度 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span> || T[i]==T[k])<span class="comment">/* T[i]表示后缀的单个字符，T[k]表示前缀的单个字符 */</span></span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">++k;</span><br><span class="line"><span class="keyword">if</span> (T[i]!=T[k])<span class="comment">/* ★★★若当前字符与前缀字符不同 */</span></span><br><span class="line">next[i] = k;<span class="comment">/* ★★★则当前的k为nextval在i位置的值 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nextval[i] = nextval[k];<span class="comment">/* 如果与前缀字符相同，则将前缀字符的 */</span></span><br><span class="line"><span class="comment">/* nextval值赋值给nextval在i位置的值 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k = next[k];<span class="comment">/* 若字符不相同，则k值回溯 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  实际匹配算法，只需要将<code>get_next (T,next);</code>改为<code>get_nextval (T,next);</code>即可，这里不再重复。</p><h2 id="6-5-nextval数组值推导">6.5 nextval数组值推导</h2><p>  改良后，我们之前的例子<code>nextval</code>值就与<code>next</code>值不完全相同了。比如：</p><ol><li>T=“ababaaaba” (如下表所示)<br><img src="https://img-blog.csdnimg.cn/fa1cc1ec319b4d449d42065eac4cf326.png" alt="在这里插入图片描述"><br>先算出<code>next</code>数组的值分别为 011234223，然后再分别判断。<br>①当<code>j=1</code>时，<code>nextval[1]=0</code>；<br>②当<code>j=2</code>时，因第二位字符&quot; b&quot; 的<code>next</code>值是 1，而第一位就是 “a”，它们不相等，所以<code>nextval[(2]=next[2]=1</code>，维持原值。<br>③当<code>j=3</code>时，因为第三位字符 “a” 的<code>next</code>值为 1，所以与第一位的“a&quot; 比较得知它们相等，所以<code>nextval[3]=nextval[1]=0</code>；如下图所示。<br><img src="https://img-blog.csdnimg.cn/188cab8f096241f2bba28a3700a76b5c.png" alt="在这里插入图片描述"><br>④当<code>j=4</code>时，第四位的字符 “b” <code>next</code>值为 2，所以与第二位的 “b” 相比较得到结果相等，因此<code>nextval[4]=nextval[2]=1</code>；如下图所示。<br><img src="https://img-blog.csdnimg.cn/2774eb51c0194f44b108a52654c96f4b.png" alt="在这里插入图片描述"><br>⑤当<code>j=5</code>时，<code>next</code>值为<code>3</code>，第五个字符 &quot;a” 与第三个字符 “a” 相等，因此<code>nextval[5]=nextval[3]=0</code>；<br>⑥当<code>j=6</code>时，<code>next</code>值为 4，第六个字符 “a” 与第四个字符 “b” 不相等，因此<code>nextval[6]=4</code>；<br>⑦当<code>j=7</code>时，<code>next</code>值为 2，第七个字符 “a” 与第二个字符 “b” 不相等，因此<code>nextval[7]=2</code>；<br>⑧当<code>j=8</code>时，<code>next</code>值为 2，第八个字符 “b” 与第二个字符 “b” 相等，因此<code>nextval[8]=nextval[2]=1</code>；<br>⑨当<code>j=9</code>时，<code>next</code>值为 3，第九个字符 “a” 与第三个字符 “a” 相等，因此<code>nextval[9]=nextval[3]=0</code>。</li><li>T=“aaaaaaaab”（如下表）<br><img src="https://img-blog.csdnimg.cn/a28819557e81487fb9ca0cde69a3120b.png" alt="在这里插入图片描述"><br>先算出<code>next</code>数组的值分别为 012345678，然后再分别判断。<br>①当<code>j=1</code>时，<code>nextval[1]=0</code>；<br>②当<code>j=2</code>时，<code>next</code>值为 1，第二个字符与第一个字符相等，所以<code>nextval[2]=nextval[1]=0</code>；<br>③同样的道理，其后都为 0 <strong>······</strong><br>④当<code>j=9</code>时，<code>next</code>值为 8，第九个字符 “b” 与第八个字符 “a”不相等，所以<code>nextval[9]=8</code>。</li></ol><p>  总结改进过的<code>KMP算法</code>，它是在计算出<code>next</code>值的同时，如果<code>a</code>位字符与它<code>next</code>值指向的<code>b</code>位字符相等，则该<code>a</code>位的<code>nextval</code>就指向<code>b</code>位的<code>nextval</code>值，如果不等，则该<code>a</code>位的<code>nextval</code>值就是它自已<code>a</code>位的<code>next</code>的值。<br><br></p><h1 id="7-总结">7. 总结</h1><p>  串（string）是由零个或多个字符组成的有限序列，又名叫字符串。本质上,它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该要理解它当中的原理，以便于在碰到复杂的问题时，可以更加灵活的使用，比如<code>KMP模式匹配算法</code>的学习，就是更有效地去理解<code>index</code>函数当中的实现细节。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法》（七）- 队列详解</title>
      <link href="/2021/11/01/algorithm_7/"/>
      <url>/2021/11/01/algorithm_7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p><h1 id="1-队列的定义">1. 队列的定义</h1><p>  相信大家在用电脑时都经历过，机器有时会处于疑似死机的状态，鼠标点什么似乎都没用，双击任何快捷方式都不动弹。就当你失去耐心，打算 reset 时。突然它像酒醒了一样， 把你刚才点击的所有操作全部都按顺序执行了一遍。这其实是因为操作系统中的多个程序因需要通过一个通道输出，而按先后次序排队等待造成的。<br>  再比如像移动、联通、电信等客服电话，客服人员与客户相比总是少数，在所有的客服人员都占线的情况下，客户会被要求等待，直到有某个客服人员空下来，才能让最先等待的客户接通电话。这里也是将所有当前拨打客服电话的客户进行了排队处理。<br>  操作系统和客服系统中，都是应用了一种数据结构来实现刚才提到的先进先出的排队功能，这就是队列。</p><blockquote><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong></p></blockquote><p>  <font color=#6495ED><strong>队列是一种先进先出（First In First Out）的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</strong></font> 假设队列是 q=(a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, … a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，那么 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 就是队头元素，而 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是队尾元素。这样我们就可以删除时，总是从 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 开始，而插入时，列在最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后，如下图所示。<br><img src="https://img-blog.csdnimg.cn/c3eee23d8be54cb2a54c59acf0c107cb.png#pic_center" alt="在这里插入图片描述"><br>  队列在程序设计中用得非常频繁。前面我们已经举了两个例子，再比如用键盘进行各种字母或数字的输入，到显示器上如记事本软件上的输出，其实就是队列的典型应用，假如你本来和女友聊天，想表达你是我的上帝，输入的是 god，而屏幕上却显示出了 dog 发了出去，这真是要气死人了。<br><br></p><h1 id="2-队列的抽象数据类型">2. 队列的抽象数据类型</h1><p>  同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列(Queue)</span><br><span class="line">Data</span><br><span class="line">同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="title function_">InitQueue</span><span class="params">(*Q)</span>：初始化操作，建立一个空队列Q。</span><br><span class="line"><span class="title function_">DestroyQueue</span><span class="params">(*Q)</span>：若队列Q存在，则销毁它。</span><br><span class="line"><span class="title function_">ClearQueue</span><span class="params">(*Q)</span>：将队列Q清空。</span><br><span class="line"><span class="title function_">QueueEmpty</span><span class="params">(Q)</span>：若队列Q为空，返回<span class="literal">true</span>,否则返回<span class="literal">false</span>。</span><br><span class="line"><span class="title function_">GetHead</span><span class="params">(Q,*e)</span>：若队列Q存在且非空，用e返回队列Q的队头元素。</span><br><span class="line"><span class="title function_">EnQueue</span><span class="params">(*Q,e)</span>：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。</span><br><span class="line"><span class="title function_">DeQueue</span><span class="params">(*Q,*e)</span>：删除队列Q中队头元素，并用e返回其值。</span><br><span class="line"><span class="title function_">QueueLength</span><span class="params">(Q)</span>：返回队列Q的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><br><h1 id="3-循环队列">3. 循环队列</h1><p>  线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。我们先来看队列的顺序存储结构。</p><h2 id="3-1-队列顺序存储的不足">3.1 队列顺序存储的不足</h2><p>  我们假设一个队列有<code>n</code>个元素，则顺序存储的队列需建立一个大于<code>n</code>的数组，并把队列的所有元素存储在数组的前<code>n</code>个单元，数组下标为 0 的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为<strong>O(1)</strong>，如下图所示。<br><img src="https://img-blog.csdnimg.cn/a9f8f9d0aa3644cf85740f95d720caf1.png#pic_center" alt="在这里插入图片描述"><br>  与栈不同的是，队列元素的出列是在队头，即下标为 0 的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为 0 的位置不为空，此时时间复杂度为<strong>O(n)</strong>，如下图所示。<br><img src="https://img-blog.csdnimg.cn/f1c2d9d028934a0b84344e1a20400c93.png#pic_center" alt="在这里插入图片描述"><br>  这里的实现和线性表的顺序存储结构完全相同，不再详述。<br>  在现实中也是如此，一群人在排队买票，前面的人买好了离开，后面的人就要全部向前一步，补上空位，似乎这也没什么不好。<br>  可有时想想，为什么出队列时一定要全部移动呢，如果不去限制队列的元素必须存储在数组的前<code>n</code>个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定在下标为 0 的位置，如下图所示。<br><img src="https://img-blog.csdnimg.cn/d4647ae71d694b53bfaa0200540a628a.png#pic_center" alt="在这里插入图片描述"><br>  为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，<code>front</code>指针指向队头元素，<code>rear</code>指针指向队尾元素的下一个位置，这样当<code>front</code>等于<code>rear</code>时，此队列不是还剩一个元素，而是空队列。<br>  假设是长度为 5 的数组，初始状态，空队列如下图的左图所示，<code>front</code>与<code>rear</code>指针均指向下标为 0 的位置。然后入队 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<code>front</code>指针依然指向下标为 0 位置，而<code>rear</code>指针指向下标为 4 的位置，如下图的右图所示。<br><img src="https://img-blog.csdnimg.cn/00f4393f5f3e433d886dec90408edf96.png#pic_center" alt="在这里插入图片描述"><br>  出队a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则<code>front</code>指针指向下标为 2 的位置，<code>rear</code>不变，如下图的左图所示，再入队a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，此时<code>front</code>指针不变，<code>rear</code>指针移动到数组之外。嗯？数组之外，那将是哪里？如下图的右图所示。<br><img src="https://img-blog.csdnimg.cn/8b70249a77d946ab96e25ba83441675a.png#pic_center" alt="在这里插入图片描述"><br>  问题还不止于此。假设这个队列的总个数不超过 5 个，但目前如果接着入队的话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为 0 和 1 的地方还是空闲的。我们把这种现象叫做 “假溢出”。<br>  现实当中，你上了公交车，发现前排有两个空座位，而后排所有座位都已经坐满，你会怎么做？立马下车，并对自己说，后面没座了，我等下一辆？<br>  没有这么笨的人，前面有座位，当然也是可以坐的，除非坐满了，才会考虑下一辆。</p><h2 id="3-2-循环队列定义">3.2 循环队列定义</h2><p>  所以解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。<font color=#6495ED><strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列。</strong></font><br>  刚才的例子继续，上图的<code>rear</code>可以改为指向下标为 0 的位置，这样就不会造成指针指向不明的问题了，如下图所示。<br><img src="https://img-blog.csdnimg.cn/c6e35bacda7945678553506446685218.png#pic_center" alt="在这里插入图片描述"><br>  接着入队 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>6</mn></msub></mrow><annotation encoding="application/x-tex">_6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，将它放置于下标为 0 处，<code>rear</code>指针指向下标为 1 处，如下图的左图所示。若再入队 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>7</mn></msub></mrow><annotation encoding="application/x-tex">_7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则<code>rear</code>指针就与<code>front</code>指针重合，同时指向下标为 2 的位置，如下图的右图所示。<br><img src="https://img-blog.csdnimg.cn/23fdabc6c06b4f08afeb60de65eb352b.png#pic_center" alt="在这里插入图片描述"></p><ul><li>此时问题又出来了， 我们刚才说，空队列时，<code>front</code>等于<code>rear</code>，现在当队列满时，也是<code>front</code>等于<code>rear</code>，那么如何判断此时的队列究竟是空还是满呢？</li><li>办法一是设置一个标志变量<code>flag</code>，当<code>front=rear</code>，且<code>flag=0</code>时为队列空，当<code>front=rear</code>，且<code>flag=1</code>时为队列满。</li><li>办法二是当队列空时，条件就是<code>front=rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。例如下图所示，我们就认为此队列已经满了，也就是说，我们不允许下图的右图情况出现。</li></ul><p><img src="https://img-blog.csdnimg.cn/0ac8557fd679414d986836b7eb7cbd8e.png#pic_center" alt="在这里插入图片描述"><br>  我们重点来讨论第二种方法，由于<code>rear</code>可能比<code>front</code>大，也可能比<code>front</code>小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。 所以若队列的最大尺寸为<code>QueueSize</code>，那么<font color=#6495ED><strong>队列满的条件是（rear+1）QueueSize == front</strong></font>（取模 “%” 的目的就是为了整合<code>rear</code>与<code>front</code>大小为一个问题）。比如上面这个例子，<code>QueueSize=5</code>，上图的左图中<code>front=0</code>，而<code>rear=4</code>，<code>(4+1)%5= 0</code>，所以此时队列满。再比如上图中的右图，<code>front=2</code>而<code>rear=1</code>。<code>(1 + 1)%5=2</code>，所以此时队列也是满的。而对于下图，<code>front=2</code>而<code>rear=0</code>，<code>(0+1)%5=1</code>，<code>1≠2</code>，所以此时队列并没有满。<br><img src="https://img-blog.csdnimg.cn/3e4be307dc764d6d9bdfb6f63e26e946.png#pic_center" alt="在这里插入图片描述"><br>  另外，当<code>rear&gt;front</code>时，即下图的左图和下图的右图，此时队列的长度为<code>rear-front</code>。 但当<code>rear&lt;front</code>时，如上图和上上图的左图，队列长度分为两段，一段是<code>QueueSize-front</code>，另一段是<code>0+rear</code>，加在一起，队列长度为<code>rear-front+QueueSize</code>。<br>  因此<font color=#6495ED><strong>通用的计算队列长度公式为：</strong></font><br>  <strong>(rear- front + QueueSize) %QueueSize</strong><br>  有了这些讲解，现在实现循环队列的代码就不难了。<br><img src="https://img-blog.csdnimg.cn/8654828e59724e6a954b2bd8d6dbd5b4.png#pic_center" alt="在这里插入图片描述"><br>  循环队列的顺序存储结构代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;<span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> front;<span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="type">int</span> rear;<span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><p>  循环队列的初始化代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化一个空队列Q */</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  循环队列求队列长度代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回Q的元素个数，也就是队列的当前长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  循环队列的入队列操作代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q,QE1emType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%SMAXSIZE == Q-&gt;front)<span class="comment">/* 队列满的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Q-&gt;data[Q-&gt;rear]=e;<span class="comment">/* 将元素e赋值给队尾 */</span></span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* rear指针向后移一位置 */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  循环队列的出队列操作代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q,QE1emType *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;front)<span class="comment">/* 队列空的判断 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=Q-&gt;data[Q-&gt;front];<span class="comment">/* 将队头元素赋值给e */</span></span><br><span class="line">Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* front指针向后移一位置 */</span></span><br><span class="line"><span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  从这一段讲解，大家应该发现，单是顺序存储，若不是循环队列，算法的时间性能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下不需要担心队列长度的链式存储结构。<br><br></p><h1 id="4-队列的链式存储结构及实现">4. 队列的链式存储结构及实现</h1><p>  <font color=#6495ED><strong>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。</strong></font> 为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点，如下图所示。<br><img src="https://img-blog.csdnimg.cn/335446a88a454c2d9ea11f9b3bfa798c.png#pic_center" alt="在这里插入图片描述"><br>  空队列时，<code>front</code>和<code>rear</code>都指向头结点，如下图所示。<br><img src="https://img-blog.csdnimg.cn/99428c61204f4b05b2c82eae69ffa0d3.png#pic_center" alt="在这里插入图片描述"><br>  链队列的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType; <span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>/* 结点结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>/* 队列的链表结构 */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr front,rear;<span class="comment">/* 队头、队尾指针 */</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h2 id="4-1-队列的链式存储结构——入队操作">4.1 队列的链式存储结构——入队操作</h2><p>  入队操作时，其实就是在链表尾部插入结点，如下图所示。<br><img src="https://img-blog.csdnimg.cn/ac54cceefd69459f83e4c3146e725578.png#pic_center" alt="在这里插入图片描述"><br>  其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue *, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">QueuePtr s=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span> (!s)<span class="comment">/* 存储分配失败 */</span></span><br><span class="line"><span class="built_in">exit</span> (OVERFLOW);</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next=s;<span class="comment">/* 把拥有元素e新结点s赋值给原队尾结点的后继,见上图中① */</span></span><br><span class="line">Q-&gt;rear=s;<span class="comment">/* 把当前的s设置为队尾结点，rear指向s，见上图中② */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-队列的链式存储结构——出队操作">4.2 队列的链式存储结构——出队操作</h2><p>  出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将<code>rear</code>指向头结点，如下图所示。<br><img src="https://img-blog.csdnimg.cn/a6d65925dc1042a1b54d1be3f89fcb96.png#pic_center" alt="在这里插入图片描述"><br>  代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front==Q-&gt;rear )</span><br><span class="line"><span class="keyword">return</span> ERROR:</span><br><span class="line">p=Q-&gt;front-&gt;next;<span class="comment">/* 将欲删除的队头结点暂存给p,见上图中① */</span></span><br><span class="line">*e=p-&gt;data;<span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></span><br><span class="line"><span class="number">0</span>-&gt;front-&gt;next=p-&gt;next;<span class="comment">/* 将原队头结点后继p-&gt;next赋值给头结点后继，见上图中② */</span></span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear==p)<span class="comment">/* 若队头是队尾，则删除后将rear指向头结点，见上图中③ */</span></span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基本操作都是常数时间，即都为 <strong>O(1)</strong> 的， 不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。<br>  总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。<br><br></p><h1 id="5-总结">5. 总结</h1><p>  栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。<br>  栈（stack）是限定仅在表尾进行插入和删除操作的线性表。<br>  队列（queue）是只允许在一端进行插入操作， 而在另一端进行删除操作的线性表。<br>  它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。<br>  对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>  对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是 <strong>O(n)</strong> 的时间复杂度变成了<strong>O(1)</strong>。<br>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同如下图所示。<br><img src="https://img-blog.csdnimg.cn/3e7b77f02382449fb1b5364d7225b6a5.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法》（六）- 栈详解</title>
      <link href="/2021/10/31/algorithm_6/"/>
      <url>/2021/10/31/algorithm_6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p><h1 id="1-栈的定义">1. 栈的定义</h1><h2 id="1-1-栈的定义">1.1 栈的定义</h2><p>  很多软件，比如Word、 Photoshop 等文档或图像编辑软件中，都有撤销（undo）的操作，也是用栈这种方式来实现的，当然不同的软件具体实现代码会有很大差异，不过原理其实都是一样的。</p><blockquote><p><strong>栈( stack )是限定仅在表尾进行插入和删除操作的线性表。</strong></p></blockquote><p>  我们把<font color=#6495ED><strong>允许插入和删除的一端称为栈顶（top）， 另一端称为栈底（bottom）， 不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</strong></font>。<br>  理解栈的定义需要注意：<br>  首先它是一个<font color=#8A2BE2><strong>线性表</strong></font>， 也就是说，栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。<br>  它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。<br>  <font color=#6495ED><strong>栈的插入操作，叫作进栈，也称压栈、入栈。</strong></font>如下图所示。<br><img src="https://img-blog.csdnimg.cn/9c937a67b9714e4e969bb7946858b4e1.png#pic_center" alt="在这里插入图片描述"><br>  <font color=#6495ED><strong>栈的删除操作，叫作出栈，也有的叫作弹栈。</strong></font>如下图所示。<br><img src="https://img-blog.csdnimg.cn/6355ec164c694d84931c523854e083c1.png#pic_center" alt="在这里插入图片描述"></p><h2 id="1-2-进栈出栈变化形式">1.2 进栈出栈变化形式</h2><p>  栈对线性表的插入和删除的位置进行了限制，并没有对元素进出的时间进行限制，也就是说，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以。<br>  举例来说，如果我们现在是有 3 个整型数字元素 1、2、3 依次进栈，会有哪些出栈次序呢？</p><ul><li>第一种：1、2、3 进，再 3、2、1 出。这是最简单的最好理解的一种，出栈次序为 3、2、1。</li><li>第二种：1 进，1 出，2 进，2 出，3 进，3 出。也就是进一个就出一个，出<br>栈次序为 1、2、3。</li><li>第三种：1 进，2 进，2 出，1 出，3 进，3 出。出栈次序为 2、1、3.</li><li>第四种：1 进，1 出，2 进，3 进，3 出，2 出。出栈次序为 1、3、2。</li><li>第五种：1 进，2 进，2 出，3 进，3 出，1 出。出栈次序为 2、3、1。</li></ul><p>  有没有可能是 3、1、2 这样的次序出栈呢？答案是肯定不会。因为 3 先出栈，就意味着，3 曾经进栈，既然 3 都进栈了，那也就意味着，1 和 2 已经进栈了，此时，2 一定是在 1 的上面，就是更接近栈顶，那么出栈只可能是 3、2、1，不然不满足 1、2、3 依次进栈的要求，所以此时不会发生 1 比 2 先出栈的情况。<br>  从这个简单的例子就能看出，只是 3 个元素，就有 5 种可能的出栈次序，如果元素数量多，其实出栈的变化将会更多的。<br><br></p><h1 id="2-栈的抽象数据类型">2. 栈的抽象数据类型</h1><p>  对于栈来讲，理论上线性表的操作特性它都具备，可由于它的特殊性，所以针对它在操作上会有些变化。特别是插入和删除操作，我们改名为<code>push</code>和<code>pop</code>，英文直译的话是压和弹，更容易理解。你就把它当成是弹夹的子弹压入和弹出就好记忆了，我们一般叫进栈和出栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT栈(<span class="built_in">stack</span>)</span><br><span class="line">Data</span><br><span class="line">同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="title function_">Initstack</span><span class="params">(*S)</span>：初始化操作，建立一个空栈S。</span><br><span class="line"><span class="title function_">DestroyStack</span><span class="params">(*S)</span>：若栈存在，则销毁它。</span><br><span class="line"><span class="title function_">Clearstack</span><span class="params">(*S)</span>：将栈清空。</span><br><span class="line"><span class="title function_">StackEmpty</span><span class="params">(S)</span>：若栈为空，返回<span class="literal">true</span>,否则返回<span class="literal">false</span>。</span><br><span class="line"><span class="title function_">GetTop</span><span class="params">(S,*e)</span>：若栈存在且非空，用e返回S的栈顶元素。</span><br><span class="line"><span class="title function_">Push</span><span class="params">(*S,e)</span>:若栈S存在，插入新元素e到栈S中并成为栈顶元素。</span><br><span class="line"><span class="title function_">Pop</span><span class="params">(*S,*e)</span> :删除栈S中栈顶元素，并用e返回其值。</span><br><span class="line"><span class="title function_">StackLength</span><span class="params">(S)</span> :返回栈S的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>  由于栈本身就是一个线性表，那么线性表的顺序存储和链式存储，对于栈来说，也是同样适用的。<br><br></p><h1 id="3-栈的顺序存储结构及实现">3. 栈的顺序存储结构及实现</h1><h2 id="3-1-栈的顺序存储结构">3.1 栈的顺序存储结构</h2><p>  既然栈是线性表的特例，那么<strong>栈的顺序存储</strong>其实也是线性表顺序存储的简化，我们简称为<strong>顺序栈</strong>。线性表是用数组来实现的，想想看，对于栈这种只能一头插入删除的线性表来说，用数组哪一端来作为栈顶和栈底比较好?<br>  对，没错，下标为0的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它作栈底。<br>  我们定义一个<code>top</code>变量来指示栈顶元素在数组中的位置，这<code>top</code>就如同中学物理学过的游标卡尺的游标，它可以来回移动，意味着栈顶的<code>top</code>可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为<code>StackSize</code>，则栈顶位置<code>top</code>必须小于<code>StackSize</code>。当栈存在一个元素时，<code>top</code>等于 0，因此通常把空栈的判定条件定为<code>top</code>等于 -1。<br>  来看栈的结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType; <span class="comment">/* SElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top;<span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>  若现在有一个栈，<code>StackSize</code>是 5，则栈普通情况、空栈和栈满的情况示意图如下图所示。<br><img src="https://img-blog.csdnimg.cn/8c0e3565e6b34eaf84d126997b2c42bc.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3-2-栈的顺序存储结构——进栈操作">3.2 栈的顺序存储结构——进栈操作</h2><p>  出栈<code>pop</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回oK;否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack *s,SElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=S-&gt;data[S-&gt;top];<span class="comment">/* 将要删除的栈顶元素赋值给e */</span></span><br><span class="line">S-&gt;top--;<span class="comment">/* 栈顶指针减一 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  两者没有涉及到任何循环语句，因此时间复杂度均是<strong>O(1)</strong>。<br><br></p><h1 id="4-两栈共享空间">4. 两栈共享空间</h1><p>  其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题。不过它有一个很大的缺陷，就是必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。对于一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于两个相同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来进行操作。<br>  打个比方，两个大学室友毕业同时到北京工作，开始时，他们觉得住了这么多年学校的集体宿舍，现在工作了一定要有自己的私密空间。于是他们都希望租房时能找到独住的一居室，可找来找去却发现，最便宜的一居室也要每月 1500 元，地段还不好，实在是承受不起，最终他俩还是合租了一套两居室， 一共2000元，各出一半，还不错。<br>  对于两个一居室，都有独立的卫生间和厨房，是私密了，但大部分空间的利用率却不高。而两居室，两个人各有卧室，还共享了客厅、厨房和卫生间，房间的利用率就显著提高，而且租房成本也大大下降了。<br>  同样的道理，如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。这又何必呢？我们完全可以用一个数组来存储两个栈，只不过需要点小技巧。<br>  我们的做法如下图，数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈为数组的末端，即下标为数组长度<code>n-1</code>处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br><img src="https://img-blog.csdnimg.cn/c967938416c84bc3b96d8a38a4186231.png#pic_center" alt="在这里插入图片描述"><br>  其实关键思路是：它们是在数组的两端，向中间靠拢。<code>top1</code>和<code>top2</code>是栈 1 和栈 2 的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。.<br>  从这里也就可以分析出来，栈 1 为空时，就是<code>top1</code>等于 -1 时；而当<code>top2</code>等于<code>n</code>时，即是栈 2 为空时，那什么时候栈满呢？<br>  想想极端的情况，若栈 2 是空栈，栈 1 的<code>top1</code>等于<code>n-1</code>时，就是栈 1 满了。反之，当栈 1 为空栈时，<code>top2</code>等于 0 时，为栈 2 满。但更多的情况，其实就是刚才说的，两个栈见面之时，也就是两个指针之间相差 1 时，即<code>top1+1==top2</code>为栈满。<br>  两栈共享空间的结构的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两栈共享空间结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top1;<span class="comment">/* 栈1栈顶指针 */</span></span><br><span class="line"><span class="type">int</span> top2;<span class="comment">/* 栈2栈顶指针 */</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure><p>  对于两栈共享空间的<code>push</code>方法，我们除了要插入元素值参数外，还需要有一个判断是栈 1 还是栈 2 的栈号参数<code>stackNumber</code>。插入元素的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqDoubleStack *S,SElemType e,<span class="type">int</span> stackNumber)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top1+<span class="number">1</span>==S-&gt;top2)<span class="comment">/* 栈已满，不能再push新元素了 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span> (stackNumber==<span class="number">1</span>)<span class="comment">/* 栈1有元素进栈 */</span></span><br><span class="line">S-&gt;data[++S-&gt;top1]=e;<span class="comment">/* 若是栈1则先top1+1后给数组元素赋值 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)<span class="comment">/* 栈2有元素进栈 */</span></span><br><span class="line">S-&gt;data[--S-&gt;top2]=e;<span class="comment">/* 若是栈2则先top2-1后给数组元素赋值 */</span></span><br><span class="line"><span class="keyword">return</span> OK:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  因为在开始时已经判断了是否有栈满的情况，所以后面的<code>top1+1</code>或<code>top2-1</code>是不担心溢出问题的。<br>  对于两栈共享空间的<code>pop</code>方法，参数就只是判断栈 1 栈 2 的参数<code>stackNumber</code>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK;否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqDoubleStack *s,SElemType *e,<span class="type">int</span> stackNumber)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stackNumber==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top1==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/* 说明栈1已经是空栈，溢出 */</span></span><br><span class="line">*e=s-&gt;data[S-&gt;top1--];<span class="comment">/* 将栈1的栈顶元素出栈 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S-&gt;top2==MAXSIZE)</span><br><span class="line"><span class="keyword">return</span> ERROR:<span class="comment">/* 说明栈2已经是空栈，溢出 */</span></span><br><span class="line">*e=S-&gt;data[S-&gt;top2++];<span class="comment">/* 将栈2的栈顶元素出栈 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK:</span><br></pre></td></tr></table></figure><p>  事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。就像买卖股票一样， 你买入时，一定是有一个你不知道的人在做卖出操作。有人赚钱，就一定是有人赔钱。这样使用两栈共享空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而溢出了。<br>  当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不相同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂，大家要注意这个前提。<br><br></p><h1 id="5-栈的链式存储结构及实现">5. 栈的链式存储结构及实现</h1><h2 id="5-1-栈的链式存储结构">5.1 栈的链式存储结构</h2><p>  讲完了栈的顺序存储结构，我们现在来看看<font color=#6495ED>栈的链式存储结构，简称为链栈。</font><br>  想想看，栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢？所以比较好的办法是把栈顶放在单链表的头部（如下图所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。<br><img src="https://img-blog.csdnimg.cn/de22bc9064da4c148c5afde1f0f0ab92.png#pic_center" alt="在这里插入图片描述"><br>  对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是否溢出的问题。<br>  但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是<code>top=NULL</code>的时候。<br>  链栈的结构代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链栈结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linkstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LinkstackPtr top;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">&#125;Linkstack;</span><br></pre></td></tr></table></figure><p>  链栈的操作绝大部分都和单链表类似，只是在插入和删除上，特殊一些。</p><h2 id="5-2-栈的链式存储结构——进栈操作">5.2 栈的链式存储结构——进栈操作</h2><p>  对于链栈的进栈<code>push</code>操作，假设元素值为<code>e</code>的新结点是<code>s</code>，<code>top </code>为栈顶指针，如下所示：<br><img src="https://img-blog.csdnimg.cn/9a73255ffdc84afc91743b158db53aca.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(Linkstack *S,SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">LinkstackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=S-&gt;top;<span class="comment">/* 把当前的栈頂元素赋值给新结点的直接后继，如图中① */</span></span><br><span class="line">S-&gt;top=s;<span class="comment">/* 将新的结点s赋值给栈顶指针，如图中② */</span></span><br><span class="line">S-&gt;count++:</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-栈的链式存储结构——出栈操作">5.3 栈的链式存储结构——出栈操作</h2><p>  至于链栈的出栈<code>pop</code>操作，也是很简单的三句操作。假设变量<code>p</code>用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放<code>p</code>即可，如下所示。<img src="https://img-blog.csdnimg.cn/2eeb04696ade4446942cc1e581124286.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK;否则返回ERROR */</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">LinkStackPtr p;</span><br><span class="line"><span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=S-&gt;top-&gt;data;</span><br><span class="line">p=S-&gt;top;<span class="comment">/* 将栈顶结点赋值给p，如图③ */</span></span><br><span class="line">S-&gt;top=S-&gt;top-&gt;next;<span class="comment">/* 使得栈顶指针下移一位，指向后一结点，如图④ */</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">/* 释放结点p */</span></span><br><span class="line">S-&gt;count--:</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  链栈的进栈<code>push</code>和出栈<code>pop</code>操作都很简单，没有任何循环操作，时间复杂度均为<strong>O(1)</strong>。<br>  对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为O(1)。 对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，<font color=#6495ED><strong>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一一些。</strong></font><br><br></p><h1 id="6-栈的作用">6. 栈的作用</h1><p>  有的人可能会觉得，用数组或链表直接实现功能不就行了吗？干嘛要引入栈这样的数据结构呢？<br>  其实这和我们明明有两只脚可以走路，干吗还要乘汽车、火车、飞机一样。理论上，陆地上的任何地方，你都是可以靠双脚走到的，可那需要多少时间和精力呢？我们更关注的是到达而不是如何去的过程。<br>  <font color=#6495ED><strong>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。</strong></font>而像线性表顺序存储结构用到的数组，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。<br>  所以现在的许多高级语言，比如<code>Java</code>、<code>C#</code>等都有对栈结构的封装，你可以不用关注它的实现细节，就可以直接使用<code>Stack</code>的<code>push</code>和<code>pop</code>方法，非常方便。<br><br></p><h1 id="7-栈的应用——递归">7. 栈的应用——递归</h1><p>  栈有一个很重要的应用：在程序设计语言中实现了递归。那么什么是递归呢？<br>  当你往镜子前面一站，镜子里面就有一个你的像。 但你试过两面镜子起照吗？如果<code>A</code>、<code>B</code>两面镜子相互面对面放着，你往中间一站，嘿，两面镜子里都有你的千百个“化身”。为什么会有这么奇妙的现象呢？原来，<code>A</code>镜子里有<code>B</code>镜子的像，<code>B</code>镜子里也有<code>A</code>镜子的像，这样反反复复，就会产生一连串的“像中像”。这是一种递归现象。<br>  我们先来看一个经典的递归例子：斐波那契数列（Fibonacci）。 为了说明这个数列，这位斐老还举了一个很形象的例子。</p><h2 id="7-1-斐波那契数列的实现">7.1 斐波那契数列的实现</h2><p>  说如果兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设所有兔都不死，那么一年以后可以繁殖多少对兔子呢？<br>  我们拿新出生的一对小兔子分析一下：第一个月小兔子没有繁殖能力，所以还是一对；两个月后，生下一对小兔子数共有两对；三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对……以此类推可以列出下表。</p><table><tr align=center><th>所经过的月数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr><tr align=center><td>兔子对数</td><td>1</td><td>1</td><td>2</td><td>3</td><td>5</td><td>8</td><td>13</td><td>21</td><td>34</td><td>55</td><td>89</td><td>144</td></tr></table>&emsp;&emsp;表中数字 1，1，2，3，5，8，13，.....… 构成了一个序列。这个数列有个十分明显的特点，那就是：前面相邻两项之和，构成了后一项，如下图所示。<p><img src="https://img-blog.csdnimg.cn/2ddcec021101470ba8a20582898f075e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  可以发现，编号①的一对兔子经过 6 个月就变成 8 对兔子了。如果我们用数学函数来定义就是：<br><img src="https://img-blog.csdnimg.cn/500e00bb37154da5a81f6881301e1e18.png#pic_center" alt="在这里插入图片描述"><br>  先考虑一下，如果我们要实现这样的数列用常规的迭代的办法如何实现？假设我们需要打印出前 40 位的斐波那契数列数。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">40</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>;i &lt; <span class="number">40</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = a[i<span class="number">-1</span>] + a[i<span class="number">-2</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码很简单，几乎不用做什么解释。但其实我们的代码，如果用递归来实现，还可以更简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契的递归函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fbi</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( i &lt; <span class="number">2</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> Fbi(i<span class="number">-1</span>)+Fbi(i<span class="number">-2</span>);<span class="comment">/* 这里Fbi就是函数自己，等于在调用自己 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;递归显示斐波那契数列：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">40</span>;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Fbi(i));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  函数怎么可以自已调用自己？听起来有些难以理解，不过你可以不要把一个递归函数中调用自己的函数看作是在调用自己，而就当它是在调另-一个函数。只不过，这个函数和自己长得一样而已。<br>  我们来模拟代码中的<code>Fbi(i)</code>函数当<code>i= 5</code>的执行过程，如下图所示。<br><img src="https://img-blog.csdnimg.cn/0df9a289bd2f406dbf82f31bbe8e79f7.png#pic_center" alt="在这里插入图片描述"></p><h2 id="7-2-递归的定义">7.2 递归的定义</h2><p>  在高级语言中，调用自己和其他函数并没有本质的不同。我们<font color=#6495ED><strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。</strong></font><br>  当然，写递归程序最怕的就是陷入永不结束的无穷递归中，所以，<font color=#6495ED><strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</strong></font>比如刚才的例子，总有一次递归会使得<code>i&lt;2</code>的，这样就可以执行<code>return i</code>的语句而不用继续递归了。<br>  对比了两种实现斐波那契的代码。迭代和递归的区别是：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。<br>  那么我们讲了这么多递归的内容，和栈有什么关系呢？这得从计算机系统的内部说起。<br>  前面我们已经看到递归是如何执行它的前行和退回阶段的。递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。<br>  这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构，因此，编译器使用栈实现递归就没什么好惊讶的了。<br>  简单的说，就是在前行阶段，对于每一层递归， 函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。<br>  当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。<br><br></p><h1 id="8-栈的应用——四则运算表达式求值">8. 栈的应用——四则运算表达式求值</h1><h2 id="8-1-后缀（逆波兰）表示法的定义">8.1 后缀（逆波兰）表示法的定义</h2><p>  栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求值。<br>  我们小学学数学的时候，有一句话是老师反复强调的，“先乘除，后加减，从左算到右，先括号内后括号外”。这个大家都不陌生。我记得我小时候，天天做这种加减乘除的数学作业，很烦，于是就偷偷拿了老爸的计算器来帮着算答案，对于单纯的两个数的加减乘除，的确是省心不少，我也因此潇酒了一两年。 可后来要求要加减乘除，甚至还有带有大中小括号的四则运算，我发现老爸那个简陋的计算器不好使了。比如<code>9+(3-1)×3+10÷2</code>，这是一个非常简单的题目，心算也可以很快算出是 20。可就这么简单的题目，计算器却不能在一次输入后马上得出结果，很是不方便。<br>  当然，后来出的计算器就高级多了，它引入了四则运算表达式的概念，也可以输入括号了，所以现在的 00 后的小朋友们，更加可以偷懒、抄近路做数学作业了。<br>  那么在新式计算器中或者计算机中，它是如何实现的呢？如果让你用<code>C</code>语言或其他高级语言实现对数学表达式的求值，你打算如何做?<br>  这里面的困难就在于乘除在加减的后面，却要先运算，而加入了括号后，就变得更加复杂。不知道该如何处理。<br>  但仔细观察后发现，括号都是成对出现的，有左括号就一定会有右括号，对于多重括号，最终也是完全嵌套匹配的。这用栈结构正好合适，只有碰到左括号，就将此左括号进栈，不管表达式有多少重括号，反正遇到左括号就进栈，而后面出现右括号时，就让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈的结果。<br>  但对于四则运算，括号也只是当中的一部分，先乘除后加减使得问题依然复杂，如何有效地处理它们呢？<br>  20 世纪 50 年代，波兰逻辑学家 Jan tukasiewicz，当时也和我们现在一样，困惑于如何才可以搞定这个四则运算，不知道他是否也像牛顿被苹果砸到头而想到万有引力的原理，或者还是阿基米德在浴缸中洗澡时想到判断皇冠是否纯金的办法，总之他也是灵感突现，想到了<font color=#6495ED><strong>一种不需要括号的后缀表达法，我们也把它称为逆波兰（Reverse Polish Noation, RPN）表示。</strong></font>我想可能是他的名字太复杂了，所以后人只用他的国籍而不是姓名来命名，实在可惜。这也告诉我们，想要流芳百世，名字还要起得朗朗上口才行。这种后缀表示法，是表达式的一种新的显示方式，非常巧妙地解决了程序实现四则运算的难题。<br>  我们先来看看，对于“9+(3-1)×3+10÷2&quot;，要用后缀表示法应该是什么样子。<br>  正常数学表达式：9+(3-1)×3+10÷2<br>  后缀表达式：9 3 1-3 * + 10 2 / +<br>  “9 3 1-3 * + 10 2 / +”这样的表达式成为<font color=#8A2BE2><strong>后缀表达式</strong></font>，叫后缀的原因在于<font color=#6495ED><strong>所有的符号都是在要运算数字的后面出现。</strong></font>显然，这里没有了括号。对于从来没有接触过后缀表达式的人来讲，这样的表述是很难受的。不过你不喜欢，有“人”喜欢，比如我们聪明的计算机。</p><h2 id="8-2-后缀表达式的计算结果">8.2 后缀表达式的计算结果</h2><p>  为了解释后缀表达式的好处，我们先来看看，计算机如何应用后缀表达式计算出最终的结果 20 的。<br>  后缀表达式：9 3 1-3 * + 10 2 / +<br>  规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><ol><li>初始化一个空栈。此栈用来对要运算的数字进出使用。</li><li>后缀表达式中前三个都是数字，所以 9、3、1 进栈，如下图所示。<br><img src="https://img-blog.csdnimg.cn/492727172cbd4bef947be82333be8b33.png" alt="在这里插入图片描述"></li><li>接下来是 “-”，所以将栈中的 1 出栈作为减数，3 出栈作为被减数，并运算 3-1 得到 2，再将 2 进栈。</li><li>接着是数字 3 进栈，如下图所示。<br><img src="https://img-blog.csdnimg.cn/5e00576bde134e56a5026238bab8546d.png" alt="在这里插入图片描述"></li><li>后面是 “*”，也就意味着栈中 3 和 2 出栈，2 与 3 相乘，得到 6，并将 6 进栈。</li><li>下面是 “+”，所以栈中 6 和 9 出栈，9 与 6 相加，得到 15，将 15 进栈，如下图所示。<br><img src="https://img-blog.csdnimg.cn/7c10d8533d354b0bb9bb8f562bb46059.png" alt="在这里插入图片描述"></li><li>接着是 10 与 2 两数字进栈。</li><li>接下来是符号 “/”，因此，栈顶的 2 与 10 出栈，10 与 2 相除，得到 5，将5 进栈，如下图所示。<br><img src="https://img-blog.csdnimg.cn/223c593f42c7472a9e311aaf604385dc.png" alt="在这里插入图片描述"></li><li>最后一个是符号 “+”，所以 15 与 5 出栈并相加，得到 20，将 20 进栈。</li><li>结果是 20 出栈，栈变为空，如下图所示。<br><img src="https://img-blog.csdnimg.cn/f4401013ca394a7e8b1f2ca92773d122.png" alt="在这里插入图片描述"></li></ol><p>  果然，后缀表达法可以很顺利解决计算的问题。那么现在应该都有同样的疑问，就是这个后缀表达式 “9 3 1-3 * + 10 2 / +” 是怎么出来的？这个问题不搞清楚，等于没有解决。所以下面，我们就来推导如何让 “9+(3-1)×3+10÷2”转化为 “9 3 1-3 * + 10 2 / +”。</p><h2 id="8-3-中缀表达式转后缀表达式">8.3 中缀表达式转后缀表达式</h2><p>  我们把平时所用的<font color=#6495ED><strong>标准四则运算表达式</strong></font>，即 “9+(3-1)×3+10÷2” 叫做中缀表达式。因为所有的运算符号都在两数字的中间，现在我们的问题就是中缀到后缀的转化。<br>  中缀表达式 “9+(3-1)×3+10÷2&quot; 转化为后缀表达式“9 3 1-3 * + 10 2 / +”。<br>  规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p><ol><li><p>初始化一空栈， 用来对符号进出栈使用。</p></li><li><p>第一个字符是数字 9，输出 9，后面是符号 “+”，进栈。如下图所示。<br><img src="https://img-blog.csdnimg.cn/c0e16c56a68942738b49991fd70fd897.png" alt="在这里插入图片描述"></p></li><li><p>第三个字符是 “(&quot;，依然是符号，因其只是左括号，还未配对，故进栈。</p></li><li><p>第四个字符是数字 3，输出，总表达式为 9 3，接着是“-&quot;，进栈。如下图所示。<br><img src="https://img-blog.csdnimg.cn/84f38f9ad4be4884a1b6fbe2fc52ec8f.png" alt="在这里插入图片描述"></p></li><li><p>接下来是数字 1，输出，总表达式为 9 3 1，后面是符号 “)”，此时，我们需要去匹配此前的 “(“，所以栈顶依次出栈，并输出，直到 “(” 出栈为止。此时左括号上方只有 “-”，因此输出 “-”。总的输出表达式为 9 3 1-。</p></li><li><p>紧接着是符号 “×”，因为此时的栈顶符号为 “+”，优先级低于 “×”，因此不能输出，“*” 进栈。接着是数字 3，输出，总的表达式为 9 3 1 - 3》如下图所示。<br><img src="https://img-blog.csdnimg.cn/bb6d80002d17434da64a2351656d8a16.png" alt="在这里插入图片描述"></p></li><li><p>之后是符号 “+'，此时当前栈顶元素 “*” 比这个 “+” 的优先级高，因此栈中元素出栈并输出（没有比 “+” 号更低的优先级，所以全部出栈），总输出表达式为 9 3 1-3 * +。然后将当前这个符号 “+” 进栈。也就是说，前 6 张图的栈底的 “+” 是指中缀表达式中开头的 9 后面那个 “+”，而下图中左图中的栈底（也是栈顶）的 “+” 是指 “9+(3-1)×3+” 中的最后一个 “+”。</p></li><li><p>紧接着数字 10，输出，总表达式变为 9 3 1-3 * + 10。后是符号 “÷”，所以“/” 进栈。如下图中右图所示。<br><img src="https://img-blog.csdnimg.cn/1fe6230022d1458b92b3603be23a05a3.png" alt="在这里插入图片描述"></p></li><li><p>最后一个数字 2，输出，总的表达式为 9 3 1 - 3 * + 10 2。</p></li><li><p>因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为 9 3 1 - 3 * + 10 2 / +。如下图所示。<br><img src="https://img-blog.csdnimg.cn/3b5700d8f4b84d81be9e94118fd95e87.png" alt="在这里插入图片描述"></p></li></ol><p>  从刚才的推导中你会发现，要想让计算机具有处理我们通常的标准（中缀）表达式的能力，最重要的就是两步：</p><ol><li>将中缀表达式转化为后缀表达式（栈用来进出运算的符号）。</li><li>将后缀表达式进行运算得出结果（栈用来进出运算的数字）。</li></ol><p>  整个过程，都充分利用了栈的后进先出特性来处理，理解好它其实也就理解好了栈这个数据结构。<br><br></p><h1 id="9-总结">9. 总结</h1><p>  栈就是特殊的线性表，只不过对插入和删除操作做了限制。<br>  栈（stack）是限定仅在表尾进行插入和删除操作的线性表。<br>  它可以用线性表的顺序存储结构来实现，但存在着顺序存储的一些弊端。如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>  它也可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法》（五）- 链表详解</title>
      <link href="/2021/10/18/algorithm_5/"/>
      <url>/2021/10/18/algorithm_5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p><h1 id="1-线性表链式存储结构">1. 线性表链式存储结构</h1><h2 id="1-1-链表的定义">1.1 链表的定义</h2><p>  线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。<br>  以前在顺序结构中，每个数据元素只需要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。<br>  因此，为了表示每个数据元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与其直接后继数据元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub><msub><mrow></mrow><mo>+</mo></msub><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{_i}{_+}{_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.52em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 之间的逻辑关系，对数据元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为<strong>数据域</strong>，把存储直接后继位置的域称为<strong>指针域</strong>。指针域中存储的信息称做<strong>指针</strong>或<strong>链</strong>。这两部分信息组成数据元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的存储映像，称为<strong>结点</strong>（Node）。<br>  <strong>n个结点（a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的存储映像）链结成一个链表，即为线性表(a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，…，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)的链式存储结构</strong>，因为此链表的每个结点中只包含一个指针域，所以叫做<strong>单链表</strong>。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。<br><img src="https://img-blog.csdnimg.cn/6da8e56cc42c468897cd8bb1fbb17bc4.png#pic_center" alt="在这里插入图片描述"><br>  对于线性表来说，总得有个头有个尾，链表也不例外。我们把<strong>链表中第一个结点的存储位置叫做头指针</strong>，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。想象一下，最后一个结点，它的指针指向哪里？<br>  最后一个，当然就意味着直接后继不存在了，所以我们规定，线性链表的最后一个结点指针为“空”（通常用<code>NULL</code>或<code>“^”</code>符号表示，如下图所示）。<br><img src="https://img-blog.csdnimg.cn/ac0e76a5c9d74c0fa1d557a43203b358.png#pic_center" alt="在这里插入图片描述"><br>  有时，我们为了更加方便地对链表进行操作，会<strong>在单链表的第一个结点前附设一个结点，称为头结点</strong>。头结点的数据域可以不存储任何信息，谁叫它是第一个呢，有这个特权。也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针，如下图所示。<br><img src="https://img-blog.csdnimg.cn/a6b4c896735444fca1450c3cda9193c9.png#pic_center" alt="在这里插入图片描述"></p><h2 id="1-2-头指针与头结点的异同">1.2 头指针与头结点的异同</h2><p><strong>头指针：</strong></p><ul><li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li><li>头指针具有标识作用，所以常用头指针冠以链表的名字</li><li>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</li></ul><p><strong>头结点：</strong></p><ul><li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</li><li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li><li>头结点不一定是链表必须要素</li></ul><h2 id="1-3-代码描述">1.3 代码描述</h2><p>  若线性表为空，则头结点的指针域为“空”，如下图：<br><img src="https://img-blog.csdnimg.cn/a3e6bb83ecbd41ff9954217fb4eec94a.png#pic_center" alt="在这里插入图片描述"><br>  这里我们大概地用图示表达了内存中单链表的存储状态。看着满图的省略号 “……”，你就知道是多么不方便。而我们真正关心的：它是在内存中的实际位置吗？不是的，这只是它所表示的线性表中的数据元素及数据元素之间的逻辑关系。所以我们改用更方便的存储示意图来表示单链表，如下图所示。<br><img src="https://img-blog.csdnimg.cn/73bd49e4b129461a9159e46c7064f6fe.png#pic_center" alt="在这里插入图片描述"><br>  若带有头结点的单链表，则如下图所示：<br><img src="https://img-blog.csdnimg.cn/368e7e6ef940468a9f790839f39c20e0.png#pic_center" alt="在这里插入图片描述"><br>  空链表如下图所示：<br><img src="https://img-blog.csdnimg.cn/2f199735ec6e493794af61d3f4d851f2.png#pic_center" alt="在这里插入图片描述"><br>  单链表中，我们在C语言中可用结构指针来描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性表的单链表存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span><span class="comment">/* 定义LinkList */</span> </span><br></pre></td></tr></table></figure><p>  从这个结构定义中，我们也就知道，<strong>结点由存放数据元素的数据域存放后继结点地址的指针域组成</strong>。假设<code>p</code>是指向线性表第<code>i</code>个元素的指针，则该结点 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的数据域我们可以用<code>p-&gt;data</code>来表示，<code>p-&gt;data</code>的值是一个数据元素，结点 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的指针域可以用<code>p-&gt;next</code>来表示，<code>p-&gt;next</code>的值是一个指针。<code>p-&gt;next</code>指向谁呢？当然是指向第<code>i+1</code>个元素，即指向 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub><msub><mrow></mrow><mo>+</mo></msub><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{_i}{_+}{_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.52em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 的指针。也就是说，如果<code>p-&gt;data</code>等于 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么<code>p-&gt;next&gt;data</code>等于 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（如下图所示）<br><img src="https://img-blog.csdnimg.cn/21ad8ee3367e4ee985d5e7ff4bd806be.png#pic_center" alt="在这里插入图片描述"><br><br></p><h1 id="2-单链表的读取">2. 单链表的读取</h1><p>  在线性表的顺序存储结构中，计算任意一个元素的存储位置是很容易的。但在单链表中，由于第<code>i</code>个元素到底在哪？没办法一开始就知道，必须得从头开始找。因此，对于单链表实现获取第<code>i</code>个元素的数据的操作<code>GetElem</code>，在算法上，相对要麻烦一些。<br>  获得链表第<code>i</code>个数据的算法思路：</p><ol><li>声明一个结点<code>p</code>指向链表第一个结点，初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让<code>p</code>的指针向后移动，不断指向下一结点，<code>j</code>累加<code>1</code>；</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个元素不存在；</li><li>否则查找成功，返回结点<code>p</code>的数据。</li></ol><p>  实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果：用e返回L中第i个数据元素的值 */</span></span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line">LinkList p;<span class="comment">/* 声明一结点p */</span></span><br><span class="line">p = L-&gt;next;<span class="comment">/* 让p指向链表L的第一个结点 */</span></span><br><span class="line">j = <span class="number">1</span>;<span class="comment">/* j为计数器 */</span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j&lt;<span class="number">1</span>)<span class="comment">/* p不为空或者计数器j还没有等于i时，循环继续 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;<span class="comment">/* 让p指向下一个结点 */</span></span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !p || j&gt;i)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/* 第i个元素不存在 */</span></span><br><span class="line">*e = p-&gt;data;<span class="comment">/* 取第i个元素的数据 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  说白了，就是从头开始找，直到第<code>i</code>个元素为止。由于这个算法的时间复杂度取决于<code>i</code>的位置，当<code>i=1</code>时，则不需遍历，第一个就取出数据了，而当<code>i=n</code>时则遍历<code>n-1</code>次才可以。因此最坏情况的时间复杂度是<strong>O(n)</strong>。<br>  由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此也就不方便使用<code>for</code>来控制循环。其主要核心思想就是“工作指针后移&quot;，这其实也是很多算法的常用技术。<br><br></p><h1 id="3-单链表的插入与删除">3. 单链表的插入与删除</h1><h2 id="3-1-单链表的插入">3.1 单链表的插入</h2><p>  假设存储元素<code>e</code>的结点为<code>s</code>，要实现结点<code>p</code>、<code>p-&gt;next</code>和<code>s</code>之间逻辑关系的变化，只需将结点<code>s</code>插入到结点<code>p</code>和<code>p-&gt;next</code>之间即可。可如何插入呢 ?<br><img src="https://img-blog.csdnimg.cn/98b4a7349dde4e8fb540200f69d28ef4.png#pic_center" alt="在这里插入图片描述"><br>  根本用不着惊动其他结点，只需要让<code>s-&gt;next</code>和<code>p-&gt;next</code>的指针做一点改变即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next=p-&gt;next;<span class="comment">/* 将p的后继节点赋值给s的后继 */</span></span><br><span class="line">p-&gt;next=s;<span class="comment">/* 将s赋值给p的后继 */</span></span><br></pre></td></tr></table></figure><p>  解读这两句代码，也就是说让<code>p</code>的后继结点改成<code>s</code>的后继结点，再把结点<code>s</code>变成<code>p</code>的后继结点。<br><img src="https://img-blog.csdnimg.cn/e48912fa33854f4e9851cb053127bf14.png#pic_center" alt="在这里插入图片描述"><br>  考虑一下，这两句的顺序可不可以交换?<br>  如果先<code>p-&gt;next=s</code>； 再<code>s-&gt;next=p-&gt;next</code>；会怎么样？因为此时第一句会将·p-&gt;nex·t给覆盖成<code>s</code>的地址了。那么<code>s-&gt;next=p-&gt;next</code>，其实就等于<code>s-&gt;next=s</code>，这样真正的拥有 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub><msub><mrow></mrow><mo>+</mo></msub><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{_i}{_+}{_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.52em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 数据元素的结点就没了上级。这样的插入操作就是失败的，造成了临场掉链子的尴尬局面。所以这两句是无论如何不能反的，这点初学者一定要注意。<br>  插入结点s后，链表如下图所示。<br><img src="https://img-blog.csdnimg.cn/b44a582e66fd44888b10f697d3414843.png#pic_center" alt="在这里插入图片描述"><br>  对于单链表的表头和表尾的特殊情况，操作是相同的，如下图所示。<br><img src="https://img-blog.csdnimg.cn/c176d4ea5b594a2887cceab2ab491d2e.png#pic_center" alt="在这里插入图片描述"><br>  单链表第<code>i</code>个数据插入结点的算法思路：</p><ol><li>声明一结点<code>p</code>指向链表第-一个结点， 初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时， 就遍历链表，让<code>p</code>的指针向后移动，不断指向下一结点，<code>j</code>累加<code>1</code>；</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个元素不存在；</li><li>否则查找成功，在系统中生成-一个空结点<code>s</code>；</li><li>将数据元素<code>e</code>赋值给<code>s-&gt;data</code>；</li><li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next</code>；<code>p-&gt;next=s</code>；</li><li>返回成功。</li></ol><p>  实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件:链式线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果:在L中第i个位置之前插入新的数据元素e. L的长度加1 */</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line">LinkList p,s;</span><br><span class="line">P = *L;</span><br><span class="line">」= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; j &lt; <span class="number">1</span>)<span class="comment">/* 寻找第i个结点 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || j&gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/* 第i个元素不存在 */</span></span><br><span class="line"></span><br><span class="line">s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">/* 生成新结点(C语言标准函数) */</span></span><br><span class="line">s-&gt;data = e;</span><br><span class="line">S-&gt;next = p-&gt;next;<span class="comment">/* 将p的后继结点赋值给s的后继 */</span></span><br><span class="line">p-&gt;next = s;<span class="comment">/* 将s赋值给p的后继 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这段算法代码中，我们用到了C语言的<code>malloc</code>标准函数，它的作用就是生成一个新的结点，其类型与<code>Node</code>是一样的， 其实质就是在内存中找了一小块空地， 准备用来存放数据<code>e</code>的<code>s</code>结点。</p><h2 id="3-2-单链表的删除">3.2 单链表的删除</h2><p>  设存储元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的结点为<code>q</code>，要实现将结点<code>q</code>删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可，如图下图所示。<br><img src="https://img-blog.csdnimg.cn/941e9b3d85224b799182aaefc88ea555.png#pic_center" alt="在这里插入图片描述"><br>  我们所要做的，实际上就是一步，<code>p-&gt;next=p-&gt;next-&gt;next</code>，用<code>q</code>来取代<code>p-&gt;next</code>，即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;<span class="comment">/* 将q的后继赋值给p的后继 */</span></span><br></pre></td></tr></table></figure><p>  解读这两句代码，也就是说把<code>p</code>的后继结点改成<code>p</code>的后继的后继结点。打个形象的比方：本来是爸爸左手牵着妈妈的手，右手牵着宝宝的手在马路边散步。突然迎面走来一美女，爸爸一下子看呆了 ，此情景被妈妈逮个正着，于是她生气地甩开牵着的爸爸的手，绕过他，扯开父子俩，拉起宝宝的左手就快步朝前走去。此时妈妈是<code>p</code>结点，妈妈的后继是爸爸<code>p-&gt;next</code>，也可以叫<code>q</code>结点，妈妈的后继的后继是儿子<code>p-&gt;next-&gt;next</code>，即<code>q-&gt;next</code>。 当妈妈去牵儿子的手时，这个爸爸就已经与母子俩没有牵手联系了，如下图所示。<br><img src="https://img-blog.csdnimg.cn/58d6d3c727704eb3a28aeafd39cee541.png#pic_center" alt="在这里插入图片描述"><br>  单链表第<code>i</code>个数据删除结点的算法思路：</p><ol><li>声明一指针<code>p</code>指向链表头结点，初始化<code>j</code>从<code>1</code>开始；</li><li>当<code>j&lt;i</code>时，就遍历链表，让<code>p</code>的指针向后移动，不断指向下一个结点，<code>j</code>累加<code>1</code>；<br>1;</li><li>若到链表末尾<code>p</code>为空，则说明第<code>i</code>个结点不存在；</li><li>否则查找成功，将欲删除的结点<code>p-&gt;next</code>赋值给<code>q</code>；</li><li>单链表的删除标准语句<code>p-&gt;next=q-&gt;next</code>；</li><li>将<code>q</code>结点中的数据赋值给<code>e</code>，作为返回；</li><li>释放<code>q</code>结点；</li><li>返回成功。</li></ol><p>  实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件:链式线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果:删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p = *L;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; j &lt; i)<span class="comment">/* 遍历寻找第i个元素 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || j &gt; i)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">/* 第i个元素不存在 */</span></span><br><span class="line">q = p-&gt;next; .</span><br><span class="line">p-&gt;next = q-&gt;next;<span class="comment">/* 将q的后继贼值给p的后继 */</span></span><br><span class="line">*e = q-&gt;data;<span class="comment">/* 将q结点中的数据給e */</span></span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">/* 让系统回收此结点，释放内存 */</span></span><br><span class="line"><span class="keyword">return</span> OK:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段算法代码里，我们又用到了另一个C语言的标准函数<code>free</code>。它的作用就是让系统回收一个<code>Node</code>结点，释放内存。</p><p>  分析一下刚才讲解的单链表插入和删除算法，可以发现，它们其实都是由两部分组成：第一部分就是遍 历查找第<code>i</code>个元素；第二部分就是插入和删除元素。<br>  从整个算法来说，我们很容易推导出：它们的时间复杂度都是<strong>O(N)</strong>。如果我们不知道第<code>i</code>个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但如果我们希望从第<code>i</code>个位置，插入<code>10</code>个元素，对于顺序存储结构意味着，每一次插入都需要移动<code>n-i</code>个元素，每次都是<strong>O(n)</strong>。 而单链表，我们只需要在第一次时， 找到第<code>i</code>个位置的指针,此时为<strong>O(n)</strong>，接下来只是简单地通过赋值移动指针而已，时间复杂度都是<strong>O(1)</strong>。显然，<strong>对于插入或删除数据越频繁的操作，单链表的效率优势就越明显</strong>。<br><br></p><h1 id="4-单链表的整表创建">4. 单链表的整表创建</h1><p>  顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表和顺序存储结构就不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对于每个链表来说，它所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。<br>  所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表。<br>  单链表整表创建的算法思路：</p><ol><li>声明一指针<code>p</code>和计数器变量<code>i</code>；</li><li>初始化一空链表<code>L</code>；</li><li>让<code>L</code>的头结点的指针指向<code>NULL</code>，即建立一个带头结点的单链表。</li><li>循环：<br>①生成一新结点赋值给<code>p</code>；<br>②随机生成一数字赋值给<code>p</code>的数据域<code>p-&gt;data</code>；<br>③将<code>p</code>插入到头结点与前一新结点之间。</li></ol><p>实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 随机产生n个元素的值，建立带表头姑点的单链线性表L(头插法) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateListHead</span><span class="params">(LinkList *L,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>))<span class="comment">/* 初始化随机数种子 */</span></span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))</span><br><span class="line">(*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)<span class="comment">/* 先建立一个带头结点的单链表 */</span></span><br><span class="line">&#123;</span><br><span class="line">p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))<span class="comment">/* 生成新结点 */</span></span><br><span class="line">p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>;<span class="comment">/* 随机生成100以内的数字 */</span></span><br><span class="line">p-&gt;next = (*L)-&gt;next;</span><br><span class="line">(*L)-&gt;next = p;<span class="comment">/* 插入到表头 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段算法代码里，用的其实是插队的办法，就是始终让新结点在第一的位置。我也可以把这种算法简称为头插法。<br><img src="https://img-blog.csdnimg.cn/f56ade1f13ae4449ae938fc23216eff2.png#pic_center" alt="在这里插入图片描述"><br>  事实上，我们还可以不这样干，为什么不把新结点都放到最后呢，这才是排队时的正常思维，所谓的先来后到。我们把每次新结点都插在终端结点的后面，这种算法称之为尾插法。<br>  实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 随机产生n个元素的值，建立带表头结点的单链线性表L(尾插法) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateListTail</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">LinkList p,r;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">srand(time(<span class="number">0</span>));<span class="comment">/* 初始化随机数种子 */</span></span><br><span class="line">*L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">/* L为整个线性表 */</span></span><br><span class="line">r=*L;<span class="comment">/* r为指向尾部的结点 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; <span class="number">1</span>++)</span><br><span class="line">&#123;</span><br><span class="line">P = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">/* 生成新结点 */</span></span><br><span class="line">p-&gt;data = rand()%<span class="number">100</span>+<span class="number">1</span>;<span class="comment">/* 随机生成100以内的数字 */</span></span><br><span class="line">r-&gt;next=p;<span class="comment">/* 将表尾终端结点的指针指向新结点 */</span></span><br><span class="line">r = p;<span class="comment">/* 将当前的新结点定义为表尾终端结点 */</span></span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;<span class="comment">/* 表示当前链表结束 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意<code>L</code>与<code>r</code>的关系，<code>L</code>是指整个单链表，而<code>r</code>是指向尾结点的变量，<code>r</code>会随着循环不断地变化结点，而<code>L</code>则是随着循环增长为一个多结点的链表。<br>  这里需解释一下，<code>r-&gt;next=p;</code>的意思， 其实就是将刚才的表尾终端结点<code>r</code>的指针指向新结点<code>p</code>，如下图所示，当中①位置的连线就是表示这个意思。<br><img src="https://img-blog.csdnimg.cn/1e716c10e466403db5ae9cbdfdcbdd62.png#pic_center" alt="在这里插入图片描述">  <code>r-&gt;next=p;</code>这一句 应该还好理解，很多人不理解的就是后面这一句<code>r=p;</code>是什么意思，看下图。<br><img src="https://img-blog.csdnimg.cn/3abc18d8fccf4cdfa7db0a0bbd84029a.png#pic_center" alt="在这里插入图片描述"><br>  它的意思，就是本来<code>r</code>是在 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub><msub><mrow></mrow><mo>−</mo></msub><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">{_i}{_-}{_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.52em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 元素的结点，可现在它已经不是最后的结点了，现在最后的结点是 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，所以应该要让将<code>p</code>结点这个最后的结点赋值给<code>r</code>。此时<code>r</code>又是最终的尾结点了。<br>  循环结束后，那么应该让这个结点的指针域置空，因此有了<code>r-&gt;next=NULL;</code>，以便以后遍历时可以确认其是尾部。<br><br></p><h1 id="5-单链表的整表删除">5. 单链表的整表删除</h1><p>  当我们不打算使用这个单链表时，我们需要把它销毁，其实也就是在内存中将它释放掉，以便于留出空间给其他程序或软件使用。<br>  单链表整表删除的算法思路如下：</p><ol><li>声明一指针p和q；</li><li>将第一个结点赋值给p；</li><li>循环：<br>①将下一结点赋值给<code>q</code>；<br>②释放<code>p</code>；<br>③将<code>q</code>赋值给<code>p</code>。</li></ol><p>  实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件:链式线性表L已存在。操作结果:将L重置为空表 */</span></span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(LinkList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p=(*L)-&gt;next;<span class="comment">/* p指向第一个结点 */</span></span><br><span class="line"><span class="keyword">while</span>(p)<span class="comment">/* 没到表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">q=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">(*L)-&gt;next=<span class="literal">NULL</span>;<span class="comment">/* 头结点指针城为空 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段算法代码里，常见的错误就是有人会觉得<code>q</code>变量没有存在的必要。在循环体内直接写<code>free(p);p=p-&gt;next</code>即可。可这样会带来什么问题?<br>  要知道<code>p</code>是一个结点，它除了有数据域，还有指针域。你在做<code>free(p);</code>时， 其实是在对它整个结点进行删除和内存释放的工作。这就好比皇帝快要病死了，却还没有册封太子，他儿子五六个，你说要是你脚一蹬倒是解脱了，这国家咋办，你那几个儿子咋办？这要是为了皇位，什么亲兄弟血肉情都成了浮云，一定会打起来。所以不行，皇帝不能马上死，得先把遗嘱写好，说清楚，哪个儿子做太子才行。而这个遗嘱就是变量<code>q</code>的作用，它使得下一个结点是谁得到了记录，以便于等当前结点释放后，把下一-结点拿回来补充。<br><br></p><h1 id="6-单链表结构与顺序存储结构的优缺点">6. 单链表结构与顺序存储结构的优缺点</h1><p>简单地对单链表结构和顺序存储结构做对比：</p><ul><li><strong>存储分配方式：</strong><ul><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li></ul></li><li><strong>时间性能</strong><ul><li>查找<ul><li>顺序存储结构O(1)</li><li>单链表O(n)</li></ul></li><li>插入和删除<ul><li>顺序存储结构需要平均移动表长一半的元素，时间为O(n)</li><li>单链表在找出某位置的指针后，插入和删除时间复杂度仅为O(1)</li></ul></li></ul></li><li><strong>空间性能</strong><ul><li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</li></ul></li></ul><p>通过上面的对比，我们可以得出一些经验性的结论：</p><ul><li><strong>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构</strong>。若需要频繁插入和删除时，宜采用单链表结构。比如说游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家的游戏过程中，可能会随时增加或删除，此时再用顺序存储就不太合适了，单链表结构就可以大展拳脚。当然，这只是简单的类比，现实中的软件开发，要考虑的问题会复杂得多。</li><li><strong>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构</strong>。这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。</li></ul><p>  总之，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。<br><br></p><h1 id="7-静态链表">7. 静态链表</h1><p>  C语言具有的指针能力，使得它可以非常容易地操作内存中的地址和数据，这比其他高级语言更加灵活方便。后来的面向对象语言，如<code>Java</code>、 <code>C#</code>等，虽不使用指针，但因为启用了对象引用机制，从某种角度也间接实现了指针的某些作用。但对于一些语言，如<code>Basic</code>、<code>Fortran</code>等早期的编程高级语言，由于没有指针，链表结构按照前面我们的讲法，它就没法实现了。怎么办呢?<br>  有人就想出来用数组来代替指针描述单链表。真是不得不佩服他们的智慧，我们来看看他是怎么做到的。<br>  首先我们让数组的元素都是由两个数据域组成，<code>data</code>和<code>cur</code>。也就是说，数组的每个下标都对应一个<code>data</code>和一个<code>cur</code>。数据域<code>data</code>，用来存放数据元素，也就是通常我们要处理的数据；而<code>cur</code>相当于单链表中的<code>next</code>指针，存放该元素的后继在数组中的下标，我们把<code>cur</code>叫做游标。<br>  我们把这种<strong>用数组描述的链表叫做静态链表</strong>，这种描述方法还有起名叫做游标实现法。<br>  为了方便插入数据，我们通常会把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000<span class="comment">/* 存储空间初始分配量*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线性表的静态链表存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="type">int</span> cur;<span class="comment">/* 游标（Cursor），为0时表示无指向 */</span></span><br><span class="line">&#125; Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><p>  另外我们对数组第一个和最后一 个元素作为特殊元素处理，不存数据。我们通常把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为<code>0</code>的元素的<code>cur</code>就存放备用链表的第一个结点的下标；而数组的最后一个元素的<code>cur</code>则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为0。如下图所示。<br><img src="https://img-blog.csdnimg.cn/92e8c5f45d494430a37b524b88e86376.png#pic_center" alt="在这里插入图片描述"><br>  此时的图示相当于初始化的数组状态，见下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 */</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(StaticLinkList space)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MAXSIZE<span class="number">-1</span>; i++ )</span><br><span class="line">space[i].cur = i+<span class="number">1</span>:</span><br><span class="line">space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>; <span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  假设我们已经将数据存入静态链表，比如分别存放着“甲”、“乙”、丁”、“戊”、“已&quot;、庚”等数据，则它将处于如下图所示这种状态。<br><img src="https://img-blog.csdnimg.cn/547bcd0df31b4d6f871f26354ed8e9af.png#pic_center" alt="在这里插入图片描述"><br>  此时“甲”这里就存有下一元素“乙&quot;的游标 2,，&quot;乙&quot;则存有下一元素“丁”的下标 3。而“庚&quot;是最后一个有值元素，所以它的<code>cur</code>设置为 0。而最后一个元素的<code>cur</code>则因“甲”是第一有值元素而存有它的下标为 1。而第一个元素则因空闲空间的第一个元素下标为 7，所以它的<code>cur</code>存有 7。</p><h2 id="7-1-静态链表的插入操作">7.1 静态链表的插入操作</h2><p>  现在我们来看看如何实现元素的插入。<br>  静态链表中要解决的是：如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。<br>  前面说过，在动态链表中，结点的申请和释放分别借用<code>malloc ()</code>和<code>free()</code>两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，所以我们需要自己实现这两个函数，才可以做插入和删除的操作。<br>  为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若备用空间链表非空，则返回分配的结点下标，否则返回0 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Malloc_SLL</span><span class="params">(StaticlinkList space)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = space[<span class="number">0</span>].cur; <span class="comment">/* 当前数组第一个元素的cur存的值 */</span></span><br><span class="line"><span class="comment">/* 就是要返回的第一个备用空闲的下标 */</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">/* 由于要拿出一个分量来使用 */</span></span><br><span class="line"><span class="comment">/* 所以我们就得把它的下一个分量用来做备用*/</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这段代码有意思，一方面它的作用就是返回一个下标值，这个值就是数组头元素的<code>cur</code>存的第一个空闲的下标。从上面的图示例子来看,其实就是返回<code>7</code>。<br>  那么既然下标为<code>7</code>的分量准备要使用了，就得有接替者，所以就把分量<code>7</code>的<code>cur</code>值赋值给头元素，也就是把<code>8</code>给<code>space[0].cur</code>, 之后就可以继续分配新的空闲分量，实现类似<code>malloc()</code>函数的作用。<br>  现在我们如果需要在“乙&quot;和“丁”之间，插入一个值为“丙&quot;的元素，按照以前顺序存储结构的做法，应该要把“丁”、“戊&quot;、“己”、“庚&quot;这些元素都往后移一位。但目前不需要，因为我们有了新的手段。<br>  新元素“丙”， 想插队是吧？可以，你先悄悄地在队伍最后一排第<code>7</code>个游标位置待着，我一会就能帮你搞定。我接着找到了“乙”， 告诉他，你的<code>cur</code>不是游标为<code>3</code>的“丁”了，这点小钱，意思意思，你把你的下一位的游标改为<code>7</code>就可以了。&quot;乙”把<code>cur</code>值改了。此时再回到“丙&quot;那里，说你把你的<code>cur</code>改为<code>3</code>。就这样，在绝大多数人都不知道的情况下，整个排队的次序发生了改变(如下图所示)。<br>  实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(StaticLinkList L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j, k, l;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;<span class="comment">/* 注意k首先是最后一个元素的下标 */</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">j = Malloc_SSL(L);<span class="comment">/* 获得空闲分量的下标 */</span></span><br><span class="line"><span class="keyword">if</span> (j)</span><br><span class="line">&#123;</span><br><span class="line">L[j].data = e;<span class="comment">/* 将数据赋值给此分量的data */</span></span><br><span class="line"><span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i <span class="number">-1</span>; l++)<span class="comment">/* 找到第i个元素之前的位置 */</span></span><br><span class="line">k = L[k].cur;</span><br><span class="line">L[j].cur = L[k].cur;<span class="comment">/* 把第i个元素之前的cur赋值给新元素的cur */</span></span><br><span class="line">L[k].cur = j;<span class="comment">/* 把新元素的下标赋值给第i个元素之前元素的cur */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当我们执行插入语句时，我们的目的是要在“乙&quot;和“丁”之间插入“丙&quot;。调用代码时，输入<code>i</code>值为3。</li><li>第 4 行让<code>k=MAX_SIZE- 1=999</code>。</li><li>第 7 行，<code>j=Malloc._SSL (L) =7</code>。此时下标为 0 的<code>cur</code>也因为 7 要被占用而更改备用链表的值为 8。</li><li>第 11~12 行，<code>for</code>循环由 1 到 2，执行两次。代码<code>k = L[k].cur;</code>使得<code>k=999</code>，得到<code>k=L[999].cur=1</code>,再得到<code>k=L[1].cur=2</code>。</li><li>第 13 行，<code>L[j].cur = L[k].cur;</code>，因<code>j=7</code>，而<code>k=2</code>得到<code>L[7].cur=L[2].cur=3</code>。这就是刚才我说的让“丙&quot;把它的<code>cur</code>改为 3 的意思。</li><li>第 14 行，<code>L[k].cur = j;</code>意思就是<code>L[2].cur=7</code>。 也就是让“乙”把它的<code>cur</code>改为指向“丙&quot;的下标 7。</li></ol><p>  就这样，我们实现了在数组中，实现不移动元素，却插入了数据的操作(如下图所示)。没理解可能觉得有些复杂，理解了，也就那么回事。<br><img src="https://img-blog.csdnimg.cn/32854f070a714ae8a22dd283346904fb.png#pic_center" alt="在这里插入图片描述"></p><h2 id="7-2-静态链表的删除操作">7.2 静态链表的删除操作</h2><p>  和前面一样，删除元素时，原来是需要释放结点的函数<code>free()</code>。 现在我们也得自己实现它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除在L中第i个数据元素e */</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(StaticLinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j, k;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">k = L[k].cur;</span><br><span class="line">j = L[k].cur;</span><br><span class="line">L[k].cur = L[j].cur;</span><br><span class="line">Free_SSL(L, j);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  有了刚才的基础，这段代码就很容易理解了。前面代码都一样，<code>for</code>循环因为<code>i=1</code>而不操作，<code>j=k[999].cur=1</code>，<code>L[k].cur=L[j].cur</code>也就是<code>L[999]cur=L[1].cur=2</code>。 这其实就是告诉计算机现在“甲” 已经离开了，“乙”才是第一个元素。<code>FreSSL(L, j);</code>是什么意思呢？来看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将下标为k的空闲结点回收到备用链表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Free_SSL</span><span class="params">(StaticLinkList space, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">space[k].cur = space[<span class="number">0</span>].cur;<span class="comment">/* 把第一个元素的cur值赋给要删除的分量cur */</span></span><br><span class="line">space[<span class="number">0</span>].cur = k;<span class="comment">/* 把要删除的分量下标赋值给第一个元素的cur */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  意思就是“甲”现在要走，这个位置就空出来了，也就是，未来如果有新人来，最优先考虑这里，所以原来的第一一个空位分量，即下标是 8 的分量，它降级了，把 8 给“甲”所在下标为 1 的分量的<code>cur</code>，也就是<code>space[1].cur=space[0].cur=8</code>，而<code>space[0].cur=k=1</code>其实就是让这个删除的位置成为第一个优先空位，把它存入第一个元素的<code>cu</code>r中，如下图所示。<br><img src="https://img-blog.csdnimg.cn/218b9d0d583e4d05bb3bd3de68a7e106.png#pic_center" alt="在这里插入图片描述"><br>  当然，静态链表也有相应的其他操作的相关实现。比如我们代码中的<code>ListLength</code>就是一个，来看代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件：静态链表L已存在。操作结果：返回L中数据元素的个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(StaticLinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line"><span class="keyword">while</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">i=L[i].cur;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  另外一些操作和线性表的基本操作相同，实现也不复杂，在这里就不讲解了。</p><h2 id="7-3-静态链表的优缺点">7.3 静态链表的优缺点</h2><p><strong>优点：</strong></p><ul><li>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点</li></ul><p><strong>缺点：</strong></p><ul><li>没有解决连续存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性</li></ul><p>  总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。<br><br></p><h1 id="8-循环链表">8. 循环链表</h1><p>  对于单链表，由于每个结点只存储了向后的指针，到了尾标志就停止了向后链的操作，这样，当中某一结点就无法找到它的前驱结点了，就像我们刚才说的，不能回到从前。<br>  比如，你是一业务员，家在上海。需要经常出差，行程就是上海到北京一路上的城市，找客户谈生意或分公司办理业务。你从上海出发，乘火车路经多个城市停留后，再乘飞机返回上海，以后，每隔一段时间，你基本还要按照这样的行程开展业务，如下图所示。<br><img src="https://img-blog.csdnimg.cn/501761f2a18441d3852ae40139b1d816.png#pic_center" alt="在这里插入图片描述"><br>  有一次，你先到南京开会，接下来要对以上的城市走一遍， 此时有人对你说，不行，你得从上海开始，因为上海是第一站。你会对这人说什么？神经病。哪有这么傻的，直接回上海根本没有必要，你可以从南京开始，下一站蚌埠，直到北京，之后再考虑走完上海及苏南的几个城市。显然这表示你是从当中一结点开始遍历整个链表，这都是原来的单链表结构解决不了的问题。<br>  事实上，把北京和上海之间连起来，形成一个环就解决了前面所面临的困难。这就是我们现在要讲的循环链表。<br>  <strong>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)。</strong><br>  从刚才的例子可以总结出，循环链表解决了一个很麻烦的问题。如何从当中一个结点出发，访问到链表的全部结点。<br>  为了使空链表与非空链表处理一致， 我们通常设一个头结点，当然，这并不是说，循环链表一定要头结点，这需要注意。循环链表带有头结点的空链表如下图所示：<br><img src="https://img-blog.csdnimg.cn/df59aecee6c14cf3a5a36ad3d50ebd9f.png#pic_center" alt="在这里插入图片描述"><br>  对于非空的循环链表就如下图所示。<br><img src="https://img-blog.csdnimg.cn/ff08538058bd4449a074ce80e7e05fd2.png#pic_center" alt="在这里插入图片描述">  其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断<code>p-&gt;next</code>是否为空，现在则是<code>p-&gt;next</code>不等于头结点，则循环未结束。<br>  在单链表中，我们有了头结点时，我们可以用 <strong>O(1)</strong> 的时间访问第一个结点，但对于要访问到最后一个结点，却需要 <strong>O(n)</strong> 时间，因为我们需要将单链表全部扫描一遍。<br>  有没有可能用 <strong>O(1)</strong> 的时间由链表指针访问到最后一一个结点呢？当然可以。<br>  不过我们需要改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表（如下图所示），此时查找开始结点和终端结点都很方便了。<br><img src="https://img-blog.csdnimg.cn/5e927c0f914c4d129c3ee24057e68604.png#pic_center" alt="在这里插入图片描述"><br>  从上图中可以看到，终端结点用尾指针<code>rear</code>指示，则查找终端结点的时间复杂度是<strong>O(1)</strong>，而开始结点，其实就是<code>rear-&gt;next-&gt;next</code>，其时间复杂也为<strong>O(1)</strong>。<br>  举个程序的例子，要将两个循环链表合并成一个表时， 有了尾指针就非常简单了。比如下面的这两个循环链表，它们的尾指针分别是<code>rearA</code>和<code>rearB</code>，如下图所示。<br><img src="https://img-blog.csdnimg.cn/121afc909cdf4ec198774bfa353c1612.png#pic_center" alt="在这里插入图片描述"><br>  要想把它们合并，只需要如下的操作即可，如下图所示。<br><img src="https://img-blog.csdnimg.cn/68b6f54bfde54d3ab410e9de2d9060d0.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=rearA-&gt;next;<span class="comment">/* 保存A表的头结点，即 ① */</span></span><br><span class="line">rearA-&gt;next=rearB-&gt;next-&gt;next;<span class="comment">/* 将本是指向B表的第一个结点(不是头结点) */</span></span><br><span class="line"><span class="comment">/* 赋值给reaA-&gt;next,即 ② */</span></span><br><span class="line">rearB-&gt;next-p;<span class="comment">/* 将原A表的头结点赋值给rearB-&gt;next,即 ③ */</span></span><br><span class="line"><span class="built_in">free</span> (p);<span class="comment">/* 释放q */</span></span><br></pre></td></tr></table></figure><br><h1 id="9-双向链表">9. 双向链表</h1><p>  继续我们刚才的例子，你平时都是从上海一路停留到北京的，可是这一次，你得先到北京开会，谁叫北京是首都呢，会就是多。开完会后，你需要例行公事，走访各个城市，此时你怎么办？<br>  有人又出主意了，你可以先飞回上海，一路再乘火车走遍这几个城市，到了北京后，你再飞回上海。<br><img src="https://img-blog.csdnimg.cn/dd6f86156bc84472821f8f7abc02a995.png#pic_center" alt="在这里插入图片描述"><br>  你会感慨，人生中为什么总会有这样出馊主意的人存在呢？真要气死人才行。哪来这么麻烦，我一路从北京坐火车或汽车回去不就完了吗。如下图所示：<br><img src="https://img-blog.csdnimg.cn/2bc3c0e80bc94c059735c96f7c9d65c1.png#pic_center" alt="在这里插入图片描述"><br>  对呀，其实生活中类似的小智慧比比皆是，并不会那么的死板教条。我们的单链表，总是从头到尾找结点，难道就不可以正反遍历都可以吗？当然可以，只不过需要加点东西而已。<br>  我们在单链表中，有了<code>next</code>指针，这就使得我们要查找下一结点的时间复杂度为<strong>O(1)</strong>。可是如果我们要查找的是上一结点的话，那最坏的时间复杂度就是 <strong>O(n)</strong> 了，因为我们每次都要从头开始遍历查找。<br>  <strong>双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</strong> 所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性表的双向链表存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span><span class="comment">/* 直接前驱指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span><span class="comment">/* 直接后驱指针 */</span></span><br><span class="line">&#125; DulNode, *DuLinkList;</span><br></pre></td></tr></table></figure><p>  既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。<br>  双向链表的循环带头结点的空链表如下图所示。<br><img src="https://img-blog.csdnimg.cn/efdf5e2297d5444ba5cbab24d5ef70ac.png#pic_center" alt="在这里插入图片描述"><br>  非空的循环的带头结点的双向链表如下图所示。<br><img src="https://img-blog.csdnimg.cn/d810b472f851467cbdb9dd30cd1961be.png#pic_center" alt="在这里插入图片描述"><br>  由于这是双向链表，那么对于链表中的某一个结点<code>p</code>，它的后继的前驱是谁？当然还是它自已。它的前驱的后继自然也是它自己，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</span><br></pre></td></tr></table></figure><p>  这就如同上海的下一站是苏州，那么上海的下一站的前一站是哪里? 这里有点废话的感觉。<br>  双向链表是单链表中扩展出来的结构，所以它的很多操作是和单链表相同的，比如求长度的<code>ListLength</code>，查找元素的<code>GetElem</code>，获得元素位置的<code>LocateElem</code>等，这些操作都只要涉及一个方向的指针即可，另一指针多了也不能提供什么帮助。<br>  就像人生一样，想享乐就得先努力，欲收获就得付代价。双向链表既然是比单链表多了如可以反向遍历查找等数据结构，那么也就需要付出一些小的代价：在插入和删除时，需要更改两个指针变量。<br>  插入操作时，其实并不复杂，不过顺序很重要，千万不能写反了。<br>  我们现在假设存储元素<code>e</code>的结点为<code>s</code>，要实现将结点<code>s</code>插入到结点<code>p</code>和<code>p-&gt;next</code>之间需要下面几步，如下图所示。<br><img src="https://img-blog.csdnimg.cn/36b388eb689f4f20b77b047e616b8832.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; prior = p;<span class="comment">/* 把p赋值給s的前驱，如图中 ① */</span></span><br><span class="line">s -&gt; next = p-&gt; next;<span class="comment">/* 把p-&gt;next赋值给s的后继，如图中 ② */</span></span><br><span class="line">p -&gt; next-&gt; prior = s;<span class="comment">/* 把s赋值给p-&gt;next的前驱，如图中 ③ */</span></span><br><span class="line">p -&gt; next = s;<span class="comment">/* 把s赋值給p的后继，如图中 ④ */</span></span><br></pre></td></tr></table></figure><p>  关键在于它们的顺序，由于第②步和第③步都用到了<code>p-&gt;next</code>。如果第④步先执行，则会使得<code>p-&gt;next</code>提前变成了<code>s</code>，使得插入的工作完不成。所以我们不妨把上面这张图在理解的基础上记忆，顺序是先搞定<code>s</code>的前驱和后继，再搞定后结点的前驱，最后解决前结点的后继。<br>  如果插入操作理解了，那么删除操作，就比较简单了。<br>  若要删除结点<code>p</code>，只需要下面两步骤，如下图所示。<br><img src="https://img-blog.csdnimg.cn/6c1f2bb0b16a4c57a10a4121d48ee4a4.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next=p-&gt;next;<span class="comment">/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中 ① */</span></span><br><span class="line">p-&gt;next- -&gt;prior=p-&gt;prior;<span class="comment">/* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中 ② */</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">/* 释放结点 */</span></span><br></pre></td></tr></table></figure><p>  双向链表相对于单链表来说，要更复杂一些，毕竟它多了<code>prior</code>指针，对于插入和删除时，需要格外小心。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。 不过，由于它良好的对称性，使得对某个结点的前后结点的操作带来了方便，可以有效提高算法的时间性能。说白了，就是用空间来换时间。<br><br></p><h1 id="10-总结">10. 总结</h1><p>  链式存储结构具有不受固定的存储空间限制，可以比较快捷的插入和删除。<br>  线性表的这两种结构其实是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。<br><img src="https://img-blog.csdnimg.cn/c465b3cb322843d998a313a97feadead.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法》（四）- 线性表详解</title>
      <link href="/2021/10/13/algorithm_4/"/>
      <url>/2021/10/13/algorithm_4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p><h1 id="1-线性表的定义">1. 线性表的定义</h1><p>  <strong>线性表（List）：零个或多个数据元素的有限序列。</strong><br>  线性表是一个序列，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。<br>  然后，线性表强调是有限的，元素个数也是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在于数学的概念中。<br>  如果用数学语言来进行定义。可如下：<br>  若将线性表记为（a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，···，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mo>−</mo></msub></mrow><annotation encoding="application/x-tex">_-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4667em;vertical-align:-0.2083em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">_+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4667em;vertical-align:-0.2083em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，···，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>），则表中 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mo>−</mo></msub></mrow><annotation encoding="application/x-tex">_-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4667em;vertical-align:-0.2083em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 领先于 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 领先于 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">_+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4667em;vertical-align:-0.2083em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，称 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mo>−</mo></msub></mrow><annotation encoding="application/x-tex">_-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4667em;vertical-align:-0.2083em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的<strong>直接前驱元素</strong>，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mo>+</mo></msub></mrow><annotation encoding="application/x-tex">_+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4667em;vertical-align:-0.2083em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的<strong>直接后继元素</strong>。当 i=1，2，…，n-1 时，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 有且仅有一个直接后继，当 i=2，3，…，n 时，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 有且仅有一个直接前驱。<br><img src="https://img-blog.csdnimg.cn/85e5e85edc5d4732b05dca5c01130fe7.png#pic_center" alt="在这里插入图片描述"><br>  所以线性表元素的个数<code>n (n&gt;0)</code>定义为<strong>线性表的长度</strong>，当<code>n=0</code>时，称为<strong>空表</strong>。<br>  在非空表中的每个数据元素都有一个确定的位置，如 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是第一个数据元素，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是最后一个数据元素，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是第 i 个数据元素，称 i 为数据元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 在线性表中的<strong>位序</strong>。<br>  <strong>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。</strong><br><br></p><h1 id="2-线性表的抽象数据类型">2. 线性表的抽象数据类型</h1><p>  <strong>抽象数据类型（abstract data type，ADT）是带有一组操作的一些对象的集合。</strong><br>  对于线性表来说，插入数据和删除数据都是最基本且必须的操作。所以，线性表的抽象数据类型定义如下：<br>  线性表的数据对象集合为{a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，……，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)，每个元素的类型均为 DataType。其中，除第一个元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表 (List)</span><br><span class="line">Data</span><br><span class="line">operation</span><br><span class="line"><span class="title function_">InitList</span><span class="params">(*I)</span>:初始化操作，建立一个空的线性表L。</span><br><span class="line"><span class="title function_">ListEmpty</span><span class="params">(L)</span>:若线性表为空，返回<span class="literal">true</span>，否则返回<span class="literal">false</span>。</span><br><span class="line"><span class="title function_">ClearList</span><span class="params">(*L）:将线性表清空。</span></span><br><span class="line"><span class="params">GetElem(L,i,*e):将线性表L中的第i个位置元素值返回给e。</span></span><br><span class="line"><span class="params">LocateElem (L,e):在线性表L中查找与给定值e相等的元素，如果查找成功,返回该元素在表中序号表示成功;否则,返回<span class="number">0</span>表示失败。</span></span><br><span class="line"><span class="params">ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e。</span></span><br><span class="line"><span class="params">ListDelete (*L,i,*e):删除线性表工中第i个位置元素，并用e返回其值。</span></span><br><span class="line"><span class="params">ListLength (L):返回线性表工的元素个数。</span></span><br><span class="line"><span class="params">endADT</span></span><br></pre></td></tr></table></figure><p>  对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。</p><p>  比如，要实现两个线性表集合<code>A</code>和<code>B</code>的并集操作。即要使得集合 A=A∪B。说白了，就是把存在集合<code>B</code>中但并不存在<code>A</code>中的数据元素插入到<code>A</code>中即可。<br>  仔细分析一下这个操作，发现我们只要循环集合<code>B</code>中的每个元素，判断当前元素是否存在<code>A</code>中，若不存在，则插入到<code>A</code>中即可。思路应该是很容易想到的。<br>我们假设<code>La</code>表示集合<code>A</code>，<code>Lb</code>表示集合<code>B</code>，则实现的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将所有的在线性表Lb中但不在La中的数据元素插入到La中 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">union</span><span class="params">(SqList *La,SqList Lb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> La_len,Lb_len,i;</span><br><span class="line">ElemType e;<span class="comment">/* 声明与La和Lb相同的数据元素e */</span></span><br><span class="line">La_len=ListLength(*La);<span class="comment">/* 求线性表的长度 */</span></span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;;i&lt;=Lb_len;i++)</span><br><span class="line">&#123;</span><br><span class="line">GetElem(Lb,i,&amp;e):<span class="comment">/* 取Lb中第i个数据元素赋给e */</span></span><br><span class="line"><span class="keyword">if</span> (!LocateElem(*La,e)) <span class="comment">/* La中不存在和e相同数据元素 */</span></span><br><span class="line">ListInsert (La,++La_len,e);<span class="comment">/* 插入 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里，我们对于union操作，用到了前面线性表基本操作 ListLength、GetElem、LocateElem、ListInsert 等，可见，对于复杂的个性化的操作，其实就是把基本操作组合起来实现的。</p><p>注意一个很容易混淆的地方：<br>  <strong>当你传递一个参数给函数的时候，这个参数会不会在函数内被改动决定了使用什么参数形式。<br>  如果需要被改动，则需要传递指向这个参数的指针。<br>  如果不用被改动，可以直接传递这个参数。</strong><br><br></p><h1 id="3-线性表的顺序存储结构">3. 线性表的顺序存储结构</h1><h2 id="3-1-顺序存储定义">3.1 顺序存储定义</h2><p>  <strong>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</strong><br>  线性表（a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，…，a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3014em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的顺序存储示意图如下：<br><img src="https://img-blog.csdnimg.cn/dd5d329c11f541dfb421cd4401ee89a3.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3-2-顺序存储方式">3.2 顺序存储方式</h2><p>  线性表的顺序存储结构，说白了，就是在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中。既然线性表的每个数据元素的类型都相同，所以可以用C语言（其他语言也相同）的<strong>一维数组来实现顺序存储结构</strong>，即把第一个数据元素存到数组下标为 0 的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。<br>  为了建立一个线性表，要在内存中找一块地，于是这块地的第一个位置就非常关键，它是存储空间的起始位置。线性表中，我们估算这个线性表的最大存储容量，建立一个数组，数组的长度就是这个最大存储容量。<br>  同样的，我们已经有了起始的位置，也有了最大的容量，于是我们可以在里面增加数据了。随着数据的插入，我们线性表的长度开始变大，不过线性表的当前长度不能超过存储容量，即数组的长度。</p><p>  来看线性表的顺序存储的结构代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20<span class="comment">/* 存储空间初始分配量 */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">/* ElemType类型根据实际情况而定，这里为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MAXSIZE]:<span class="comment">/* 数组，存储数据元素 */</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>  这里，我们就发现描述顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量：数组长度 MAXSIZE。</li><li>线性表的当前长度：length。</li></ul><h2 id="3-3-数组长度和线性表长度的区别">3.3 数组长度和线性表长度的区别</h2><p>  数组的长度是存放线性表的存储空间的长度，存储分配后这个量是一般是不变的。那么数组的大小一定不可以变吗？不是的，一般高级语言，比如C、VB、C++都可以用编程手段实现动态分配数组，不过这会带来性能上的损耗。<br>  线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>  在任意时刻，线性表的长度应该小于等于数组的长度。</p><h2 id="3-4-地址计算方法">3.4 地址计算方法</h2><p>  由于我们数数都是从 1 开始数的，线性表的定义也不能免俗，起始也是 1，可C语言中的数组却是从 0 开始第一个下标的，于是线性表的第<code>i</code>个元素是要存储在数组下标为<code>i-1</code>的位置，即数据元素的序号和存放它的数组下标之间存在对应关系。<br><img src="https://img-blog.csdnimg.cn/4e306584da674e9bbe18f03d692e2525.png#pic_center" alt="在这里插入图片描述"><br>  用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。<br>  其实，内存中的地址，就和图书馆或电影院里的座位一样，都是有编号的。<strong>存储器中的每个存储单元都有自己的编号，这个编号称为地址</strong>。当我们占座后，占座的第一个位置确定后，后面的位置都是可以计算的。试想一下，我是班级成绩第五名，我后面的 10 名同学成绩名次是多少呢？当然是<code>6,7,…,15，</code>因为<code>5+1,5+2,…,5+10</code>。由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是 c 个存储单元，那么线性表中第<code>i+1</code>个数据元素的存储位置和第主个数据元素的存储位置满足下列关系（LOC表示获得存储位置的函数）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><mi>a</mi><msub><mrow></mrow><mi>i</mi></msub><msub><mrow></mrow><mo>+</mo></msub><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">LOC(a{_i}{_+}{_1})=LOC(a_i)+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span></p><p>  所以对于第<code>i</code>个数据元素 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4617em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的存储位置可以由 a<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 推算得出：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">LOC(a_i)=LOC(a_1)+(i-1)*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span></p><p><img src="https://img-blog.csdnimg.cn/73019c0f9c074993aaaa49e87bc2e12f.png#pic_center" alt="在这里插入图片描述"><br>  通过这个公式，你可以随时算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此用我们算法中学到的时间复杂度的概念来说，它的存取时间性能为<code>O(1)</code>。我们通常把具有这一特点的存储结构称为<strong>随机存取结构</strong>。<br><br></p><h1 id="4-顺序存储结构的插入与删除">4. 顺序存储结构的插入与删除</h1><h2 id="4-1-获得元素操作">4.1 获得元素操作</h2><p>  对于线性表的顺序存储结构来说，如果我们要实现 GetElem 操作，即将线性表<code>L</code>中的第<code>i</code>个位置元素值返回，其实是非常简单的。就程序而言，只要<code>i</code>的数值在数组下标范围内，就是把数组第<code>i-1</code>下标的值返回即可。来看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR O</span></span><br><span class="line"><span class="comment">/* Status是函数的类型，其值是函数结果状态代码，如OK等 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始条件:顺序线性表工已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果:用e返回工中第i个数据元素的值，注意i是指位置，第1个位置的数组是从0开始 */</span></span><br><span class="line">Status <span class="title function_">GetElem</span> <span class="params">(SqList L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(L.length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=L.data[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意这里我们是把指针<code>*e</code>的值给修改成<code>L.data[i+1]</code>，这就是真正要返回的数据，函数返回值只不过是函数处理的状态，返回值类型 Status 是一个整型，返回 OK 代表 1，ERROR 代表 0。</p><h2 id="4-2-插入操作">4.2 插入操作</h2><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；</li><li>从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置；</li><li>将要插入元素填入位置 i 处；</li><li>表长加 1。</li></ul><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件:顺序线性表L已存在，1≤i≤ListLength(L) */</span></span><br><span class="line"><span class="comment">/* 操作结果:在L中第i个位置之前插入新的数据元素e,L的长度加1 */</span></span><br><span class="line">Status <span class="title function_">ListInsert</span> <span class="params">(SqList *L,<span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length==MAXSIZE)<span class="comment">/* 顺序线性表已经满 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">/* 当i不在范围内时 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i&lt;-L-&gt;length)<span class="comment">/* 若插入数据位置不在表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)<span class="comment">/* 将要插入位置后数据元素向后移动一位 */</span></span><br><span class="line">L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=e;<span class="comment">/* 将新元素插入 */</span></span><br><span class="line">L-&gt;length++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-删除操作">4.3 删除操作</h2><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常;</li><li>如果线性长度大于等于数组长度，则抛出异常或动态增加容量；</li><li>从最后一个元素开始向前遍历到第<code>i</code>个位置，分别将它们都向后移动一个位置；</li><li>将要插入元素填入位置<code>i</code>处；</li><li>表长减 1。</li></ul><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始条件:顺序线性表L已存在，1≤i≤ListLength (L) */</span></span><br><span class="line"><span class="comment">/* 操作结果:删除工的第i个数据元素,并用e返回其值，L的长度减1 */</span></span><br><span class="line">status <span class="title function_">ListDelete</span><span class="params">(sqList *L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length==<span class="number">0</span>)<span class="comment">/*线性表为空*/</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)<span class="comment">/* 删除位置不变 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">*e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> (i&lt;L-&gt;length)<span class="comment">/* 如果删除不是最后位置 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)<span class="comment">/* 将删除位置后继元素前移 */</span></span><br><span class="line">L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;length--;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br></pre></td></tr></table></figure><p>  现在我们来分析一下，插入和删除的时间复杂度。<br>  先来看最好的情况，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为<code>O(1)</code>，因为不需要移动元素的。<br>  最坏的情况呢，如果元素要插入到第一个位置或者删除第一个元素，此时时间复杂度是多少呢？那就意味着要移动所有的元素向后或者向前，所以这个时间复杂度为<code>o(n)</code>。<br>  至于平均的情况，由于元素插入到第<code>1</code>个位置，或删除第<code>i</code>个元素，需要移动<code>n-i</code>个元素。根据概率原理，每个位置插入或删除元素的可能性是相同的，也就说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的移动次数相等，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n-1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。<br>  我们前面讨论过时间复杂度的推导，可以得出，平均时间复杂度还是<code>O(n)</code>。<br>  这说明什么？线性表的顺序存储结构，在读数据时，不管是哪个位置，时间复杂度都是<code>O(1)</code>；而插入或删除时，时间复杂度都是<code>O(n)</code>。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。</p><h2 id="4-4-线性表顺序存储结构的优缺点">4.4 线性表顺序存储结构的优缺点</h2><p><strong>优点：</strong></p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间；</li><li>可以快速地存取表中任一位置的元素；</li></ul><p><strong>缺点：</strong></p><ul><li>插入和删除操作需要移动大量元素；</li><li>当线性表长度变化较大时，难以确定存储空间的容量；</li><li>造成存储空间的“碎片”；</li></ul><h1 id="5-总结">5. 总结</h1><p>  <strong>线性表是零个或多个具有相同类型的数据元素的有限序列。</strong><br>  线性表的两大存储结构：<strong>顺序存储结构和链式存储结构</strong>。<br>  相比链式存储结构，顺序存储结构比较容易理解，是<strong>用一段连续的存储单元依次存储线性表的数据元素</strong>。通常用数组来实现这一结构。<br>  下一篇博客再具体说线性表的另一个存储结构：链式存储结构。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法》（三）- 如何估算时间复杂度</title>
      <link href="/2021/10/11/algorithm_3/"/>
      <url>/2021/10/11/algorithm_3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p><h1 id="1-算法时间复杂度">1. 算法时间复杂度</h1><h2 id="1-1-算法时间复杂度的定义">1.1 算法时间复杂度的定义</h2><p>  <strong>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</strong></p><p>  这样用大写<code>O()</code>来体现算法时间复杂度的记法，我们称之为<code>大О记法</code>。<br>  一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。</p><h2 id="1-2-推导大O阶方法">1.2 推导大O阶方法</h2><p>  那么如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？我们给出了下面的推导方法，基本上，这也就是总结前面我们举的例子。<br>  推导大O阶：</p><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。</li></ol><p>  得到的结果就是大O阶。</p><p>  事实上，分析一个算法的时间复杂度，没有这么简单，我们还需要多看几个例子。</p><h2 id="1-3-常数阶">1.3 常数阶</h2><p>  首先顺序结构的时间复杂度。下面这个算法，为什么时间复杂度不是<code>O(3)</code>，而是<code>O(1)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>,n = <span class="number">100</span>;<span class="comment">/* 执行1次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行1次 */</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行1次 */</span></span><br></pre></td></tr></table></figure><p>  这个算法的运行次数函数是<code>f(n)=3</code>。根据我们推导大О阶的方法，第一步就是把常数项<code>3</code>改为<code>1</code>。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为<code>O(1)</code>。<br>  另外，我们试想一下，如果这个算法当中的语句<code>sum=(1+n)*n/2</code>有 10 句，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">/* 执行1次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行1次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行2次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行3次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行4次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行5次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行6次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行7次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行8次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行9次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行10次 */</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行1次 */</span></span><br></pre></td></tr></table></figure><p>  事实上无论<code>n</code>为多少，上面的两段代码就是<code>3</code>次和<code>12</code>次执行的差异。这种与问题的大小无关（<code>n</code>的多少），执行时间恒定的算法，我们称之为具有<code>O(1)</code>的时间复杂度，又叫常数阶。<br>  <strong>注意：不管这个常数是多少，我们都记作O(1)，而不能是O(3)、O(12)等其他任何数字，这是初学者常常犯的错误。</strong><br>  对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着<code>n</code>的变大而发生变化，所以单纯的分支结构（不包含在循环结构中)，其时间复杂度也是<code>O(1)</code>。</p><h2 id="1-4-线性阶">1.4 线性阶</h2><p>  线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要<strong>分析算法的复杂度，关键就是要分析循环结构的运行情况。</strong><br>  下面这段代码，它的循环的时间复杂度为<code>O(n)</code>，因为循环体中的代码须要执行<code>n</code>次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-对数阶">1.5 对数阶</h2><p>  下面的这段代码，时间复杂度又是多少呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">count = count * <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于每次<code>count</code>乘以<code>2</code>之后，就距离<code>n</code>更近了一分。也就是说，有多少个<code>2</code>相乘后大于<code>n</code>，则会退出循环。由<strong>2^x^=n</strong>得到<strong>x=log<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">{_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>n</strong>。所以这个循环的时间复杂度为<code>O(logn)</code>。</p><h2 id="1-6-平方阶">1.6 平方阶</h2><p>  下面例子是一个循环嵌套，它的内循环刚才我们已经分析过，时间复杂度为<code>O(n)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  而对于外层的循环，不过是内部这个时间复杂度为<code>O(n)</code>的语句，再循环<code>n</code>次。所以这段代码的时间复杂度为O(n^2^)。<br>  如果外循环的循环次数改为了<code>m</code>，时间复杂度就变为<code>O(m×n)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。<br>  那么下面这个循环嵌套,它的时间复杂度是多少呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; n; j++)<span class="comment">/* 注意j = i而不是0 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于当<code>i=0</code>时，内循环执行了<code>n</code>次，当<code>i=1</code>时，执行了<code>n-1</code>次，……当<code>i=n-1</code>时，执行了<code>1</code>次。所以总的执行次数为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo>…</mo><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">n+(n-1)+(n- 2)+…+1=\frac{n(n+1)} {2}=\frac{n^2}{2}+\frac{n}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1771em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>  用我们推导大О阶的方法，第一条，没有加法常数不予考虑；第二条，只保留最高阶项，因此保留<strong>n^2^/2</strong> ；第三条，去除这个项相乘的常数，也就是去除<code>1/2</code>，最终这段代码的时间复杂度为<strong>O(n^2^)</strong>。<br>  从这个例子，我们也可以得到一个经验，其实<strong>理解大О推导不算难，难的是对数列的一些相关运算，这更多的是考察你的数学知识和能力</strong>，所以想考研的朋友，要想在求算法时间复杂度这里不失分，可能需要强化你的数学，特别是数列方面的知识和解题能力。</p><p>  我们继续看例子，对于方法调用的时间复杂度又如何分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">function (i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面这段代码调用一个<code>function()</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span> <span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">print (count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  函数体是打印<code>count</code>这个参数。其实这很好理解，<code>function()</code>函数的时间复杂度是<code>O(1)</code>。所以整体的时间复杂度为<code>O(1)</code>。<br>  假如function()是下面这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span> <span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = count; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  事实上，这和刚才举的例子是一样的，只不过把嵌套内循环放到了函数中，所以最终的时间复杂度为<strong>O(n^2^)</strong>。<br>  下面这段相对复杂的语句:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n++;<span class="comment">/* 执行次数为1 */</span></span><br><span class="line">function (n);<span class="comment">/* 执行次数为n */</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">/* 执行次数为n×n */</span></span><br><span class="line">&#123;</span><br><span class="line">function (i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">/* 执行次数为n(n+1)/2 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  它的执行次数<strong>f(n)=1+n+n^2^+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>3</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>n^2^+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>3</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>n+1</strong>，根据推导大O阶的方法，最终这段代码的时间复杂度也是<strong>O(n^2^)</strong>。</p><h1 id="2-常见的时间复杂度">2. 常见的时间复杂度</h1><table><tr align=center><th>执行次级函数</th><th>阶</th><th>非正式术语</th></tr><tr align=center><td>12</td><td>O(1)</td><td>常数阶</td></tr><tr align=center><td>2n+3</td><td>O(n)</td><td>线性阶</td></tr><tr align=center><td>3n<sup>2</sup>+2n+1</td><td>O(n<sup>2</sup>)</td><td>平方阶</td></tr><tr align=center><td>5log<sub>2</sub>n+20</td><td>O(logn)</td><td>对数阶</td></tr><tr align=center><td>2n+3nlog<sub>2</sub>n+19</td><td>O(nlogn)</td><td>nlogn阶</td></tr><tr align=center><td>6n<sup>3</sup>+2n<sup>2</sup>+3n+4</td><td>O(N<sup>3</sup>)</td><td>立方阶</td></tr><tr align=center><td>2<sup>n</sup></td><td>O(2<sup>n</sup>)</td><td>指数阶</td></tr></table><p>  常用的时间复杂度所耗费的时间从小到大依次是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(n!)&lt;O(n^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>  我们前面已经谈到了<strong>O(1)常数阶</strong>、<strong>O(logn)对数阶</strong>、<strong>O(n)线性阶</strong>、<strong>O(n^2^)平方阶</strong>等，至于<strong>O(nlogn)<strong>会在后面介绍，而像</strong>O(n^3^)</strong>，过大的<code>n</code>都会使得结果变得不现实。同样<strong>指数阶O(2^n^)</strong> 和<strong>阶乘阶O(n!)</strong> 等除非是很小的<code>n</code>值，否则哪怕<code>n</code>只是<code>100</code>，都是噩梦般的运行时间。所以这种不切实际的算法时间复杂度，一般我们都不去讨论它。<br><br></p><h1 id="3-最坏情况和平均情况">3. 最坏情况和平均情况</h1><p>  你早晨上班出门后突然想起来，手机忘记带了，这年头，钥匙、钱包、手机三大件，出门哪样也不能少呀。于是回家找。打开门一看，手机就在门口玄关的台子上，原来是出门穿鞋时忘记拿了。这当然是比较好，基本没花什么时间寻找。可如果不是放在那里，你就得进去到处找，找完客厅找卧室、找完卧室找厨房、找完厨房找卫生间，就是找不到，时间一分一秒的过去，你突然想起来，可以用家里座机打一下手机，听着手机铃声来找呀，真是笨。终于找到了，在床上枕头下面。你再去上班，迟到。见鬼，这一年的全勤奖,就因为找手机给黄了。<br>  找东西有运气好的时候，也有怎么也找不到的情况。但在现实中,通常我们碰到的绝大多数既不是最好的也不是最坏的，所以算下来是平均情况居多。<br>  算法的分析也是类似，我们查找一个有<code>n</code>个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为<code>O(1)</code>，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是<code>O(n)</code>，这是最坏的一种情况了。<br>  最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。<br>  而平均运行时间也就是从概率的角度看，这个数字在每一个位置的可能性是相同的，所以平均的查找时间为<code>n/2</code>次后发现这个目标元素。<br>  <strong>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。</strong> 也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。<br>  对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。<strong>一般在没有特殊说明的情况下，都是指最坏时间复杂度。</strong><br><br></p><h1 id="4-算法空间复杂度">4. 算法空间复杂度</h1><p>  我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有<code>2050</code>个元素的数组（年数略比现实多一点)，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是<code>1</code>，如果不是值为<code>0</code>。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时,我们的运算是最小化了，但是硬盘上或者内存中需要存储这<code>2050</code>个<code>0</code>和<code>1</code>。<br>  这是通过一笔空间上的开销来换取计算时间的小技巧。到底哪一个好，其实要看你用在什么地方。<br>  算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：<code>S(n)=o(f(n))</code>，其中，<code>n</code>为问题的规模，<code>f(n)</code>为语句关于<code>n</code>所占存储空间的函数。<br>  一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为<code>O(1)</code>。<br>  通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。</p><h2 id="4-1-递归情况">4.1 递归情况</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* ptr,<span class="type">const</span> <span class="type">int</span> x,<span class="type">const</span> <span class="type">int</span> left,<span class="type">const</span> <span class="type">int</span> right)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(x&lt;ptr[mid])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> BinarySearch2(ptr,x,left,mid<span class="number">-1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr[mid])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> BinarySearch2(ptr,x,mid+<span class="number">1</span>,right);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> mid;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>递归情况下的空间复杂度：</strong> 递归深度为<code>N*每次递归的辅助空间大小</code>，如果每次递归的辅助空间为常数，则空间复杂度为<code>O(N)</code>。<br>  对于递归的二分查找，递归深度是log2^n^，每次递归的辅助空间为常数，所以空间复杂度为<strong>O(log<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4511em;vertical-align:-0.15em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>N)</strong></p><h2 id="4-2-非递归情况">4.2 非递归情况</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch1</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* ptr,<span class="type">const</span> <span class="type">int</span> x,<span class="type">const</span> <span class="type">int</span> len)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> right=len<span class="number">-1</span>;  </span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(x&lt;ptr[mid])  </span><br><span class="line">        &#123;  </span><br><span class="line">            right=mid<span class="number">-1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;ptr[mid])  </span><br><span class="line">        &#123;  </span><br><span class="line">            left=mid+<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这个过程中，辅助空间为常数级别，所以空间复杂度为<code>O(1)</code>。<br><br></p><h1 id="5-总结">5. 总结</h1><p>  推导大O阶的步骤：</p><ul><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数。</li></ul><p>  得到的结果就是大О阶。</p><p>  通过这个步骤，我们可以在得到算法的运行次数表达式后，很快得到它的时间复杂度，即大О阶。同时我也提醒了大家，其实推导大О阶很容易，但如何得到运行次数的表达式却是需要数学功底的。</p><p>  常见的时间复杂度所耗时间的大小排列：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(n!)&lt;O(n^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法》（二）- 算法详解</title>
      <link href="/2021/10/11/algorithm_2/"/>
      <url>/2021/10/11/algorithm_2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p><h1 id="1-数据结构与算法的关系">1. 数据结构与算法的关系</h1><p>数据结构为算法提供服务，算法围绕数据结构操作。</p><ul><li>数据结构只是静态的描述了数据元素之间的关系。</li><li>高效的程序需要在数据结构的基础上设计和选择算法。</li></ul><p><code>程序=数据结构+算法</code><br><br></p><h1 id="2-两种算法的比较">2. 两种算法的比较</h1><p>  用C语言实现一个求<code>1+2+3+·····+100</code>的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, sum);</span><br></pre></td></tr></table></figure><p>  这是最简单的计算机程序之一，它就是一种算法，我不去解释这代码的含义了。问题在于，你的第一直觉是这样写的，但这样是不是真的很好?是不是最高效?<br>  还有另一种比这更快的方法：<br><img src="https://img-blog.csdnimg.cn/54efb12087e54c07a79b3ad01ee8c127.png#pic_center" alt="在这里插入图片描述"><br>  用程序来实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>,n = <span class="number">100</span>;</span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, sum);</span><br></pre></td></tr></table></figure><p>  这种方法相当于另一种求等差数列的算法，不仅仅可以用于<code>1</code>加到<code>100</code>，就是加到一千、一万、一亿（需要更改整型变量类型为长整型，否则会溢出），也就是瞬间之事。但如果用刚才的程序，显然计算机要循环一千、一万、一亿次的加法运算。人脑比电脑算得快，似乎成为了现实。<br><br></p><h1 id="3-算法的定义">3. 算法的定义</h1><p>  <strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</strong><br>  现实世界中的问题千奇百怪，算法当然也就千变万化，没有通用的算法可以解决所有的问题。甚至解决一个小问题，很优秀的算法却不一定适合它。<br>  算法定义中，提到了指令，指令能被人或机器等计算装置执行。它可以是计算机指令，也可以是我们平时的语言文字。<br><br></p><h1 id="4-算法的特性">4. 算法的特性</h1><p>  <strong>算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。</strong></p><h2 id="4-1-输入输出">4.1 输入输出</h2><p>  输入和输出特性比较容易理解，<strong>算法具有零个或多个输入</strong>。尽管对于绝大多数算法来说，输入参数都是必要的，但对于个别情况，如打印“hello world!”这样的代码，不需要任何输入参数，因此算法的输入可以是零个。<strong>算法至少有一个或多个输出</strong>，算法是一定需要输出的，不需要输出,你用这个算法干吗?输出的形式可以是打印输出，也可以是返回一个或多个值等。</p><h2 id="4-2-有穷性">4.2 有穷性</h2><p>  <strong>有穷性指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</strong> 现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用当中合理的、可以接受的“有边界”。你说你写一个算法，计算机需要算上个二十年，一定会结束，它在数学意义上是有穷了，可是媳妇都熬成婆了，算法的意义也就不大了。</p><h2 id="4-3-确定性">4.3 确定性</h2><p>  <strong>确定性：算法的每一步骤都具有确定的含义，不会出现二义性。</strong> 算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p><h2 id="4-4-可行性">4.4 可行性</h2><p>  <strong>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</strong> 可行性意味着算法可以转换为程序上机运行，并得到正确的结果。尽管在目前计算机界也存在那种没有实现的极为复杂的算法，不是说理论上不能实现，而是因为过于复杂，我们当前的编程方法、工具和大脑限制了这个工作，不过这都是理论研究领域的问题，不属于我们现在要考虑的范围。<br><br></p><h1 id="5-算法设计的要求">5. 算法设计的要求</h1><h2 id="5-1-正确性">5.1 正确性</h2><p>  <strong>正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。</strong><br>  但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次：</p><ol><li>算法程序没有语法错误。</li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li><li>算法程序对于非法的输入数据能够得出满足规格说明的结果。</li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li></ol><p>  对于这四层含义，层次 1 要求最低，但是仅仅没有语法错误实在谈不上是好算法。这就如同仅仅解决温饱，不能算是生活幸福一样。而层次 4 是最困难的，我们几乎不可能逐一验证所有的输入都得到正确的结果。<br>  因此算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有层次上都是正确的，代价非常昂贵。所以一般情况下，我们把层次 3 作为个算法是否正确的标准。</p><h2 id="5-2-可读性">5.2 可读性</h2><p>  <strong>可读性：算法设计的另一目的是为了便于阅读、理解和交流。</strong><br>  可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。<br>  我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。可读性是算法（也包括实现它的代码）好坏很重要的标志。</p><h2 id="5-3-健壮性">5.3 健壮性</h2><p>  一个好的算法还应该能对输入数据不合法的情况做合适的处理。比如输入的时间或者距离不应该是负数等。<br>  <strong>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</strong></p><h2 id="5-4-时间效率高和存储量低">5.4 时间效率高和存储量低</h2><p>  最后，好的算法还应该具备时间效率高和存储量低的特点。<br>  时间效率指的是算法的执行时间。对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。<strong>设计算法应该尽量满足时间效率高和存储量低的需求。</strong> 在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，花最少的时间，办成同样的事就是好的算法。求100个人的高考成绩平均分，与求全省的所有考生的成绩平均分在占用时间和内存存储上是有非常大的差异的，我们自然是追求可以高效率和低存储量的算法来解决问题。</p><p>  综上，好的算法，应该具有<code>正确性</code>、<code>可读性</code>、<code>健壮性</code>、<code>高效率和低存储量</code>的特征。<br><br></p><h1 id="6-算法效率的度量方法">6. 算法效率的度量方法</h1><h2 id="6-1-事后统计法">6.1 事后统计法</h2><p>  <strong>事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</strong><br>  但这种方法显然是有很大缺陷的：</p><ul><li>必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。如果编制出来发现它根本是很糟糕的算法，不是竹篮打水一场空吗?</li><li>时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。要知道，现在的一台四核处理器的计算机，跟当年286、386、486等老爷爷辈的机器相比，在处理算法的运算速度上,是不能相提并论的;而所用的操作系统、编译器、运行框架等软件的不同，也可以影响它们的结果；就算是同一台机器，CPU使用率和内存占用情况不一样，也会造成细微的差异。</li><li>算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。比如 10 个数字的排序，不管用什么算法，差异几乎是零。而如果有一百万个随机数字排序，那不同算法的差异就非常大了。那么我们为了比较算法,到底用多少数据来测试,这是很难判断的问题。</li></ul><p>  基于事后统计方法有这样那样的缺陷，我们考虑不予采纳。</p><h2 id="6-2-事前分析估算法">6.2 事前分析估算法</h2><p>  <strong>事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。</strong><br>  经过分析，我们发现，一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素:</p><ol><li>算法采用的策略、方法。</li><li>编译产生的代码质量。</li><li>问题的输入规模。</li><li>机器执行指令的速度。</li></ol><p>  第 1 条当然是算法好坏的根本，第 2 条要由软件来支持，第 4 条要看硬件性能。也就是说，抛开这些与计算机硬件、软件有关的因素，<strong>一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。</strong></p><p>我们来看看前面举的例子，两种求和的算法:<br>第一种算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">/* 执行1次 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">/* 执行了n+1次 */</span></span><br><span class="line">&#123;</span><br><span class="line">sum = sum + i;<span class="comment">/* 执行n次 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行1次 */</span></span><br></pre></td></tr></table></figure><p>第二种算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>,n = <span class="number">100</span>;<span class="comment">/* 执行1次 */</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">/* 执行1次 */</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行1次 */</span></span><br></pre></td></tr></table></figure><p>  显然，第一种算法，执行了<code>1+(n+1) +n+1次=2n+3次</code>；而第二种算法，是<code>1+1+1=3次</code>。事实上两个算法的第一条和最后一条语句是一样的，所以我们关注的代码其实是中间的那部分，我们把循环看作一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是<code>n</code>次与<code>1</code>次的差距。算法好坏显而易见。<br>  我们再来延伸一下上面这个句子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, x = <span class="number">0</span>, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">/* 执行1次 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>;j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">x++;<span class="comment">/* 执行n×n次 */</span></span><br><span class="line">sum = sum + x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">/* 执行1次 */</span></span><br></pre></td></tr></table></figure><p>  这个例子中，<code>i</code>从 1 到 100，每次都要让<code>j</code>循环 100 次，而当中的<code>x++</code>和 <code>sum =sum + x</code>；其实就是<code>1+2+3+……+10000</code>，也就是 100^2^ 次，所以这个算法当中，循环部分的代码整体需要执行 n^2^（忽略循环体头尾的开销）次。显然这个算法的执行次数对于同样的输入规模<code>n = 100</code>，要多于前面两种算法，这个算法的执行时间随着<code>n</code>的增加也将远远多于前面两个。<br>此时你会看到，测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。运行时间与这个计数成正比。</p><p>  我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作，<strong>最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。</strong><br>  可以从问题描述中得到启示，同样问题的输入规模是<code>n</code>，求和算法的第一种，求<code>1+2+…+n</code>需要一段代码运行<code>n</code>次。那么这个问题的输入规模使得操作数量是<strong>f(n)= n</strong>，显然运行 100 次的同一段代码规模是运算 10 次的 10 倍。而第二种，无论<code>n</code>为多少,运行次数都为 1，即<strong>f(n)=1</strong>；第三种，运算100次是运算 10 次的 100 倍。因为它是<strong>f(n)=n^2^</strong>。<br>  我们在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。<br><img src="https://img-blog.csdnimg.cn/6c9d82b1fd324641a36ea0bdc9868727.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  我们可以这样认为，随着<code>n</code>值的越来越大，它们在时间效率上的差异也就越来越大。<br><br></p><h1 id="7-函数的渐进增长">7. 函数的渐进增长</h1><p>  我们现在来判断一下，两个算法<code>A</code>和<code>B</code>哪个更好。假设两个算法的输入规模都是<code>n</code>，算法<code>A</code>要做<code>2n+3</code>次操作，你可以理解为先有一个<code>n</code>次的循环，执行完成后，再有一个<code>n</code>次循环，最后有三次赋值或运算，共<code>2n+3</code>次操作。算法<code>B</code>要做<code>3n+1</code>次操作。你觉得它们谁更快呢?<br>  准确说来，答案是不一定的：</p><table><tr align=center><th>次数</th><th>算法A（2n+3）</th><th>算法A'（2n）</th><th>算法B（3n+1）</th><th>算法B'（3n）</th></tr><tr align=center><td>n = 1</td><td>5</td><td>2</td><td>4</td><td>3</td></tr><tr align=center><td>n = 2</td><td>7</td><td>4</td><td>7</td><td>6</td></tr><tr align=center><td>n = 3</td><td>9</td><td>6</td><td>10</td><td>9</td></tr><tr align=center><td>n = 10</td><td>23</td><td>20</td><td>31</td><td>30</td></tr><tr align=center><td>n = 100</td><td>203</td><td>200</td><td>301</td><td>300</td></tr></table><p>  当<code>n =1</code>时，算法<code>A</code>效率不如算法<code>B</code>（次数比算法<code>B</code>要多一次）。而当<code>n=2</code>时，两者效率相同；当<code>n&gt;2</code>时，算法<code>A</code>就开始优于算法<code>B</code>了，随着<code>n</code>的增加,算法<code>A</code>比算法<code>B</code>越来越好了（执行的次数比<code>B</code>要少）。于是我们可以得出结论，算法<code>A</code>总体上要好过算法<code>B</code>。<br>  此时我们给出这样的定义，输入规模<code>n</code>在没有限制的情况下，只要超过一个数值<code>N</code>，这个函数就总是大于另一个函数，我们称函数是渐近增长的。<br>  <strong>函数的渐近增长：给定两个函数 f(n) 和 g(n)，如果存在一个整数N,使得对于所有的n&gt;N, f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。</strong><br>从中我们发现，随着<code>n</code>的增大，后面的<code>+3</code>还是<code>+1</code>其实是不影响最终的算法变化的，例如算法<code>A’</code>与算法<code>B’</code>，所以，<strong>我们可以忽略这些加法常数</strong>。后面的例子，这样的常数被忽略的意义可能会更加明显。</p><p>  我们来看第二个例子，算法<code>C</code>是<code>4n+8</code>，算法<code>D</code>是<code>2n2+1</code>：</p><table><tr align=center><th>次数</th><th>算法C（4n+8）</th><th>算法C'（4n）</th><th>算法D（2n^2+1）</th><th>算法D'（n^2）</th></tr><tr align=center><td>n = 1</td><td>12</td><td>1</td><td>3</td><td>1</td></tr><tr align=center><td>n = 2</td><td>16</td><td>2</td><td>9</td><td>4</td></tr><tr align=center><td>n = 3</td><td>20</td><td>3</td><td>19</td><td>9</td></tr><tr align=center><td>n = 10</td><td>48</td><td>10</td><td>201</td><td>100</td></tr><tr align=center><td>n = 100</td><td>408</td><td>100</td><td>20001</td><td>10000</td></tr><tr align=center><td>n = 1000</td><td>4008</td><td>1000</td><td>2000001</td><td>1000000</td></tr></table><p>  当<code>n≤3</code>的时候，算法<code>C</code>要差于算法<code>D</code>（因为算法<code>C</code>次数比较多），但当<code>n&gt;3</code>后，算法<code>C</code>的优势就越来越优于算法<code>D</code>了，到后来更是远远胜过。而当后面的常数去掉后，我们发现其实结果没有发生改变。甚至我们再观察发现，哪怕去掉与<code>n</code>相乘的常数，这样的结果也没发生改变，算法<code>C’</code>的次数随着<code>n</code>的增长，还是远小于算法<code>D’</code>。也就是说，<strong>与最高次项相乘的常数并不重要</strong>。</p><p>  我们再来看第三个例子。算法<code>E</code>是<code>2n^2+3n+1</code>，算法<code>F</code>是<code>2n^3+3n+1</code>：</p><table><tr align=center><th>次数</th><th>算法E（2n^2+3N+1）</th><th>算法E'（n^2）</th><th>算法F（2n^3+3N+1）</th><th>算法F'（n^3）</th></tr><tr align=center><td>n = 1</td><td>6</td><td>1</td><td>6</td><td>1</td></tr><tr align=center><td>n = 2</td><td>15</td><td>4</td><td>23</td><td>8</td></tr><tr align=center><td>n = 3</td><td>28</td><td>9</td><td>64</td><td>27</td></tr><tr align=center><td>n = 10</td><td>231</td><td>100</td><td>2031</td><td>1000</td></tr><tr align=center><td>n = 100</td><td>20301</td><td>10000</td><td>2000301</td><td>1000000</td></tr></table><p>  当<code>n=1</code>的时候，算法<code>E</code>与算法<code>F</code>结果相同，但当<code>n&gt;1</code>后，算法<code>E</code>的优势就要开始优于算法<code>F</code>，随着<code>n</code>的增大，差异非常明显。通过观察发现，<strong>最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快。</strong><br>  我们来看最后一个例子。算法<code>G</code>是<code>2n^2</code>，算法<code>H</code>是<code>3n+1</code>，算法<code>I</code>是<code>2n^2+ 3n+1</code>：</p><table><tr align=center><th>次数</th><th>算法G（2n^2）</th><th>算法H（3n+1）</th><th>算法I（2n^2+3N+1）</th></tr><tr align=center><td>n = 1</td><td>2</td><td>4</td><td>6</td></tr><tr align=center><td>n = 2</td><td>8</td><td>7</td><td>15</td></tr><tr align=center><td>n = 5</td><td>50</td><td>16</td><td>66</td></tr><tr align=center><td>n = 10</td><td>200</td><td>31</td><td>231</td></tr><tr align=center><td>n = 100</td><td>20000</td><td>301</td><td>20301</td></tr><tr align=center><td>n = 1000</td><td>2000000</td><td>3001</td><td>2003001</td></tr><tr align=center><td>n = 10000</td><td>200000000</td><td>30001</td><td>200030001</td></tr><tr align=center><td>n = 100000</td><td>20000000000</td><td>300001</td><td>20000300001</td></tr><tr align=center><td>n = 1000000</td><td>2000000000000</td><td>3000001</td><td>2000003000001</td></tr></table><p>  这组数据应该就看得很清楚。当<code>n</code>的值越来越大时，你会发现，<code>3n+1</code>已经没法和<code>2n^2</code>的结果相比较，最终几乎可以忽略不计。也就是说，随着<code>n</code>值变得非常大以后，算法<code>G</code>其实已经很趋近于算法<code>I</code>。于是我们可以得到这样一个结论，<strong>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。</strong></p><p>  判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据刚才的几个样例，我们发现，如果我们可以对比这几个算法的关键执行次数函数的渐近增长性，基本就可以分析出：<strong>某个算法，随着n的增大，它会越来越优于另一算法，或者越来越差于另一算法。</strong> 这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。<br><br></p><h1 id="8-总结">8. 总结</h1><p>  <strong>算法的定义：</strong> 算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。<br>  <strong>算法的特性：</strong> 有穷性、确定性、可行性、输入、输出。<br>  <strong>算法的设计的要求：</strong> 正确性、可读性、健壮性、高效率和低存储量需求。算法特性与算法设计容易混，需要对比记忆。<br>  <strong>算法的度量方法：</strong> 事后统计方法（不科学、不准确)、事前分析估算方法。在讲解如何用事前分析估算方法之前，我们先给出了函数渐近增长的定义。<br>  <strong>函数的渐近增长：</strong> 给定两个函数<code>f(n)</code>和<code>g(n)</code>，如果存在一个整数<code>N</code>,使得对于所有的<code>n&gt;N</code>，<code>f(n)</code>总是比<code>g(n)</code>大，那么，我们说<code>f(n)</code>的增长渐近快于<code>g(n)</code>。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着<code>n</code>的变大，它会越来越优于另一算法，或者越来越差于另一算法。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法》（一）- 数据结构详解</title>
      <link href="/2021/10/11/algorithm_1/"/>
      <url>/2021/10/11/algorithm_1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >部分内容摘自程杰的《大话数据结构》</font></p><h1 id="1-基本概念和术语">1. 基本概念和术语</h1><p>  数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</p><h2 id="1-1-数据">1.1 数据</h2><p>  <strong>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</strong> 数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><p>  比如我们在浏览器上搜索，一般会有网页、图片、文字、音频等等。图片是图像数据，音频是声音数据，而网页其实指的就是全部数据的搜索，包括最重要的数字和字符等文字数据。<br>  也就是说，我们这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><ul><li>可以输入到计算机中</li><li>能被计算机程序处理</li></ul><p>  对于整型、实型等数值类型，可以进行数值计算。<br>  对于字符数据类型，就需要进行非数值的处理。而声音、图像、视频等都是可以通过编码的手段变成字符数据来处理的。</p><h2 id="1-2-数据元素">1.2 数据元素</h2><p>  <strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。</strong><br>  比如，人类的数据元素就是人，畜禽类的数据元素，就是牛、马、羊、猪、鸭、鸡等动物了。</p><h2 id="1-3-数据项">1.3 数据项</h2><p>  <strong>一个数据元素可以由最干戈数据项组成。</strong><br>  比如“人”这样的数据元素，可以由眼睛、耳朵、鼻子、嘴巴、手、脚这些数据项，也可以由姓名、年龄、性别、电话、家庭住址等等数据项，具体有哪些数据项，由你做的系统来决定。<br>  <strong>数据项是数据不可分割的最小单位。</strong> 但真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点。就像我们讨论一部电影时，是讨论这部电影角色这样的“数据元素”，而不是针对这个角色的姓名或者年龄这样的“数据项”去研究分析。</p><h2 id="1-4-数据对象">1.4 数据对象</h2><p>  <strong>是性质相同的数据元素的集合，是数据的子集。</strong><br>  性质相同是指数据元素具有相同数量和类型的数据项，比如，人都有姓名、生日、性别等相同的数据项。</p><h2 id="1-5-数据结构">1.5 数据结构</h2><p>  结构，简单的理解就是关系，比如分子结构，就是说组成分子的原子之间的排列方式。严格点说，结构是指各个组成部分相互搭配和排列的方式。<strong>在现实世界中，不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系成为结构。</strong><br>  <strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</strong> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。<br>为编写出一个“好”的程序，必须分析待处理对象的特性及各处理对象之前存在的关系。这也就是研究数据结构的意义所在。<br><br></p><h1 id="2-逻辑结构与物理结构">2. 逻辑结构与物理结构</h1><p>  数据结构分为逻辑结构和物理结构。</p><h2 id="2-1-逻辑结构">2.1 逻辑结构</h2><p>  逻辑结构是指数据对象中数据元素之间的相互关系。</p><h3 id="2-1-1-集合结构">2.1.1 集合结构</h3><p><img src="https://img-blog.csdnimg.cn/083745ff207440e881ccb304dd13ffcc.png#pic_center" alt="在这里插入图片描述"></p><p>  <strong>集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。</strong> 各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。数据结构中的集合关系就类似于数学中的集合。</p><h3 id="2-1-2-线性结构">2.1.2 线性结构</h3><p><img src="https://img-blog.csdnimg.cn/3365b197fa1b4e2cb7d4fef8db6660c6.png#pic_center" alt="在这里插入图片描述"></p><p>  <strong>线性结构中的数据元素之间是一对一的关系。</strong></p><h3 id="2-1-3-树形结构">2.1.3 树形结构</h3><p><img src="https://img-blog.csdnimg.cn/02799fc885974d9d905804c9cc31ee4a.png#pic_center" alt="在这里插入图片描述"></p><p>  <strong>树形结构中的数据元素之间存在一种一对多的层次关系。</strong></p><h3 id="2-1-4-图形结构">2.1.4 图形结构</h3><p><img src="https://img-blog.csdnimg.cn/c8781152b1694f2da7f382d15d6fec4d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_6,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>  <strong>图形结构的数据元素是多对多的关系。</strong><br><br></p><h2 id="2-2-物理结构">2.2 物理结构</h2><p>  <strong>物理结构是指数据的逻辑结构在计算机中的存储形式。</strong><br>  数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。<br>  数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。<br>数据元素的存储结构形式有两种：顺序存储和链式存储。</p><h3 id="2-2-1-顺序存储结构">2.2.1 顺序存储结构</h3><p><img src="https://img-blog.csdnimg.cn/7d5b16e885ea428bb8ed72f8cc792f26.png#pic_center" alt="在这里插入图片描述"></p><p>  <strong>顺序存储结构是指把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的。</strong><br>  这种存储结构说白了，就是排队占位。大家都按顺序排好，每个人占一小段空间，谁也别插谁的队。在计算机语言中，数组就是这样的顺序存储结构。</p><h3 id="2-2-2-链式存储结构">2.2.2 链式存储结构</h3><p><img src="https://img-blog.csdnimg.cn/e5011dc9f2c444b8b2973e5ccba2169b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_6,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><p>  <strong>链式存储结构是把数据元素放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</strong> 数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联的数据元素的位置。<br>  显然，链式存储就灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。</p><p>  逻辑结构是<code>面向问题</code>的，而物理结构就是<code>面向计算机</code>的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。<br><br></p><h1 id="3-数据类型">3. 数据类型</h1><p>  <strong>数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</strong></p><h2 id="3-1-数据类型的定义">3.1 数据类型的定义</h2><p>  数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p><p>  当年那些设计计算机语言的人，为什么会考虑到数据类型呢?<br>  比如，大家都需要住房子，也都希望房子越大越好。但显然,没有钱，考虑房子是没啥意义的。于是商品房就出现了各种各样的房型，有别墅的，有错层的，有单间的;有一百多平米的，也有几十平米的，甚至在北京还出现了胶囊公寓——只有两平米的房间………这样就满足了不同人的需要。</p><p>  同样，在计算机中，内存也不是无限大的，你要计算一个如<code>1+1=2</code>、<code>3+5=8</code>这样的整型数字的加减乘除运算，显然不需要开辟很大的适合小数甚至字符运算的内存空间。于是计算机的研究者们就考虑，要对数据进行分类，分出来多种数据类型。<br>  在C语言中,按照取值的不同,数据类型可以分为两类：</p><ul><li>原子类型:是不可以再分解的基本类型，包括整型、实型、字符型等。</li><li>结构类型:由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。</li></ul><p>  比如，在C语言中变量声明<code>int a</code>，<code>b</code>，这就意味着，在给变量<code>a</code>和<code>b</code>赋值时不能超出<code>int</code>的取值范围，变量<code>a</code>和<code>b</code>之间的运算只能是<code>int</code>类型所允许的运算。<br>  因为不同的计算机有不同的硬件系统，这就要求程序语言最终通过编译器或解释器转换成底层语言，如汇编语言甚至是通过机器语言的数据类型来实现的。可事实上，高级语言的编程者不管最终程序运行在什么计算机上，他的目的就是为了实现两个整型数字的运算，如<code>a+b</code>、<code>a-b</code>、<code>a×b</code>和<code>a/b</code>等，他才不关心整数在计算机内部是如何表示的，也不想知道CPU为了实现<code>1+2</code>进行几次开关操作，这些操作是如何实现的，对高级语言开发者来讲根本不重要。于是我们就会考虑，无论什么计算机、什么计算机语言，大都会面临着如整数运算、实数运算、字符运算等操作，我们可以考虑把它们都抽象出来。</p><p>  <strong>抽象是指抽取出事物具有的普遍性的本质。</strong> 它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p><h2 id="3-2-抽象数据类型">3.2 抽象数据类型</h2><p>  我们对已有的数据类型进行抽象，就有了抽象数据类型。<br>  <strong>抽象数据类型(Abstract Data Type，ADT):是指一个数学模型及定义在该模型上的一组操作。</strong> 抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。<br>  比如刚才的例子，各个计算机，不管是大型机、小型机、PC、平板电脑、PDA，甚至智能手机都拥有“整数”类型，也需要整数间的运算，那么整型其实就是一个抽象数据类型，尽管它在上面提到的这些在不同计算机中实现方法上可能不一样，但由于其定义的数学特性相同，在计算机编程者看来。它们都是相同的。因此，“抽象”的意义在于数据类型的数学抽象特性。<br>  而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型，比如我们编写关于计算机绘图或者地图类的软件系统，经常都会用到坐标。也就是说，总是有成对出现的<code>x</code>和<code>y</code>，在3D系统中还有<code>z</code>出现，既然这三个整型数字是始终在一起出现，我们就定义一个叫<code>point</code>的抽象数据类型，它有<code>x</code>、<code>y</code>、<code>z</code>三个整型变量，这样我们很方便地操作一个<code>point</code>数据变量就能知道这一点的坐标了。<br>  根据抽象数据类型的定义，它还包括定义在该模型上的一组操作。<br>  实际上，<strong>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。</strong> 抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。<br><br></p><h1 id="4-总结">4. 总结</h1><p><img src="https://img-blog.csdnimg.cn/2fbdbca3c5b543e4954fad60938c27e6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>  <strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</strong> 同样是结构，从不同的角度来讨论，也会有不同的分类。<br><img src="https://img-blog.csdnimg.cn/8bd7ae3a7f4048e08e9166ed0c6b4752.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 配额限速机制</title>
      <link href="/2021/09/18/kafka_12/"/>
      <url>/2021/09/18/kafka_12/</url>
      
        <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>生产者和消费者以极高的速度生产/消费大量数据或产生请求，从而占用broker上的全部资源，造成网络 IO 饱和。有了配额（Quotas）就可以避免这些问题。Kafka 支持配额管理，从而可以对 Producer 和 Consumer 的 produce&amp;fetch 操作进行流量限制，防止个别业务压爆服务器。</p><h1 id="限制producer端速率">限制producer端速率</h1><p>为所有 client id 设置默认值，以下为所有 producer 程序设置其 TPS 不超过 1MB/s，即 1048576/s，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-configs.sh --zookeeper IP:2181 --alter --add-config &#x27;producer_byte_rate=1048576&#x27; --entity-type clients --entity-default</span><br></pre></td></tr></table></figure><h1 id="限制consumer端速率">限制consumer端速率</h1><p>对consumer限速与producer类似，只不过参数名不一样。为指定的topic进行限速，以下为所有 consumer 程序设置topic速率不超过 1MB/s，即 1048576/s。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-configs.sh --zookeeper IP:2181 --alter --add-config &#x27;consumer_byte_rate=1048576&#x27; --entity-type clients --entity-default</span><br></pre></td></tr></table></figure><h1 id="取消Kafka的Quota配置">取消Kafka的Quota配置</h1><p>使用以下命令，删除Kafka的Quota配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-configs.sh --zookeeper IP:2181 --alter --delete-config &#x27;producer_byte_rate&#x27; --entity-type clients --entity-default</span><br><span class="line">./bin/kafka-configs.sh --zookeeper IP:2181 --alter --delete-config &#x27;consumer_byte_rate&#x27; --entity-type clients --entity-default</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 数据清理</title>
      <link href="/2021/09/18/kafka_11/"/>
      <url>/2021/09/18/kafka_11/</url>
      
        <content type="html"><![CDATA[<h1 id="kafka数据清理">kafka数据清理</h1><p>Kafka 的消息存储在磁盘中，为了控制磁盘占用空间，Kafka 需要不断地对过去的一些消息进行清理工作。Kafka 的每个分区都有很多的日志文件，这样也是为了方便进行日志的清理。在 Kafka 中，提供两种日志清理方式：</p><ul><li>日志删除（Log Deletion）：按照指定的策略直接删除不符合条件的日志。</li><li>日志压缩（Log Compaction）：按照消息的 key 进行整合，有相同 key 的但有不同 value 值，只保留最后一个版本。</li></ul><p>在Kafka的broker或topic配置中：</p><table><tr><th>配置项</th><th>配置值</th><th>说明</th></tr><tr><td>log.cleaner.enable</td><td>true（默认）</td><td>开启自动清理日志功能</td></tr><tr><td>log.cleanup.policy</td><td>delete（默认）</td><td>删除日志</td></tr><tr><td>log.cleanup.policy</td><td>compaction</td><td>压缩日志</td></tr><tr><td>log.cleanup.policy</td><td>delete，compact</td><td>同时支持删除、压缩</td></tr></table><p>日志删除是以段（segment日志）为单位来进行定期清理的。</p><h2 id="日志删除（Log-Deletion）">日志删除（Log Deletion）</h2><p>Kafka 日志管理器中会有一个专门的日志删除任务来定期检测和删除不符合保留条件的日志分段文件，这个周期可以通过 broker 端参数<code>log.retention.check.interval.ms</code>来配置，默认值为 300,000，即 5 分钟。当前日志分段的保留策略有 3 种：</p><ol><li>基于时间的保留策略</li><li>基于日志大小的保留策略</li><li>基于日志起始偏移量的保留策略</li></ol><p><img src="https://img-blog.csdnimg.cn/d36582ef2ea84f36b9b480396a1aae42.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="1-基于时间的保留策略">1. 基于时间的保留策略</h3><p>以下三种配置可以指定如果Kafka中的消息超过指定的阈值，就会将日志进行自动清理：</p><ul><li>log.retention.hours</li><li>log.retention.minutes</li><li><a href="http://log.retention.ms">log.retention.ms</a></li></ul><p>其中，优先级为<code>log.retention.ms &gt; log.retention.minutes &gt; log.retention.hours</code>。默认情况，在broker中，配置如下：<code>log.retention.hours=168</code>，也就是，默认日志的保留时间为 168 小时，相当于保留 7 天。</p><p>删除日志分段时：</p><ol><li>从日志文件对象中所维护日志分段的跳跃表中移除待删除的日志分段，以保证没有线程对这些日志分段进行读取操作</li><li>将日志分段文件添加上“.deleted”的后缀（也包括日志分段对应的索引文件）</li><li>Kafka 的后台定时任务会定期删除这些“.deleted”为后缀的文件，这个任务的延迟执行时间可以通过<code>file.delete.delay.ms</code>参数来设置，默认值为 60000，即 1 分钟。</li></ol><h3 id="2-基于日志大小的保留策略">2. 基于日志大小的保留策略</h3><p>日志删除任务会检查当前日志的大小是否超过设定的阈值来寻找可删除的日志分段的文件集合。可以通过 broker 端参数<code>log.retention.bytes</code>来配置，默认值为 -1，表示无穷大。如果超过该大小，会自动将超出部分删除。</p><p><font color=red>注意：</font><code>log.retention.bytes</code>配置的是日志文件的总大小，而不是单个的日志分段的大小，一个日志文件包含多个日志分段。</p><h3 id="3-基于日志起始偏移量保留策略">3. 基于日志起始偏移量保留策略</h3><p>每个 segment 日志都有它的起始偏移量，如果起始偏移量小于 logStartOffset，那么这些日志文件将会标记为删除。</p><h2 id="日志压缩（Log-Compaction）">日志压缩（Log Compaction）</h2><p>Log Compaction 是默认的日志删除之外的清理过时数据的方式。它会将相同的 key 对应的数据只保留一个版本。<br><img src="https://img-blog.csdnimg.cn/98dfc531a53547199dfcde635c5ba5e7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>Log Compaction 执行后，offset 将不再连续，但依然可以查询 Segment</li><li>Log Compaction 执行前后，日志分段中的每条消息偏移量保持不变。Log Compaction 会生成一个新的 Segment 文件</li><li>Log Compaction 是针对 key 的，在使用的时候注意每个消息的 key 不为空</li><li>基于 Log Compaction 可以保留 key 的最新更新，可以基于 Log Compaction 来恢复消费者的最新状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 高级&amp;低级 API、同异步发送及拦截器原理</title>
      <link href="/2021/09/18/kafka_10/"/>
      <url>/2021/09/18/kafka_10/</url>
      
        <content type="html"><![CDATA[<h1 id="一、高级API">一、高级API</h1><p><strong>优点：</strong></p><ul><li>不需要执行去管理 offset，直接通过 ZK 管理；也不需要管理分区、副本，由 Kafka 统一管理</li><li>消费者会自动根据上一次在 ZK 中保存的 offset 去接着获取数据</li><li>在 ZK 中，不同的消费者组（group）同一个 topic 记录不同的 offset，这样不同程序读取同一个 topic，不会受 offset 的影响</li></ul><p><strong>缺点：</strong></p><ul><li>不能控制offset，例如：想从指定的位置读取</li><li>不能细化控制分区、副本、ZK 等</li></ul><h2 id="1-自动提交offset">1. 自动提交offset</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_2ConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Kafka消费者配置</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.88.100:9092&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否开启自动提交 offset 功能</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="comment">// 自动提交 offset 的时间间隔</span></span><br><span class="line">        props.setProperty(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Kafka消费者</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅要消费的主题</span></span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一个while循环，不断从Kafka的topic中拉取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 定义100毫秒超时</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、低级API">二、低级API</h1><p>通过使用低级 API，我们可以自己来控制 offset，想从哪儿读，就可以从哪儿读。而且，可以自己控制连接分区，对分区自定义负载均衡。而且，之前 offset 是自动保存在 ZK 中，使用低级 API，我们可以将 offset 不一定要使用 ZK 存储，我们可以自己来存储 offset。例如：存储在文件、MySQL、或者内存中。但是低级 API，比较复杂，需要执行控制 offset，连接到哪个分区，并找到分区的 leader。<br><strong>优点：</strong></p><ul><li>能够开发者自己控制 offset，想从哪里读取就从哪里读取。</li><li>自行控制连接分区，对分区自定义进行负载均衡</li><li>对 zookeeper 的依赖性降低（如：offset 不一定非要靠 zk 存储，自行存储 offset 即可，比如存在文件或者内存中）</li></ul><p><strong>缺点：</strong></p><ul><li>太过复杂，需要自行控制 offset，连接哪个分区，找到分区 leader 等</li></ul><h2 id="1-手动提交offset">1. 手动提交offset</h2><p>虽然高级 API 自动提交 offset 十分简介便利，但由于其是基于时间提交的，开发人员难以把握 offset 提交的时机。因此 Kafka 还提供了手动提交 offset 的 API。<br>手动提交 offset 的方法有两种：分别是 commitSync（同步提交）和 commitAsync（异步提交）。两者的相同点是，都会将本次 poll 的一批数据最高的偏移量提交；不同点是， commitSync 阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致， 也会出现提交失败）；而 commitAsync 则没有失败重试机制，故有可能提交失败。</p><h3 id="1-1-同步提交offset">1.1. 同步提交offset</h3><p>同步提交 offset 有失败重试机制，故更加可靠</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomComsumer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//Kafka 集群</span></span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line"><span class="comment">//消费者组，只要 group.id 相同，就属于同一个消费者组</span></span><br><span class="line">props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//关闭自动提交offse</span></span><br><span class="line">props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者订阅主题</span></span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 消费者拉取数据</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同步提交，当前线程会阻塞直到 offset 提交成功</span></span><br><span class="line">consumer.commitSync();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-异步提交offset">1.2. 异步提交offset</h3><p>虽然同步提交 offset 更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会收到很大的影响。因此更多的情况下，会选用异步提交 offset 的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomConsumer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">// Kafka 集群</span></span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line"><span class="comment">// 消费者组，只要 group.id 相同，就属于同一个消费者组</span></span><br><span class="line">props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭自动提交 offset</span></span><br><span class="line">props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者订阅主题</span></span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 消费者拉取数据</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步提交</span></span><br><span class="line">consumer.commitAsync(<span class="keyword">new</span> <span class="title class_">OffsetCommitCallback</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(Map&lt;TopicPartition, </span></span><br><span class="line"><span class="params">OffsetAndMetadata&gt; offsets, Exception exception)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;Commit failed for&quot;</span> + offsets);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-数据漏消费和重复消费">1.3. 数据漏消费和重复消费</h3><p>无论是同步提交还是异步提交 offset，都有可能会造成数据的漏消费或者重复消费。先提交 offset 后消费，有可能造成数据的漏消费；而先消费后提交 offset，有可能会造成数据的重复消费。</p><h2 id="2-自定义存储offset">2. 自定义存储offset</h2><p>Kafka 0.9 版本之前，offset 存储在 zookeeper，0.9 版本及之后，默认将 offset 存储在 Kafka 的一个内置的topic 中。除此之外，Kafka 还可以选择自定义存储 offset。offset 的维护是相当繁琐的，因为需要考虑到消费者的 Rebalace（当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发生变化，就会触发到分区的重新分配，重新分配的过程叫做 Rebalance）。</p><p>消费者发生 Rebalance 之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的 offset 位置继续消费。要实现自定义存储 offset，需要借助 ConsumerRebalanceListener，以下为示例代码，其<br>中提交和获取offset 的方法，需要根据所选的 offset 存储系统自行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;TopicPartition, Long&gt; currentOffset = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建配置信息</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">// Kafka 集群</span></span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line"><span class="comment">// 消费者组，只要 group.id 相同，就属于同一个消费者组</span></span><br><span class="line">props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭自动提交offset</span></span><br><span class="line">props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line"><span class="comment">// Key 和 Value 的反序列化类</span></span><br><span class="line">props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个消费者</span></span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者订阅主题</span></span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">&quot;first&quot;</span>),<span class="keyword">new</span> <span class="title class_">ConsumerRebalanceListener</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法会在 Rebalance 之前调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line">commitOffset(currentOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法会在 Rebalance 之后调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line">currentOffset.clear();</span><br><span class="line"><span class="keyword">for</span> (TopicPartition partition : partitions) &#123;</span><br><span class="line"><span class="comment">// 定位到最近提交的 offset 位置继续消费</span></span><br><span class="line">consumer.seek(partition, getOffset(partition));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 消费者拉取数据</span></span><br><span class="line">ConsumerRecords&lt;String,String&gt;records= consumer.poll(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123; </span><br><span class="line">System.out.printf(<span class="string">&quot;offset =%d,key= %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value()); </span><br><span class="line">currentOffset.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition()), record.offset());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步提交</span></span><br><span class="line">commitOffset(currentOffset);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某分区的最新 offset</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getOffset</span><span class="params">(TopicPartition partition)</span> &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交该消费者所有分区的 offset</span></span><br><span class="line"><span class="keyword">private</span><span class="keyword">static</span> <span class="keyword">void</span><span class="title function_">commitOffset</span><span class="params">(Map&lt;TopicPartition, Long&gt; currentOffset)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、kafka-同步、异步发送">三、kafka 同步、异步发送</h1><p><img src="https://img-blog.csdnimg.cn/d69f9f9e7ab4483c9618bd11f5902684.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>Kafka 的 Producer 发送消息采用的是异步发送的方式</li><li>在消息发送的过程中，涉及到了两个线程——main 线程和 Sender 线程，以及一个线程共享变量——RecordAccumulator</li><li>main 线程将消息发送给 RecordAccumulator，消息根据 topic-partition 分类缓存</li><li>消息累积到<code>batch.size</code>或者时间达到了<code>linger.ms</code>，sender 线程将该批量的消息发送到 topic-partition 所在的 broker</li></ul><h2 id="1-异步发送">1. 异步发送</h2><h3 id="1-1-不带回调函数">1.1. 不带回调函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,InterruptedException &#123;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//kafka 集 群 ，broker-list</span></span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line"><span class="comment">//重试次数</span></span><br><span class="line">props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//批次大小</span></span><br><span class="line">props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line"><span class="comment">//等待时间</span></span><br><span class="line">props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//RecordAccumulator 缓冲区大小</span></span><br><span class="line">props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer =<span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 每条数据都要封装成一个ProducerRecord 对象</span></span><br><span class="line">producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;test&quot;</span>, <span class="literal">null</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-带回调函数">1.2. 带回调函数</h3><p>如果我们想获取生产者消息是否成功，或者成功生产消息到Kafka中后，执行一些其他动作。此时，可以很方便地使用带有回调函数来发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建用于连接Kafka的Properties配置</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;node1.itcast.cn:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        <span class="comment">//重试次数</span></span><br><span class="line">props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//批次大小</span></span><br><span class="line">props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line"><span class="comment">//等待时间</span></span><br><span class="line">props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//RecordAccumulator 缓冲区大小</span></span><br><span class="line">props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个生产者对象KafkaProducer</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用send发送1-100消息到指定Topic test</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 带回调函数异步方式</span></span><br><span class="line">            producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;test&quot;</span>, <span class="literal">null</span>, i + <span class="string">&quot;&quot;</span>), <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;发送消息出现异常&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> metadata.topic();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">partition</span> <span class="operator">=</span> metadata.partition();</span><br><span class="line">                        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> metadata.offset();</span><br><span class="line"><span class="comment">// 发送消息成功，打印Kafka的topic名字、分区id、offset</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;发送消息到Kafka中的名字为&quot;</span> + topic + <span class="string">&quot;的主题，第&quot;</span> + partition + <span class="string">&quot;分区，第&quot;</span> + offset + <span class="string">&quot;条数据成功!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭生产者</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-同步发送">2. 同步发送</h2><p>同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回 ack。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建用于连接Kafka的Properties配置</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.88.100:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个生产者对象KafkaProducer</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;String, String&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用send发送1-100消息到指定Topic test</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取返回值Future，该对象封装了返回值</span></span><br><span class="line">                Future&lt;RecordMetadata&gt; future = producer.send(<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(<span class="string">&quot;test&quot;</span>, <span class="literal">null</span>, i + <span class="string">&quot;&quot;</span>));</span><br><span class="line">                <span class="comment">// 调用一个Future.get()方法等待响应</span></span><br><span class="line">                future.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭生产者</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、自定义Interceptor">四、自定义Interceptor</h1><h2 id="1-拦截器原理">1. 拦截器原理</h2><p>Producer 拦截器(interceptor) 是在 Kafka 0.10 版本被引入的，主要用于实现 clients 端的定制化控制逻辑。<br>对于 producer 而言，interceptor 使得用户在消息发送前以及 producer 回调逻辑前有机会对消息做一些定制化需求，比如<code>修改消息</code>等。同时，producer 允许用户指定多个 interceptor 按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor 的实现接口是<code>org.apache.kafka.clients.producer.ProducerInterceptor</code>，其定义的方法包括：</p><ul><li><strong>configure(configs)</strong><ul><li>获取配置信息和初始化数据时调用</li></ul></li><li><strong>onSend(ProducerRecord)</strong><ul><li>该方法封装进 KafkaProducer.send 方法中，即它运行在用户主线程中。Producer 确保在消息被序列化以及计算分区前调用该方法。<code>用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区</code>，否则会影响目标分区的计算。</li></ul></li><li><strong>onAcknowledgement(RecordMetadata, Exception)</strong><ul><li><code>该方法会在消息从RecordAccumulator 成功发送到Kafka Broker之后，或者在发送过程中失败时调用。</code>并且通常都是在 producer 回调逻辑触发之前。onAcknowledgement 运行在producer 的 IO 线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢 producer 的消息发送效率。</li></ul></li><li><strong>close</strong><ul><li>关闭 interceptor，主要用于执行一些资源清理工作</li></ul></li></ul><p>如前所述，interceptor 可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外<code>倘若指定了多个interceptor，则producer将按照指定顺序调用它们</code>，并仅仅是捕获每个interceptor 可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中要特别留意。</p><h2 id="2-拦截器案例">2. 拦截器案例</h2><p><strong>需求：</strong> 实现一个简单的双 interceptor 组成的拦截链。第一个 interceptor 会在消息发送前将时间戳信息加到消息 value 的最前部；第二个 interceptor 会在消息发送后更新成功发送消息数或失败发送消息数。<br><img src="https://img-blog.csdnimg.cn/4c7be0fae7254ed08b972ca688a28dc1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>实操：</strong></p><ol><li>增加时间戳拦截器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ProducerInterceptor</span>&lt;String, String&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title function_">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个新的 record，把时间戳写入消息体的最前部</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>(record.topic(), record.partition(), record.timestamp(), record.key(), System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + record.value().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>统计发送消息成功和发送失败消息数，并在 producer 关闭时打印这两个计数器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ProducerInterceptor</span>&lt;String, String&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">errorCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">successCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title function_">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> record;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line"><span class="comment">// 统计成功和失败的次数</span></span><br><span class="line"><span class="keyword">if</span> (exception == <span class="literal">null</span>) &#123;</span><br><span class="line">successCounter++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">errorCounter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 保存结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;Successful sent: &quot;</span> + successCounter);</span><br><span class="line">System.out.println(<span class="string">&quot;Failed sent: &quot;</span> + errorCounter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>producer 主程序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorProducer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 1 设置配置信息</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">3</span>);</span><br><span class="line">props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"><span class="comment">// 2 构建拦截链</span></span><br><span class="line">List&lt;String&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">interceptors.add(<span class="string">&quot;com.atguigu.kafka.interceptor.TimeInterceptor&quot;</span>); </span><br><span class="line">interceptors.add(<span class="string">&quot;com.atguigu.kafka.interceptor.CounterInterceptor&quot;</span>); </span><br><span class="line"></span><br><span class="line">props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;first&quot;</span>;</span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 发送消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, <span class="string">&quot;message&quot;</span> + i);</span><br><span class="line"> producer.send(record);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 一定要关闭 producer，这样才会调用 interceptor 的 close 方法</span></span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 生产、消费数据的工作流程</title>
      <link href="/2021/09/18/kafka_9/"/>
      <url>/2021/09/18/kafka_9/</url>
      
        <content type="html"><![CDATA[<h1 id="1-生产者写入数据流程">1. 生产者写入数据流程</h1><p><img src="https://img-blog.csdnimg.cn/278fffa05fe44cd892ae40be47af4ca9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>生产者先从 zookeeper 的 &quot;/brokers/topics/主题名/partitions/分区名/state&quot;节点找到该 partition 的 leader</li><li>生产者将消息发送给作为 leader 的 partition</li><li>leader 收到消息后，将消息写入到本地 log 中</li><li>follower 从 leader 上拉取消息，写入到本地 log，并向 leader 发送 ACK</li><li>leader 接收到所有的 ISR 中的 Replica 的 ACK 后，并向生产者返回 ACK</li><li>生产者收到 leader 的 ACK，证明生产的数据已被 kafka 成功写入</li></ol><h1 id="2-消费者消费数据流程">2. 消费者消费数据流程</h1><p><img src="https://img-blog.csdnimg.cn/74bfd444994d4a5d9d62a2b557a3c871.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>kafka 采用拉取模型，由消费者自己记录消费状态，每个消费者互相独立地顺序拉取每个分区的消息</li><li>消费者可以按照任意的顺序消费消息。比如，消费者可以重置到旧的偏移量，重新处理之前已经消费过的消息；或者直接跳到最近的位置，从当前的时刻开始消费。</li></ul><p><img src="https://img-blog.csdnimg.cn/aea0d4b88a4d457db471e4f3d3ebaae6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li>每个 consumer 都可以根据分配策略（默认RangeAssignor），获得要消费的分区</li><li>获取到 consumer 对应的 offset（默认从 ZK 中获取上一次消费的offset）</li><li>找到该分区的 leader，拉取数据</li><li>消费者提交 offset</li></ol>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 分区分配策略</title>
      <link href="/2021/09/18/kafka_8/"/>
      <url>/2021/09/18/kafka_8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、分区是什么">一、分区是什么</h1><p>从整体上来说，一个 Kafka 集群有多个机器（一个机器就是一个 Broker），创建一个 Topic 是针对集群创建的，也就是说一个集群共享一个 Topic。一个Topic 可以有多个分区，如果机器数量够用的话，多个分区会在不同的 Broker 上，当然如果 Broker 不够用，那么一个 Broker 就可能保存一个 Topic 的多个分区。</p><p>那么分区是什么呢？简单来说就是，生产者会源源不断的发送数据给Topic，如果生产者没有指定发送到哪个分区的话，那么这些数据会按照一定的策略分发到这个Topic的几个分区，即多个分区中都有数据，这样就无法保证数据整体的有序性存储。</p><p><strong>为什么分区？</strong></p><ul><li>方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic 又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了；</li><li>可以提高并发，因为可以以 Partition 为单位读写了</li></ul><h1 id="二、生产者分区写入策略">二、生产者分区写入策略</h1><h2 id="1-轮询分区">1. 轮询分区</h2><p><img src="https://img-blog.csdnimg.cn/880002446d5b4130a06a1452a4e47b4e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>默认的策略，也是使用最多的策略，可以最大限度保证所有消息平均分配到一个分区</li><li>如果在生产消息时，key为 null，则使用轮询算法均衡地分配分区</li></ul><h2 id="2-随机策略">2. 随机策略</h2><p><img src="https://img-blog.csdnimg.cn/355663de04114454831f825294087402.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>随机策略，每次都随机地将消息分配到每个分区。在较早的版本，默认的分区策略就是随机策略，也是为了将消息均衡地写入到每个分区。但后续轮询策略表现更佳，所以基本上很少会使用随机策略。</p><h2 id="3-按key分配策略">3. 按key分配策略</h2><p><img src="https://img-blog.csdnimg.cn/af0548a81e844a9588a6b2a89916066f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>按key分配策略，有可能会出现「数据倾斜」，例如：某个 key 包含了大量的数据，因为key值一样，所有所有的数据将都分配到一个分区中，造成该分区的消息数量远大于其他的分区。<br>轮询策略、随机策略都会导致一个问题，生产到 Kafka 中的数据是<code>乱序存储</code>的。而按 key 分区可以一定程度上实现数据有序存储——也就是局部有序，但这又可能会导致数据倾斜，所以在实际生产环境中要结合实际情况来做取舍。</p><h2 id="4-自定义分区策略">4. 自定义分区策略</h2><p><img src="https://img-blog.csdnimg.cn/960c7aabe24b45bd8c6077a2cc15ab54.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>创建自定义分区器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyWithRandomPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random r;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line">        r = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">        <span class="comment">// cluster.partitionCountForTopic 表示获取指定topic的分区数量</span></span><br><span class="line">        <span class="keyword">return</span> r.nextInt(<span class="number">1000</span>) % cluster.partitionCountForTopic(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、消费者组Rebalance机制">三、消费者组Rebalance机制</h1><p>Kafka 中的 Rebalance 称之为再均衡，是 Kafka 中确保 Consumer group 下所有的 consumer 如何达成一致，分配订阅的 topic 的每个分区的机制。<br>Rebalance 触发的时机有：</p><ol><li>消费者组中 consumer 的个数发生变化。例如：有新的 consumer 加入到消费者组，或者是某个 consumer 停止了。<br><img src="https://img-blog.csdnimg.cn/5f6c58a115e04f8a9692dbfe0699a89f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>订阅的 topic 个数发生变化<br>消费者可以订阅多个主题，假设当前的消费者组订阅了三个主题，但有一个主题突然被删除了，此时也需要发生再均衡。<br><img src="https://img-blog.csdnimg.cn/ab3d224e963d48b183d66ae32491c1aa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>订阅的 topic 分区数发生变化<br><img src="https://img-blog.csdnimg.cn/135ea25ff17346f596a9057af7f6ed65.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><p><strong>Rebalance的不良影响：</strong></p><ul><li>发生 Rebalance 时，consumer group 下的所有 consumer 都会协调在一起共同参与，Kafka 使用分配策略尽可能达到最公平的分配</li><li>Rebalance 过程会对 consumer group 产生非常严重的影响，Rebalance 的过程中所有的消费者都将停止工作，直到 Rebalance 完成</li></ul><h1 id="四、消费者分区分配策略">四、消费者分区分配策略</h1><h2 id="1-Range范围分配策略">1. Range范围分配策略</h2><p>Range 范围分配策略是 Kafka 默认的分配策略，它可以确保每个消费者消费的分区数量是均衡的。<br><font color=red>注意：</font>Rangle 范围分配策略是针对每个 Topic 的。</p><p><strong>配置：</strong><br>配置消费者的<code>partition.assignment.strategy</code>为<code>org.apache.kafka.clients.consumer.RangeAssignor</code>。</p><p><strong>算法公式：</strong><br><code>n = 分区数量 / 消费者数量</code><br><code>m = 分区数量 % 消费者数量</code><br><code>前m个消费者消费n+1个</code><br><code>剩余消费者消费n个</code><br><img src="https://img-blog.csdnimg.cn/b4902f93a24b49e0a8839ab12be3fc69.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4ef1e8822f694801967aa4c8d95c1439.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-RoundRobin轮询策略">2. RoundRobin轮询策略</h2><p>RoundRobinAssignor 轮询策略是将消费组内所有消费者以及消费者所订阅的所有 topic 的 partition 按照字典序排序（topic 和分区的 hashcode 进行排序），然后通过轮询方式逐个将分区以此分配给每个消费者。</p><p><strong>配置：</strong><br>配置消费者的<code>partition.assignment.strategy</code>为<code>org.apache.kafka.clients.consumer.RoundRobinAssignor</code>。<br><img src="https://img-blog.csdnimg.cn/cee1b4b849444e189df197b05b9cb3ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="3-Stricky粘性分配策略">3. Stricky粘性分配策略</h2><p>从 Kafka 0.11.x 开始，引入此类分配策略。主要目的：</p><ol><li>分区分配尽可能均匀</li><li>在发生 rebalance 的时候，分区的分配尽可能与上一次分配保持相同</li></ol><p>没有发生 rebalance 时，Striky 粘性分配策略和 RoundRobin 分配策略类似。<br><img src="https://img-blog.csdnimg.cn/af8c5afdcbb64cf2be26540c03646511.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>上面如果 consumer2 崩溃了，此时需要进行 rebalance。如果是 Range 分配和轮询分配都会重新进行分配，例如：<br><img src="https://img-blog.csdnimg.cn/00ecb89f669f4a2f819de134c144c48c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>通过上图，我们发现，consumer0 和 consumer1 原来消费的分区大多发生了改变。接下来我们再来看下粘性分配策略：<br><img src="https://img-blog.csdnimg.cn/0be8ea122721427ca92ef6550f07a138.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我们发现，Striky 粘性分配策略，保留 rebalance 之前的分配结果。这样，只是将原先 consumer2 负责的两个分区再均匀分配给 consumer0、consumer1。这样可以明显减少系统资源的浪费，例如：之前 consumer0、consumer1 之前正在消费某几个分区，但由于 rebalance 发生，导致 consumer0、consumer1 需要重新消费之前正在处理的分区，导致不必要的系统开销。（例如：某个事务正在进行就必须要取消了）</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 的幂等性和事务</title>
      <link href="/2021/09/17/kafka_7/"/>
      <url>/2021/09/17/kafka_7/</url>
      
        <content type="html"><![CDATA[<h1 id="幂等性">幂等性</h1><h2 id="1-简介">1. 简介</h2><p>Kafka在 0.11 版本引入了一项重大特性，幂等性。所谓的幂等性就是指 Producer 不论向 Server 发送多少次重复数据，Server 端都只会持久化一条。<br>拿 http 举例来说，一次或多次请求，得到的响应是一致的（网络超时等问题除外），换句话说，就是执行多次操作与执行一次操作的影响是一样的。<br><img src="https://img-blog.csdnimg.cn/d249988b4b4e4657ae49c53220d5580e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>如果，某个系统是不具备幂等性的，如果用户重复提交了某个表格，就可能会造成不良影响。例如：用户在浏览器上点击了多次提交订单按钮，会在后台生成多个一模一样的订单。</p><h2 id="2-生产者幂等性">2. 生产者幂等性</h2><p><img src="https://img-blog.csdnimg.cn/c36ebfb87b95487f88d481ad936ccd30.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>对于Kafka来说，要解决的是生产者发送消息的幂等问题。在生产者生产消息时，如果出现 retry 时，有可能会一条消息被发送了多次，如果Kafka不具备幂等性的，就有可能会在partition中保存多条一模一样的消息。</p><p>为了实现生产者的幂等性，Kafka 引入了 Producer ID（PID）和 Sequence Number 的概念。</p><ul><li>PID：每个 Producer 在初始化时，都会分配一个唯一的 PID，这个 PID 对用户来说，是透明的。</li><li>Sequence Number：针对每个生产者（对应 PID ）发送到指定主题分区的消息都对应一个从 0 开始递增的 Sequence Number。</li></ul><p><img src="https://img-blog.csdnimg.cn/65d24203c9764651a9238dd5ed887df4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>当 Producer 发送消息给 Broker 时，Broker 接收到消息并将其追加到消息流中。此时，Broker 返回 Ack 信号给 Producer 时，发生异常导致 Producer 接收 Ack 信号失败。对于 Producer 来说，会触发重试机制，将消息再次发送，但是，由于引入了幂等性，在每条消息中附带了 PID（Producer ID）和Sequence Number。相同的 PID 和 Sequence Number 发送给 Broker，而之前 Broker 缓存过之前发送的相同的消息，那么在消息流中的消息就只有一条，不会出现重复发送的情况。</p><ul><li><strong>幂等性 Producer 只能保证单分区上的幂等性</strong><ul><li>即只能保证某个主题上的一个分区上不出现重复消息，无法实现多个分区的幂等性</li></ul></li><li><strong>幂等性 Producer 只能实现单会话上的幂等性，不能实现跨会话的幂等性</strong><ul><li>会话：Producer 进程的一次运行，如果重启 Producer 进程，将丢失幂等性保证</li></ul></li></ul><p><strong>配置幂等性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(<span class="string">&quot;enable.idempotence&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="2-Exactly-Once语义">2. Exactly Once语义</h2><p>将服务器的 ACK 级别设置为-1，可以保证 Producer 到 Server 之间不会丢失数据，即 <code>At Least Once（至少一次） 语义</code>。相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被发送一次，即<code>At Most Once（最多一次） 语义</code>。<br>At Least Once 可以保证数据不丢失，但是不能保证数据不重复；相对的，At Least Once 可以保证数据不重复，但是不能保证数据不丢失。<code>但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once（刚好一次） 语义</code>。在 0.11 版本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。</p><p>0.11 版本的 Kafka，引入了一项重大特性：幂等性。幂等性结合 At Least Once 语义，就构成了 Kafka 的Exactly Once 语义。即：<br><code>At Least Once + 幂等性 = Exactly Once</code><br>Kafka 的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。</p><h1 id="事务">事务</h1><h2 id="1-简介-2">1. 简介</h2><p>幂等性并不能跨多个分区运作，而事务可以弥补这个缺陷。Kafka 事务是 2017 年 Kafka 0.11 引入的新特性。类似于数据库的事务。Kafka 事务指的是在 Exactly Once 语义的基础上，生产和消费可以跨分区和会话，生产者生产消息以及消费者提交 offset 的操作可以在一个原子操作中，要么都成功，要么都失败。尤其是在生产者、消费者并存时，事务的保障尤其重要。（consumer-transform-producer模式）<br><img src="https://img-blog.csdnimg.cn/7c7e4244e32048838258891970690008.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="2-Producer事务">2. Producer事务</h2><p>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的 PID 和 Transaction ID 绑定。这样当 Producer 重启后就可以通过正在进行的Transaction ID 获得原来的PID。<br>为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p><h2 id="3-Consumer事务">3. Consumer事务</h2><p>上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对较弱，尤其是无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 如何保证数据的可靠性</title>
      <link href="/2021/09/17/kafka_6/"/>
      <url>/2021/09/17/kafka_6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据的可靠性保证">1. 数据的可靠性保证</h1><p><img src="https://img-blog.csdnimg.cn/0e3028c471cf47e5b2be16faf5a43d9c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 的每个 partition 收到producer 发送的数据后，都需要向 producer 发送 ack（acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</p><h1 id="2-副本数据同步策略">2. 副本数据同步策略</h1><table><tr><th>方案</th><th>优点</th><th>缺点</th></tr><tr><td>半数以上完成同步，就发送 ack</td><td>延迟低</td><td>选举新的 leader 时，容忍 n 台节点的故障，需要 2n+1 个副本</td></tr><tr><td>全部完成同步，才发送 ack</td><td>选举新的 leader 时，容忍 n 台节点的故障，需要 n+1 个副本</td><td>延迟高</td></tr></table><p>Kafka 选择了第二种方案，原因如下：</p><ol><li>同样为了容忍 n 台节点的故障，第一种方案需要 2n+1 个副本，而第二种方案只需要 n+1 个副本，而Kafka 的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</li><li>虽然第二种方案的网络延迟会比较高，但网络延迟对 Kafka 的影响较小。</li></ol><h1 id="3-AR、ISR、OSR">3. AR、ISR、OSR</h1><p>采用第二种方案之后，设想以下情景：leader 收到数据，所有 follower 都开始同步数据， 但有一个 follower，因为某种故障，迟迟不能与 leader 进行同步，那 leader 就要一直等下去， 直到它完成同步，才能发送 ack。这个问题怎么解决呢？<br><img src="https://img-blog.csdnimg.cn/e6ad21393c854b6ab885c2041bf7e06b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>Kafka中，把 follower 可以按照不同状态分为三类 —— AR、ISR、OSR。</p><ul><li>分区的所有副本称为 「AR」（Assigned Replicas —— 已分配的副本）</li><li>所有与leader副本保持一定程度同步的副本（包括 leader 副本在内）组成 「ISR」（In-Sync Replicas——在同步中的副本）</li><li>由于 follower 副本同步滞后过多的副本（不包括 leader 副本）组成 「OSR」（Out-of-Sync Replias）</li><li>AR = ISR + OSR</li><li>正常情况下，所有的 follower 副本都应该与 leader 副本保持同步，即 AR = ISR，OSR 集合为空。</li></ul><p>Leader 维护了一个动态的 <code>in-sync replica set (ISR)</code>，意为和 leader 保持同步的 follower 集合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间 未 向 leader 同 步 数 据 ， 则 该 follower 将 被 踢 出 ISR ， 该 时 间 阈 值 由<code>replica.lag.time.max.ms</code> 参数设定。Leader 发生故障之后，就会从 ISR 中选举新的 leader。</p><h1 id="4-ACK应答机制">4. ACK应答机制</h1><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失， 所以没必要等 ISR 中的 follower 全部接收成功。<br>所以 Kafka 为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡， 选择以下的配置：</p><ul><li><p>0：producer 不等待 broker 的 ack，这一操作提供了一个最低的延迟，broker 一接收到还没有写入磁盘就已经返回，当 broker 故障时有可能<code>丢失数据</code>；<br><img src="https://img-blog.csdnimg.cn/8aef277899824f3f9b112c82c1b3b383.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>1：producer 等待broker 的 ack，partition 的 leader 落盘成功后返回 ack<br><img src="https://img-blog.csdnimg.cn/c0545fa9da694426803ae9b44f906021.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>如果在 follower 同步成功之前leader 故障，那么将会<code>丢失数据</code>；<br><img src="https://img-blog.csdnimg.cn/e5ae20055290413a9953030d7a603e3a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>-1（all）：producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才返回 ack<br><img src="https://img-blog.csdnimg.cn/adef797606b84c53834ab0ee07bee944.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会造成<code>数据重复</code>。<br><img src="https://img-blog.csdnimg.cn/302f0a1a54e44a128e3b01a12c24c1ea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h1 id="5-分区的leader和follower">5. 分区的leader和follower</h1><p>在 Kafka 中，每个 topic 都可以配置多个分区以及多个副本。每个分区都有一个 leader 以及 0 个或者多个follower，在创建 topic 时，Kafka 会将每个分区的 leader 均匀地分配在每个 broker 上。我们正常使用 kafka 是感觉不到 leader、follower 的存在的。但其实，所有的读写操作都是由 leader 处理，而所有的 follower 都复制 leader 的日志数据文件，如果 leader 出现故障时，follower 就会被选举为 leader。所以，可以这样说：<br><img src="https://img-blog.csdnimg.cn/4ae8ea7e39c94b3da7da6e86709c2013.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>Kafka 中的 leader 负责处理读写操作，而 follower 只负责副本数据的同步</li><li>如果 leader 出现故障，其他 follower 会被重新选举为 leader</li><li>follower 像一个 consumer 一样，拉取 leader 对应分区的数据，并保存到日志数据文件中</li></ul><h1 id="6-故障处理">6. 故障处理</h1><p><img src="https://img-blog.csdnimg.cn/87e8dfa492b04e68b375eee714ab3c4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>LEO：指的是每个副本最大的 offset；</strong><br><strong>HW：指的是消费者能见到的最大的 offset，ISR 队列中最小的 LEO</strong></p><ul><li><strong>follower 故障</strong><ul><li>follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重新加入 ISR 了。</li></ul></li><li><strong>leader 故障</strong><ul><li>leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader同步数据。<br><font color=red><strong>注：</strong></font>这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</li></ul></li></ul><h1 id="7-Controller介绍">7. Controller介绍</h1><ul><li>Kafka 启动时，会在所有的 broker 中选择一个 controller</li><li>前面 leader 和 follower 是针对 partition，而 controller 是针对 broker 的</li><li>创建 topic、或者添加分区、修改副本数量之类的管理任务都是由 controller 完成的</li><li>Kafka 分区 leader 的选举，也是由 controller 决定的</li></ul><h1 id="8-Controller的选举">8. Controller的选举</h1><ul><li>在 Kafka 集群启动的时候，每个 broker 都会尝试去 ZooKeeper 上注册成为 Controller（ZK临时节点）</li><li>但只有一个竞争成功，其他的 broker 会注册该节点的监视器</li><li>一但该临时节点状态发生变化，就可以进行相应的处理</li><li>Controller 也是高可用的，一旦某个 broker 崩溃，其他的 broker 会重新注册为 Controller</li></ul><h1 id="9-Controller选举partition-leader">9. Controller选举partition leader</h1><ul><li>所有 Partition 的 leader 选举都由 controller 决定</li><li>controller 会将 leader 的改变直接通过 RPC 的方式通知需为此作出响应的 Broker</li><li>controller 读取到当前分区的 ISR，只要有一个 Replica 还幸存，就选择其中一个作为 leader，否则，则任意选择一个 Replica 作为 leader</li><li>如果该 partition 的所有 Replica 都已经宕机，则新的 leader 为 -1</li></ul><p><strong>为什么不能通过ZK的方式来选举partition的leader？</strong></p><ul><li>Kafka 集群如果业务很多的情况下，会有很多的 partition</li><li>假设某个 broker 宕机，就会出现很多的 partiton 都需要重新选举 leader</li><li>如果使用 zookeeper 选举 leader，会给 zookeeper 带来巨大的压力。所以，kafka 中 leader 的选举不能使用 ZK 来实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 的文件存储机制</title>
      <link href="/2021/09/16/kafka_5/"/>
      <url>/2021/09/16/kafka_5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据存储形式">1. 数据存储形式</h1><p><img src="https://img-blog.csdnimg.cn/c8fe76420dfd4233aa52c1edbfb6597e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>Kafka 中消息是以 topic 进行分类的，生产者生产消息，消费者消费消息，都是面向 topic 的。<br>topic 是逻辑上的概念，而 partition 是物理上的概念，每个 partition 对应于一个 log 文件，该 log 文件中存储的就是 producer 生产的数据。Producer 生产的数据会被不断追加到该log 文件末端，且每条数据都有自己的 offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个offset，以便出错恢复时，从上次的位置继续消费。<br><img src="https://img-blog.csdnimg.cn/775dd36d6f8d4fee8e8fc089dc150129.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>一个topic由多个分区组成</li><li>一个分区（partition）由多个 segment（段）组成</li><li>一个 segment（段）由多个文件组成（log、index、timeindex）</li></ul><h1 id="2-日志文件">2. 日志文件</h1><p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka 采取了<code>分片</code>和<code>索引</code>机制，将每个 partition 分为多个 segment。<br>每个 segment 对应三个文件——“.index”文件、“.log”文件和“.timeindex”文件。这些文件位于一个文件夹下，该文件夹的命名规则为：<code>topic名称+分区序号</code>。例如，first 这个 topic 有三个分区，则其对应的文件夹为 first- 0，first-1，first-2，数据文件夹总包含以下内容：<br><img src="https://img-blog.csdnimg.cn/c7ed702ef8ce4628a27e42dfebbd2830.png" alt="在这里插入图片描述"></p><table><tr><th>文件名</th><th>说明</th></tr><tr><td>00000000000169821432.index</td><td>索引文件，根据offset查找数据就是通过该索引文件来操作的</td></tr><tr><td>00000000000169821432.log</td><td>日志数据文件</td></tr><tr><td>00000000000169821432.timeindex</td><td>时间索引</td></tr><tr><td>leader-epoch-checkpoint</td><td>持久化每个partition leader对应的LEO（log end offset、日志文件中下一条待写入消息的offset）</td></tr><tr><td>partition.metadata</td><td>分区的元数据</td></tr></table><ul><li>每个日志文件的文件名为起始偏移量，因为每个分区的起始偏移量是0，所以，分区的日志文件都以<code>0000000000000000000.log</code>开始</li><li>默认的每个日志文件最大为<code>「log.segment.bytes=1024*1024*1024」1G</code></li><li>为了简化根据offset查找消息，Kafka日志文件名设计为开始的偏移量</li></ul><h1 id="3-写入消息">3. 写入消息</h1><p><img src="https://img-blog.csdnimg.cn/4ac6032d592d4cd89903b94005683572.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>新的消息总是写入到最后的一个日志文件中</li><li>该文件如果到达指定的大小（默认为：1GB）时，将滚动到一个新的文件中</li></ul><h1 id="4-读取消息">4. 读取消息</h1><p><img src="https://img-blog.csdnimg.cn/735f926ed64a412aae38026a24421df3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>根据「offset」首先需要找到存储数据的 segment 段（注意：offset指定分区的全局偏移量）</li><li>然后根据这个「全局分区offset」找到相对于文件的「segment段offset」</li></ul><p><img src="https://img-blog.csdnimg.cn/1ff6ff7702d14ddebcc4dc6307517568.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><ul><li>最后再根据 「segment 段 offset」读取消息</li><li>为了提高查询效率，每个文件都会维护对应的范围内存，查找的时候就是使用简单的二分查找</li></ul><h1 id="5-删除消息">5. 删除消息</h1><ul><li>在Kafka中，消息是会被定期清理的。一次删除一个segment段的日志文件</li><li>Kafka的日志管理器，会根据Kafka的配置，来决定哪些文件可以被删除</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 基础架构及命令行操作</title>
      <link href="/2021/09/08/kafka_4/"/>
      <url>/2021/09/08/kafka_4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Kafka基础架构">1. Kafka基础架构</h1><p><img src="https://img-blog.csdnimg.cn/8f5b55adfd674a68ac2342ea26a45881.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li><strong>Producer</strong><ul><li>消息生产者，负责将数据推送给 broker 的 topic</li></ul></li><li><strong>Consumer</strong><ul><li>消息消费者，负责从 broker 的 topic 中拉取数据，并自己进行处理</li></ul></li><li><strong>Consumer Group</strong><br><img src="https://img-blog.csdnimg.cn/cac70a3e1b0a4998b081427ccef51b21.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><ul><li>consumer group 是 kafka 提供的可扩展且具有容错性的消费者机制</li><li>一个消费者组可以包含多个消费者</li><li>一个消费者组有一个唯一的 ID（group Id）</li><li>消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费</li><li>所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者</li><li>消费者组之间互不影响</li></ul></li><li><strong>Broker</strong><br><img src="https://img-blog.csdnimg.cn/11caa886be92441d9555af2773ed58d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><ul><li>一台 kafka 服务器就是一个 broker，一个 broker 可以容纳多个topic</li><li>一个集群由多个 broker 组成，这样才能实现负载均衡、以及容错</li><li>broker是无状态（Sateless）的，它们是通过 ZooKeeper 来维护集群状态</li><li>一个Kafka的broker每秒可以处理数十万次读写，每个broker都可以处理TB消息而不影响性能</li></ul></li><li><strong>Zookeeper</strong><ul><li>ZK 用来管理和协调 broker，并且存储了 Kafka 的元数据（例如：有多少topic、partition、consumer）</li><li>ZK 服务主要用于通知生产者和消费者 Kafka 集群中有新的 broker 加入、或者 Kafka 集群中出现故障的 broker</li><li>Kafka 正在逐步想办法将 ZooKeeper 剥离，维护两套集群成本较高，社区提出 KIP-500 就是要替换掉 ZooKeeper 的依赖。“Kafka on Kafka”——Kafka 自己来管理自己的元数据</li></ul></li><li><strong>Partitions</strong><br><img src="https://img-blog.csdnimg.cn/f3717129ae3346bcad0a8d04cbcc9c9d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><ul><li>为了实现扩展性，一个非常大的 topic 可以分布到多个broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列</li></ul></li><li><strong>Replicas</strong><br><img src="https://img-blog.csdnimg.cn/8be5292048d049ed8fb8c1574985c65e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><ul><li>副本可以确保某个服务器出现故障时，确保数据依然可用</li><li>一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower</li><li>在Kafka中，一般都会设计副本的个数＞1</li></ul></li><li><strong>Topic</strong><br><img src="https://img-blog.csdnimg.cn/788d5c9f4cae46cab0e5d14ffbf49995.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><ul><li>主题是一个逻辑概念，用于生产者发布数据，消费者拉取数据</li><li>Kafka 中的主题必须要有标识符，而且是唯一的，Kafka 中可以有任意数量的主题，没有数量上的限制</li><li>在主题中的消息是有结构的，一般一个主题包含某一类消息</li><li>一旦生产者发送消息到主题中，这些消息就不能被更新（更改）</li></ul></li><li><strong>Offset</strong><br><img src="https://img-blog.csdnimg.cn/0be61eb9078843d28c38089a45a237e4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><ul><li>offset 记录着下一条将要发送给 Consumer 的消息的序号</li><li>默认 Kafka 将 offset 存储在 ZooKeeper 中</li><li>在一个分区中，消息是有顺序的方式存储着，每个在分区的消费都是有一个递增的 id，这个就是偏移量 offset</li><li>偏移量在分区中才是有意义的。在分区之间，offset是没有任何意义的</li></ul></li><li><strong>leader</strong><ul><li>每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 leader</li></ul></li><li><strong>follower</strong><ul><li>每个分区多个副本中的“从”，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 会成为新的 follower。</li></ul></li></ul><h1 id="2-Kafka的命令行操作">2. Kafka的命令行操作</h1><ul><li><strong>启动内置zookeeper</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br><span class="line">-daemon使用守护进程启动</span><br></pre></td></tr></table></figure><ul><li><strong>启动kafka</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br><span class="line">-daemon使用守护进程启动</span><br></pre></td></tr></table></figure><ul><li><strong>查看当前服务器中的所有topic</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --zookeeper IP:2181 --list</span><br></pre></td></tr></table></figure><ul><li><strong>创建topic</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --zookeeper IP:2181 --create --replication-factor 1 --partitions 1 --topic test</span><br><span class="line">--topic定义topic名</span><br><span class="line">--replication-factor定义副本数</span><br><span class="line">--partitions定义分区数</span><br></pre></td></tr></table></figure><ul><li><strong>删除topic</strong><ul><li>需要server.properties中设置delete.topic.enable=true否则只是标记删除或者直接重启</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --zookeeper IP:2181 --delete --topic test</span><br></pre></td></tr></table></figure><ul><li><strong>生产者发送消息</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list IP:9092 --topic test</span><br></pre></td></tr></table></figure><ul><li><strong>消费者消费消息</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server IP:9092 --from-beginning --topic test --consumer-property group.id=group_1</span><br><span class="line">--from-beginning会把主题中以往所有的数据都读取出来，根据业务场景选择是否增加该配置</span><br><span class="line">--consumer-property group.id=group_1指定消费者组为group_1</span><br></pre></td></tr></table></figure><ul><li><strong>查看某个Topic的详情状态和分区负载详情</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-topics.sh --zookeeper IP:2181 --describe --topic test</span><br></pre></td></tr></table></figure><ul><li><strong>查看某一个topic最大最小的offset</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看最小offset</span><br><span class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list IP:9092 --topic test --time -2</span><br><span class="line"># 查看最大offset</span><br><span class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list IP:9092 --topic test --time -1</span><br></pre></td></tr></table></figure><ul><li><strong>查看所有消费者组</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-consumer-groups.sh --bootstrap-server IP:9092 --list</span><br></pre></td></tr></table></figure><ul><li><strong>查看某一消费者组的详细信息</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-consumer-groups.sh --bootstrap-server IP:9092 --group group_1 --describe</span><br></pre></td></tr></table></figure><ul><li><strong>删除某一消费者组</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-consumer-groups.sh --bootstrap-server IP:9092 --delete --group group_1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列及 Kafka 简介</title>
      <link href="/2021/09/08/kafka_3/"/>
      <url>/2021/09/08/kafka_3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >本文记录消息队列基本概念、使用场景，以及Kafka的简介，仅供学习参考。</font><br><font color=#999AAA >文章部分内容来自黑马课件。</font></p><h1 id="1-消息队列简介">1. 消息队列简介</h1><p><code>消息队列（Message Queue）</code>，也就是我们常说的 MQ。从字面上来理解，消息队列是一种用来存储消息的队列。</p><p>消息队列中间件就是用来存储消息的软件（组件）。举个例子来理解，为了分析网站的用户行为，我们需要记录用户的访问日志。这些一条条的日志，可以看成是一条条的消息，我们可以将它们保存到消息队列中。将来有一些应用程序需要处理这些日志，就可以随时将这些消息取出来处理。<br>目前市面上的消息队列有很多，例如：Kafka、RabbitMQ、ActiveMQ、RocketMQ、ZeroMQ 等。</p><h1 id="2-消息队列的应用场景">2. 消息队列的应用场景</h1><ul><li><p><strong>异步处理</strong></p><ul><li>电商网站中，新的用户注册时，需要将用户的信息保存到数据库中，同时还需要额外发送注册的邮件通知、以及短信注册码给用户。但因为发送邮件、发送注册短信需要连接外部的服务器，需要额外等待一段时间，此时，就可以使用消息队列来进行异步处理，从而实现快速响应。</li></ul><p><img src="https://img-blog.csdnimg.cn/3b0f765a62104b54a1fcd3ad53078f89.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p><strong>系统解耦</strong><br><img src="https://img-blog.csdnimg.cn/45812c519e3a4f5bbd8af949990d1395.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p><strong>流量削峰</strong><br><img src="https://img-blog.csdnimg.cn/f7132de48f564f54b284681b07808073.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p><strong>日志处理</strong><br><img src="https://img-blog.csdnimg.cn/bee9ef3cb16b4ff89eddefb07a9a6030.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h1 id="3-生产者、消费者模型">3. 生产者、消费者模型</h1><p>Java服务器端开发的交互模型是这样的：<br><img src="https://img-blog.csdnimg.cn/edcade035eb6465c9123f2d860f27c3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>使用Java JDBC来访问操作 MySQL 数据库的交互模型是这样的：<br><img src="https://img-blog.csdnimg.cn/19936c69033c40c1bf28e4ed11178801.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这也是一种请求响应模型，只不过它不再是基于 http 协议，而是基于 MySQL 数据库的通信协议。<br>而如果我们基于消息队列来编程，此时的交互模式成为：生产者、消费者模型：<br><img src="https://img-blog.csdnimg.cn/8a979535bc514dcfafc67a1ba945e5e5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="4-消息队列的两种模式">4. 消息队列的两种模式</h1><h2 id="4-1-点对点模式">4.1 点对点模式</h2><p><img src="https://img-blog.csdnimg.cn/c2d406455998456cbfa751ec5baea688.png#pic_center" alt="在这里插入图片描述"><br>消息发送者生产消息发送到消息队列中，然后消息接收者从消息队列中取出并且消费消息。消息被消费以后，消息队列中不再有存储，所以消息接收者不可能消费到已经被消费的消息。<br>消息队列支持存在多个消费者， 但是对一个消息而言， 只会有一个消费者可以消费。</p><p><strong>点对点模式的特点：</strong></p><ul><li>每个消息只有一个接收者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li><li>发送者和接收者间没有依赖性，发送者发送消息之后，不管有没有接收者在运行，都不会影响到发送者下次发送消息</li><li>接收者在成功接收消息之后需向队列应答成功，以便消息队列删除当前接收的消息</li></ul><h2 id="4-2-发布订阅模式">4.2 发布订阅模式</h2><p><img src="https://img-blog.csdnimg.cn/0727b190193f4dfa9d6f68af71ed4d2c.png#pic_center" alt="在这里插入图片描述"><br>消息生产者（发布）将消息发布到消息队列中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到消息队列的消息会被所有订阅者消费。</p><p><strong>发布/订阅模式特点：</strong></p><ul><li>每个消息可以有多个订阅者</li><li>发布者和订阅者之间有时间上的依赖性，针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息</li><li>为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行</li></ul><h1 id="5-使用消息队列的好处">5. 使用消息队列的好处</h1><ul><li><strong>解耦</strong><ul><li>允许独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束</li></ul></li><li><strong>可恢复性</strong><ul><li>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理</li></ul></li><li><strong>缓冲</strong><ul><li>有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况</li></ul></li><li><strong>灵活性、峰值处理能力</strong><ul><li>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃</li></ul></li><li><strong>异步通信</strong><ul><li>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</li></ul></li></ul><h1 id="6-Kafka简介">6. Kafka简介</h1><p>Kafka 是一个<code>分布式</code>的基于<code>发布/订阅模式</code>的消息队列（Message Queue），由 Scala 和 Java 编写，主要应用于大数据实时处理领域。</p><p>Apache Kafka是一个分布式流平台。一个分布式的流平台应该包含3点关键的能力（官网介绍）：</p><ol><li>发布和订阅流数据流，类似于消息队列或者是企业消息传递系统</li><li>以容错的持久化方式存储数据流</li><li>处理数据流</li></ol><h1 id="7-Kafka的应用场景">7. Kafka的应用场景</h1><p>Kafka通常用在两类程序中：</p><ol><li>建立实时数据管道，以可靠地在系统或应用程序之间获取数据</li><li>构建实时流应用程序，以转换或响应数据流</li></ol><p><img src="https://img-blog.csdnimg.cn/578cb7b8c0f04468b7d36dd8855658b5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_7,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>从上图可以看到：</p><ol><li>Producers：可以有很多的应用程序，将消息数据放入到Kafka集群中。</li><li>Consumers：可以有很多的应用程序，将消息数据从Kafka集群中拉取出来。</li><li>Connectors：Kafka的连接器可以将数据库中的数据导入到Kafka，也可以将Kafka的数据导出到<br>数据库中。</li><li>Stream Processors：流处理器可以Kafka中拉取数据，也可以将数据写入到Kafka中。</li></ol><h1 id="8-Kafka的优势">8. Kafka的优势</h1><table><tr align=center><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr><tr align=center><th>所属社区/公司</th><td>Apache</td><td>Mozilla Public License</td><td>Apache</td><td>Apache/Ali</td></tr><tr align=center><th>成熟度</th><td>成熟</td><td>成熟</td><td>成熟</td><td>比较成熟</td></tr><tr align=center><th>生产者-消费者模式</th><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr align=center><th>发布-订阅</th><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr align=center><th>REQUEST-REPLY</th><td>支持</td><td>支持</td><td>-</td><td>支持</td></tr><tr align=center><th>API完备性</th><td>高</td><td>高</td><td>高</td><td>低（静态配置）</td></tr><tr align=center><th>多语言支持</th><td>支持，JAVA优先</td><td>语言无关</td><td>支持，JAVA优先</td><td>支持</td></tr><tr align=center><th>单机呑吐量</th><td>万级（最差）</td><td>万级</td><td>十万级</td><td>十万级（最高）</td></tr><tr align=center><th>消息延迟</th><td>-</td><td>微秒级</td><td>毫秒级</td><td>-</td></tr><tr align=center><th>可用性</th><td>高（主从）</td><td>高（主从）</td><td>非常高（分布式）</td><td>高</td></tr><tr align=center><th>消息丢失</th><td>-</td><td>低</td><td>理论上不会丢失</td><td>-</td></tr><tr align=center><th>消息重复</th><td>-</td><td>可控制</td><td>理论上会有重复</td><td>-</td></tr><tr align=center><th>事务</th><td>支持</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr align=center><th>文档的完备性</th><td>高</td><td>高</td><td>高</td><td>中</td></tr><tr align=center><th>提供快速入门</th><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr align=center><th>首次部署难度</th><td>-</td><td>低</td><td>中</td><td>高</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10 下 VMware15 安装 CentOS7 虚拟机</title>
      <link href="/2021/09/07/linux_3/"/>
      <url>/2021/09/07/linux_3/</url>
      
        <content type="html"><![CDATA[<p>VMware安装包：<a href="https://pan.baidu.com/s/1g7lOABTVYVxPvAKvSYUbng">https://pan.baidu.com/s/1g7lOABTVYVxPvAKvSYUbng</a> 提取码：m10q<br>CentOS7镜像：<a href="https://pan.baidu.com/s/1eILMTsWNCEBEvG3YoBIMMQ">https://pan.baidu.com/s/1eILMTsWNCEBEvG3YoBIMMQ </a> 提取码：w447</p><ol><li><p>创建新的虚拟机——选择典型——点击下一步<br><img src="https://img-blog.csdnimg.cn/a960af85cfb94b52b16e86ab9900ff2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>选择稍后安装操作系统——点击下一步<br><img src="https://img-blog.csdnimg.cn/ea8ffcf2c0c447f2b76a48f12cc92de3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>操作系统选择<code>Linux</code>——版本选择<code>CentOS 7 64 位</code>——点击下一步<br><img src="https://img-blog.csdnimg.cn/291a6dd3ec114af291c13e4c37d75ca9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>编写虚拟机名称——指定虚拟机安装位置——点击下一步<br><img src="https://img-blog.csdnimg.cn/e4f2e3ff0b214374b04c9e4cc6274bb7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>磁盘大小选择默认 20G ——将虚拟磁盘存为单个文件（磁盘储存为单个文件读写效率高一些，磁盘拆分成多个文件有利于虚拟机的迁移）——点击下一步<br><img src="https://img-blog.csdnimg.cn/560f498a54544c25aeaa8d91730cd443.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>核对信息无误，点击完成<br><img src="https://img-blog.csdnimg.cn/f5f3e8e6c22b4cdc9115fed67f98b5be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>左边会出现创建的虚拟机——点击编辑虚拟机设置<br><img src="https://img-blog.csdnimg.cn/fc82c2fbf5824b0c863e7a5efa651d5a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置虚拟机内存，我这里给的是 3G<br><img src="https://img-blog.csdnimg.cn/e9e0f8f716264ec9ae03e81bd849cfc0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置 cpu 核数，我这里给的是2核2c<br><img src="https://img-blog.csdnimg.cn/0586a0c8731849d6a098ff226e7f4fa0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>点击<code>CD/DVD(IDE)</code>选项——使用ISO映像文件，指定DVD镜像路径——点击确定<br><img src="https://img-blog.csdnimg.cn/206da39d44ae48189336677bcfe001bc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>开启虚拟机<br><img src="https://img-blog.csdnimg.cn/98f0e9e9b2ea45de8c309c7e1271f4c1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>进入安装界面，选择 Install CentOS 7 ，启动安装 服务运行一会 出现语言选择界面，可以选择中文，建议选择英文，然后点击 Continue<img src="https://img-blog.csdnimg.cn/c8f5f02ba90b4a72a8ae2023822cf721.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置时间<br><img src="https://img-blog.csdnimg.cn/fde5960dafbe44c69c028cde57e7c733.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>区域选择亚洲，城市选择上海，点击完成<br><img src="https://img-blog.csdnimg.cn/faff9c9530684e50b9e324a6274aeadc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置键盘语言<br><img src="https://img-blog.csdnimg.cn/31b1422419574948acb193563b767d87.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>点击加号，添加中文，点击完成<br><img src="https://img-blog.csdnimg.cn/8eb66034934342cd967e5ec367c6b1f6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置语言支持<br><img src="https://img-blog.csdnimg.cn/60da347eabbd4de1b624a45707a36a6e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>这里选择了英文和简体中文，点击完成<br><img src="https://img-blog.csdnimg.cn/603f7f727ea64ded856674d99d9b0485.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>选择要安装的软件<br><img src="https://img-blog.csdnimg.cn/e84c00fd34654255991a941eafde86dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>选择最小化安装，右边全选，点击完成<br><img src="https://img-blog.csdnimg.cn/cba2d8f5af30484c9e4f41a3cb7d533b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置网络和用户名<br><img src="https://img-blog.csdnimg.cn/eb93339c4efd43539995bab36db52ff9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>点击开始按钮，打开网络ip配置页面<br><img src="https://img-blog.csdnimg.cn/f9bf711fad904ffbbf6b3a2f6e559c3c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置连接名，网络类型选择 IPv4，点击 Add，添加具体的网络配置，添加DNS，点击确认<br><img src="https://img-blog.csdnimg.cn/af67095a4ac447dc803474ced1f4d394.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>划分磁盘<br><img src="https://img-blog.csdnimg.cn/69c45e5735774eafac99721ffc4d64e7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>选择要划分的磁盘，选择手动分区，点击完成<br><img src="https://img-blog.csdnimg.cn/7b4d9ffb39de47d6bc035c7d92b77b09.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>选择<code>standard Partition</code>，点击创建目录<br><img src="https://img-blog.csdnimg.cn/2941862c395b44a287fa0876f5906563.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>根据个人需要，依次添加下面的盘并划分磁盘<br><img src="https://img-blog.csdnimg.cn/543608c67f004ce28fd8a8060e598b0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>点击确认<br><img src="https://img-blog.csdnimg.cn/a2d0fe13480e4db9a3ad2def88e4d58d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>点击<code>Begin Installation</code><br><img src="https://img-blog.csdnimg.cn/b56e9b2c7340410d9bed377a6446d095.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置 root 用户密码<img src="https://img-blog.csdnimg.cn/1550a6675c4e4e069e9f1293eeb96254.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>点击完成<br><img src="https://img-blog.csdnimg.cn/5e8a7d44bd9143f3b088d99e71e0acba.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>等待出现以下界面，点击 reboot<br><img src="https://img-blog.csdnimg.cn/2dec02a2b844470fb7737ceefb33ed5e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>重启之后发现<code>ping www.baidu.com</code>，不能成功，可以检查虚拟机网络是否正常，点击编辑——点击虚拟网络编辑器<br><img src="https://img-blog.csdnimg.cn/38f50d1b257f4c7eb6fbe37d7b8f40d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>检查是否是 NAT 模式<br><img src="https://img-blog.csdnimg.cn/d928ea1fb63a4e0991d974b167220611.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果没问题，还是连不到外网的话，可以打开 windows 的网络连接，点击 WLAN<img src="https://img-blog.csdnimg.cn/904119a0ab0b40b7b3eca437add4721a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点击属性，再点击共享，勾选允许其他网络用户，选择 VMnet8，点击确认<br><img src="https://img-blog.csdnimg.cn/d82b962f45ed4543a5686b6ea9c4419e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">33. 可以看到这时候可以正常访问外网了<br><img src="https://img-blog.csdnimg.cn/58704e272b9e4f119b99014c4fe2afa0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>到这里就安装完成了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 缓存穿透、缓存击穿、缓存雪崩</title>
      <link href="/2021/09/06/redis_15/"/>
      <url>/2021/09/06/redis_15/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >Redis 缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。<br>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿，这些问题都影响着服务的高可用性。目前，业界也都有比较流行的解决方案。</font></p><p><font color=#999AAA >这里要特别感谢b站的up主：狂神说，在我Redis的学习中，很多内容笔记都是从这位大佬那里找来的，感兴趣的可以去看他的视频或者关注他的微信公众号“狂神说“”</font></p><h1 id="一、缓存穿透">一、缓存穿透</h1><h2 id="1-概念">1. 概念</h2><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。<br><img src="https://img-blog.csdnimg.cn/a03693947e7d4cb7bd3a69f33a5edeba.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-解决方案">2. 解决方案</h2><ul><li><strong>布隆过滤器</strong><ul><li>布隆过滤器是一种数据结构，对所有可能查询的数据以 hash 形式存储到一个足够大的bitmaps中，在控制层先进行校验，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力（布隆过滤器可以用于检索一个元素是否在一个集合中，它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难）。</li></ul></li><li><strong>缓存空对象</strong><ul><li>当存储层不命中后，即使返回的空对象也将其缓存起来，同时设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</li><li>缺点：<ul><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ul></li></ul></li><li><strong>设置可访问的白名单</strong><ul><li>使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问</li></ul></li><li><strong>进行实时监控</strong><ul><li>当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</li></ul></li></ul><h1 id="二、缓存击穿">二、缓存击穿</h1><h2 id="1-概念-2">1. 概念</h2><p>缓存击穿，是指一个 key 非常热点，在不停的承担数据的并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<br>当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大，这个时候大并发的请求可能会瞬间把后端 DB 压垮。<br><img src="https://img-blog.csdnimg.cn/7befd3897f6e437991c964e5d05b9ab2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-解决方案-2">2. 解决方案</h2><ul><li><p><strong>预先设置热门数据</strong></p><ul><li>预先设置热门数据：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长</li></ul></li><li><p><strong>实时调整</strong></p><ul><li>现场监控哪些数据热门，实时调整key的过期时长</li></ul></li><li><p><strong>使用锁</strong></p><ul><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX ）去 set 一个 mutex key</li><li>当操作返回成功时，再进行 load db 的操作，并回设缓存,最后删除 mutex key</li><li>当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法</li></ul><p><img src="https://img-blog.csdnimg.cn/bfd65f8ec52f40959a3d82013202edfc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h1 id="三、缓存雪崩">三、缓存雪崩</h1><h2 id="1-概念-3">1. 概念</h2><p>缓存雪崩是指在某个时间段，缓存集中过期失效，key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。<br>其实集中过期，倒不是很致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务器节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key</p><p>正常访问：<br><img src="https://img-blog.csdnimg.cn/1057dee03374408da5b706ed4b419375.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>缓存失效瞬间：<br><img src="https://img-blog.csdnimg.cn/ebacac90ef1a4ce9a83f8bb5be005bb8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-解决方案-3">2. 解决方案</h2><ul><li><strong>redis高可用</strong><ul><li>增加 redis 集群规模</li></ul></li><li><strong>构建多级缓存架构</strong><ul><li>nginx 缓存 + redis 缓存 + 其他缓存（ehcache等）</li></ul></li><li><strong>使用锁或队列</strong><ul><li>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上（不适用高并发情况）</li></ul></li><li><strong>设置过期标志更新缓存</strong><ul><li>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存</li></ul></li><li><strong>将缓存失效时间分散开</strong><ul><li>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 哨兵模式详解</title>
      <link href="/2021/09/06/redis_14/"/>
      <url>/2021/09/06/redis_14/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA >当主服务器宕机后，需要手动把一台从节点服务器切换为主节点服务器，这就需要人为干预，费时费力，还会造成一段时间内服务不可用。所以更多时候，我们优先考虑哨兵模式。Redis 从 2.8 开始正式提供了 Sentinel（哨兵）结构来解决这个问题。</font></p><h1 id="1-哨兵模式的概述">1. 哨兵模式的概述</h1><p>哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。</strong></p><p>这里的哨兵有两个作用：</p><ol><li>通过发送命令，让 Redis 服务器返回监控其运行状态，包括主节点和从节点；</li><li>当哨兵检测到 Master 宕机，会自动将 Slave 切换成 Master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li></ol><p>然而一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。<br>假设主服务器宕机，哨兵 1 先监测到这个结果，系统不会马上进行 failover 过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象称为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover[故障转移] 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。</p><h1 id="2-怎么开启哨兵模式">2. 怎么开启哨兵模式</h1><ol><li>在自己的 redis 目录下新建<code>sentinel.conf</code>文件，名字只能写此唯一名，然后在文件中加入下面内容</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"># 其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量</span><br></pre></td></tr></table></figure><ol start="2"><li>执行<code>redis-sentinel sentinel.conf</code>命令，启动哨兵<br><img src="https://img-blog.csdnimg.cn/3f1e8293d4fd4cc4aa0d7fe7d90e72a0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>当主节点挂掉，会从 Slave 中选举产生新的主节点，大概 10s 左右可以看到哨兵窗口的日志，切换了新的主节点，根据<code>redis.conf</code>中的<code>replica-priority</code>优先级别来选择哪个从机作为主节点（更多详情可参考<a href="https://blog.csdn.net/weixin_44758876/article/details/119865587">《Redis配置文件详解》</a>中的主从复制模块）。这时如果原来挂掉的主节点重启后，会变为从节点。<br><img src="https://img-blog.csdnimg.cn/a5b620f6e0e24f6e847f1533cde3da23.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><h1 id="3-哨兵模式的全部配置">3. 哨兵模式的全部配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf</span><br><span class="line"></span><br><span class="line"># 哨兵sentinel实例运行的端口 默认26379</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 哨兵sentinel的工作目录</span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port</span><br><span class="line"># master-name 可以自己命名的主节点名字，只能由字母A-Z、数字0-9、这三个字符“.-_”组成</span><br><span class="line"># quorum 配置多少个sentinel哨兵统一认为master主节点失联，那么这时客观上认为主节点失联了</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line">#当在redis实例中开启了requirepass foobared 授权密码时，所有连接redis实例的客户端都要提供密码</span><br><span class="line"># 设置哨兵sentinel连接主从的密码，注意必须为主从设置一样的验证密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passwOrd</span><br><span class="line"></span><br><span class="line"># 指定多少毫秒之后，主节点没有应答哨兵sentinel时，哨兵主观上认为主节点下线，默认30秒</span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">setinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 指定在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间越长</span><br><span class="line"># 这个数字越大，就意味着越多的slave因为replication而不可用</span><br><span class="line"># 可以通过将这个值设为 1 来保证每次只有一个slave处于不能处理命令请求的状态</span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><br><span class="line"># 1. 同一个sentine1对同一个master两次failover之间的间隔时间</span><br><span class="line"># 2．当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时</span><br><span class="line"># 3. 当想要取消一个正在进行的failover所需要的时间</span><br><span class="line"># 4. 当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line">#默认三分钟</span><br><span class="line"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"># SCRIPTS EXECUTION</span><br><span class="line"></span><br><span class="line"># 配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="line"># 对于脚本的运行结果有以下规则：</span><br><span class="line"># 若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="line"># 若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行</span><br><span class="line"># 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同</span><br><span class="line"># 一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="line"></span><br><span class="line"># 通知型脚本：当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="line"># 通知脚本</span><br><span class="line">#sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"># 客户端重新配置主节点参数脚本</span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="line"># 以下参数将会在调用脚本时传给脚本：</span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line"># 目前&lt;state&gt;总是&quot;failover”</span><br><span class="line"># &lt;role&gt;是“7eader”或者“observer”中的一个</span><br><span class="line"># 参数 from-ip，from-port，to-ip，to-port是用来和旧的master和新的master（即旧的s1ave）通信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的</span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure><h1 id="4-复制延时">4. 复制延时</h1><p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。</p><h1 id="5-故障恢复的流程">5. 故障恢复的流程</h1><ol><li>当主节点宕机或下线后，sentinel 从下线的主节点的所有从服务器中挑选一个从节点，将其转成主节点，选择的条件依次为：<ol><li>选择优先级靠前的（优先级在<code>redis.conf</code>中默认：<code>replica-priority 100</code>，值越小优先级越高）；</li><li>选择偏移量最大的（偏移量指获得原主节点数据最全的）；</li><li>选择 runid 最小的（每个 redis 实例启动后都会随机生成一个 40 位的 runid）；</li></ol></li><li>挑选出新的主节点之后，sentinel 向其余所有的从节点发送 slaveof 新主服务 的命令，赋值新 Master；</li><li>当已下线的服务重新上线时，sentinel 会向其发送 slaveof 命令，让其成为新主节点的从节点。</li></ol><h1 id="6-哨兵模式的优缺点">6. 哨兵模式的优缺点</h1><p><strong>优点：</strong></p><ul><li>哨兵模式基于主从复制，所有主从配置的优点和哨兵模式同等；</li><li>主从可以切换，故障转移，系统的可用性更好；</li><li>哨兵模式就是主从模式的升级，从手动到自动，更加健壮</li></ul><p><strong>缺点：</strong></p><ul><li>Redis 集群不好在线扩容，集群容量一旦到达上限，在线扩容很麻烦；</li><li>实现哨兵模式的配置很麻烦。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 主从复制</title>
      <link href="/2021/09/06/redis_13/"/>
      <url>/2021/09/06/redis_13/</url>
      
        <content type="html"><![CDATA[<h1 id="1-主从复制的概念">1. 主从复制的概念</h1><p>主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器，前者成为主节点（Master/Leader），后者称为从节点（Slave/Follower）。<code>数据的复制是单向的，只能由主节点复制到从节点。</code><br>Master 以写为主，Slave 以读为主。<br><code>默认情况下，每台 Redis 服务器都是主节点。</code><br>一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p><h1 id="2-主从复制的作用">2. 主从复制的作用</h1><ul><li><strong>数据冗余</strong><ul><li>主从复制实现的数据的热备份，是持久化之外的一种数据冗余方式</li></ul></li><li><strong>故障恢复</strong><ul><li>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li></ul></li><li><strong>负载均衡</strong><ul><li>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量</li></ul></li><li><strong>高可用（集群）基石</strong><ul><li>除了上诉作用外，主从复制还是哨兵模式和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础</li></ul></li></ul><p>一般来说，要将 Redis 运用于工程项目中，只使用一台 Redis 是万万不能的（宕机），原因如下：</p><ol><li>从结构上，单个 Redis 服务器会发生单点故障，并且一台服务区需要处理所有的请求负载，压力较大；</li><li>从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量为 256G，也不能将所有内存用作 Redis 存储内存，一般来说，单台 Redis 最大使用内存不应该超过 20G；</li></ol><h1 id="3-如何开启主从复制">3. 如何开启主从复制</h1><p><code>默认情况下，每台 Redis 服务器都是主节点</code>，我们只用配置从节点就好了。</p><ol><li><p>使用<code>info replication</code>命令能看到当前主机的运行情况：<br><img src="https://img-blog.csdnimg.cn/6ce6a1f5fde74c469f597071f0da575b.png" alt="在这里插入图片描述"></p></li><li><p>在从节点上，指定成为某个实例的从服务器<code>slaveof 127.0.0.1 6379</code> <code>slaveof  &lt;ip&gt; &lt;port&gt;</code><br><img src="https://img-blog.csdnimg.cn/21f2f772948a4c708c9d43fbab7d0006.png" alt="在这里插入图片描述"><br>这样就开启成功了。</p></li><li><p>从节点重启后需要重设：<code>slaveof 127.0.0.1 6379</code>，可以将配置加到配置文件中，永久生效<br><img src="https://img-blog.csdnimg.cn/7aedd5dcf86e4a11a3c0b99e56f101d3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>更多详情可以参考<a href="https://blog.csdn.net/weixin_44758876/article/details/119865587">《Redis配置文件详解》</a>中的主从复制模块。</p></li></ol><p>如果主节点突然宕机，可以手动将从节点改为主节点，执行<code>SLAVEOF no one</code>即可（开启哨兵模式可以自动选取主节点，这个会放在另一篇博客中详讲，感兴趣的可以在我的专栏中找）。</p><h1 id="4-主从复制的原理">4. 主从复制的原理</h1><p><img src="https://img-blog.csdnimg.cn/15a82e921c1e438ca1b980c5446d1619.png#pic_center" alt="在这里插入图片描述"></p><ol><li>Slave 启动成功连接到 Master 后会发送一个 sync 命令</li><li>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，Master 将传送整个数据文件到 Slave，以完成一次完全同步</li><li>全量复制：而 Slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中</li><li>增量复制：Master 继续将新的所有收集到的修改命令依次传给 Slave，完成同步</li><li>但是只要是重新连接 Master，一次完全同步（全量复制）将被自动执行</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的发布和订阅</title>
      <link href="/2021/09/03/redis_12/"/>
      <url>/2021/09/03/redis_12/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是发布和订阅">1. 什么是发布和订阅</h1><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>Redis 客户端可以订阅任意数量的频道。</p><h1 id="2-发布、订阅的流程">2. 发布、订阅的流程</h1><ol><li>客户端可以订阅频道<br><img src="https://img-blog.csdnimg.cn/f3f797a991154e288111e1f89056b362.png" alt="在这里插入图片描述"></li><li>当给这个频道发布消息后，消息就会发送给订阅的客户端<br><img src="https://img-blog.csdnimg.cn/58e6125690e64c29b56054201f7824f8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_6,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><h1 id="3-命令行实现发布订阅">3. 命令行实现发布订阅</h1><p><img src="https://img-blog.csdnimg.cn/bf61ec39750641be99b98230b889b3e8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li><code>subscribe channel1</code>打开一个客户端订阅 channel1<br><img src="https://img-blog.csdnimg.cn/4da13f6306ca46c28a5f9a2a50eb1664.png" alt="在这里插入图片描述"></li><li><code>publish channel1 hello</code>打开另一个客户端，给 channel1 发布消息 hello<br><img src="https://img-blog.csdnimg.cn/3be6419e341843a6a17a273a6c406373.png" alt="在这里插入图片描述"><br>返回的 1 是订阅者的数量</li><li>这时候从第一个客户端可以看到发送的消息<br><img src="https://img-blog.csdnimg.cn/e549c020e82b4f8b8af07cf37528c1c6.png" alt="在这里插入图片描述"></li></ol><p><strong>注：</strong> 发布的消息没有持久化，如果是正在订阅的客户端收不到 hello，只能收到订阅后发布的消息。</p><h1 id="4-发布、订阅的原理">4. 发布、订阅的原理</h1><p>Redis是使用 C 实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，以此加深对 Redis 的理解。</p><p>Redis 通过 PUBLISH、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。<br>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。<br>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在 Redis 中，你可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的持久化操作</title>
      <link href="/2021/09/03/redis_11/"/>
      <url>/2021/09/03/redis_11/</url>
      
        <content type="html"><![CDATA[<p><strong>Redis 提供了 2 个不同形式的持久化方式：</strong></p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append Of File）</li></ul><h1 id="RDB（Redis-DataBase）">RDB（Redis DataBase）</h1><h2 id="1-官网介绍">1. 官网介绍</h2><p><img src="https://img-blog.csdnimg.cn/530b8aa8c6c942658df4105892142d9e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="2-RDB的定义">2. RDB的定义</h2><p>在指定的<code>时间间隔</code>内将内存中的数据集<code>快照</code>写入磁盘，也就是我们常说的 Snapshot 快照，它恢复时是将快照文件直接读到内存中。</p><h2 id="3-备份是如何执行的">3. 备份是如何执行的</h2><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个<code>临时文件</code>中，待持久化过程都结束了，再用这个<code>临时文件替换上次持久化</code>好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。<code>RDB的缺点是最后一次持久化后的数据可能丢失。</code></p><h2 id="4-Fork">4. Fork</h2><ul><li>Fork的作用是复制一个与当前进程<code>一样的进程</code>。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并<code>作为原进程的子进程</code></li><li>在Linux程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，Linux中引入了<code>“写时复制技术”</code></li><li><code>一般情况父进程和子进程会共用同一段物理内存</code>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li></ul><h2 id="5-RDB持久化流程">5. RDB持久化流程</h2><p><img src="https://img-blog.csdnimg.cn/9ff9c6a7f96c448eaec18d868c110a11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_7,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="6-rdb文件">6. rdb文件</h2><p>rdb保存的文件在<code>redis.conf</code>中配置文件名称，默认为<code>dump.rdb</code>（更多详情可参考<a href="https://blog.csdn.net/weixin_44758876/article/details/119865587">Redis配置文件详解</a>）<br><img src="https://img-blog.csdnimg.cn/fd17ddad683a4cb0a47745e84d0dfbc7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="7-文件保存位置">7. 文件保存位置</h2><p>rdb 文件的保存路径，可以指定（<code>dir &quot;/myredis/&quot;</code>），默认为 Redis 启动时命令行所在目录下。（更多详情可参考<a href="https://blog.csdn.net/weixin_44758876/article/details/119865587">Redis配置文件详解</a>）<br><img src="https://img-blog.csdnimg.cn/20a4d3e0a5d94b57b75b7df07051d693.png" alt="在这里插入图片描述"></p><h2 id="8-如何触发RDB快照">8. 如何触发RDB快照</h2><ol><li><p>配置文件中默认的快照配置<br><img src="https://img-blog.csdnimg.cn/b363251fa66745ca86f87651020a4053.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p><strong>save VS bgsave</strong></p><ul><li>save<ul><li>save 时只会保存，其他不管，全部阻塞（不建议）</li></ul></li><li><strong>bgsave</strong><ul><li>Redis 会在后台异步进行快照操作， 快照同时还可以响应客户端请求</li></ul></li></ul><p>可以通过lastsave 命令获取最后一次成功执行快照的时间。</p></li><li><p>执行<code>flushall</code>命令，也会产生<code>dump.rdb</code>文件，但里面是空的，无意义。</p></li><li><p>退出 redis，也会产生 rdb 文件。</p></li></ol><h2 id="9-stop-writes-on-bgsave-error">9. stop-writes-on-bgsave-error</h2><p>当Redis无法写入磁盘的话，就直接关掉Redis的写操作（推荐yes）<br><img src="https://img-blog.csdnimg.cn/f75d3e391d8f4f07bc457ff1de9e2cd3.png" alt="在这里插入图片描述"></p><h2 id="10-rdbcompression-压缩文件">10. rdbcompression 压缩文件</h2><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。<br>如果是的话，redis会采用<code>LZF</code>算法进行压缩。<br>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能（推荐yes）<br><img src="https://img-blog.csdnimg.cn/9350ca4173c54fd4b2628c8f84259000.png" alt="在这里插入图片描述"></p><h2 id="11-rdbchecksum-检查完整性">11. rdbchecksum 检查完整性</h2><p>在存储快照后，还可以让 redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能（推荐yes）<br><img src="https://img-blog.csdnimg.cn/f91c3af45c1a4328b386c688d3458ec1.png" alt="在这里插入图片描述"></p><h2 id="12-rdb的备份及恢复">12. rdb的备份及恢复</h2><p>可以通过<code>config get dir</code>查询 rdb 文件的目录，然后将<code>*.rdb</code>的文件拷贝到别的地方。<br>rdb 的恢复：</p><ol><li>关闭 Redis</li><li>先把备份的文件拷贝到工作目录下</li><li>启动 Redis，备份数据会直接加载</li></ol><h2 id="13-RDB的优劣势">13. RDB的优劣势</h2><p><strong>优势：</strong></p><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快<br><img src="https://img-blog.csdnimg.cn/c3ec00db9f9a4adbbae3daca766fb9db.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></li></ul><p><strong>劣势：</strong></p><ul><li><code>Fork</code>的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑</li><li>虽然 Redis 在 fork 时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能</li><li>备份周期在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改</li></ul><h2 id="14-总结">14. 总结</h2><p><img src="https://img-blog.csdnimg.cn/7c781933d2974f95a3d3ec831101e43e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="AOF（Append-Of-File）">AOF（Append Of File）</h1><h2 id="1-AOF的定义">1. AOF的定义</h2><p><code>以日志的形式来记录每个写操作（增量保存）</code>，将 Redis 执行过的所有写指令记录下来<code>(读操作不记录)</code>， <code>只许追加文件但不可以改写文件</code>，redis 启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h2 id="2-AOF持久化流程">2. AOF持久化流程</h2><p><img src="https://img-blog.csdnimg.cn/a68d4789643f400dafdd0741db1baf02.png#pic_center" alt="在这里插入图片描述"></p><ol><li>客户端的请求写命令会被 append 追加到 AOF 缓冲区内；</li><li>AOF 缓冲区根据 AOF 持久化策略<code>[always,everysec,no]</code>将操作 sync 同步到磁盘的 AOF 文件中（更多详情可参考<a href="https://blog.csdn.net/weixin_44758876/article/details/119865587">Redis配置文件详解</a>）；</li><li>AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 rewrite 重写，压缩 AOF 文件容量；</li><li>Redis 服务重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的；</li></ol><h2 id="3-AOF默认不开启">3. AOF默认不开启</h2><p>可以在<code>redis.conf</code>中配置文件名称，默认为<code>appendonly.aof</code><br>AOF 文件的保存路径，同 RDB 的路径一致</p><h2 id="4-AOF和RDB同时开启，redis听谁的？">4. AOF和RDB同时开启，redis听谁的？</h2><p>AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）</p><h2 id="5-AOF的启动、修复、恢复">5. AOF的启动、修复、恢复</h2><ul><li>AOF 的备份机制和性能虽然和 RDB 不同, 但是备份和恢复的操作同 RDB 一样，都是拷贝备份文件，需要恢复时再拷贝到 Redis 工作目录下，启动系统即加载</li><li>正常恢复<ul><li>修改默认的<code>appendonly no</code>，改为 yes</li><li>将有数据的 aof 文件复制一份保存到对应目录(查看目录：<code>config get dir</code>)</li><li>恢复：重启 redis 然后重新加载</li></ul></li><li>异常恢复<ul><li>修改默认的<code>appendonly no</code>，改为 yes</li><li>如遇到<code>AOF文件损坏</code>，通过<code>redis-check-aof --fix appendonly.aof</code>进行恢复</li><li>备份被写坏的 AOF 文件</li><li>恢复：重启redis，然后重新加载</li></ul></li></ul><h2 id="6-AOF同步频率设置">6. AOF同步频率设置</h2><ul><li><code>appendfsync always</code><ul><li>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</li></ul></li><li><code>appendfsync everysec</code><ul><li>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失</li></ul></li><li><code>appendfsync no</code><ul><li>redis 不主动进行同步，把同步时机交给操作系统</li></ul></li></ul><h2 id="7-Rewrite压缩">7. Rewrite压缩</h2><h3 id="7-1-Rewrite压缩是什么">7.1 Rewrite压缩是什么</h3><p>AOF 采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令<code>bgrewriteaof</code></p><h3 id="7-2-重写原理、触发机制、如何实现重写">7.2 重写原理、触发机制、如何实现重写</h3><p><strong>重写原理：</strong> AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写(也是先写临时文件最后再 rename )，redis4.0 版本后的重写，是指上就是把 rdb 的快照，以二级制的形式附在新的 aof 头部，作为已有的历史数据，替换掉原来的流水账操作<br><code>no-appendfsync-on-rewrite：</code></p><ul><li>如果<code>no-appendfsync-on-rewrite=yes </code>,不写入 aof 文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</li><li>如果<code>no-appendfsync-on-rewrite=no</code>,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</li></ul><p><strong>触发机制：</strong><br>Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发</p><p><code>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写</code><br><code>auto-aof-rewrite-percentage：</code>设置重写的基准值，文件达到 100% 时开始重写（文件是原来重写后文件的2倍时触发）<br><code>auto-aof-rewrite-min-size：</code>设置重写的基准值，最小文件 64MB。达到这个值开始重写<br><strong>例如</strong>：文件达到 70MB 开始重写，降到 50MB ，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis 会记录此时 AOF 大小，设为base_size，如果 <code>Redis的AOF当前大小 &gt;= base_size + base_size * 100% (默认)</code>且<code>当前大小 &gt;= 64mb (默认)</code>的情况下，Redis 会对 AOF 进行重写。</p><h3 id="7-3-重写流程">7.3 重写流程</h3><p><img src="https://img-blog.csdnimg.cn/62ecfbb3b6e2416baed53db8361030f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ol><li><code>bgrewriteaof</code>触发重写，判断是否当前有 bgsave 或 bgrewriteaof 在运行，如果有，则等待该命令结束后再继续执行；</li><li>主进程 fork 出子进程执行重写操作，保证主进程不会阻塞；</li><li>子进程遍历 redis 内存中数据到临时文件，客户端的写请求同时写入 aof_buf 缓冲区和 aof_rewrite_buf 重写缓冲区保证原 AOF 文件完整以及新 AOF 文件生成期间的新的数据修改动作不会丢失；</li><li>子进程写完新的 AOF 文件后，向主进程发信号，父进程更新统计信息；</li><li>主进程把 aof_rewrite_buf 中的数据写入到新的 AOF 文件；</li><li>使用新的 AOF 文件覆盖旧的 AOF 文件，完成 AOF 重写</li></ol><h2 id="8-AOF的优劣势">8. AOF的优劣势</h2><p><strong>优势：</strong><br><img src="https://img-blog.csdnimg.cn/91d3922106e8416881148b8ed64033a1.png#pic_center" alt="在这里插入图片描述"></p><ul><li>备份机制更稳健，丢失数据概率更低</li><li>可读的日志文本，通过操作 AOF 稳健，可以处理误操作</li></ul><p><strong>劣势：</strong></p><ul><li>比起RDB占用更多的磁盘空间</li><li>恢复备份速度要慢</li><li>每次读写都同步的话，有一定的性能压力</li><li>存在个别Bug，造成恢复失败</li></ul><h2 id="9-总结">9. 总结</h2><p><img src="https://img-blog.csdnimg.cn/4b319ac51f1146528f4c5813fa53a883.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="总结">总结</h1><p><strong>用哪个好？</strong></p><ul><li>官方推荐两个都启用<ul><li>如果对数据不敏感，可以选单独用 RDB</li><li>不建议单独用 AOF，因为可能会出现 Bug</li><li>如果只是做纯内存缓存，可以都不用</li></ul></li></ul><p><strong>官网建议：</strong><br><img src="https://img-blog.csdnimg.cn/2cec050cb13942f68c493a2c7d268ecc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li><li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 redis 协议追加保存每次写的操作到文件末尾</li><li>Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式.</li><li>同时开启两种持久化方式：<ul><li>在这种情况下,当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据,，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整.</li></ul></li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。那要不要只使用 AOF 呢？<ul><li>建议不要，因为 RDB 更适合用于备份数据库（AOF 在不断变化不好备份）， 快速重启，而且不会有 AOF 可能潜在的 bug，留着作为一个万一的手段。</li></ul></li><li>性能建议<ul><li>因为 RDB 文件只用作后备用途，建议<code>只在Slave上持久化RDB文件</code>，而且只要 15 分钟备份一次就够了，只保留<code>save 900 1</code>这条规则</li><li>如果使用 AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只 load 自己的 AOF 文件就可以了；代价一是带来了持续的 IO，二是 AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少 AOF rewrite 的频率，AOF 重写的基础大小默认值 64M 太小了，可以设到5G以上，默认超过原大小 100% 大小时重写可以改到适当的数值</li><li>如果不使用AOF，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔 IO，也减少了 rewrite 时带来的系统波动；代价是如果 Master/Slave 同时挂掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB 文件，载入较新的那个，微博就是这种架构。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 配置文件详解</title>
      <link href="/2021/08/30/redis_10/"/>
      <url>/2021/08/30/redis_10/</url>
      
        <content type="html"><![CDATA[<ul><li>单位：配置文件对<code>unit</code>单位大小写不敏感<br><img src="https://img-blog.csdnimg.cn/43d6fc9032d243b3b878460892528e7b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>可以包含多个配置文件<br><img src="https://img-blog.csdnimg.cn/dd15fd9bc267449f90cb3644b5c1b89b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="NETWORK（网络）">#### NETWORK（网络）####</h1><ul><li><p>绑定的IP，默认只接受本机的访问请求，生产环境要写应用服务器的地址<br><img src="https://img-blog.csdnimg.cn/e2656ba059fe4988b6df791b0e5ef083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应<br><img src="https://img-blog.csdnimg.cn/e4c561d709314eb582e56c87411fadd9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>端口号默认6379<br><img src="https://img-blog.csdnimg.cn/46c7026667be4f4ab2314cca8069ced5.png" alt="在这里插入图片描述"></p></li><li><p>设置 tcp 的 backlog</p><ul><li>backlog 其实是一个连接队列，backlog<code>队列总和=未完成三次握手队列 + 已经完成三次握手队列</code></li><li>在高并发环境下需要一个高 backlog 值来避免慢客户端连接问题</li><li>注意 Linux 内核会将这个值减小到<code>/proc/sys/net/core/somaxconn的值（128）</code>，所以需要确认增大<code>/proc/sys/net/core/somaxconn</code>和<code>/proc/sys/net/ipv4/tcp_max_syn_backlog（128）</code>两个值来达到想要的效果</li></ul><p><img src="https://img-blog.csdnimg.cn/f83982fefa7f490fa8f714ecde1d5547.png" alt="在这里插入图片描述"></p></li><li><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能，即永不关闭<br><img src="https://img-blog.csdnimg.cn/ac454671f546446ba1fbfa7baca7ab1a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>对访问客户端的一种心跳检测，每隔 n 秒检测一次</p><ul><li>单位为秒，如果设置为 0，则不会进行 Keepalive 检测，建议设置成 60</li><li>使用keepalive有两个好处：<ul><li>检测挂掉的对端</li><li>降低中间设备出问题而导致网络看似连接却已经与对端端口的问题</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/b3ab2bc70ee04e48889b348c0c7a3ce7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h1 id="GENERAL（通用）">#### GENERAL（通用）####</h1><ul><li><p>以守护进程方式运行，默认是 no<br><img src="https://img-blog.csdnimg.cn/dfdee24af96d4d79bda181db6e1ef83e.png" alt="在这里插入图片描述"></p></li><li><p>存放pid文件的位置，每个实例会产生一个不同的pid文件<br><img src="https://img-blog.csdnimg.cn/c2415dd32af54068a9e0f61d99e3f4b8.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>指定日志记录级别，Redis总共支持四个级别：</p><ul><li><code>debug</code>（很多信息，方便开发、测试）、</li><li><code>verbose</code>（许多有用的信息，但是没有debug级别信息多）、</li><li><code>notice</code>（默认，适当的日志级别，适合生产环境）、</li><li><code>warning</code>（只有非常重要的信息）</li></ul><p><img src="https://img-blog.csdnimg.cn/f749df74f74a437193522617dca26a25.png" alt="在这里插入图片描述"></p></li><li><p>指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备，后台运行的 redis 标准输出是<code>/dev/null</code><br><img src="https://img-blog.csdnimg.cn/e40c49c3eded4f98aacfde1fbbacad9f.png" alt="在这里插入图片描述"></p></li><li><p>Syslog 相关配置<br><img src="https://img-blog.csdnimg.cn/7a8bf395a8a040798abc8067f7545031.png" alt="在这里插入图片描述"></p></li><li><p>设定库的数量默认 16，默认数据库为 0，可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库 id<br><img src="https://img-blog.csdnimg.cn/41cbcf55f1664c75b6fbe2f70bc538fa.png" alt="在这里插入图片描述"></p></li></ul><h1 id="SNAPSHOTTING（快照）">#### SNAPSHOTTING（快照）####</h1><ul><li><p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb.aof</p><ul><li>redis是内存数据库，没有持久化，那么断电后数据就会丢失</li></ul><p><img src="https://img-blog.csdnimg.cn/559b916cba5e4b468621f0b689298c12.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>当<code>RDB</code>持久化出现错误后，是否依然进行继续进行工作</p><ul><li>可以通过 info 中的<code>rdb_last_bgsave_status</code>了解<code>RDB</code>持久化是否有错误</li></ul><p><img src="https://img-blog.csdnimg.cn/12af0c428a674ebf86e0a713e1a1529a.png" alt="在这里插入图片描述"></p></li><li><p>使用压缩<code>RDB</code>文件，<code>RDB</code>文件压缩使用 LZF 压缩算法<br><img src="https://img-blog.csdnimg.cn/12d65d8f1568440ba360881ac5c21d61.png" alt="在这里插入图片描述"></p></li><li><p>保存<code>RDB</code>文件时，进行错误的检查校验</p><ul><li>从 rdb 格式的第五个版本开始，在 rdb 文件的末尾会带上<code>CRC64</code>的校验和。这跟有利于文件的容错性，但是在保存 rdb 文件的时候，会有大概 10% 的性能损耗，所以如果追求高性能，可以关闭该配置</li></ul><p><img src="https://img-blog.csdnimg.cn/4ff5a087978e41c9912b242bcf2b70ea.png" alt="在这里插入图片描述"></p></li><li><p><code>RDB</code>文件的名称<br><img src="https://img-blog.csdnimg.cn/fd2092314c874f028a60741da80a1860.png" alt="在这里插入图片描述"></p></li><li><p>数据目录，数据库的写入会在这个目录</p><ul><li>rdb、aof文件也会写在这个目录</li></ul><p><img src="https://img-blog.csdnimg.cn/f23fabed8ccb49089376fa1517992f20.png" alt="在这里插入图片描述"></p></li></ul><h1 id="REPLICATION（主从复制）">#### REPLICATION（主从复制）####</h1><ul><li><p>复制选项，slave复制对应的master<br><img src="https://img-blog.csdnimg.cn/c7000199e1604f31a2cc260ee7b29698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>如果 master 设置了 requirepass ，那么 slave 要连上 master ，需要有 master 的密码</p><ul><li>masterauth 就是用来配置master的密码，这样可以在连上 master 后进行认证</li></ul><p><img src="https://img-blog.csdnimg.cn/48c21ad36f654b2ca6b8d80a21387d3c.png" alt="在这里插入图片描述"></p></li><li><p>当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：</p><ul><li>如果<code>replica-serve-stale-data</code>设置为<code>yes</code>(默认设置)，从库会继续响应客户端的请求</li><li>如果<code>replica-serve-stale-data</code>设置为no，除去INFO和SLAVOF命令之外的任何请求都会返回一个错误<code>SYNC with master in progress</code><br><img src="https://img-blog.csdnimg.cn/010958124b824b29a1362c5ba18ad308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li><li><p>作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）<img src="https://img-blog.csdnimg.cn/c478f1abe4ea4bc99325d47db4b6fddc.png" alt="在这里插入图片描述"></p></li><li><p>是否使用 socket 方式复制数据</p><ul><li>目前 redis 复制提供两种方式，disk 和 socket</li><li>如果新的 slave 连上来或者重连的 slave 无法部分同步，就会执行全量同步，master 会生成 rdb 文件</li><li>disk 方式是 master 创建一个新的进程把 rdb 文件保存到磁盘，再把磁盘上的 rdb 文件传递给 slave</li><li>socket 是 master 创建一个新的进程，直接把 rdb 文件以 socket 的方式发给 slave</li><li>disk 方式的时候，当一个 rdb 保存的过程中，多个 slave 都能共享这个 rdb 文件</li><li>socket 的方式就的一个个 slave 顺序复制。在磁盘速度缓慢，网速快的情况下推荐用 socket 方式</li></ul><p><img src="https://img-blog.csdnimg.cn/d35a3a3345034810b38a39ac3a3980a5.png" alt="在这里插入图片描述"></p></li><li><p>diskless复制的延迟时间，防止设置为0</p><ul><li>一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输</li><li>所以最好等待一段时间，等更多的slave连上来</li></ul><p><img src="https://img-blog.csdnimg.cn/3e4ef4a9fc924c79bbcdad4a54f4b8df.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>slave根据指定的时间间隔向服务器发送ping请求</p><ul><li>时间间隔可以通过<code>repl_ping_slave_period</code>来设置，默认 10 秒</li></ul><p><img src="https://img-blog.csdnimg.cn/fcf717e6a9764f459491f84cfcf905dd.png" alt="在这里插入图片描述"></p></li><li><p>复制连接超时时间</p><ul><li>master 和 slave 都有超时时间的设置。master 检测到 slave 上次发送的时间超过<code>repl-timeout</code>，即认为 slave 离线，清除该 slave 信息。</li><li>slave 检测到上次和 master 交互的时间超过<code>repl-timeout</code>，则认为 master 离线。</li><li>需要注意的是<code>repl-timeout</code>需要设置一个比<code>repl-ping-slave-period</code>更大的值，不然会经常检测到超时。</li></ul><p><img src="https://img-blog.csdnimg.cn/c87978b01e6447fe86a34791362b547b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>是否禁止复制tcp链接的tcp</p><ul><li>nodelay 参数，可传递 yes 或者 no（默认是no，即使用tcp nodelay）</li><li>如果 master 设置了 yes 来禁止<code>tcp nodelay</code>设置，在把数据复制给 slave 的时候，会减少包的数量和更小的网络带宽。但是这也可能带来数据的延迟。</li><li>默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择 yes</li></ul><p><img src="https://img-blog.csdnimg.cn/6b542adaac324b5eb3eab8710a51b850.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>复制缓冲区大小</p><ul><li>这是一个环形复制缓冲区，用来保存最新复制的命令</li><li>这样在 slave 离线的时候，不需要完全复制 master 的数据</li><li>如果可以执行部分同步，只需要把缓冲区的部分数据复制给 slave，就能恢复正常复制状态</li><li>缓冲区的大小越大，slave 离线的时间可以更长，复制缓冲区只有在有 slave 连接的时候才分配内存</li><li>没有 slave 的一段时间，内存会被释放出来，默认 1m</li></ul><p><img src="https://img-blog.csdnimg.cn/e30795f5ecfd4406b5b305578650ae63.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>master 没有 slave 一段时间会释放复制缓冲区的内存</p><ul><li><code>repl-backlog-ttl</code>用来设置该时间长度，单位为秒</li></ul><p><img src="https://img-blog.csdnimg.cn/a796eccfb9d1405189fbf37ffac05c0a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>当master不可用，Sentinel会根据slave的优先级选举一个master</p><ul><li>最低的优先级的slave，当选master。而配置成0，永远不会被选举</li></ul><p><img src="https://img-blog.csdnimg.cn/da03b6d4eb4c4bc5ad68faaacbaa51fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>redis 提供了可以让 master 停止写入的方式</p><ul><li>如果配置了<code>min-slaves-to-write</code>，健康的 slave 的个数小于 N，mater 就禁止写入</li><li>master 最少得有多少个健康的 slave 存活才能执行写命令</li><li>这个配置虽然不能保证 N 个 slave 都一定能接收到 master 的写操作，但是能避免没有足够健康的 slave 的时候，master 不能写入来避免数据丢失</li><li>设置为 0 是关闭该功能</li></ul><p><img src="https://img-blog.csdnimg.cn/bc92c34a7dd64c13accf80283e34bdfc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>延迟小于<code>min-slaves-max-lag</code>秒的 slave 才认为是健康的 slave<br><img src="https://img-blog.csdnimg.cn/03526168fc4a4d10b932db3d74fbcd7d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置1或另一个设置为0禁用这个特性<br><img src="https://img-blog.csdnimg.cn/91207b6d7a1e47bc9d5f8024bed61485.png" alt="在这里插入图片描述"></p></li></ul><h1 id="SECURITY（安全）">#### SECURITY（安全）####</h1><ul><li><p><code>requirepass</code>配置可以让用户使用 AUTH 命令来认证密码，才能使用其他命令</p><ul><li>这让 redis 可以使用在不受信任的网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证</li><li>使用<code>requirepass</code>的时候需要注意，因为 redis 太快了，每秒可以认证 15w 次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码</li><li>注意只有密码没有用户名</li></ul><p><img src="https://img-blog.csdnimg.cn/82ed1cb37007432d841d764e317f9714.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>把危险的命令给修改成其他名称</p><ul><li>比如<code>CONFIG</code>命令可以重命名为一个很难被猜到的命令，这样用户不能使用，而内部工具还能接着使用</li></ul><p><img src="https://img-blog.csdnimg.cn/5b4d31a319874fe4b40220104d5a4dd5.png" alt="在这里插入图片描述"></p></li><li><p>设置成一个空的值，可以禁止一个命令<br><img src="https://img-blog.csdnimg.cn/22ff50f560314e26a7b1193db1856b75.png" alt="在这里插入图片描述"></p></li></ul><h1 id="CLIENTS（进程限制相关）">#### CLIENTS（进程限制相关）####</h1><ul><li><p>设置能连上redis的最大客户端连接数量。默认是10000个客户端连接</p><ul><li>由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32</li><li>如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接</li></ul><p><img src="https://img-blog.csdnimg.cn/f247b272da7f42768612f7e560bfde24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>redis 配置的最大内存容量。当内存满了，需要配合<code>maxmemory-policy</code>策略进行处理</p><ul><li>注意 slave 的输出缓冲区是不计算在<code>maxmemory</code>内的</li><li>所以为了防止主机内存使用完，建议设置的<code>maxmemory</code>需要更小一些</li></ul><p><img src="https://img-blog.csdnimg.cn/66edcb20db19415e8032938a9a54ad31.png" alt="在这里插入图片描述"></p></li><li><p>内存容量超过<code>maxmemory</code>后的处理策略</p><ul><li>volatile-lru：利用 LRU 算法移除设置过过期时间的 key</li><li>volatile-random：随机移除设置过过期时间的 key</li><li>volatile-ttl：移除即将过期的 key，根据最近过期时间来删除（辅以 TTL ）</li><li>allkeys-lru：利用LRU算法移除任何 key</li><li>allkeys-random：随机移除任何 key</li><li>noeviction：不移除任何 key，只是返回一个写错误</li><li>上面的这些驱逐策略，如果 redis 没有合适的 key 驱逐，对于写命令，还是会返回错误</li><li>redis 将不再接收写请求，只接收 get 请求</li><li>写命令包括：<code>set</code> <code>setnx</code> <code>setex</code> <code>append</code> <code>incr</code> <code>decr</code> <code>rpush</code> <code>lpush</code> <code>rpushx</code> <code>lpushx</code> <code>linsert</code> <code>lset</code> <code>rpoplpush</code> <code>sadd</code> <code>sinter</code> <code>sinterstore</code> <code>sunion</code> <code>sunionstore</code> <code>sdiff</code> <code>sdiffstore</code> <code>zadd</code> <code>zincrby</code> <code>zunionstore</code> <code>zinterstore</code> <code>hset</code> <code>hsetnx</code> <code>hmset</code> <code>hincrby</code> <code>incrby</code> <code>decrby</code> <code>getset</code> <code>mset</code> <code>msetnx</code> <code>exec</code> <code>sort</code></li></ul><p><img src="https://img-blog.csdnimg.cn/c4f7018b96994c648297ad47b15ca6a7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>lru 检测的样本数</p><ul><li>使用 lru 或者 ttl 淘汰算法，从需要淘汰的列表中随机选择 sample 个 key，选出闲置时间最长的 key 移除</li></ul><p><img src="https://img-blog.csdnimg.cn/a292051cbe6241718dd8140b166e6f30.png" alt="在这里插入图片描述"></p></li></ul><h1 id="APPEND-ONLY-MODE（持久化方式）">#### APPEND ONLY MODE（持久化方式）####</h1><ul><li><p>默认 redis 使用的是 rdb 方式持久化，这种方式在许多应用中已经足够用了</p><ul><li>但是 redis 如果中途宕机，会导致可能有几分钟的数据丢失，根据 save 来策略进行持久化，<code>Append Only File</code>是另一种持久化方式，可以提供更好的持久化特性</li><li>Redis 会把每次写入的数据在接收后都写入 <code>appendonly.aof </code>文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略<code>RDB</code>文件</li></ul><p><img src="https://img-blog.csdnimg.cn/48d5154ab1434edbbdd3751ef56813eb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>aof 文件名<br><img src="https://img-blog.csdnimg.cn/3ef5525d3421466b9e3811382680fcbd.png" alt="在这里插入图片描述"></p></li><li><p>aof 持久化策略的配置</p><ul><li>no 表示不执行 fsync，由操作系统保证数据同步到磁盘，速度最快</li><li>always 表示每次写入都执行 fsync，以保证数据同步到磁盘</li><li>everysec 表示每秒执行一次 fsync，可能会导致丢失这 1s 数据</li></ul><p><img src="https://img-blog.csdnimg.cn/fd9f60ded03243a38c2409045bd3e5c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>在 aof 重写或者写入 rdb 文件的时候，会执行大量 IO</p><ul><li>此时对于 everysec 和 always 的 aof 模式来说，执行 fsync 会造成阻塞过长时间，<code>no-appendfsync-on-rewrite</code>字段设置为默认设置为 no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题</li><li>如果对延迟要求很高的应用，这个字段可以设置为 yes，，设置为 ye s表示 rewrite 期间对新写操作不 fsync，暂时存在内存中,不会造成阻塞的问题（因为没有磁盘竞争），等 rewrite 完成后再写入，这个时候 redis 会丢失数据</li><li>Linux 的默认 fsync 策略是 30 秒。可能丢失 30 秒数据</li><li>因此，如果应用系统无法忍受延迟，而可以容忍少量的数据丢失，则设置为 yes</li><li>如果应用系统无法忍受数据丢失，则设置为 no</li></ul><p><img src="https://img-blog.csdnimg.cn/94af5050d4b14ec88b7c5b5d297d9420.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>aof 自动重写配置</p><ul><li>当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写</li><li>即当 aof 文件增长到一定大小的时候Redis能够调用 bgrewriteaof 对日志文件进行重写</li><li>当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍（设置为 100 ）时，自动启动新的日志重写过程</li></ul><p><img src="https://img-blog.csdnimg.cn/478bfeb443fb4b21bd2f62538af771ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写<br><img src="https://img-blog.csdnimg.cn/05315adedea3415fa20bf0ef744f2166.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>aof 文件可能在尾部是不完整的，当 redis 启动的时候，aof 文件的数据被载入内存</p><ul><li>重启可能发生在 redis 所在的主机操作系统宕机后，尤其在 ext4 文件系统没有加上<code>data=ordered</code>选项（ redis 宕机或者异常终止不会造成尾部不完整现象。）出现这种现象</li><li>可以选择让 redis 退出，或者导入尽可能多的数据</li><li>如果选择的是 yes，当截断的 aof 文件被导入的时候，会自动发布一个 log 给客户端然后 load</li><li>如果是 no，用户必须手动<code>redis-check-aof</code>修复 AOF 文件才可以</li></ul><p><img src="https://img-blog.csdnimg.cn/cd8705e10c5544328a2a56e32c6b463c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h1 id="LUA-SCRIPTING（LUA脚本）">#### LUA SCRIPTING（LUA脚本）####</h1><ul><li><p>如果达到最大时间限制（毫秒），redis 会记个 log，然后返回 error</p><ul><li>当一个脚本超过了最大时限。只有<code>SCRIPT KILL和SHUTDOWN NOSAVE</code>可以用</li><li>第一个可以杀没有调 write 命令的东西。要是已经调用了 write，只能用第二个命令杀</li></ul><p><img src="https://img-blog.csdnimg.cn/f5443f87cacc438791aa6d5bcf160603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h1 id="REDIS-CLUSTER（集群相关）">#### REDIS CLUSTER（集群相关）####</h1><ul><li><p>集群开关，默认是不开启集群模式<br><img src="https://img-blog.csdnimg.cn/31f912e96dbf4bbf90c5e6460b57e0ad.png" alt="在这里插入图片描述"></p></li><li><p>集群配置文件的名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息</p><ul><li>这个文件并不需要手动配置，这个配置文件有 Redis 生成并更新，每个 Redis 集群节点需要一个单独的配置文件，请确保与实例运行的系统中配置文件名称不冲突</li></ul><p><img src="https://img-blog.csdnimg.cn/64f08d975ab6494f82d35125d68a232c.png" alt="在这里插入图片描述"></p></li><li><p>节点互连超时的阀值。集群节点超时毫秒数<br><img src="https://img-blog.csdnimg.cn/bcbd203397c84326aa5f56f28cf24a08.png" alt="在这里插入图片描述"></p></li><li><p>在进行故障转移的时候，全部 slave 都会请求申请为 master ，但是有些 slave 可能与 master 断开连接一段时间了，导致数据过于陈旧，这样的 slave 不应该被提升为 master</p><ul><li>该参数就是用来判断 slave 节点与 master 断线的时间是否过长</li><li>判断方法：<ul><li>比较 slave 断开连接的时间和<code>(node-timeout * slave-validity-factor) + repl-ping-slave-period</code></li><li>如果节点超时时间为三十秒, 并且<code>slave-validity-factor</code>为 10 ,假设默认的<code>repl-ping-slave-period</code>是 10 秒，即如果超过 310 秒 slave 将不会尝试进行故障转移</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/ae7ac278dc8046c0ab44d6e9771c7b91.png" alt="在这里插入图片描述"></p></li><li><p>master 的 slave 数量大于该值，slave 才能迁移到其他孤立master上</p><ul><li>如这个参数若被设为 2，那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移</li></ul><p><img src="https://img-blog.csdnimg.cn/651dc63f91ee4e2da2726af5f170102a.png" alt="在这里插入图片描述"></p></li><li><p>默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置<br><img src="https://img-blog.csdnimg.cn/700e164f8f054a9087988767abf0e896.png" alt="在这里插入图片描述"></p></li></ul><h1 id="SLOW-LOG（慢查询日志）">#### SLOW LOG（慢查询日志）####</h1><ul><li><p>slog log 是用来记录 redis 运行中执行比较慢的命令耗时</p><ul><li>当命令的执行超过了指定时间，就记录在 slow log 中，slog log 保存在内存中，所以没有 IO 操作</li><li>执行时间比<code>slowlog-log-slower-than</code>大的请求记录到 slowlog 里面，单位是微秒，所以 1000000 就是 1 秒</li><li>注意，负数时间会禁用慢查询日志，而 0 则会强制记录所有命令</li></ul><p><img src="https://img-blog.csdnimg.cn/dafaeb3ccc714e109429b47f7647b138.png" alt="在这里插入图片描述"></p></li><li><p>慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉</p><ul><li>这个长度没有限制，只要有足够的内存就行</li><li>你可以通过 <code>SLOWLOG RESET</code> 来释放内存</li></ul><p><img src="https://img-blog.csdnimg.cn/29bd2b1f9cc54d2583452d991bed6b4a.png" alt="在这里插入图片描述"></p></li></ul><h1 id="LATENCY-MONITOR（延迟监控）">#### LATENCY MONITOR（延迟监控）####</h1><ul><li><p>延迟监控功能是用来监控 redis 中执行比较缓慢的一些操作，用 LATENCY 打印 redis 实例在跑命令时的耗时图表</p><ul><li>只记录大于等于下边设置的值的操作，0 的话，就是关闭监视。默认延迟监控功能是关闭的</li><li>如果你需要打开，也可以通过<code>CONFIG SET</code>命令动态设置</li></ul><p><img src="https://img-blog.csdnimg.cn/53b22e9a3f46444d95795dd9d0675899.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5L2N5pyo5bim5oSf5oOF55qE56CB5Yac,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><h1 id="EVENT-NOTIFICATION（订阅通知）">#### EVENT NOTIFICATION（订阅通知）####</h1><ul><li><p>键空间通知使得客户端可以通过订阅频道或模式，来接收那些以某种方式改动了 Redis 数据集的事件</p><ul><li>因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态</li><li><code>notify-keyspace-events</code> 的参数可以是以下字符的任意组合</li><li>它指定了服务器该发送哪些类型的通知：<ul><li><code>K</code> 键空间通知，所有通知以 __keyspace@__ 为前缀</li><li><code>E</code> 键事件通知，所有通知以 __keyevent@__ 为前缀</li><li><code>g</code> DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</li><li><code>$</code> 字符串命令的通知</li><li><code>l</code> 列表命令的通知</li><li><code>s</code> 集合命令的通知</li><li><code>h</code> 哈希命令的通知</li><li><code>z</code> 有序集合命令的通知</li><li><code>x</code> 过期事件：每当有过期键被删除时发送</li><li><code>e</code> 驱逐(evict)事件：每当有键因为 <code>maxmemory</code>政策而被删除时发送</li><li><code>A</code> 参数 g$lshzxe 的别名</li><li>输入的参数中至少要有一个 <code>K</code> 或者 <code>E</code>，否则的话，不管其余的参数是什么，都不会有任何通知被分发</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/4e5100994a8349daa3a27cde926f9974.png" alt="在这里插入图片描述"></p></li></ul><h1 id="ADVANCED-CONFIG（高级配置）">#### ADVANCED CONFIG（高级配置）####</h1><ul><li><p>数据量小于等于<code>hash-max-ziplist-entries</code>的用 ziplist ，大于<code>hash-max-ziplist-entries</code>用 hash<br><img src="https://img-blog.csdnimg.cn/9a6d4a795f2d43d2a1b8175452779e3a.png" alt="在这里插入图片描述"></p></li><li><p>value 大小小于等于<code>hash-max-ziplist-value</code>的用 ziplist，大于<code>hash-max-ziplist-value</code>用 hash<br><img src="https://img-blog.csdnimg.cn/18fdffa7de7742e5aa97fa05cc356498.png" alt="在这里插入图片描述"></p></li><li><p>数据量小于等于<code>set-max-intset-entries</code>用 iniset，大于<code>set-max-intset-entries</code>用 set<br><img src="https://img-blog.csdnimg.cn/ca8e9df21e92432191daea97b22047dd.png" alt="在这里插入图片描述"></p></li><li><p>value 大小小于等于<code>zset-max-ziplist-value</code>用 ziplist，大于<code>zset-max-ziplist-value</code>用 zset<br><img src="https://img-blog.csdnimg.cn/44ce0be71ac44ca09f49a92b1bd367b9.png" alt="在这里插入图片描述"></p></li><li><p>数据量小于等于<code>zset-max-ziplist-entries</code>用 ziplist ，大于<code>zset-max-ziplist-entries</code>用 zset<br><img src="https://img-blog.csdnimg.cn/e82af1b17e0f4acca739fe634a3ddc17.png" alt="在这里插入图片描述"></p></li><li><p>value 大小小于等于<code>hll-sparse-max-bytes</code>使用稀疏数据结构（sparse），大于<code>hll-sparse-max-bytes</code>使用稠密的数据结构（dense）</p><ul><li>一个比 16000 大的 value 是几乎没用的，建议的 value 大概为 3000</li><li>如果对 CPU 要求不高，对空间要求较高的，建议设置到 10000 左右</li></ul><p><img src="https://img-blog.csdnimg.cn/a2cdb029d80e4acfa36df49d4233e50e.png" alt="在这里插入图片描述"></p></li><li><p>Redis 将在每100毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash，可以降低内存的使用</p><ul><li>当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no</li><li>如果没有这么严格的实时性要求，可以设置为 yes，以便能够尽可能快的释放内存</li></ul><p><img src="https://img-blog.csdnimg.cn/098f6370919445e6a7ad34f337bf9797.png" alt="在这里插入图片描述"></p></li><li><p>redis 执行任务的频率为 1s 除以 hz</p><ul><li>在 aof 重写的时候，如果打开了<code>aof-rewrite-incremental-fsync</code>开关，系统会每 32MB 执行一次 fsync</li><li>这对于把文件写入磁盘是有帮助的，可以避免过大的延迟峰值</li></ul><p><img src="https://img-blog.csdnimg.cn/10e77ecba71e47e1aab3dfb66abd49b8.png" alt="在这里插入图片描述"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python整数相除保留小数SyntaxError: from __future__ imports must occur at the beginning of the file</title>
      <link href="/2021/08/23/python_13/"/>
      <url>/2021/08/23/python_13/</url>
      
        <content type="html"><![CDATA[<p>今天在测试时发现结果有问题，排查出是因为两个变量相除时没有保留小数<br><img src="https://img-blog.csdnimg.cn/adf2ecc999c04524a21412e560472810.png" alt="在这里插入图片描述"><br>通过百度可以通过添加<code>from __future__ import division</code>的方法来保留小数，结果运行后报下面的错<br><img src="https://img-blog.csdnimg.cn/f16596ec1b5d4cb8a6d82a1b068c7b58.png" alt="在这里插入图片描述"><br>最后发现原来<code>from __future__ import division</code>是要放在所有代码的最前面才行<br><img src="https://img-blog.csdnimg.cn/a497a8d21c91498b99a53d903c6a3c54.png" alt="在这里插入图片描述"><br>这样就能正确保留小数位了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug记录 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的事务操作、乐观锁</title>
      <link href="/2021/08/17/redis_9/"/>
      <url>/2021/08/17/redis_9/</url>
      
        <content type="html"><![CDATA[<h1 id="1-事务的定义">1. 事务的定义</h1><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>本质上就是一组命令的集合，一个事务中的所有命令都会被序列化，按顺序执行。<br>Redis事务的主要作用就是<code>串联多个命令</code>防止别的命令插队。<br>所有的命令在事务中，并没有直接执行，二是发起执行命令<code>Exec</code>的时候才会执行。<br><strong>Redis 事务没有隔离级别的概念。</strong><br><strong>Redis 单条命令是保证原子性的，但是事务不保证原子性。</strong></p><h1 id="2-事务的提交">2. 事务的提交</h1><p>从输入<code>Multi</code>命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入<code>Exec</code>后，Redis 会将之前的命令队列中的命令依次执行。<br>组队的过程中可以通过<code>discard</code>来放弃组队。<br><img src="https://img-blog.csdnimg.cn/ba0f00e2461641828a89a7c609af84ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>案例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure><h1 id="3-事务的错误处理">3. 事务的错误处理</h1><p>组队中某个命令出现了报告错误，也就是<code>编译型异常</code>（代码有问题，命令报错），执行时整个的所有队列都会被取消。<br><img src="https://img-blog.csdnimg.cn/b1970196a9144c2d8a4ea99310437514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">如果执行阶段某个命令报出了错误，也就是<code>运行时异常</code>，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。<br><img src="https://img-blog.csdnimg.cn/eb036751f9eb41fcb65be840d3f6ad53.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="4-为什么要做成事务">4. 为什么要做成事务</h1><p>场景：有很多人同时操作你的账户,同时去参加双十一抢购，没有事务性的后果…</p><h1 id="5-事务冲突的问题">5. 事务冲突的问题</h1><h2 id="5-1-举例">5.1 举例</h2><p>一个请求想给金额减8000<br>一个请求想给金额减5000<br>一个请求想给金额减1000<br><img src="https://img-blog.csdnimg.cn/18532710c8fb4a70ae4324061366b83f.png#pic_center" alt="在这里插入图片描述"></p><h2 id="5-2-悲观锁">5.2 悲观锁</h2><p><img src="https://img-blog.csdnimg.cn/fe9ca0bc15b44ec9998e0e23527aa04a.png#pic_center" alt="在这里插入图片描述"><br><code>悲观锁(Pessimistic Lock)</code>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<code>传统的关系型数据库里边就用到了很多这种锁机制</code>，比如<code>行锁</code>，<code>表锁</code>等，<code>读锁</code>，<code>写锁</code>等，都是在做操作之前先上锁。</p><h2 id="5-3-乐观锁">5.3 乐观锁</h2><p><img src="https://img-blog.csdnimg.cn/0a9307c7bad34e7ba6a7a249888db6d8.png#pic_center" alt="在这里插入图片描述"><br><code>乐观锁(Optimistic Lock)</code>, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<code>乐观锁适用于多读的应用类型，这样可以提高吞吐量</code>。<code>Redis就是利用这种check-and-set机制实现事务的</code>。</p><h2 id="5-4-watch监视">5.4 watch监视</h2><p>在执行<code>multi</code>之前，先执行<code>watch key1 [key2]</code>，可以监视一个(或多个) key ，如果在事务执行之前这个（或这些） key 被其他命令所改动，那么事务将被打断。</p><p><strong>正常执行：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br></pre></td></tr></table></figure><p><strong>利用多线程修改值，使用<code>watch</code>可以当做 redis 的乐观锁操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 10</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>此时先不执行<code>exec</code>，重新开启另一个客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line">&quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; set money 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>这时再回到客户端一继续执行<code>exec</code>，可以看到事务执行失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>使用<code>unwatch</code>命令可以取消<code>watch</code>命令对所有 key 的监视。<br>如果在执行 <code>watch</code>命令之后，<code>exec</code>命令或<code>discard</code>命令先被执行了的话，那么就不需要再执行<code>unwatch</code>了。</p><h1 id="6-Redis事务的三大特性">6. Redis事务的三大特性</h1><ul><li><strong>单独的隔离操作</strong><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul></li><li><strong>没有隔离级别的概念</strong><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</li></ul></li><li><strong>不保证原子性</strong><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul></li></ul><h1 id="7-Redis事务秒杀案例">7. Redis事务秒杀案例</h1><h2 id="7-1-解决计数器和人员记录的事务操作">7.1 解决计数器和人员记录的事务操作</h2><p><img src="https://img-blog.csdnimg.cn/8682b6505fb74a28861c5475386bb521.png#pic_center" alt="在这里插入图片描述"></p><h2 id="7-2-秒杀并发模拟">7.2 秒杀并发模拟</h2><p>使用工具ab模拟测试：</p><ol><li>yum install httpd-tools</li><li>vim postfile 模拟表单提交参数,以&amp;符号结尾，存放在当前目录</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prodid=0101&amp;</span><br></pre></td></tr></table></figure><ol start="3"><li>执行<code>ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded</code><br><img src="https://img-blog.csdnimg.cn/54b7a0ba51a74a4c9d639052f4509e44.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0cd6bbe0697c44e78c60b6e1a52c5d18.png" alt="在这里插入图片描述"></li></ol><h2 id="7-3-超卖问题">7.3 超卖问题</h2><p><img src="https://img-blog.csdnimg.cn/6f2654e6d03c443397629049ee30e1db.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="7-4-利用乐观锁淘汰用户，解决超卖问题">7.4 利用乐观锁淘汰用户，解决超卖问题</h2><p><img src="https://img-blog.csdnimg.cn/c46505e89eff4bf7893d6c35f45be1c0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加乐观锁</span></span><br><span class="line">jedis.watch(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.判断库存</span></span><br><span class="line"><span class="type">String</span> <span class="variable">qtkeystr</span> <span class="operator">=</span> jedis.get(qtkey);</span><br><span class="line"><span class="keyword">if</span>(qtkeystr==<span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(qtkeystr.trim())) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;未初始化库存&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="variable">qt</span> <span class="operator">=</span> Integer.parseInt(qtkeystr);</span><br><span class="line"><span class="keyword">if</span>(qt&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;已经秒光&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//4.减少库存</span></span><br><span class="line"><span class="comment">//jedis.decr(qtkey);</span></span><br><span class="line">multi.decr(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//5.加人</span></span><br><span class="line"><span class="comment">//jedis.sadd(usrkey, uid);</span></span><br><span class="line">multi.sadd(usrkey, uid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行事务</span></span><br><span class="line">List&lt;Object&gt; list = multi.exec();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断事务提交是否失败</span></span><br><span class="line"><span class="keyword">if</span>(list==<span class="literal">null</span> || list.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f3c19f14fedf4d4dbd14dce1ed5de16c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/05e5afa1d1fa476ca068136fdb59400b.png" alt="在这里插入图片描述"></p><h2 id="7-5-继续增加并发测试">7.5 继续增加并发测试</h2><h3 id="7-5-1-连接有限制">7.5.1 连接有限制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 2000 -c 200 -k -p postfile -T &#x27;application/x-www-form-urlencoded&#x27; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c717ecddf2544b6ca520552ee9bda223.png#pic_center" alt="在这里插入图片描述">增加<code>-r</code>参数，<code>-r</code>   <code>Don't exit on socket receive errors.</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 2000 -c 100 -r -p postfile -T &#x27;application/x-www-form-urlencoded&#x27; </span><br></pre></td></tr></table></figure><h3 id="7-5-2-已经秒光，可是还有库存">7.5.2 已经秒光，可是还有库存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 2000 -c 100 -p postfile -T &#x27;application/x-www-form-urlencoded&#x27; </span><br></pre></td></tr></table></figure><p>已经秒光，可是还有库存。原因就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。<br><img src="https://img-blog.csdnimg.cn/6a1c4ebef25044109a798fb8d16b74e2.png#pic_center" alt="在这里插入图片描述"></p><h3 id="7-5-3-连接超时，通过连接池解决">7.5.3 连接超时，通过连接池解决</h3><p><img src="https://img-blog.csdnimg.cn/bc80bd824d344937b83361e4684f9250.png#pic_center" alt="在这里插入图片描述"></p><h3 id="7-5-4-连接池">7.5.4 连接池</h3><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。<br>通过参数管理连接的行为</p><ul><li>连接池参数<ul><li>MaxTotal：控制一个 pool 可分配多少个 jedis 实例，通过<code>pool.getResource()</code>来获取；如果赋值为 -1 ，则表示不限制；如果 pool 已经分配了 MaxTotal 个 jedis 实例，则此时 pool 的状态为 exhausted</li><li>maxIdle：控制一个 pool 最多有多少个状态为 idle (空闲)的 jedis 实例</li><li>MaxWaitMillis：表示当 borrow 一个 jedis 实例时，最大的等待毫秒数，如果超过等待时间，则直接抛<code>JedisConnectionException</code></li><li>testOnBorrow：获得一个 jedis 实例的时候是否检查连接可用性（ping()）；如果为 true ，则得到的 jedis 实例均是可用的</li></ul></li></ul><h2 id="7-6-解决库存遗留问题">7.6 解决库存遗留问题</h2><h3 id="7-6-1-LUA脚本">7.6.1 LUA脚本</h3><p><img src="https://img-blog.csdnimg.cn/81fb72f1c3af44a8bd361e720831e62a.png" alt="在这里插入图片描述"><br>Lua 是一个小巧的脚本语言，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。<br>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。<br>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</p><h3 id="7-6-2-LUA脚本在Redis中的优势">7.6.2 LUA脚本在Redis中的优势</h3><p><strong>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。</strong><br>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。<br>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。<br>利用lua脚本淘汰用户，解决超卖问题。<br>redis 2.6版本以后，通过lua脚本解决<code>争抢问题</code>，实际上是<code>redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题</code>。<br><img src="https://img-blog.csdnimg.cn/224ddedcb783401db304949350ab00f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AttributeEroor: ‘list‘ object has no attribute ‘clear‘</title>
      <link href="/2021/08/13/python_12/"/>
      <url>/2021/08/13/python_12/</url>
      
        <content type="html"><![CDATA[<p>今天在测试时出现了<code>AttributeEroor: 'list' object has no attribute 'clear'</code>的报错<br><img src="https://img-blog.csdnimg.cn/671f43f13029467797a9d7fb3d2be34d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>经过查询发现，原来是 python2.7 版本的列表没有clear()方法，把<code>dataList.clear()</code>改为<code>dataList = []</code>即可。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug记录 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之对文件进行哈希校验</title>
      <link href="/2021/08/10/python_11/"/>
      <url>/2021/08/10/python_11/</url>
      
        <content type="html"><![CDATA[<p>需求为对文件进行加密，保留哈希，防止别人篡改文件，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time,re,os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> watchdog.events <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> watchdog.observers <span class="keyword">import</span> Observer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotation_left</span>(<span class="params">x, num</span>):</span><br><span class="line">    <span class="comment"># 循环左移</span></span><br><span class="line">    num %= <span class="number">32</span></span><br><span class="line">    left = (x &lt;&lt; num) % (<span class="number">2</span> ** <span class="number">32</span>)</span><br><span class="line">    right = (x &gt;&gt; (<span class="number">32</span> - num)) % (<span class="number">2</span> ** <span class="number">32</span>)</span><br><span class="line">    result = left ^ right</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Int2Bin</span>(<span class="params">x, k</span>):</span><br><span class="line">    x = <span class="built_in">str</span>(<span class="built_in">bin</span>(x)[<span class="number">2</span>:])</span><br><span class="line">    result = <span class="string">&quot;0&quot;</span> * (k - <span class="built_in">len</span>(x)) + x</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SM3</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 常量初始化</span></span><br><span class="line">        self.IV = [<span class="number">0x7380166F</span>, <span class="number">0x4914B2B9</span>, <span class="number">0x172442D7</span>, <span class="number">0xDA8A0600</span>, <span class="number">0xA96F30BC</span>, <span class="number">0x163138AA</span>, <span class="number">0xE38DEE4D</span>, <span class="number">0xB0FB0E4E</span>]</span><br><span class="line">        self.T = [<span class="number">0x79cc4519</span>, <span class="number">0x7a879d8a</span>]</span><br><span class="line">        self.maxu32 = <span class="number">2</span> ** <span class="number">32</span></span><br><span class="line">        self.w1 = [<span class="number">0</span>] * <span class="number">68</span></span><br><span class="line">        self.w2 = [<span class="number">0</span>] * <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ff</span>(<span class="params">self, x, y, z, j</span>):</span><br><span class="line">        <span class="comment"># 布尔函数FF</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">16</span>:</span><br><span class="line">            result = x ^ y ^ z</span><br><span class="line">        <span class="keyword">elif</span> j &gt;= <span class="number">16</span>:</span><br><span class="line">            result = (x &amp; y) | (x &amp; z) | (y &amp; z)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gg</span>(<span class="params">self, x, y, z, j</span>):</span><br><span class="line">        <span class="comment"># 布尔函数GG</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">16</span>:</span><br><span class="line">            result = x ^ y ^ z</span><br><span class="line">        <span class="keyword">elif</span> j &gt;= <span class="number">16</span>:</span><br><span class="line">            result = (x &amp; y) | (~x &amp; z)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">p</span>(<span class="params">self, x, mode</span>):</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 置换函数P</span></span><br><span class="line">        <span class="comment"># 输入参数X的长度为32bit(=1个字)</span></span><br><span class="line">        <span class="comment"># 输入参数mode共两种取值：0和1</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="number">0</span>:</span><br><span class="line">            result = x ^ rotation_left(x, <span class="number">9</span>) ^ rotation_left(x, <span class="number">17</span>)</span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="number">1</span>:</span><br><span class="line">            result = x ^ rotation_left(x, <span class="number">15</span>) ^ rotation_left(x, <span class="number">23</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_fill</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="comment"># 填充消息，使其长度为512bit的整数倍</span></span><br><span class="line">        <span class="comment"># 输入参数msg为bytearray类型</span></span><br><span class="line">        <span class="comment"># 中间参数msg_new_bin为二进制string类型</span></span><br><span class="line">        <span class="comment"># 输出参数msg_new_bytes为bytearray类型</span></span><br><span class="line">        length = <span class="built_in">len</span>(msg)  <span class="comment"># msg的长度（单位：byte）</span></span><br><span class="line">        l = length * <span class="number">8</span>  <span class="comment"># msg的长度（单位：bit）</span></span><br><span class="line"></span><br><span class="line">        num = length // <span class="number">64</span></span><br><span class="line">        remain_byte = length % <span class="number">64</span></span><br><span class="line">        msg_remain_bin = <span class="string">&quot;&quot;</span></span><br><span class="line">        msg_new_bytes = <span class="built_in">bytearray</span>((num + <span class="number">1</span>) * <span class="number">64</span>)  <span class="comment">##填充后的消息长度，单位：byte</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将原数据存储至msg_new_bytes中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            msg_new_bytes[i] = msg[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># remain部分以二进制字符串形式存储</span></span><br><span class="line">        remain_bit = remain_byte * <span class="number">8</span>  <span class="comment"># 单位：bit</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(remain_byte):</span><br><span class="line">            msg_remain_bin += <span class="string">&quot;&#123;:08b&#125;&quot;</span>.<span class="built_in">format</span>(msg[num * <span class="number">64</span> + i])</span><br><span class="line"></span><br><span class="line">        k = (<span class="number">448</span> - l - <span class="number">1</span>) % <span class="number">512</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># k为满足 l + k + 1 = 448 % 512 的最小非负整数</span></span><br><span class="line">            k += <span class="number">512</span></span><br><span class="line"></span><br><span class="line">        msg_remain_bin += <span class="string">&quot;1&quot;</span> + <span class="string">&quot;0&quot;</span> * k + Int2Bin(l, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">64</span> - remain_byte):</span><br><span class="line">            <span class="built_in">str</span> = msg_remain_bin[i * <span class="number">8</span> + remain_bit: (i + <span class="number">1</span>) * <span class="number">8</span> + remain_bit]</span><br><span class="line">            temp = length + i</span><br><span class="line">            msg_new_bytes[temp] = <span class="built_in">int</span>(<span class="built_in">str</span>, <span class="number">2</span>)  <span class="comment"># 将2进制字符串按byte为组转换为整数</span></span><br><span class="line">        <span class="keyword">return</span> msg_new_bytes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_msg_extend</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="comment"># 扩展函数: 将512bit的数据msg扩展为132个字（w1共68个字，w2共64个字）</span></span><br><span class="line">        <span class="comment"># 输入参数msg为bytearray类型,长度为512bit=64byte</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">16</span>):</span><br><span class="line">            self.w1[i] = <span class="built_in">int</span>.from_bytes(msg[i * <span class="number">4</span>:(i + <span class="number">1</span>) * <span class="number">4</span>], byteorder=<span class="string">&quot;big&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>, <span class="number">68</span>):</span><br><span class="line">            self.w1[i] = self.p(self.w1[i - <span class="number">16</span>] ^ self.w1[i - <span class="number">9</span>] ^ rotation_left(self.w1[i - <span class="number">3</span>], <span class="number">15</span>),</span><br><span class="line">                                <span class="number">1</span>) ^ rotation_left(self.w1[i - <span class="number">13</span>], <span class="number">7</span>) ^ self.w1[i - <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">            self.w2[i] = self.w1[i] ^ self.w1[i + <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 测试扩展数据w1和w2</span></span><br><span class="line">        <span class="comment"># print(&quot;w1:&quot;)</span></span><br><span class="line">        <span class="comment"># for i in range(0, len(self.w1), 8):</span></span><br><span class="line">        <span class="comment">#     print(hex(self.w1[i]))</span></span><br><span class="line">        <span class="comment"># print(&quot;w2:&quot;)</span></span><br><span class="line">        <span class="comment"># for i in range(0, len(self.w2), 8):</span></span><br><span class="line">        <span class="comment">#     print(hex(self.w2[i]))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_compress</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="comment"># 压缩函数</span></span><br><span class="line">        <span class="comment"># 输入参数v为初始化参数，类型为bytes/bytearray，大小为256bit</span></span><br><span class="line">        <span class="comment"># 输入参数msg为512bit的待压缩数据</span></span><br><span class="line"></span><br><span class="line">        self.sm3_msg_extend(msg)</span><br><span class="line">        ss1 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        A = self.IV[<span class="number">0</span>]</span><br><span class="line">        B = self.IV[<span class="number">1</span>]</span><br><span class="line">        C = self.IV[<span class="number">2</span>]</span><br><span class="line">        D = self.IV[<span class="number">3</span>]</span><br><span class="line">        E = self.IV[<span class="number">4</span>]</span><br><span class="line">        F = self.IV[<span class="number">5</span>]</span><br><span class="line">        G = self.IV[<span class="number">6</span>]</span><br><span class="line">        H = self.IV[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">16</span>:</span><br><span class="line">                ss1 = rotation_left((rotation_left(A, <span class="number">12</span>) + E + rotation_left(self.T[<span class="number">0</span>], j)) % self.maxu32, <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">elif</span> j &gt;= <span class="number">16</span>:</span><br><span class="line">                ss1 = rotation_left((rotation_left(A, <span class="number">12</span>) + E + rotation_left(self.T[<span class="number">1</span>], j)) % self.maxu32, <span class="number">7</span>)</span><br><span class="line">            ss2 = ss1 ^ rotation_left(A, <span class="number">12</span>)</span><br><span class="line">            tt1 = (self.ff(A, B, C, j) + D + ss2 + self.w2[j]) % self.maxu32</span><br><span class="line">            tt2 = (self.gg(E, F, G, j) + H + ss1 + self.w1[j]) % self.maxu32</span><br><span class="line">            D = C</span><br><span class="line">            C = rotation_left(B, <span class="number">9</span>)</span><br><span class="line">            B = A</span><br><span class="line">            A = tt1</span><br><span class="line">            H = G</span><br><span class="line">            G = rotation_left(F, <span class="number">19</span>)</span><br><span class="line">            F = E</span><br><span class="line">            E = self.p(tt2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 测试IV的压缩中间值</span></span><br><span class="line">            <span class="comment"># print(&quot;j= %d：&quot; % j, hex(A)[2:], hex(B)[2:], hex(C)[2:], hex(D)[2:], hex(E)[2:], hex(F)[2:], hex(G)[2:], hex(H)[2:])</span></span><br><span class="line"></span><br><span class="line">        self.IV[<span class="number">0</span>] ^= A</span><br><span class="line">        self.IV[<span class="number">1</span>] ^= B</span><br><span class="line">        self.IV[<span class="number">2</span>] ^= C</span><br><span class="line">        self.IV[<span class="number">3</span>] ^= D</span><br><span class="line">        self.IV[<span class="number">4</span>] ^= E</span><br><span class="line">        self.IV[<span class="number">5</span>] ^= F</span><br><span class="line">        self.IV[<span class="number">6</span>] ^= G</span><br><span class="line">        self.IV[<span class="number">7</span>] ^= H</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_update</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="comment"># 迭代函数</span></span><br><span class="line">        <span class="comment"># 输入参数msg为bytearray类型</span></span><br><span class="line">        <span class="comment"># msg_new为bytearray类型</span></span><br><span class="line">        msg_new = self.sm3_fill(msg)  <span class="comment"># msg_new经过填充后一定是512的整数倍</span></span><br><span class="line">        n = <span class="built_in">len</span>(msg_new) // <span class="number">64</span>  <span class="comment"># n是整数，n&gt;=1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">            self.sm3_compress(msg_new[i * <span class="number">64</span>:(i + <span class="number">1</span>) * <span class="number">64</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm3_final</span>(<span class="params">self</span>):</span><br><span class="line">        digest_str = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.IV)):</span><br><span class="line">            digest_str += <span class="built_in">hex</span>(self.IV[i])[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> digest_str.upper()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hashFile</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            contents = fp.read()</span><br><span class="line">            self.sm3_update(<span class="built_in">bytearray</span>(contents))</span><br><span class="line">        <span class="keyword">return</span> self.sm3_final()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileName</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 获取指定目录下的所有指定后缀的文件名 &#x27;&#x27;&#x27;</span></span><br><span class="line">    f_list = os.listdir(path)</span><br><span class="line">    <span class="comment"># print f_list</span></span><br><span class="line">    <span class="built_in">list</span> = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f_list:</span><br><span class="line">        <span class="comment"># os.path.splitext():分离文件名与扩展名</span></span><br><span class="line">        <span class="keyword">if</span> os.path.splitext(i)[<span class="number">1</span>] == <span class="string">&#x27;.tsidx&#x27;</span>:</span><br><span class="line">            <span class="built_in">list</span>.append(i)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileEventHandler</span>(<span class="title class_ inherited__">FileSystemEventHandler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        FileSystemEventHandler.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_created</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="keyword">if</span> event.is_directory:</span><br><span class="line">            <span class="built_in">print</span>(event.src_path)</span><br><span class="line">            time.sleep(<span class="number">15</span>)</span><br><span class="line">            <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;db_\d+_\d+_\d+&quot;</span>).findall(event.src_path.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]):</span><br><span class="line">                <span class="built_in">list</span> = getFileName(event.src_path)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">                    file_digest = SM3().hashFile(event.src_path + <span class="string">&quot;/&quot;</span> + <span class="built_in">list</span>[i])</span><br><span class="line">                    file = <span class="built_in">open</span>(event.src_path + <span class="string">&quot;/sm3(&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;).txt&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">                    file.write(file_digest+ <span class="string">&quot; &quot;</span> + <span class="built_in">list</span>[i] + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                    file.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    observer = Observer()</span><br><span class="line">    event_handler = FileEventHandler()</span><br><span class="line">    observer.schedule(event_handler, <span class="string">&quot;/tmp&quot;</span>, <span class="literal">True</span>)</span><br><span class="line">    observer.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        observer.stop()</span><br><span class="line">    observer.join()</span><br></pre></td></tr></table></figure><p>代码中借鉴了<a href="https://blog.csdn.net/weixin_43936250/article/details/105543266">https://blog.csdn.net/weixin_43936250/article/details/105543266</a>的sm3加密，和<a href="https://blog.csdn.net/jerry_liufeng/article/details/109603462">https://blog.csdn.net/jerry_liufeng/article/details/109603462</a>的目录实时监控</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 新建脚本开头模板设置</title>
      <link href="/2021/08/09/pycharm_2/"/>
      <url>/2021/08/09/pycharm_2/</url>
      
        <content type="html"><![CDATA[<ol><li>点击菜单栏左上角<code>File</code>，选择<code>Settings</code>（快捷键：【ctrl】+【Alt】+【s】）</li><li>点击<code>Editor</code>，选择<code>File and Code Templates</code><br><img src="https://img-blog.csdnimg.cn/de03e74452a043bfa740554007d14f11.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>选择<code>Python Script</code><br><img src="https://img-blog.csdnimg.cn/d573faf7480248338b178f34be96a700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>在对应位置上写上对应的代码<br><img src="https://img-blog.csdnimg.cn/82d0a25ac4e848738ecdc0ca98f0b0ca.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是我写的代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">##!/usr/bin/python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time : $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"># @Author : $&#123;USER&#125;</span><br><span class="line"># @Email : 邮箱地址</span><br><span class="line"># @File : $&#123;NAME&#125;.py</span><br><span class="line"># @Project : $&#123;PROJECT_NAME&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>保存之后新建py文件开头就会有模板了<br><img src="https://img-blog.csdnimg.cn/7bff6be93bb3445f9afd47dc0b3f10d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p>其他可用的预定义模板变量：<br><img src="https://img-blog.csdnimg.cn/748921f6945048fd8f44f3ca444a4759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm 修改背景颜色</title>
      <link href="/2021/08/09/pycharm_1/"/>
      <url>/2021/08/09/pycharm_1/</url>
      
        <content type="html"><![CDATA[<ol><li>打开PyCharm，可以看的默认是黑色的<br><img src="https://img-blog.csdnimg.cn/73065aa97c87436eb397bc57d495c556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击菜单栏左上角<code>File</code>，选择<code>Settings</code>（快捷键：【ctrl】+【Alt】+【s】）<br><img src="https://img-blog.csdnimg.cn/7c54d55693584cc3826a82900726f379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击<code>Editor</code>，选择<code>color Scheme</code>，默认Scheme有八种，这样就可以修改背景主题了<br><img src="https://img-blog.csdnimg.cn/4ef1279c4d70496da10592c1247b31ea.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下安装 Scala</title>
      <link href="/2021/08/09/scala_2/"/>
      <url>/2021/08/09/scala_2/</url>
      
        <content type="html"><![CDATA[<ol><li><p>安装scala首先需要java6以上的支持，这里是java的安装教程：<a href="https://blog.csdn.net/weixin_44758876/article/details/119546446">windows下安装java</a></p></li><li><p>然后去官网下载自己需要的版本，我这里下载的是2.12.14的：<a href="https://www.scala-lang.org/download/2.12.14.html">https://www.scala-lang.org/download/2.12.14.html</a></p></li><li><p>点击安装包安装<br><img src="https://img-blog.csdnimg.cn/c653a5e23a2f414ebdecd2ecc4bb4860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一路默认即可，路径可以自己指定</p></li><li><p>配置环境变量，左下角搜索高级系统设置<br><img src="https://img-blog.csdnimg.cn/3ea274b434c14bc4ae2ad91119263ca6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>点击环境变量，点击新建，设置变量名和路径<br><img src="https://img-blog.csdnimg.cn/33bc0d683c9847f9aad7b3af9655d3d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>创建SCALA_HOME变量<br><img src="https://img-blog.csdnimg.cn/33a26cd48f654b97b5ce8fec05be66db.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p></li><li><p>再编辑CLASSPATH变量，在后面加入<code>;%SCALA_HOME%\bin;%SCALA_HOME%\lib\dt.jar;%SCALA_HOME%\lib\tools.jar</code>内容<br><img src="https://img-blog.csdnimg.cn/69833fd7dc93441a81fb1906a1689868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>选择Path变量，点击编辑，再点击新建<br><img src="https://img-blog.csdnimg.cn/f7a4451fad0d4e33ae1ad674b0a38f05.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5dcd102337044fff84fabbb92deaec99.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>新建，加入下面两行内容，然后保存即可<br><img src="https://img-blog.csdnimg.cn/75ec44cebbfb47c1927071e6bf330169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>最后验证安装成功即可<br><img src="https://img-blog.csdnimg.cn/a32e58381e96426b9217414633ec7c75.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下安装 Java</title>
      <link href="/2021/08/09/java_3/"/>
      <url>/2021/08/09/java_3/</url>
      
        <content type="html"><![CDATA[<ol><li>首先上官网下载安装包：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></li><li>点击安装包进行安装<br><img src="https://img-blog.csdnimg.cn/b7c8369895fa4657b3f2f1315c9d0097.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0104b276bc9946d28819d942553eace9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>安装完毕，配置环境变量</li><li>左下角搜索高级系统设置<br><img src="https://img-blog.csdnimg.cn/3ea274b434c14bc4ae2ad91119263ca6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击环境变量，点击新建，设置变量名和路径<br><img src="https://img-blog.csdnimg.cn/33bc0d683c9847f9aad7b3af9655d3d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/cae6cf8193dd4e4599162f187a4ec225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>再新建CLASSPATH变量，注意内容是<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code><br><img src="https://img-blog.csdnimg.cn/a5e0448a943349049a0bc8df6a1f4886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>选择Path变量，点击编辑，再点击新建<br><img src="https://img-blog.csdnimg.cn/f7a4451fad0d4e33ae1ad674b0a38f05.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5dcd102337044fff84fabbb92deaec99.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击新建，在下面追加<code>%JAVA_HOME%\bin</code>和<code>%JAVA_HOME%\jre\bin</code><br><img src="https://img-blog.csdnimg.cn/8860873e87f9406081e8daab8075b6a6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>保存生效，然后验证安装成功即可<br><img src="https://img-blog.csdnimg.cn/f374542af6334bf790b6cdf3ad0a9fb6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下安装 Python 环境</title>
      <link href="/2021/08/09/python_10/"/>
      <url>/2021/08/09/python_10/</url>
      
        <content type="html"><![CDATA[<ol><li>首先去官网下载安装包：<a href="https://www.python.org/">https://www.python.org/</a><br>我下载的是3.9.6版本，目前最新的版本</li><li>运行安装包，选择自定义安装，也可以选择默认安装<br><img src="https://img-blog.csdnimg.cn/c94ba6a274204027bd4a05f220b9da95.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5d596d7f6954476ca3bb76334bd012a3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>安装在指定目录下<br><img src="https://img-blog.csdnimg.cn/646a1960e3654ecdb528f311e2342e27.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>安装完毕后，可以禁用系统的Path长度自动限制，后面会省去不少麻烦<br><img src="https://img-blog.csdnimg.cn/2299da22c8f24990bd1d37a3b70831a7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>打印“hello python”，检验安装成功<br><img src="https://img-blog.csdnimg.cn/a95c3f39357844bf893a6dba9e1899a3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之 API 数据合并（第二版）</title>
      <link href="/2021/07/29/python_9/"/>
      <url>/2021/07/29/python_9/</url>
      
        <content type="html"><![CDATA[<p>这是继上一篇<a href="https://blog.csdn.net/weixin_44758876/article/details/118413513">python脚本之api数据合并</a>之后做出的第二版，最近比较忙一直拖到现在才想起来更新。<br>第一版实现的是单参数的合并，这一版就是实现多参数的合并了，样例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/api/login/001-1/index/1</span><br><span class="line">/api/login/001-2/index/2</span><br><span class="line">/api/login/001-3/index/3</span><br><span class="line">/api/login/001-4/index/4</span><br></pre></td></tr></table></figure><p>最后合并成下面的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/login/&#123;id1&#125;/index/&#123;id2&#125;</span><br></pre></td></tr></table></figure><p>代码加注释一共三百行左右，说实话我自己看着都费事，所以做了个xmind思维导图，和部分模块的“白话版”代码。<br>思维导图：<br><img src="https://img-blog.csdnimg.cn/57f88939f81a4f5199c6790944e7a5aa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图画的一般，，，，凑合看吧。<br>“白话版”代码块放最后，先上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,math,datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将包含数字的段替换为“&#123;id1&#125;，&#123;id2&#125;，&#123;id3&#125;...”</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="built_in">list</span> = re.findall(<span class="string">&#x27;/[^/,]*\d[^/,]*&#x27;</span>, data)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        data = data.replace(<span class="built_in">list</span>[i], <span class="string">&quot;/&#123;id&quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;&#125;&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># C:\\Users\\lkm86\\Desktop\\API自动发现2021-06-24 17_46_41.csv</span></span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\lkm86\\Desktop\\API自动发现2021-07-20 16_04_32.csv&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 读取数据</span></span><br><span class="line">    content = file.readlines()</span><br><span class="line">    <span class="comment"># 存放一个包含数字的段的要计数api</span></span><br><span class="line">    patternList = []</span><br><span class="line">    <span class="comment"># 存放一个包含数字的段的api</span></span><br><span class="line">    patternBranch = []</span><br><span class="line">    <span class="comment"># 存放多个包含数字的段的api</span></span><br><span class="line">    patternsDict = &#123;&#125;</span><br><span class="line">    <span class="comment"># # 存放多个包含数字的段的api</span></span><br><span class="line">    patternsBranch = &#123;&#125;</span><br><span class="line">    <span class="comment"># 存放最终结果</span></span><br><span class="line">    patterns = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    数据分组，划分为：</span></span><br><span class="line"><span class="string">        （1）不包含数字；</span></span><br><span class="line"><span class="string">        （2）1个段包含数字；</span></span><br><span class="line"><span class="string">        （3）N+1个段包含数字。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 遍历数据列表</span></span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> content:</span><br><span class="line">        <span class="comment"># 取出api中包含数字的段</span></span><br><span class="line">        apiList = re.findall(<span class="string">&#x27;/[^/,]*\d[^/,]*&#x27;</span>, lines)</span><br><span class="line">        <span class="comment"># 正则匹配是否有包含数字的段</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(apiList) &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 替换包含数字的段为“&#123;id&#125;”</span></span><br><span class="line">            api = sub(lines)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将替换后的api表达式再和别的字段合并放入patternsDict，后续计数使用</span></span><br><span class="line">            <span class="keyword">if</span> patternsDict.get(<span class="built_in">len</span>(apiList)) == <span class="literal">None</span>:</span><br><span class="line">                patternsDict[<span class="built_in">len</span>(apiList)] = [api.strip()]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                patternsDict[<span class="built_in">len</span>(apiList)].append(api.strip())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将未做替换的api和其余字段合并并放入patternsBranch，后续过滤符合表达式的api使用</span></span><br><span class="line">            <span class="keyword">if</span> patternsBranch.get(<span class="built_in">len</span>(apiList)) == <span class="literal">None</span>:</span><br><span class="line">                patternsBranch[<span class="built_in">len</span>(apiList)] = [lines.strip()]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                patternsBranch[<span class="built_in">len</span>(apiList)].append(lines.strip())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(apiList) == <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 替换包含数字的段为“&#123;id&#125;”</span></span><br><span class="line">            api = sub(lines)</span><br><span class="line">            <span class="comment"># 将替换后的api表达式再和别的字段合并放入patternList，后续计数使用</span></span><br><span class="line">            patternList.append(api.strip())</span><br><span class="line">            <span class="comment"># 将未做替换的api和其余字段合并并放入patternBranch，后续过滤符合表达式的api使用</span></span><br><span class="line">            patternBranch.append(lines.strip())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将不包含数字的数据直接放入patterns，并计算与总数据量的占比</span></span><br><span class="line">            patterns[lines.strip()] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    处理一个段包含数据的api</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(patternList) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 将patternList计数，得到字典cnt，key是patternList的原数据，value是原数据出现的次数</span></span><br><span class="line">        cnt = Counter(patternList)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历字典cnt</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> cnt.keys():</span><br><span class="line">            <span class="comment"># 判断表达式出现次数是否小于2</span></span><br><span class="line">            <span class="keyword">if</span> cnt[key] &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 将表达式中的api的“&#123;id1&#125;”替换为是否包含数字的正则表达式</span></span><br><span class="line">                reString = key.replace(<span class="string">&quot;&#123;id1&#125;&quot;</span>, <span class="string">&quot;[^\\/]*\d[^\\/]*&quot;</span>)</span><br><span class="line">reString = <span class="string">&quot;^&quot;</span> + reString + <span class="string">&quot;$&quot;</span></span><br><span class="line">                <span class="comment"># 遍历patternBranch</span></span><br><span class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> patternBranch:</span><br><span class="line">                    <span class="comment"># 判断patternBranch中数据的api是否符合正则表达式reString</span></span><br><span class="line">                    <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(line):</span><br><span class="line">                        <span class="comment"># 将符合正则表达式的放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">                        patterns[line] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将表达式出现次数大于等于2的放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">                patterns[key] = math.ceil(cnt[key] / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    处理N+1个段包含数据的api</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 遍历转换“&#123;id&#125;”后的正则表达式</span></span><br><span class="line">    <span class="keyword">for</span> keyDict <span class="keyword">in</span> patternsDict.keys():</span><br><span class="line">        <span class="comment"># 将包含“&#123;id&#125;”个数相同的api统一计数</span></span><br><span class="line">        cnt = Counter(patternsDict[keyDict])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断如果计数的key为1就说明只有一个表达式，不需要再做是否匹配表达式这一操作</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cnt) &gt; <span class="number">1</span> :</span><br><span class="line">            <span class="comment"># 遍历计数字典cnt</span></span><br><span class="line">            <span class="keyword">for</span> keyCnt <span class="keyword">in</span> cnt.keys():</span><br><span class="line">                <span class="comment"># 替换表达式为正则，以此筛选出符合当前格式的数据</span></span><br><span class="line">                reString = re.<span class="built_in">compile</span>(<span class="string">&#x27;/[^/,]*\d[^/,]*&#x27;</span>).sub(<span class="string">&quot;/[^/,]*\\\d[^/,]*&quot;</span>, keyCnt)</span><br><span class="line">                reString = <span class="string">&quot;^&quot;</span> + reString + <span class="string">&quot;$&quot;</span></span><br><span class="line">                <span class="comment"># 如果value小于或等于2，说明此表达式最多由两条数据生成，就不产生表达式，直接将匹配此表达式的数据加入到 patterns</span></span><br><span class="line">                <span class="keyword">if</span> cnt[keyCnt] &lt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                    <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line">                        <span class="comment"># 符合当前表达式格式的数据加入patterns</span></span><br><span class="line">                        <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(data):</span><br><span class="line">                            patterns[data] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 存放要计数的数据</span></span><br><span class="line">                    dataList = []</span><br><span class="line">                    <span class="comment"># 存放不是&#123;id&#125;的段的下标</span></span><br><span class="line">                    idList = []</span><br><span class="line">                    <span class="comment"># 计数，防止下标越界</span></span><br><span class="line">                    num = <span class="number">1</span></span><br><span class="line">                    <span class="comment"># keyDict为当前处理的数据的“&#123;id&#125;”个数，个数多少就循环多少次，可以得到相同数据类型下不是真的参数的包含数字的段的下标</span></span><br><span class="line">                    <span class="keyword">while</span> num &lt;= keyDict:</span><br><span class="line">                        <span class="comment"># 清空dataList</span></span><br><span class="line">                        dataList.clear()</span><br><span class="line">                        <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                        <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line">                            <span class="comment"># 判断数据是否符合当前表达式格式</span></span><br><span class="line">                            <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(data):</span><br><span class="line"></span><br><span class="line">                                <span class="comment"># 存放转换后的数据</span></span><br><span class="line">                                dataString = <span class="string">&quot;&quot;</span></span><br><span class="line">                                <span class="comment"># 计数，和num做对比</span></span><br><span class="line">                                datanum = <span class="number">1</span></span><br><span class="line">                                <span class="comment"># 根据包含数字的部分拆分数据</span></span><br><span class="line">                                <span class="built_in">list</span> = re.split(<span class="string">&quot;(/[^/,]*\d[^/,]*)&quot;</span>, data)</span><br><span class="line">                                <span class="comment"># 遍历拆分后的列表</span></span><br><span class="line">                                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                                    <span class="comment"># 判断是否包含数字，不包含直接和dataString拼接</span></span><br><span class="line">                                    <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;/[^/,]*\d[^/,]*&quot;</span>).findall(i):</span><br><span class="line">                                        <span class="comment"># 判断是否和num相同，相同则不转换为“/&#123;id&#125;”，不相同则转换为“/&#123;id&#125;”</span></span><br><span class="line">                                        <span class="keyword">if</span> datanum == num:</span><br><span class="line">                                            dataString = dataString + i</span><br><span class="line">                                        <span class="keyword">else</span>:</span><br><span class="line">                                            dataString = dataString + <span class="string">&quot;/&#123;id&#125;&quot;</span></span><br><span class="line">                                        <span class="comment"># 计数+1</span></span><br><span class="line">                                        datanum = datanum + <span class="number">1</span></span><br><span class="line">                                    <span class="keyword">else</span>:</span><br><span class="line">                                        dataString = dataString + i</span><br><span class="line"></span><br><span class="line">                                <span class="comment"># 将转换后的数据放入dataList，后续计数使用</span></span><br><span class="line">                                dataList.append(dataString)</span><br><span class="line">                        <span class="comment"># 去重，得到当前类型的数据中，“&#123;id&#125;”的值不同的个数</span></span><br><span class="line">                        dataSet = <span class="built_in">set</span>(dataList)</span><br><span class="line">                        <span class="comment"># 如果“&#123;id&#125;”值不同的个数占全部的60%以下，则判定当前段不是真正的参数，将当前段的下标加入到idList</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(dataSet) / <span class="built_in">len</span>(dataList) &lt; <span class="number">0.6</span>:</span><br><span class="line">                            idList.append(num)</span><br><span class="line">                        <span class="comment"># 计数 +1</span></span><br><span class="line">                        num = num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 存放转换“&#123;id&#125;”后的数据，计数使用</span></span><br><span class="line">                    pattern = []</span><br><span class="line">                    <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                    <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line">                        <span class="comment"># 判断数据是否符合当前表达式格式</span></span><br><span class="line">                        <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(data):</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 存放转换后的数据</span></span><br><span class="line">                            dataString = <span class="string">&quot;&quot;</span></span><br><span class="line">                            <span class="comment"># 计数，判断idList中包不包含当前下标的段</span></span><br><span class="line">                            datanum1 = <span class="number">1</span></span><br><span class="line">                            <span class="comment"># 计数，统计当前数据有几个“&#123;id&#125;”</span></span><br><span class="line">                            datanum2 = <span class="number">1</span></span><br><span class="line">                            <span class="comment"># 根据包含数字的部分拆分数据</span></span><br><span class="line">                            <span class="built_in">list</span> = re.split(<span class="string">&quot;(/[^/,]*\d[^/,]*)&quot;</span>, data)</span><br><span class="line">                            <span class="comment"># 遍历拆分后的列表</span></span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                                <span class="comment"># 判断当前段是否包含数字，如果不包含直接和dataString拼接</span></span><br><span class="line">                                <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;/[^/,]*\d[^/,]*&quot;</span>).findall(i):</span><br><span class="line">                                    <span class="comment"># 如果当前下标的段在idList中，则表示当前包含数字的段非真正的“&#123;id&#125;”；不在idList中，就拼接“&#123;id&#125;”</span></span><br><span class="line">                                    <span class="keyword">if</span> datanum1 <span class="keyword">in</span> idList:</span><br><span class="line">                                        dataString = dataString + i</span><br><span class="line">                                    <span class="keyword">else</span>:</span><br><span class="line">                                        dataString = dataString + <span class="string">&quot;/&#123;id&quot;</span> + <span class="built_in">str</span>(datanum2) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                                        datanum2 = datanum2 + <span class="number">1</span></span><br><span class="line">                                    <span class="comment"># 计数+1</span></span><br><span class="line">                                    datanum1 = datanum1 + <span class="number">1</span></span><br><span class="line">                                <span class="keyword">else</span>:</span><br><span class="line">                                    dataString = dataString + i</span><br><span class="line"></span><br><span class="line">                            pattern.append(dataString)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 计数，也是去重，之所以不直接去重是因为要计算当前表达式的个数来算百分比</span></span><br><span class="line">                    patternsCnt = Counter(pattern)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 将表达式加入列表patterns</span></span><br><span class="line">                    <span class="keyword">for</span> key <span class="keyword">in</span> patternsCnt.keys():</span><br><span class="line">                        patterns[key] = math.ceil(patternsCnt[key] / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 遍历计数字典cnt</span></span><br><span class="line">            <span class="keyword">for</span> keyCnt <span class="keyword">in</span> cnt.keys():</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果value小于或等于2，说明此表达式最多由两条数据生成，就不产生表达式，直接将匹配此表达式的数据加入到 patterns</span></span><br><span class="line">                <span class="keyword">if</span> cnt[keyCnt] &lt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表，将数据直接加入patterns</span></span><br><span class="line">                    <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line">                        patterns[data] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 存放要计数的数据</span></span><br><span class="line">                    dataList = []</span><br><span class="line">                    <span class="comment"># 存放不是&#123;id&#125;的段的下标</span></span><br><span class="line">                    idList = []</span><br><span class="line">                    <span class="comment"># 计数，防止下标越界</span></span><br><span class="line">                    num = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># keyDict为当前处理的数据的“&#123;id&#125;”个数，个数多少就循环多少次，可以得到相同数据类型下不是真的参数的包含数字的段的下标</span></span><br><span class="line">                    <span class="keyword">while</span> num &lt;= keyDict:</span><br><span class="line">                        <span class="comment"># 清空dataList</span></span><br><span class="line">                        dataList.clear()</span><br><span class="line">                        <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                        <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 存放转换后的数据</span></span><br><span class="line">                            dataString = <span class="string">&quot;&quot;</span></span><br><span class="line">                            <span class="comment"># 计数，和num做对比</span></span><br><span class="line">                            datanum = <span class="number">1</span></span><br><span class="line">                            <span class="comment"># 根据包含数字的部分拆分数据</span></span><br><span class="line">                            <span class="built_in">list</span> = re.split(<span class="string">&quot;(/[^/,]*\d[^/,]*)&quot;</span>, data)</span><br><span class="line">                            <span class="comment"># 遍历拆分后的列表</span></span><br><span class="line">                            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                                <span class="comment"># 判断是否包含数字，不包含直接和dataString拼接</span></span><br><span class="line">                                <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;/[^/,]*\d[^/,]*&quot;</span>).findall(i):</span><br><span class="line">                                    <span class="comment"># 判断是否和num相同，相同则不转换为“/&#123;id&#125;”，不相同则转换为“/&#123;id&#125;”</span></span><br><span class="line">                                    <span class="keyword">if</span> datanum == num:</span><br><span class="line">                                        dataString = dataString + i</span><br><span class="line">                                    <span class="keyword">else</span>:</span><br><span class="line">                                        dataString = dataString + <span class="string">&quot;/&#123;id&#125;&quot;</span></span><br><span class="line">                                    <span class="comment"># 计数+1</span></span><br><span class="line">                                    datanum = datanum + <span class="number">1</span></span><br><span class="line">                                <span class="keyword">else</span>:</span><br><span class="line">                                    dataString = dataString + i</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 将转换后的数据放入dataList，后续计数使用</span></span><br><span class="line">                            dataList.append(dataString)</span><br><span class="line">                        <span class="comment"># 去重，得到当前类型的数据中，“&#123;id&#125;”的值不同的个数</span></span><br><span class="line">                        dataSet = <span class="built_in">set</span>(dataList)</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 如果“&#123;id&#125;”值不同的个数占全部的60%以下，则判定当前段不是真正的参数，将当前段的下标加入到idList</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(dataSet) / <span class="built_in">len</span>(dataList) &lt; <span class="number">0.6</span>:</span><br><span class="line">                            idList.append(num)</span><br><span class="line">                        <span class="comment"># 计数 +1</span></span><br><span class="line">                        num = num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 存放转换“&#123;id&#125;”后的数据，计数使用</span></span><br><span class="line">                    pattern = []</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 遍历当前包含“&#123;id&#125;”个数的数据列表</span></span><br><span class="line">                    <span class="keyword">for</span> data <span class="keyword">in</span> patternsBranch[keyDict]:</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 存放转换后的数据</span></span><br><span class="line">                        dataString = <span class="string">&quot;&quot;</span></span><br><span class="line">                        <span class="comment"># 计数，判断idList中包不包含当前下标的段</span></span><br><span class="line">                        datanum1 = <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 计数，统计当前数据有几个“&#123;id&#125;”</span></span><br><span class="line">                        datanum2 = <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 根据包含数字的部分拆分数据</span></span><br><span class="line">                        <span class="built_in">list</span> = re.split(<span class="string">&quot;(/[^/,]*\d[^/,]*)&quot;</span>, data)</span><br><span class="line">                        <span class="comment"># 遍历拆分后的列表</span></span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                            <span class="comment"># 判断当前段是否包含数字，如果不包含直接和dataString拼接</span></span><br><span class="line">                            <span class="keyword">if</span> re.<span class="built_in">compile</span>(<span class="string">&quot;/[^/,]*\d[^/,]*&quot;</span>).findall(i):</span><br><span class="line">                                <span class="comment"># 如果当前下标的段在idList中，则表示当前包含数字的段非真正的“&#123;id&#125;”；不在idList中，就拼接“&#123;id&#125;”</span></span><br><span class="line">                                <span class="keyword">if</span> datanum1 <span class="keyword">in</span> idList:</span><br><span class="line">                                    dataString = dataString + i</span><br><span class="line">                                <span class="keyword">else</span>:</span><br><span class="line">                                    dataString = dataString + <span class="string">&quot;/&#123;id&quot;</span> + <span class="built_in">str</span>(datanum2) + <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                                    datanum2 = datanum2 + <span class="number">1</span></span><br><span class="line">                                <span class="comment"># 计数+1</span></span><br><span class="line">                                datanum1 = datanum1 + <span class="number">1</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                dataString = dataString + i</span><br><span class="line"></span><br><span class="line">                        pattern.append(dataString)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 计数，也是去重，之所以不直接去重是因为要计算当前表达式的个数来算百分比</span></span><br><span class="line">                    patternsCnt = Counter(pattern)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 将表达式加入列表patterns</span></span><br><span class="line">                    <span class="keyword">for</span> key <span class="keyword">in</span> patternsCnt.keys():</span><br><span class="line">                        patterns[key] = math.ceil(patternsCnt[key] / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    打印输出</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> patterns.keys():</span><br><span class="line">        <span class="built_in">print</span>(key)</span><br><span class="line">        <span class="built_in">print</span>(patterns[key])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(datetime.datetime.now())</span><br><span class="line">    main()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(datetime.datetime.now())</span><br></pre></td></tr></table></figure><p>处理多参数数据模块的“白话版”代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">patternsDict&#123;</span><br><span class="line">2：</span><br><span class="line">[......],</span><br><span class="line">3：</span><br><span class="line">[&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot;,</span><br><span class="line">&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot;,</span><br><span class="line">&quot;/api/login/&#123;id1&#125;/index/&#123;id2&#125;/&#123;id3&#125;&quot;,</span><br><span class="line">......],</span><br><span class="line">4：</span><br><span class="line">[......]</span><br><span class="line">&#125;</span><br><span class="line">patternsBranch&#123;</span><br><span class="line">2：</span><br><span class="line">[......],</span><br><span class="line">3：</span><br><span class="line">[&quot;/api/1/login/1/index/1&quot;,</span><br><span class="line">&quot;/api/2/login/2/index/2&quot;,</span><br><span class="line">&quot;/api/login/1/index/1/1&quot;,</span><br><span class="line">......],</span><br><span class="line">4：</span><br><span class="line">[......]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">假设 patternsDict[3] 中&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot;有 5 个，&quot;/api/login/&#123;id1&#125;/index/&#123;id2&#125;/&#123;id3&#125;&quot;有 4 个</span><br><span class="line"></span><br><span class="line">遍历patternsDict</span><br><span class="line">cnt = Counter(patternsDict[key])</span><br><span class="line"></span><br><span class="line">cnt&#123;</span><br><span class="line">&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot; ： 5 ,</span><br><span class="line">&quot;/api/login/&#123;id1&#125;/index/&#123;id2&#125;/&#123;id3&#125;&quot; : 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如果len(cnt)为1就说明只有一个表达式，不需要再做下面是否匹配表达式这一操作</span><br><span class="line">if len(cnt) &gt; 1 :</span><br><span class="line"></span><br><span class="line">遍历cnt</span><br><span class="line"></span><br><span class="line">转换数据得到正则表达式</span><br><span class="line">例：&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot;，得到正则表达式&quot;/api/[^/,]*\d[^/,]*/login/[^/,]*\d[^/,]*/index/[^/,]*\d[^/,]*&quot;</span><br><span class="line"></span><br><span class="line">如果value小于等于2，不再进行计算，直接把符合当前key的表达式的数据加入 patterns （patterns存放最终结果）</span><br><span class="line"></span><br><span class="line">如果value大于2，进行下一步计算</span><br><span class="line"></span><br><span class="line">while循环，循环次数为当前patternsDict[key]，也就是包含数字的段的个数</span><br><span class="line"></span><br><span class="line">遍历patternsBranch[3]</span><br><span class="line">“/api/1/login/1/index/1”转换为“/api/&#123;id&#125;/login/1/index/1”，</span><br><span class="line">将“/api/&#123;id&#125;/login/1/index/1”放入dataList</span><br><span class="line"></span><br><span class="line">注：随着while的循环，patternsBranch[3]的数据会不断转换成“/api/1/login/&#123;id&#125;/index/1”、“/api/1/login/1/index/&#123;id&#125;”</span><br><span class="line"></span><br><span class="line">dataSet = set(dataList)，得到去重后的dataSet</span><br><span class="line">if len(dataSet) / len(dataList) &lt; 0.6 :</span><br><span class="line">判断len(dataSet)不到len(dataList)的五分之三，说明当前 &#123;id&#125; 不是真的参数，将当前 &#123;id&#125; 的下标加入idList</span><br><span class="line"></span><br><span class="line">遍历patternsBranch[3]（也就是遍历一条条data）</span><br><span class="line"></span><br><span class="line">判断是否符合当前key的正则表达式</span><br><span class="line"></span><br><span class="line">根据idList中记录的下标，将data中对应下标的包含数字的段转换为 &#123;id1&#125;、&#123;id2&#125;、&#123;id3&#125;...</span><br><span class="line"></span><br><span class="line">将转换后的data，放入列表 pattern 中</span><br><span class="line"></span><br><span class="line">patternsCnt = Counter(pattern) ， 得到patternsCnt&#123;</span><br><span class="line">&quot;/api/&#123;id1&#125;/login/&#123;id2&#125;/index/&#123;id3&#125;&quot; : 5 ,</span><br><span class="line">&quot;/api/login/&#123;id1&#125;/index/&#123;id2&#125;/&#123;id3&#125;&quot; : 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将patternsCnt中的表达式放入 patterns （patterns存放最终结果）</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">重复if len(cnt) &gt; 1 后面的计算，只是不需要再做“判断是否符合当前key的正则表达式”这一操作</span><br></pre></td></tr></table></figure><p>整体代码不用心花时间看肯定是看不懂的，需要的就慢慢看吧。。。。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> API数据合并 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的基本数据类型与特殊数据类型详解</title>
      <link href="/2021/07/29/redis_8/"/>
      <url>/2021/07/29/redis_8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、官网介绍">一、官网介绍</h1><p><img src="https://img-blog.csdnimg.cn/20210712203520640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作<code>数据库</code>、<code>缓存</code>和<code>消息中间件</code>。 它支持多种类型的数据结构，如<code>字符串（strings）</code>， <code>散列（hashes）</code>，<code>列表（lists）</code>，<code>集合（sets）</code>，<code>有序集合（sorted sets）</code> 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p><h1 id="二、Redis常用的五大数据类型">二、Redis常用的五大数据类型</h1><p>Redis常用的五大数据类型为：<code>String（字符串）</code>、<code>List（列表）</code>、<code>Set（集合）</code>、<code>Hash（哈希，类似java里的map）</code>、<code>Zset（sorted set：有序集合）</code>。</p><h2 id="1-String（字符串）">1. String（字符串）</h2><p>String 是 Redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。<br>String 类型是 Redis 最基本的数据类型（可以为整形、浮点型和字符串，统称为元素），最大能存储 <code>512MB</code>。</p><h3 id="1-1-常用命令">1.1 常用命令</h3><ul><li><code>set : 设置值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 v1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li><code>get : 获取值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>获取所有的key</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>exists : 判断某个key是否存在</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXISTS key1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li><code>append : 追加字符串，如果当前key不存在，就相当于‘set key’</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; APPEND key1 &quot;hello&quot;</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;v1hello&quot;</span><br></pre></td></tr></table></figure><ul><li><code>strlen : 获取字符串的长度</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; STRLEN key1</span><br><span class="line">(integer) 7</span><br></pre></td></tr></table></figure><ul><li><code>incr : 自增</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>decr : 自减</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;0&quot;</span><br></pre></td></tr></table></figure><ul><li><code>incrby : 加</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incrby views 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><ul><li><code>decrby : 减</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; decrby views 5</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line">&quot;-2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>getrange : 获取字符串指定下标范围的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 &quot;hello,redis&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;hello,redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 5</span><br><span class="line">&quot;hello,&quot;</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 -1</span><br><span class="line">&quot;hello,redis&quot;</span><br></pre></td></tr></table></figure><ul><li><code>setrange : 替换字符串指定下标的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key2 &quot;abcdefghijklmn&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;abcdefghijklmn&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETRANGE key2 1 xx</span><br><span class="line">(integer) 14</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">&quot;axxdefghijklmn&quot;</span><br></pre></td></tr></table></figure><ul><li><code>setex : 设置过期时间</code></li><li><code>ttl : 查看剩余过期时间</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置“key3”30秒后过期</span><br><span class="line">127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key3</span><br><span class="line">(integer) 20</span><br></pre></td></tr></table></figure><ul><li><code>setnx : 设置值，前提是键必须不存在</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key4 v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key4&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;key1&quot;</span><br><span class="line">127.0.0.1:6379&gt; setnx key4 v3</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get key4</span><br><span class="line">&quot;v1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>mset : 批量设置值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;k3&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>mget : 批量获取值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br></pre></td></tr></table></figure><ul><li><code>msetnx : 批量设置值，前提是键必须不存在</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;k3&quot;</span><br><span class="line">2) &quot;k1&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v2 k4 v4# msetnx 是一个原子性的操作，要么一起成功，要么一起失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ul><li><code>设置一个对象</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># user:&#123;id&#125;:&#123;filed&#125;</span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>设置一个对象，用json字符串保存</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set user:1 &#123;name:zhangsan,age:26&#125;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line">&quot;&#123;name:zhangsan,age:26&#125;&quot;</span><br></pre></td></tr></table></figure><ul><li><code>getset 组合命令</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; getset key1 hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; getset key1 redis</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure><p><code>想知道更多详细的命令可以访问：</code> <a href="https://blog.csdn.net/weixin_44758876/article/details/118191804">Redis命令详解</a></p><h3 id="1-2-使用场景">1.2 使用场景</h3><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存、存储</li></ul><h3 id="1-3-数据结构">1.3 数据结构</h3><p>String的数据结构为简单动态字符串（Simple Dynamic String,缩写SDS）。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList ，采用预分配冗余空间的方式来减少内存的频繁分配。<br><img src="https://img-blog.csdnimg.cn/59d3706049054848bdb41c586fee4085.png#pic_center" alt="在这里插入图片描述"><br>如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len 。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。<br><br></p><h2 id="2-List（列表）">2. List（列表）</h2><p><img src="https://img-blog.csdnimg.cn/5050488cb18a4a088afc6def567707f1.png#pic_center" alt="在这里插入图片描述"></p><p>Redis 的列表类型是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个<code>双向链表</code>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><h3 id="2-1-常用命令">2.1 常用命令</h3><ul><li><code>lrange : 获取列表的多个元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lindex : 获取列表指定下标的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line">&quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 1</span><br><span class="line">&quot;two&quot;</span><br><span class="line">127.0.0.1:6379&gt; lindex list 3</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ul><li><code>llen : 获取列表的长度</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><ul><li><code>lpush : 将一个值或多个值插入列表的头部</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list two three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br></pre></td></tr></table></figure><ul><li><code>rpush : 将一个值或多个值插入列表的尾部</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush list one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush list two three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lpop : 移除列表头部的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">&quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;three&quot;</span><br></pre></td></tr></table></figure><ul><li><code>rpop : 移除列表尾部的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line">&quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lrem : 移除列表指定的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lrem : 移除列表指定的多个元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br><span class="line">4) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 one</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br></pre></td></tr></table></figure><ul><li><code>ltrim : 截取列表指定下标内的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist &quot;hello&quot; &quot;hello1&quot; &quot;hello2&quot; &quot;hello3&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br><span class="line">3) &quot;hello2&quot;</span><br><span class="line">4) &quot;hello3&quot;</span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello1&quot;</span><br><span class="line">2) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>rpoplpush : 移除列表最后一个元素，将该元素移动到新的列表中（新列表不存在时会自动创建）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br><span class="line">3) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpoplpush mylist myotherlist</span><br><span class="line">&quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange myotherlist 0 -1</span><br><span class="line">1) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lset : 将列表中指定下标的值替换为另一个值（更新操作，更新不存在的下标会报错）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists list</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lpush list value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 item</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">127.0.0.1:6379&gt; lset list 1 other</span><br><span class="line">(error) ERR index out of range</span><br></pre></td></tr></table></figure><ul><li><code>linsert : 将某个具体的值插入到列表中指定元素的前面或后面</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before &quot;world&quot; &quot;other&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;other&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after &quot;world&quot; &quot;new&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;other&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">4) &quot;new&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用场景">2.2 使用场景</h3><ul><li>List 类型经常会被用于消息队列的服务，以完成多程序之间的消息交换</li><li>消息队列（lpush rpop）</li><li>栈（lpush lpop）</li></ul><h3 id="2-3-数据结构">2.3 数据结构</h3><p>List的数据结构为快速链表 quickList 。<br>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。<br>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。<br>当数据量比较多的时候才会改成quicklist。<br>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。<br><img src="https://img-blog.csdnimg.cn/04f1550332bc48d797f57011add50a1a.png#pic_center" alt="在这里插入图片描述"><br>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h2 id="3-Set（集合）">3. Set（集合）</h2><p>set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<code>自动排重</code>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。<br>edis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的<code>复杂度都是O(1)</code>。<br>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。</p><h3 id="3-1-常用命令">3.1 常用命令</h3><ul><li><code>smembers : 查看集合的所有元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sadd : 往集合中添加值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;Redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;Redis&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br><span class="line">4) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset &quot;hello1&quot; &quot;hello2&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">4) &quot;Redis&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line">6) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sismember : 判断集合中是否存在指定元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;world&quot;</span><br><span class="line">4) &quot;Redis&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line">6) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset hello3</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><ul><li><code>scard : 获取集合所有元素的个数</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;Redis&quot;</span><br><span class="line">4) &quot;redis&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line">6) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><ul><li><code>srem : 移除集合中指定元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">3) &quot;Redis&quot;</span><br><span class="line">4) &quot;redis&quot;</span><br><span class="line">5) &quot;hello1&quot;</span><br><span class="line">6) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; srem myset world</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;Redis&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;hello1&quot;</span><br><span class="line">5) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>srandmember : 随机获取集合中的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;Redis&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;hello1&quot;</span><br><span class="line">5) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line">&quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) &quot;Redis&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;hello2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>spop : 随机删除集合中的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;Redis&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;hello1&quot;</span><br><span class="line">5) &quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line">&quot;hello2&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;Redis&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line">&quot;Redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;hello1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>smove : 将集合中指定的元素移动到另一个集合中</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">3) &quot;hello1&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; smove myset myset2 &quot;hello1&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers myset2</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;hello1&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sdiff : 获取两个集合之间的差集</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; sdiff set2 set1</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">2) &quot;d&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sinter : 获取两个集合之间的交集</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2</span><br><span class="line">1) &quot;c&quot;</span><br></pre></td></tr></table></figure><ul><li><code>sunion : 获取两个集合之间的并集</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) &quot;e&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunion set1 set2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;e&quot;</span><br><span class="line">5) &quot;d&quot;</span><br></pre></td></tr></table></figure><h3 id="3-2-使用场景">3.2 使用场景</h3><ul><li>用户之间的共同关注、共同爱好、二度好友</li><li>推荐好友</li><li>六度分割理论</li></ul><h3 id="3-3-数据结构">3.3 数据结构</h3><p>Set数据结构是dict字典，字典是用哈希表实现的。<br>Java中 HashSet 的内部实现使用的是 HashMap ，只不过所有的 value 都指向同一个对象。Redis的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向同一个内部值。</p><h2 id="4-Hash（哈希）">4. Hash（哈希）</h2><p>Redis hash 是一个键值对集合。<br>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。<br>类似 Java 里面的<code>Map&lt;String,Object&gt;</code>。</p><p>举个例子，用户ID为查找的 key ，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key/value 结构来存储，主要有以下2种存储方式：</p><ol><li>每次修改用户的某个属性需要，先反序列化改好后再序列化回去，开销较大。<br><img src="https://img-blog.csdnimg.cn/81bd9b7532f4442695a5416f9837ec4c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>用户ID数据冗余。<br><img src="https://img-blog.csdnimg.cn/001df24aca2c40ba8a8321e402347f9e.png#pic_center" alt="在这里插入图片描述"></li></ol><p>通过 <code>key(用户ID) + field(属性标签)</code> 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。<br><img src="https://img-blog.csdnimg.cn/75dd0fc25371410dbc2baf86e9b6c633.png#pic_center" alt="在这里插入图片描述"></p><h3 id="4-1-常用命令">4.1 常用命令</h3><ul><li><code>hkeys : 获取hash中所有的field</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;field2&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hvals : 获取hash中所有的value</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hset : 设置hash的field-value值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash field1 &quot;hello&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;hello&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hmset : 设置多个hash的field-value值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset myhash field1 hello field2 world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;field2&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hget : 获取hash中指定的value</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget myhash field1</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hmget : 获取hash中指定的多个value</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget myhash field1 field2</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hgetall : 获取hash中所有的值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;field2&quot;</span><br><span class="line">4) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hdel : 删除hash中指定的field（对应的value同样被删除）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;field2&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;hello&quot;</span><br><span class="line">2) &quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; hdel myhash field1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;world&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hlen : 获取hash的元素数量</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">2) &quot;field1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; hlen myhash</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><ul><li><code>hexists : 判断hash中的指定元素是否存在</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys myhash</span><br><span class="line">1) &quot;field2&quot;</span><br><span class="line">2) &quot;field1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals myhash</span><br><span class="line">1) &quot;world&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash field3</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><ul><li><code>hincrby : 使hash中指定field的值增量</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash field1 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field1 1</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash field1 -1</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;3&quot;</span><br></pre></td></tr></table></figure><ul><li><code>hsetnx : 设置hash的field-value值，如果field存在则不能设置，如果field不存在可以设置</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hsetnx myhash field1 hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash field1 hello1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) &quot;field1&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br></pre></td></tr></table></figure><h3 id="4-2-使用场景">4.2 使用场景</h3><ul><li>hash更适合存储对象，而string更适合存储字符串</li><li>用户信息，经常变动的信息</li></ul><h3 id="4-3-数据结构">4.3 数据结构</h3><p>Hash类型对应的数据结构是两种：<code>ziplist（压缩列表）</code>，<code>hashtable（哈希表）</code>。<br>当 field-value 长度较短且个数较少时，使用 ziplist ，否则使用 hashtable 。</p><h2 id="5-Zset（sorted-set：有序集合）">5. Zset（sorted set：有序集合）</h2><p>Redis有序集合zset与普通集合set非常相似，是一个<code>没有重复元素</code>的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<code>评分（score）</code>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<code>集合的成员是唯一的，但是评分可以是重复了</code> 。<br>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h3 id="5-1-常用命令">5.1 常用命令</h3><ul><li><code>zrange : 获取zset集合的多个元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 1</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br></pre></td></tr></table></figure><ul><li><code>zadd : 向zset集合中添加数据</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myset 1 one</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 two 3 three</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><ul><li><code>zrangebyscore : 排序，从小到大</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd salary 2500 zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 1000 wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;1000&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;lisi&quot;</span><br><span class="line">6) &quot;5000&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +2500 withscores</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;1000&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br></pre></td></tr></table></figure><ul><li><code>zrevrange : 排序，从大到小</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;zhaoliu&quot;</span><br><span class="line">4) &quot;wangwu&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1 withscores</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;5000&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;zhaoliu&quot;</span><br><span class="line">6) &quot;2000&quot;</span><br><span class="line">7) &quot;wangwu&quot;</span><br><span class="line">8) &quot;1000&quot;</span><br></pre></td></tr></table></figure><ul><li><code>zrem : 删除zset集合中的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;wangwu&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem salary wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br></pre></td></tr></table></figure><ul><li><code>zcard : 获取zset集合所有元素的个数</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcard salary</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><ul><li><code>zcount : 获取指定区间内的元素数量</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1 withscores</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;5000&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;2500&quot;</span><br><span class="line">5) &quot;zhaoliu&quot;</span><br><span class="line">6) &quot;2000&quot;</span><br><span class="line">7) &quot;wangwu&quot;</span><br><span class="line">8) &quot;1000&quot;</span><br><span class="line">127.0.0.1:6379&gt; zcount salary 2000 5000</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><h3 id="5-2-使用场景">5.2 使用场景</h3><ul><li>存储班级成绩表、工资表排序</li><li>带权重排序，普通消息为1，重要消息为2</li><li>排行榜应用实现、取TopN</li></ul><h3 id="5-3-数据结构">5.3 数据结构</h3><p>SortedSet（zset） 是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素 value 赋予一个权重 score ，另一方面它又类似于<code>TreeSet</code>，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</p><p>zset 底层使用了两个数据结构：</p><ol><li>hash ，hash 的作用就是关联元素 value 和权重 score ，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</li><li>跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</li></ol><h3 id="5-4-跳跃表（跳表）">5.4 跳跃表（跳表）</h3><h4 id="5-4-1-简介">5.4.1 简介</h4><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。 Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><h4 id="5-4-2-实例">5.4.2 实例</h4><p><strong>对比有序链表和跳跃表，从链表中查询出“51”：</strong></p><ol><li>有序链表<br><img src="https://img-blog.csdnimg.cn/b84964b25e504d4ca76524d5582676f8.png#pic_center" alt="在这里插入图片描述">要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</li><li>跳跃表<br><img src="https://img-blog.csdnimg.cn/1e8d09a0060e4f50a4a894f64d440aee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层；<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下；<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</li></ol><p><strong>从此可以看出跳跃表比有序链表效率要高。</strong></p><h1 id="三、Redis的三种特殊数据类型">三、Redis的三种特殊数据类型</h1><p><code>Geospatial（地理信息）</code>、<code>HyperLogLog（基数统计）</code>、Bitmaps</p><h2 id="1-Geospatial（地理信息）">1. Geospatial（地理信息）</h2><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO 是 Geographic（地理信息）的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。 redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</p><h3 id="1-1-常用命令-2">1.1 常用命令</h3><ul><li><code>geoadd : 添加地理位置，两级无法直接添加（一般会下载城市数据通过java程序一次性导入），有效的经度是 -180 度到 180 度，有效的纬度是 -85.05112878 度到 85.05112878 度，当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.405285 39.904989 beijing</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.472644 31.231706 shanghai</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 114.085947 22.547 shenzhen</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 113.280637 23.125178 guangzhou</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li><code>geopos : 获取指定地区的坐标值</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city beijing</span><br><span class="line">1) 1) &quot;116.40528291463851929&quot;</span><br><span class="line">   2) &quot;39.9049884229125027&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos china:city beijing shanghai</span><br><span class="line">1) 1) &quot;116.40528291463851929&quot;</span><br><span class="line">   2) &quot;39.9049884229125027&quot;</span><br><span class="line">2) 1) &quot;121.47264629602432251&quot;</span><br><span class="line">   2) &quot;31.23170490709807012&quot;</span><br></pre></td></tr></table></figure><ul><li><code>geodist : 获取两个位置之间的直线距离</code><ul><li>m 表示单位为米 [ 默认值 ]</li><li>km 表示单位为千米</li><li>mi 表示单位为英里</li><li>ft 表示单位为英尺</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai</span><br><span class="line">&quot;1067597.9668&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km</span><br><span class="line">&quot;1067.5980&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai mi</span><br><span class="line">&quot;663.3763&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai ft</span><br><span class="line">&quot;3502618.0013&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing guangzhou km</span><br><span class="line">&quot;1889.3706&quot;</span><br></pre></td></tr></table></figure><ul><li><code>georadius : 以给定的维度为中心，找出半径内的元素</code><ul><li>withdist : 显示到中心位置的距离</li><li>withcoord : 显示半径内元素的坐标</li><li>count : 限定显示几个元素</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km</span><br><span class="line">1) &quot;shenzhen&quot;</span><br><span class="line">2) &quot;guangzhou&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 900 km</span><br><span class="line">1) &quot;guangzhou&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withdist</span><br><span class="line">1) 1) &quot;shenzhen&quot;</span><br><span class="line">   2) &quot;923.4929&quot;</span><br><span class="line">2) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) &quot;831.2636&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 900 km withdist</span><br><span class="line">1) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) &quot;831.2636&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withcoord</span><br><span class="line">1) 1) &quot;shenzhen&quot;</span><br><span class="line">   2) 1) &quot;114.08594459295272827&quot;</span><br><span class="line">      2) &quot;22.54699993773966327&quot;</span><br><span class="line">2) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) 1) &quot;113.28063815832138062&quot;</span><br><span class="line">      2) &quot;23.12517743834835215&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withdist withcoord</span><br><span class="line">1) 1) &quot;shenzhen&quot;</span><br><span class="line">   2) &quot;923.4929&quot;</span><br><span class="line">   3) 1) &quot;114.08594459295272827&quot;</span><br><span class="line">      2) &quot;22.54699993773966327&quot;</span><br><span class="line">2) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) &quot;831.2636&quot;</span><br><span class="line">   3) 1) &quot;113.28063815832138062&quot;</span><br><span class="line">      2) &quot;23.12517743834835215&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withdist withcoord count 1</span><br><span class="line">1) 1) &quot;guangzhou&quot;</span><br><span class="line">   2) &quot;831.2636&quot;</span><br><span class="line">   3) 1) &quot;113.28063815832138062&quot;</span><br><span class="line">      2) &quot;23.12517743834835215&quot;</span><br></pre></td></tr></table></figure><ul><li><code>georadiusbymember : 以指定元素为中心，找出半径内的元素</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city beijing 1500 km</span><br><span class="line">1) &quot;shanghai&quot;</span><br><span class="line">2) &quot;beijing&quot;</span><br></pre></td></tr></table></figure><ul><li><code>geohash : 返回一个或多个位置元素，以Geohash表示（会返回一个11个字符的Geohash字符串）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，则距离越近</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city beijing guangzhou</span><br><span class="line">1) &quot;wx4g0b7xrt0&quot;</span><br><span class="line">2) &quot;ws0e9cb3yj0&quot;</span><br></pre></td></tr></table></figure><p><strong>GEO底层的实现原理其实就是Zset，可以使用Zset命令来操作GEO</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) &quot;shenzhen&quot;</span><br><span class="line">2) &quot;guangzhou&quot;</span><br><span class="line">3) &quot;shanghai&quot;</span><br><span class="line">4) &quot;beijing&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) &quot;shenzhen&quot;</span><br><span class="line">2) &quot;guangzhou&quot;</span><br><span class="line">3) &quot;shanghai&quot;</span><br></pre></td></tr></table></figure><h3 id="1-2-使用场景-2">1.2 使用场景</h3><ul><li>附近的人</li><li>打车距离计算</li></ul><h2 id="2-HyperLogLog（基数统计）">2. HyperLogLog（基数统计）</h2><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量）,可以使用 Redis 的 incr 、incrby 轻松实现。<br>但像 UV（UniqueVisitor，独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。<br>解决基数问题有很多种方案：</p><ol><li>数据存储在 MySQL 表中，使用 distinct count 计算不重复个数</li><li>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理</li></ol><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了 HyperLogLog<br>Redis HyperLogLog 是用来做<code>基数统计的算法</code>，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。<br>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。<br>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?<br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h3 id="2-1-常用命令-2">2.1 常用命令</h3><ul><li><code>pfadd : 添加指定元素到HyperLogLog中（如果执行命令后HyperLogLog估计的近似基数发生变化，则返回1，否则返回0）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e f g h i j k l m</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey2 f s v z a b i j l</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey a</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><ul><li><code>pfcount : 统计HyperLogLog的元素个数，计算HyperLogLog的近似基数（可以计算多个HyperLogLog，比如用HyperLogLog存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e f g h i j k l m</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey</span><br><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey2 f s v z a b i j l</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey2</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey mykey2</span><br><span class="line">(integer) 16</span><br></pre></td></tr></table></figure><ul><li><code>pfmerge : 将一个或多个HyperLogLog合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfcount mykey</span><br><span class="line">(integer) 13</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey2</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey mykey2</span><br><span class="line">(integer) 16</span><br><span class="line">127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey3</span><br><span class="line">(integer) 16</span><br></pre></td></tr></table></figure><h3 id="2-2-使用场景-2">2.2 使用场景</h3><ul><li>网页的UV统计</li></ul><h2 id="3-Bitmaps（位图）">3. Bitmaps（位图）</h2><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是 01100001、 01100010 和 01100011，如下图：<br><img src="https://img-blog.csdnimg.cn/9ace81b9faa2438f91e20654cc7025dc.png#pic_center" alt="在这里插入图片描述"><br>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用Bitmaps和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做<code>偏移量</code>。</li></ol><p><img src="https://img-blog.csdnimg.cn/6ed7f1c8e8814073b725d97f65607f6e.png#pic_center" alt="在这里插入图片描述"></p><h3 id="3-1-常用命令-2">3.1 常用命令</h3><ul><li><code>setbit : 设置Bitmaps中某个偏移量的值（0或1）</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>实例：</strong> 每个独立用户是否访问过网站存放在 Bitmaps 中， 将访问的用户记做 1， 没有访问的用户记做 0， 用偏移量作为用户的 id。<br>设置键的第 offset 个位的值（从0算起） ， 假设现在有 20 个用户，userid=1， 6， 11， 15， 19 的用户对网站进行了访问， 那么当前 Bitmaps 初始化结果如图：<br><img src="https://img-blog.csdnimg.cn/fb11189682884b79a71f232119982347.png#pic_center" alt="在这里插入图片描述"><br>unique:users:20201106 代表 2020-11-06 这天的独立访问用户的 Bitmaps<br><img src="https://img-blog.csdnimg.cn/efc2112d7e3e453f89d8455bee9885c1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong><font color=red>注：</font></strong> 很多应用的用户 id 以一个指定数字（例如10000） 开头， 直接将用户 id 和 Bitmaps 的偏移量对应势必会造成一定的浪费， 通常的做法是每次做 setbit 操作时将用户id减去这个指定数字。<br>在第一次初始化 Bitmaps 时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成 Redis 的阻塞。</p><ul><li><code>getbit : 获取Bitmaps中某个偏移量的值（获取键的第offset位的值（从0开始算））</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>实例：</strong> 获取 id=8 的用户是否在 2020-11-06 这天访问过， 返回 0 说明没有访问过：<br><img src="https://img-blog.csdnimg.cn/246d76ed52be4fd1a90688e45fbd9742.png#pic_center" alt="在这里插入图片描述"><br><strong><font color=red>注：</font></strong> 因为 100 根本不存在，所以也是返回 0</p><ul><li><code>bitcount : 统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p><strong>实例：</strong> 计算 2022-11-06 这天的独立访问用户数量<br><img src="https://img-blog.csdnimg.cn/9ddc7b9bef2c471a871a04ff2d2f270b.png#pic_center" alt="在这里插入图片描述"><br>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19</p><p><img src="https://img-blog.csdnimg.cn/a6785cc6cbd04b208336a5565c7994c3.png#pic_center" alt="在这里插入图片描述"></p><ul><li><code>bitop : 复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit bitmap1 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap1 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap1 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap2 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap2 3 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit bitmap2 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitop and bitmap3 bitmap1 bitmap2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitcount bitmap3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitop or bitmap4 bitmap1 bitmap2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitcount bitmap4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; bitop xor bitmap5 bitmap1 bitmap2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitcount bitmap5</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h3 id="3-2-使用场景-2">3.2 使用场景</h3><ul><li>统计用户信息</li><li>区分活跃、不活跃用户；登录、未登录等等</li><li>上班打卡</li></ul><h3 id="3-3-Bitmaps与set对比">3.3 Bitmaps与set对比</h3><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table><tr align=center><th colspan="4">set 和 Bitmaps 存储一天活跃用户对比</th></tr><tr align=center><td>数据类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr align=center><td>集合类型</td><td>64位</td><td>50000000</td><td>64位 * 50000000 = 400MB</td></tr><tr align=center><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位 * 100000000 = 12.5MB</td></tr></table>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的<table><tr align=center><th colspan="4">set 和 Bitmaps 存储独立用户空间对比</th></tr><tr align=center><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr align=center><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr align=center><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></table>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0<table><tr align=center><th colspan="4">set 和 Bitmaps 存储一天活跃用户对比（独立用户比较少）</th></tr><tr align=center><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr align=center><td>集合类型</td><td>64位</td><td>100000</td><td>64位 * 100000 = 800KB</td></tr><tr align=center><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位 * 100000000 = 12.5MB</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日算法 —— 两数之和</title>
      <link href="/2021/07/22/leetcode_1/"/>
      <url>/2021/07/22/leetcode_1/</url>
      
        <content type="html"><![CDATA[<p><strong>原题：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h1 id="1-方法一">1. 方法一</h1><p>暴力破解，没什么思路可说的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> num1 <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> num2 <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num1 + num2 == target:</span><br><span class="line">                    <span class="keyword">if</span> (num1 == num2) &amp; (nums.count(num1) == <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> [nums.index(num1),nums.index(num2, nums.index(num1) + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h1 id="2-方法二">2. 方法二</h1><p>解题关键主要是想找到 num2 = target - num1，判断num2 是否也在 list 中，找到 num2，再直接返回 num2 的索引即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target - nums[num] <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> (nums.count(target - nums[num]) == <span class="number">1</span>) &amp; (target - nums[num] == nums[num]):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> [num, nums.index(target - nums[num], num + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h1 id="3-方法三">3. 方法三</h1><p>遍历数组 nums，num 为当前下标，每个值都判断字典 dic 中是否存在 target-nums[num] 的 key 值；如果存在则找到了两个值，如果不存在则将当前的 (nums[num],num) 存入字典 dic 中，继续遍历直到找到为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> dic.get(target - nums[num]) == <span class="literal">None</span> :</span><br><span class="line">                dic[nums[num]] = num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [dic[target - nums[num]], num]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 单线程为什么还这么快？</title>
      <link href="/2021/07/12/redis_7/"/>
      <url>/2021/07/12/redis_7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-官网的解释">1. 官网的解释</h1><p><img src="https://img-blog.csdnimg.cn/20210712192848680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CPU并不是您使用Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制。例如，使用在一般Linux系统上运行的流水线Redis每秒可以发送一百万个请求，因此，如果您的应用程序主要使用O（N）或O（log（N））命令，则几乎不会使用过多的CPU 。<br>但是，为了最大程度地利用CPU，您可以在同一服务器上启动多个Redis实例，并将它们视为不同的服务器。在某个时候，单个实例可能还不够，因此，如果您要使用多个CPU，则可以开始考虑更早地分片的某种方法。<br>但是，在Redis 4.0中，我们开始使Redis具有更多线程。目前，这仅限于在后台删除对象，以及阻止通过Redis模块实现的命令。对于将来的版本，计划是使Redis越来越线程化。</p><h1 id="2-Redis为什么是单线程的？">2. Redis为什么是单线程的？</h1><p>Redis是基于<code>内存操作</code>的，CPU并不是Redis的瓶颈，Redis的瓶颈是机器的<code>内存</code>和<code>网络带宽</code>，既然可以使用单线程来实现，那当然就使用单线程了。</p><p>相反，如果使用多线程的话，多个CPU还要进行<code>上下文切换</code>，CPU上下文切换的效率远远比不上直接在内存中读取的速度；并且，采用多线程，还会带来数据安全的问题，假如我们在操作redis的List、Hash等数据结构时，多线程就可能存在数据不安全的情况，这时候就需要加锁，一旦加锁就又影响了程序的执行速度。</p><h1 id="3-Redis单线程的优势和劣势">3. Redis单线程的优势和劣势</h1><p><code>优势</code>：</p><ol><li>代码更清晰，处理逻辑更简单；</li><li>不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>不存在“多进程或者多线程导致的切换”而消耗CPU。</li></ol><p><code>劣势</code>：</p><ol><li>无法发挥多核CPU性能（可以通过在单机开多个Redis实例来完善，单一线程只能用到一个CPU核心，所以可以在同一个多核的服务器中，启动多个实例，组成<code>master-master</code>或者<code>master-slave</code>的形式，耗时的读命令可以完全在 slave 进行，充分发挥 Redis 的作用）。</li></ol><h1 id="4-Redis速度为什么那么快？">4. Redis速度为什么那么快？</h1><ol><li>Redis是纯内存数据库，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制；</li><li>Redis使用单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，<code>减少了线程切换时上下文的切换和竞争</code>，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li><li>Redis采用了<code>非阻塞I/O多路复用机制</code>。</li></ol><h1 id="5-Redis的多路IO复用">5. Redis的多路IO复用</h1><p>redis 采用网络IO多路复用技术，来保证在多连接的时候系统的高吞吐量。<br><code>多路</code>指的是多个socket网络连接，<code>复用</code>指的是复用一个线程。</p><p>多路复用主要有三种技术：select，poll，epoll（epoll是最新的、也是目前最好的多路复用技术），可以同时监察多个流的 I/O 事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流，并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作，从而提高效率。</p><p>采用多路I/O复用技术的原因：</p><ol><li>可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）；</li><li>Redis在内存中操作数据的速度非常快（内存里的操作不会成为这里的性能瓶颈）。</li></ol><p>主要以上两点造就了Redis具有很高的吞吐量。</p><h1 id="6-Redis的持久化">6. Redis的持久化</h1><p>由于redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。</p><p>redis提供两种方式进行持久化，一种是<code>RDB持久化</code>（原理是将redis在内存中的数据库记录定时 dump到磁盘上的RDB持久化），另外一种是<code>AOF（append only file）持久化</code>（原理是将redis的操作日志以追加的方式写入文件）。</p><p>持久化似乎和redis的速度并没有直接关系，但是这保证的redis数据的安全性和可靠性，也起到数据备份的作用。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之 API 数据合并</title>
      <link href="/2021/07/02/python_8/"/>
      <url>/2021/07/02/python_8/</url>
      
        <content type="html"><![CDATA[<p>最近有个需求，就是数据源那边会过来许多api数据，样例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/api/login/001-1,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/001-2,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/001-3,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/001-4,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/index,10.145.205.53:10081,POST,100</span><br></pre></td></tr></table></figure><p>可以看到过来的数据除了id字段，其余部分是一样的，这样就造成了数据的重复占用资源，理想的情况是将数据合并成下面的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/api/login/&#123;id&#125;,10.145.205.53:10081,GET,100</span><br><span class="line">/api/login/index,10.145.205.53:10081,POST,100</span><br></pre></td></tr></table></figure><p>用 <code>&#123;id&#125;</code> 来替代无意义的段，并且后面要加入合并出来的<code>/api/login/&#123;id&#125;</code>占总数据量的百分比，PM要求的处理速度是10w条/s，目前做的是第一版，后续会更新第二版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,math,datetime</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\lkm86\\Desktop\\data.csv&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="comment"># 读取数据</span></span><br><span class="line">    content = file.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存放要计数的api</span></span><br><span class="line">    patternList = []</span><br><span class="line">    <span class="comment"># 存放包含数字的api</span></span><br><span class="line">    patternBranch = []</span><br><span class="line">    <span class="comment"># 存放最终结果</span></span><br><span class="line">    patternDict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 正则匹配是否包含数字</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;\/[^\\/]*\d[^\\/]*\/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历数据列表</span></span><br><span class="line">    <span class="keyword">for</span> lines <span class="keyword">in</span> content:</span><br><span class="line">        <span class="comment"># 取出api字段</span></span><br><span class="line">        line = lines[:lines.index(<span class="string">&quot;,&quot;</span>)]</span><br><span class="line">        <span class="comment"># 给api后面加”/“方面后续正则匹配</span></span><br><span class="line">        <span class="keyword">if</span> line[-<span class="number">1</span>] != <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            line += <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="comment"># 正则匹配是否有包含数字的段</span></span><br><span class="line">        <span class="keyword">if</span> pattern.findall(line):</span><br><span class="line">            <span class="comment"># 替换包含数字的段为“&#123;id&#125;”</span></span><br><span class="line">            url = pattern.sub(<span class="string">&#x27;/&#123;id&#125;/&#x27;</span>, line)</span><br><span class="line">            <span class="comment"># 将替换后的api表达式再和别的字段合并放入patternList，后续计数使用</span></span><br><span class="line">            patternList.append(url + lines[lines.index(<span class="string">&quot;,&quot;</span>):].strip())</span><br><span class="line">            <span class="comment"># 将加了“/”且未做替换的api和其余字段合并并放入patternBranch，后续过滤符合表达式的api使用</span></span><br><span class="line">            patternBranch.append(line + lines[lines.index(<span class="string">&quot;,&quot;</span>):].strip())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将不包含数字的数据直接放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">            patternDict[lines.strip()] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># 将patternList计数，得到字典cnt，key是patternList的原数据，value是原数据出现的次数</span></span><br><span class="line">    cnt = Counter(patternList)</span><br><span class="line">    <span class="comment"># 遍历字典cnt</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> cnt.keys():</span><br><span class="line">        <span class="comment"># 判断表达式出现次数是否小于2</span></span><br><span class="line">        <span class="keyword">if</span> cnt[key] &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 获取表达式中的api字段</span></span><br><span class="line">            <span class="built_in">str</span> = key[:key.index(<span class="string">&quot;,&quot;</span>)]</span><br><span class="line">            <span class="comment"># 将表达式中的api的“&#123;id&#125;”替换为是否包含数字的正则表达式</span></span><br><span class="line">            reString = <span class="built_in">str</span>.replace(<span class="string">&quot;&#123;id&#125;&quot;</span>, <span class="string">&quot;[^\\/]*\d[^\\/]*&quot;</span>)</span><br><span class="line">            <span class="comment"># 遍历patternBranch</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> patternBranch:</span><br><span class="line">                <span class="comment"># 判断patternBranch中数据的api是否符合正则表达式reString</span></span><br><span class="line">                <span class="keyword">if</span> re.<span class="built_in">compile</span>(reString).findall(line[:line.index(<span class="string">&quot;,&quot;</span>)]):</span><br><span class="line">                    <span class="comment"># 将符合正则表达式的放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">                    patternDict[line.strip()] = math.ceil(<span class="number">1</span> / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将表达式出现次数大于等于2的放入patternDict，并计算与总数据量的占比</span></span><br><span class="line">            patternDict[key] = math.ceil(cnt[key] / <span class="built_in">len</span>(content) * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历最终结果</span></span><br><span class="line">    <span class="comment"># for key in patternDict.keys():</span></span><br><span class="line">    <span class="comment">#     print(key)</span></span><br><span class="line">    <span class="comment">#     print(patternDict[key])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(datetime.datetime.now())</span><br><span class="line">    main()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结束时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(datetime.datetime.now())</span><br></pre></td></tr></table></figure><p>我的文件里是11w条数据，测试结果符合需求：<br><img src="https://img-blog.csdnimg.cn/20210702144315762.png" alt="在这里插入图片描述"><br>当然，现在第一版只考虑了出现一个<code>&#123;id&#125;</code>的情况，如果出现像下面的这种数据，这个脚本就不能计算出正确的结果了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/api/login/001-1/index/1</span><br><span class="line">/api/login/001-2/index/2</span><br><span class="line">/api/login/001-3/index/3</span><br><span class="line">/api/login/001-4/index/4</span><br></pre></td></tr></table></figure><p>如果出现这种两个甚至多个包含数字的段的情况的话，处理过程就要复杂的多了，这个等后续第二版再来想办法实现。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> API数据合并 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 保证状态一致性的原理</title>
      <link href="/2021/07/01/flink_15/"/>
      <url>/2021/07/01/flink_15/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是状态一致性">1. 什么是状态一致性</h1><p>有状态的流处理，内部每个算子任务都可以有自己的状态，对于流处理器内部来说，所谓的状态一致性，其实就是我们所说的计算结果要保证准确。一条数据不应该丢失，也不应该重复计算。在遇到故障时可以恢复状态，恢复以后的重新计算，结果应该也是完全正确的。</p><p><strong>在流处理中，一致性分为三个级别：</strong></p><ul><li><strong>at-most-once（最多一次）</strong>:<ul><li>这其实是没有正确性保障的委婉说法——故障发生之后， 计数结果可能丢失，类似的还有 udp</li></ul></li><li><strong>at-least-once（至少一次）</strong>:<ul><li>这表示计数结果可能大于正确值， 但绝不会小于正确值。也就是说， 计数程序在发生故障后可能多算， 但是绝不会少算</li><li>它意味着所有事件最终都会处理，虽然有些可能会处理多次</li></ul></li><li><strong>exactly-once（精确一次）</strong>:<ul><li>这指的是系统保证在发生故障后得到的计数结果与正确值一致</li><li>它不但能够保证事件没有丢失，而且每个事件对于内部状态的更新都只有一次</li><li>Flink利用Checkpoints机制来保证精确一次语义</li></ul></li></ul><p>曾经， at-least-once 非常流行。第一代流处理器(如 Storm 和 Samza)刚问世时只保证 at-least-once， 原因有二：</p><ul><li>保证 exactly-once 的系统实现起来更复杂。这在基础架构层(决定什么代表正确， 以及 exactly-once 的范围是什么)和实现层都很有挑战性</li><li>流处理系统的早期用户愿意接受框架的局限性， 并在应用层想办法弥补(例如使应用程序具有幂等性， 或者用批量计算层再做一遍计算)</li></ul><p>最先保证 exactly-once 的系统(Storm Trident 和 Spark Streaming)在性能和表现力这两个方面付出了很大的代价。为了保证 exactly-once，这些系统无法单独地对每条记录运用应用逻辑， 而是同时处理多条(一批)记录， 保证对每一批的处理要么全部成功，要么全部失败。这就导致在得到结果前，必须等待一批记录处理结束。因此， 用户经常不得不使用两个流处理框架(一个用来保证 exactly-once， 另一个用来对每个元素做低延迟处理)， 结果使基础设施更加复杂。曾经， 用户不得不在保证exactly-once 与获得低延迟和效率之间权衡利弊。Flink 避免了这种权衡。<br><img src="https://img-blog.csdnimg.cn/20210701151633327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 使用了一种轻量级快照机制，检查点(checkpoint)来保证 exactly-once语义。有状态流应用的一致性检查点，其实就是：所有任务的状态，在某个时间点的一份拷贝(一份快照)。而这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候。应用状态的一致性检查点，是 Flink故障恢复机制的核心。<br>Flink 的一个重大价值在于，<code>它既保证了 exactly-once， 也具有低延迟和高吞吐的处理能力</code>。</p><h1 id="2-端到端的状态一致性">2. 端到端的状态一致性</h1><p>目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在 Flink 流处理器内部保证的； 而在真实应用中， 流处理应用除了流处理器以外还包含了数据源（ 例如 Kafka） 和输出到持久化系统。<br>端到端的一致性保证， 意味着结果的正确性贯穿了整个流处理应用的始终； 每一个组件都保证了它自己的一致性， <code>整个端到端的一致性级别取决于所有组件中一致性最弱的组件</code>。具体可以划分如下：</p><ul><li>内部保证 —— 依赖 checkpoint</li><li>source 端 —— 需要外部源可重设数据的读取位置</li><li>sink 端 —— 需要保证从故障恢复时， 数据不会重复写入外部系统</li></ul><p><strong>其中前两种在上文已经介绍过了，下面说说 Sink 如何提供端到端的精确一次性保障。</strong><br>应用若是想提供端到端的精确一次性保障，就需要一些特殊的Sink连接器，根据情况不同，这些连接器可以使用两种技术来实现精确一次保障：</p><ul><li><strong>幂等性写入（idempotent write）</strong><ul><li>幂等操作的含义就是可以多次执行，但是只会引起一次改变，也就是说， 后面再重复执行就不起作用了</li><li>例如我们将相同的键值对插入一个哈希结构中就是一个幂等操作， 因为由于该键值对已存在后，无论插入多少次都不会改变结果</li><li>由于可以在不改变结果的前提下多次执行，因此幂等性写操作在一定程度上减轻Flink检查点机制所带来的重复结果的影响</li></ul></li><li><strong>事务性写入（transactional write）</strong><ul><li>事务性写其实就是原子性写，即只有在上次成功的检查点之前计算的结果才会被写入外部Sink系统</li><li>事务性写虽然不会像幂等性写那样出现重放过程中的不一致现象，但是会增加一定延迟，因为结果只有在检查点完成后才对外可见</li><li>实现思想：构建的事务对应着Checkpoints，待Checkpoints真正完成的时候，才把所有对应的结果写入Sink系统中</li></ul></li></ul><p>对于事务性写入， 具体又有两种实现方式： <code>预写日志（ WAL）</code> 和<code>两阶段提交（ 2PC）</code>。<br><strong>预写日志</strong></p><ul><li>把结果数据先当成状态保存，然后在收到Checkpoints完成的通知时，一次性写入Sink系统</li><li>简单易于实现，由于数据提前在状态后端做了缓存，所以无论什么Sink系统都能用这种方式一批搞定</li><li>但同时它也存在问题，写入数据时出现故障则会导致一部分数据成功一部分失败</li><li>DataStream API提供了一个模板类<code>GenericWriteAheadSink</code>，来实现这种事务性Sink</li></ul><p><strong>两阶段提交</strong></p><ul><li>对于每个Checkpoints，Sink任务会启动一个事务，并将接下来所有接收的数据添加到事务里</li><li>然后将这些数据写入外部 Sink，但不提交它们，这时只是“预提交”</li><li>当它收到Checkpoints完成的通知时，它才正式提交事务，实现结果的真正写入</li><li>这种方式真正实现了精确一次，它需要一个提供事务支持的外部Sink系统，Flink提供了<code>TwoPhaseCommitSinkFunction</code>接口</li><li>对外部Sink系统的要求<ul><li>外部Sink系统必须提供事务支持，或者Sink任务必须能够模拟外部系统上的事务</li><li>在Checkpoints的隔离期间里，必须能够开启一个事务并接受数据写入</li><li>在收到Checkpoints完成的通知之前，事务必须是“等待提交”的状态。在故障恢复的情况下，这可能需要一些时间。如果这个时候 Sink系统关闭事务（例如超时了），那么未提交的数据就会丢失</li><li>Sink任务必须能够在进程失败后恢复事务</li><li>提交事务必须是幂等操作</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210701153024608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="3-检查点（checkpoint）">3. 检查点（checkpoint）</h1><p>Flink 具体如何保证 exactly-once 呢? 它使用一种被称为&quot;检查点&quot;（checkpoint）的特性，在出现故障时将系统重置回正确状态。下面通过简单的类比来解释检查点 的作用。<br>假设你和两位朋友正在数项链上有多少颗珠子，如下图所示。你捏住珠子，边数边拨，每拨过一颗珠子就给总数加一。你的朋友也这样数他们手中的珠子。当你分神忘记数到哪里时，怎么办呢? 如果项链上有很多珠子，你显然不想从头再数一 遍，尤其是当三人的速度不一样却又试图合作的时候，更是如此(比如想记录前一分钟三人一共数了多少颗珠子，回想一下一分钟滚动窗口)。<br><img src="https://img-blog.csdnimg.cn/20210519111950813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>于是，你想了一个更好的办法：在项链上每隔一段就松松地系上一根有色皮筋，将珠子分隔开；当珠子被拨动的时候，皮筋也可以被拨动； 然后，你安排一个助手， 让他在你和朋友拨到皮筋时记录总数。用这种方法，当有人数错时，就不必从头开始数。相反，你向其他人发出错误警示，然后你们都从上一根皮筋处开始重数，助手则会告诉每个人重数时的起始数值，例如在粉色皮筋处的数值是多少。<br>Flink 检查点的作用就类似于皮筋标记。数珠子这个类比的关键点是：对于指定的皮筋而言，珠子的相对位置是确定的;  这让皮筋成为重新计数的参考点。总状态(珠子的总数)在每颗珠子被拨动之后更新一次，助手则会保存与每根皮筋对应的检查点状态，如当遇到粉色皮筋时一共数了多少珠子，当遇到橙色皮筋时又是多少。当问题出现时，这种方法使得重新计数变得简单。<br><strong>Flink的检查点算法：</strong><br>Flink 检查点的核心作用是确保状态正确，即使遇到程序中断，也要正确。记住 这一基本点之后，我们用一个例子来看检查点是如何运行的。Flink 为用户提供了用 来定义状态的工具。例如，以下这个 Scala 程序按照输入记录的第一个字段(一个字 符串)进行分组并维护第二个字段的计数状态。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = ... </span><br><span class="line"><span class="keyword">val</span> counts: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = stream</span><br><span class="line">.keyBy(record =&gt; record._1)</span><br><span class="line">.mapWithState((in: (<span class="type">String</span>, <span class="type">Int</span>), state: <span class="type">Option</span>[<span class="type">Int</span>])=&gt; </span><br><span class="line">state <span class="keyword">match</span> &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="type">Some</span>(c) =&gt; ( (in._1, c + in._2), <span class="type">Some</span>(c + in._2) ) </span><br><span class="line"><span class="keyword">case</span> <span class="type">None</span> =&gt; ( (in._1, in._2), <span class="type">Some</span>(in._2) )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该程序有两个算子: keyBy 算子用来将记录按照第一个元素(一个字符串)进行分 组，根据该 key 将数据进行重新分区，然后将记录再发送给下一个算子: 有状态的 map 算子(mapWithState)。map 算子在接收到每个元素后，将输入记录的第二个字段 的数据加到现有总数中，再将更新过的元素发射出去。下图表示程序的初始状态: 输 入流中的 6 条记录被检查点分割线(checkpoint barrier)隔开，所有的 map 算子状态均为 0(计数还未开始)。所有 key 为 a 的记录将被顶层的 map 算子处理，所有 key 为 b 的记录将被中间层的 map 算子处理，所有 key 为 c 的记录则将被底层的 map 算子处理。<br><img src="https://img-blog.csdnimg.cn/20210519112714781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="按 key 累加计数程序初始状态"><br>上图是程序的初始状态。注意，a、b、c 三组的初始计数状态都是 0，即三个圆 柱上的值。ckpt 表示检查点分割线（checkpoint barriers）。每条记录在处理顺序上 严格地遵守在检查点之前或之后的规定，例如[“b”,2]在检查点之前被处理，[“a”,2] 则在检查点之后被处理。<br>当该程序处理输入流中的 6 条记录时，涉及的操作遍布 3 个并行实例(节点、CPU 内核等)。那么，检查点该如何保证 exactly-once 呢?<br>检查点分割线和普通数据记录类似。它们由算子处理，但并不参与计算，而是 会触发与检查点相关的行为。当读取输入流的数据源(在本例中与 keyBy 算子内联) 遇到检查点屏障时，它将其在输入流中的位置保存到持久化存储中。如果输入流来 自消息传输系统(Kafka)，这个位置就是偏移量。Flink 的存储机制是插件化的，持久 化存储可以是分布式文件系统，如 HDFS。下图展示了这个过程（遇到 checkpoint barrier 时， 保存其在输入流中的位置）<br><img src="https://img-blog.csdnimg.cn/20210519113405164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当 Flink 数据源(在本例中与 keyBy 算子内联)遇到检查点分界线（barrier）时， 它会将其在输入流中的位置保存到持久化存储中。这让 Flink 可以根据该位置重启。<br>检查点像普通数据记录一样在算子之间流动。当 map 算子处理完前 3 条数据并 收到检查点分界线时，它们会将状态以异步的方式写入持久化存储，如下图所示（保存 map 算子状态， 也就是当前各个 key 的计数值）<br><img src="https://img-blog.csdnimg.cn/20210519113643798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>位于检查点之前的所有记录([“b”,2]、[“b”,3]和[“c”,1])被 map 算子处理之后的情 况。此时，持久化存储已经备份了检查点分界线在输入流中的位置(备份操作发生在 barrier 被输入算子处理的时候)。map 算子接着开始处理检查点分界线，并触发将状 态异步备份到稳定存储中这个动作。<br>当 map 算子的状态备份和检查点分界线的位置备份被确认之后，该检查点操作 就可以被标记为完成，如下图所示。我们在无须停止或者阻断计算的条件下，在一 个逻辑时间点(对应检查点屏障在输入流中的位置)为计算状态拍了快照。通过确保 备份的状态和位置指向同一个逻辑时间点，后文将解释如何基于备份恢复计算，从 而保证 exactly-once。值得注意的是，当没有出现故障时，Flink 检查点的开销极小， 检查点操作的速度由持久化存储的可用带宽决定。回顾数珠子的例子: 除了因为数 错而需要用到皮筋之外，皮筋会被很快地拨过。<br><img src="https://img-blog.csdnimg.cn/20210519113733345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>检查点操作完成，状态和位置均已备份到稳定存储中。输入流中的所有数据记 录都已处理完成。值得注意的是，备份的状态值与实际的状态值是不同的。备份反 映的是检查点的状态。<br>如果检查点操作失败，Flink 可以丢弃该检查点并继续正常执行，因为之后的某 一个检查点可能会成功。虽然恢复时间可能更长，但是对于状态的保证依旧很有力。 只有在一系列连续的检查点操作失败之后，Flink 才会抛出错误，因为这通常预示着 发生了严重且持久的错误。<br>现在来看看下图所示的情况：检查点操作已经完成，但故障紧随其后（故障紧跟检查点， 导致最底部的实例丢失）<br><img src="https://img-blog.csdnimg.cn/20210519113827989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在这种情况下（故障时的状态恢复），Flink 会重新拓扑(可能会获取新的执行资源)，将输入流倒回到 上一个检查点，然后恢复状态值并从该处开始继续计算。在本例中，[“a”,2]、[“a”,2] 和[“c”,2]这几条记录将被重播。<br>下图展示了这一重新处理过程。从上一个检查点开始重新计算，可以保证在剩 下的记录被处理之后，得到的 map 算子的状态值与没有发生故障时的状态值一致。<br><img src="https://img-blog.csdnimg.cn/20210519114227718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 将输入流倒回到上一个检查点屏障的位置，同时恢复 map 算子的状态值。 然后，Flink 从此处开始重新处理。这样做保证了在记录被处理之后，map 算子的状 态值与没有发生故障时的一致。<br>Flink 检查点算法的正式名称是<code>异步分界线快照(asynchronous barrier snapshotting)</code>。该算法大致基于 Chandy-Lamport 分布式快照算法。<br>检查点是 Flink 最有价值的创新之一，因为<strong>它使 Flink 可以保证 exactly-once， 并且不需要牺牲性能</strong>。</p><h1 id="4-Flink-Kafka-如何实现端到端的-exactly-once-语义">4. Flink+Kafka 如何实现端到端的 exactly-once 语义</h1><p>我们知道，端到端的状态一致性的实现，需要每一个组件都实现，对于 Flink + Kafka 的数据管道系统（Kafka 进、Kafka 出）而言，各组件怎样保证 exactly-once 语义呢？</p><ul><li>内部 —— 利用 checkpoint 机制，把状态存盘，发生故障的时候可以恢复，保证内部的状态一致性</li><li>source —— kafka consumer 作为 source，可以将偏移量保存下来，如果后续任务出现了故障，恢复的时候可以由连接器重置偏移量，重新消费数据，保证一致性</li><li>sink —— kafka producer 作为 sink，采用两阶段提交 sink，需要实现一个 <code>TwoPhaseCommitSinkFunction</code></li></ul><p>内部的 checkpoint 机制我们已经有了了解，那 source 和 sink 具体又是怎样运行的呢？接下来我们逐步做一个分析。<br>我们知道 Flink 由 JobManager 协调各个 TaskManager 进行 checkpoint 存储， checkpoint 保存在 StateBackend 中，默认 StateBackend 是内存级的，也可以改为文件级的进行持久化保存。<br><img src="https://img-blog.csdnimg.cn/20210519114544418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当 checkpoint 启动时，JobManager 会将检查点分界线（barrier）注入数据流； barrier 会在算子间传递下去。<br><img src="https://img-blog.csdnimg.cn/20210519114628309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>每个算子会对当前的状态做个快照，保存到状态后端。对于 source 任务而言， 就会把当前的 offset 作为状态保存起来。下次从 checkpoint 恢复时，source 任务可以重新提交偏移量，从上次保存的位置开始重新消费数据。<br><img src="https://img-blog.csdnimg.cn/20210519114708854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>每个内部的 transform 任务遇到 barrier 时，都会把状态存到 checkpoint 里。<br>sink 任务首先把数据写入外部 kafka，这些数据都属于预提交的事务（还不能被消费）；当遇到 barrier 时，把状态保存到状态后端，并开启新的预提交事务。<br><img src="https://img-blog.csdnimg.cn/20210519114806911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当所有算子任务的快照完成，也就是这次的 checkpoint 完成时，JobManager 会向所有任务发通知，确认这次 checkpoint 完成。<br>当 sink 任务收到确认通知，就会正式提交之前的事务，kafka 中未确认的数据 就改为“已确认”，数据就真正可以被消费了。<br><img src="https://img-blog.csdnimg.cn/20210519114847109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以我们看到，执行过程实际上是一个两段式提交，每个算子执行完成，会进 行“预提交”，直到执行完 sink 操作，会发起“确认提交”，如果执行失败，预提 交会放弃掉。<br>具体的两阶段提交步骤总结如下：</p><ul><li>第一条数据来了之后，开启一个 kafka 的事务（transaction），正常写入 kafka 分区日志但标记为未提交，这就是“预提交”</li><li>jobmanager 触发 checkpoint 操作，barrier 从 source 开始向下传递，遇到 barrier 的算子将状态存入状态后端，并通知 jobmanager</li><li>sink 连接器收到 barrier，保存当前状态，存入 checkpoint，通知 jobmanager，并开启下一阶段的事务，用于提交下个检查点的数据</li><li>jobmanager 收到所有任务的通知，发出确认信息，表示 checkpoint 完成</li><li>sink 任务收到 jobmanager 的确认信息，正式提交这段时间的数据</li><li>外部 kafka 关闭事务，提交的数据可以正常消费了</li></ul><p>所以我们也可以看到，如果宕机需要通过 StateBackend 进行恢复，只能恢复所有确认提交的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 的状态后端（State Backends）</title>
      <link href="/2021/07/01/flink_14/"/>
      <url>/2021/07/01/flink_14/</url>
      
        <content type="html"><![CDATA[<h1 id="1-State-Backends-的作用">1. State Backends 的作用</h1><p>有状态的流计算是Flink的一大特点，状态本质上是数据，数据是需要维护的，例如数据库就是维护数据的一种解决方案。State Backends 的作用就是用来维护State的。一个 State Backend 主要负责两件事：<code>Local State Management(本地状态管理)</code> 和 <code>Remote State Checkpointing（远程状态备份）</code>。</p><h1 id="2-Local-State-Management（本地状态管理）">2. Local State Management（本地状态管理）</h1><p><code>State Management</code> 的主要任务是确保状态的更新和访问。类似于数据库系统对数据的管理，State Backends 的状态管理就是提供对 State 的访问或更新操作，从这一点上看，State Backends 与数据库很相似。Flink 提供的 State Backends 主要有两种形式的状态管理：</p><ul><li>直接将 State 以对象的形式存储到JVM的堆上面</li><li>将 State 对象序列化后存储到 RocksDB 中（RocksDB会写到本地的磁盘上）</li></ul><p>以上两种方式，第一种存储到JVM堆中，因为是在内存中读写，延迟会很低，但State的大小受限于内存的大小；第二种方式存储到State Backends上（本地磁盘上），读写较内存会慢一些，但不受内存大小的限制，同时因为state存储在磁盘上，可以减少应用程序对内存的占用。根据使用经验，对延迟不是特别敏感的应用，选择第二种方式较好，尤其是State比较大的情况下。</p><h1 id="3-Remote-State-Checkpointing（远程状态备份）">3. Remote State Checkpointing（远程状态备份）</h1><p>Flink程序是分布式运行的，而State都是存储到各个节点上的，一旦TaskManager节点出现问题，就会导致State的丢失。State Backend 提供了 <code>State Checkpointing</code> 的功能，将 TaskManager 本地的 State 的备份到远程的存储介质上，可以是分布式的存储系统或者数据库。不同的 State Backends 备份的方式不同，会有效率高低的区别。</p><h1 id="4-可用的状态后端">4. 可用的状态后端</h1><ul><li><strong>MemoryStateBackend</strong><ul><li>对于状态管理，MemoryStateBackend直接将State对象存储到TaskManager的JVM堆上，如MapState会被存储为一个HashMap对象</li><li>对于远程备份，MemoryStateBackend会将State备份到JobManager的堆内存上，这种方式是非常不安全的，且受限于JobManager的内存大小</li></ul></li><li><strong>FsStateBackend</strong><ul><li>对于状态管理，FsStateBackend与MemoryStateBackend一样，将State存储到TaskManager的JVM堆上</li><li>对于远程备份，FsStateBackend会将State写入到远程的文件系统，如HDFS中</li></ul></li><li><strong>RocksDBStateBackend</strong><ul><li>对于状态管理，RocksDBStateBackend将state存储到TaskManager节点上的RocksDB数据库实例上</li><li>对于远程备份，RocksDBstateBackend会将State备份到远程的存储系统中</li></ul></li></ul><h2 id="4-1-MemoryStateBackend">4.1 MemoryStateBackend</h2><p><code>MemoryStateBackend </code>是将状态维护在 Java 堆上的一个内部状态后端。键值状态和窗口算子使用哈希表来存储数据（values）和定时器（timers）。当应用程序 checkpoint 时，此后端会在将状态发给 JobManager 之前快照下状态，JobManager 也将状态存储在 Java 堆上。默认情况下，<code>MemoryStateBackend</code> 配置成支持异步快照。异步快照可以避免阻塞数据流的处理，从而避免反压的发生。当然，使用 <code>new MemoryStateBackend(MAX_MEM_STATE_SIZE, false)</code> 也可以禁用该特点。<br><strong>缺点：</strong></p><ul><li>默认情况下，每一个状态的大小限制为 5 MB。可以通过 <code>MemoryStateBackend</code> 的构造函数增加这个大小。状态大小受到 akka 帧大小的限制(maxStateSize &lt;= akka.framesize 默认 10 M)，所以无论怎么调整状态大小配置，都不能大于 akka 的帧大小。也可以通过 akka.framesize 调整 akka 帧大小</li><li>状态的总大小不能超过 JobManager 的内存</li></ul><p><strong>使用场景：</strong></p><ul><li>本地测试、几乎无状态的作业，比如 ETL、JobManager 不容易挂，或挂掉影响不大的情况</li><li>不推荐在生产场景使用</li></ul><h2 id="4-2-FsStateBackend">4.2 FsStateBackend</h2><p><code>FsStateBackend</code>需要配置的主要是文件系统，如 URL（类型，地址，路径）。<br>当选择使用 <code>FsStateBackend</code>时，正在进行的数据会被存在TaskManager的内存中。在checkpoint时，此后端会将状态快照写入配置的文件系统和目录的文件中，同时会在JobManager的内存中（在高可用场景下会存在 Zookeeper 中）存储极少的元数据。容量限制上，单 TaskManager 上 State 总量不超过它的内存，总大小不超过配置的文件系统容量。</p><p>默认情况下，<code>FsStateBackend</code> 配置成提供异步快照，以避免在状态 checkpoint 时阻塞数据流的处理。该特性可以实例化 <code>FsStateBackend</code> 时传入false的布尔标志来禁用掉，例如：<code>new FsStateBackend(path, false)</code><br><strong>使用场景：</strong></p><ul><li>处理大状态，长窗口，或大键值状态的有状态处理任务， 例如分钟级窗口聚合或 join</li><li>适合用于高可用方案（需要开启HA的作业）</li><li>可以在生产环境中使用</li></ul><h2 id="4-3-RocksDBStateBackend">4.3 RocksDBStateBackend</h2><p><code>RocksDBStateBackend</code> 的配置也需要一个文件系统（类型，地址，路径）。<br><code>RocksDB</code> 是一种嵌入式的本地数据库。<code>RocksDBStateBackend</code> 将处理中的数据使用 <code>RocksDB</code> 存储在本地磁盘上。在 checkpoint 时，整个 <code>RocksDB</code> 数据库会被存储到配置的文件系统中，或者在超大状态作业时可以将增量的数据存储到配置的文件系统中。同时 Flink 会将极少的元数据存储在 JobManager 的内存中，或者在 Zookeeper 中（对于高可用的情况）。<code>RocksDB</code> 默认也是配置成异步快照的模式。</p><p><code>RocksDB</code>是一个 key/value 的内存存储系统，和其他的 key/value 一样，先将状态放到内存中，如果内存快满时，则写入到磁盘中，但需要注意<code>RocksDB</code>不支持同步的 Checkpoint，构造方法中没有同步快照这个选项。不过<code>RocksDB</code>支持增量的 Checkpoint，也是目前唯一增量 Checkpoint 的 Backend，意味着并不需要把所有 sst 文件上传到 Checkpoint 目录，仅需要上传新生成的 sst 文件即可。它的 Checkpoint 存储在外部文件系统（本地或HDFS），其容量限制只要单个 TaskManager 上 State 总量不超过它的内存+磁盘，单Key最大2G，总大小不超过配置的文件系统容量即可。<br><strong>缺点：</strong></p><ul><li>RocksDB支持的单key和单value的大小最大为每个 2^31 字节。这是因为 RocksDB 的 JNI API 是基于byte[]的</li><li>对于使用具有合并操作的状态的应用程序，例如 ListState，随着时间可能会累积到超过 2^31 字节大小，这将会导致在接下来的查询中失败</li></ul><p><strong>使用场景：</strong></p><ul><li>最适合用于处理大状态，长窗口，或大键值状态的有状态处理任务</li><li>非常适合用于高可用方案</li><li>最好是对状态读写性能要求不高的作业</li></ul><p><strong>RocksDB的安装方法：</strong></p><p><a href="https://blog.csdn.net/weixin_44758876/article/details/117710577">CentOS7 安装RocksDB</a><br><a href="https://blog.csdn.net/weixin_44758876/article/details/117717889">Ubuntu下安装RocksDB</a></p><p>综上所述，<code>MemoryStateBackend</code> 和 <code>FsStateBackend</code> 都是在内存中进行状态管理，所以可以获取较低的读写延迟，但会受限于TaskManager的内存大小；而<code>RocksDBStateBackend</code>直接将State存储到RocksDB数据库中，所以不受JobManager的内存限制，但会有读写延迟，同时 <code>RocksDBStateBackend</code> 支持增量备份，这是其他两个都不支持的特性。一般来说，如果不是对延迟有极高的要求，<code>RocksDBStateBackend</code>是更好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 的状态管理</title>
      <link href="/2021/07/01/flink_13/"/>
      <url>/2021/07/01/flink_13/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Flink中的状态">1. Flink中的状态</h1><p><img src="https://img-blog.csdnimg.cn/20210701114405912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>由一个任务维护，并且用来计算某个结果的所有数据，都属于这个任务的状态</li><li>可以认为状态就是一个本地变量，可以被任务的业务逻辑访问</li><li>Flink 会进行状态管理，包括状态一致性、故障处理以及高效存储和访问，以便开发人员可以专注于应用程序的逻辑</li></ul><h1 id="2-管理状态的原因">2. 管理状态的原因</h1><p>有状态的计算是流处理框架要实现的重要功能，因为稍复杂的流处理场景都需要记录状态，然后在新流入数据的基础上不断更新状态。下面的几个场景都需要使用流处理的状态功能：</p><ul><li>数据流中的数据有重复，我们想对重复数据去重，需要记录哪些数据已经流入过应用，当新数据流入时，根据已流入过的数据来判断去重</li><li>检查输入流是否符合某个特定的模式，需要将之前流入的元素以状态的形式缓存下来。比如，判断一个温度传感器数据流中的温度是否在持续上升</li><li>对一个时间窗口内的数据进行聚合分析，分析一个小时内某项指标的75分位或99分位的数值</li><li>在线机器学习场景下，需要根据新流入数据不断更新机器学习的模型参数</li></ul><p>Flink的一个算子有多个子任务，每个子任务分布在不同实例上，我们可以把状态理解为某个算子子任务在其当前实例上的一个变量，变量记录了数据流的历史信息。当新数据流入时，我们可以结合历史信息来进行计算。实际上，Flink的状态是由算子的子任务来创建和管理的。一个状态更新和获取的流程如下图所示，一个算子子任务接收输入流，获取对应的状态，根据新的计算结果更新状态。一个简单的例子是对一个时间窗口内输入流的某个整数字段求和，那么当算子子任务接收到新元素时，会获取已经存储在状态中的数值，然后将当前输入加到状态上，并将状态数据更新。</p><h1 id="3-Flink的状态分类">3. Flink的状态分类</h1><h2 id="3-1-Managed-State和Raw-State">3.1 Managed State和Raw State</h2><p>Flink有两种基本类型的状态：托管状态（Managed State）和原生状态（Raw State）。<br>Managed State是由Flink管理的，Flink帮忙存储、恢复和优化，Raw State是开发者自己管理的，需要自己序列化。<br><img src="https://img-blog.csdnimg.cn/20210701115754125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">两者的具体区别有：</p><ul><li>从状态管理的方式上来说，Managed State由Flink Runtime托管，状态是自动存储、自动恢复的，Flink在存储管理和持久化上做了一些优化。当我们横向伸缩，或者说我们修改Flink应用的并行度时，状态也能自动重新分布到多个并行实例上。Raw State是用户自定义的状态</li><li>从状态的数据结构上来说，Managed State支持了一系列常见的数据结构，如ValueState、ListState、MapState等。Raw State只支持字节，任何上层数据结构需要序列化为字节数组。使用时，需要用户自己序列化，以非常底层的字节数组形式存储，Flink并不知道存储的是什么样的数据结构</li><li>从具体使用场景来说，绝大多数的算子都可以通过继承Rich函数类或其他提供好的接口类，在里面使用Managed State。Raw State是在已有算子和Managed State不够用时，用户自定义算子时使用</li></ul><p>对Managed State继续细分，它又有两种类型：<strong>Keyed State</strong>和<strong>Operator State</strong>。<br><img src="https://img-blog.csdnimg.cn/20210701122339865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="3-1-1-Operator-State">3.1.1 Operator State</h3><p><strong>算子状态（Operator State）的作用范围限定为算子任务</strong>。这意味着由同一并行任务所处理的所有数据都可以访问到相同的状态，  状态对于同一任务而言是共享的。算子状态不能由相同或不同算子的另一个任务访问。<br><img src="https://img-blog.csdnimg.cn/20210519105207400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 为算子状态提供三种基本数据结构：</p><ul><li>列表状态（List state）<ul><li>将状态表示为一组数据的列表</li></ul></li><li>联合列表状态（Union list state）<ul><li>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保 存点（savepoint）启动应用程序时如何恢复</li></ul></li><li>广播状态（Broadcast state）<ul><li>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态</li></ul></li></ul><h3 id="3-1-2-Keyed-State">3.1.2 Keyed State</h3><p>键控状态是根据输入数据流中定义的键（key）来维护和访问的。Flink 为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个 key 对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的 key。因此，具有相同 key 的所有数据都会访问相同的状态。Keyed State 很类似于一个分布式的 key-value map 数据结构，只能用于 KeyedStream（ keyBy 算子处理之后）。<br><img src="https://img-blog.csdnimg.cn/20210519105522865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 的 Keyed State 支持以下数据类型：</p><ul><li>ValueState[T]保存单个的值，值的类型为 T<ul><li>获取状态<ul><li>ValueState.value()</li></ul></li><li>更新状态<ul><li>ValueState.update(value: T)</li></ul></li></ul></li><li>ListState[T]保存一个列表，列表里的元素的数据类型为 T<ul><li>添加元素<ul><li>ListState.add(value: T)</li><li>ListState.addAll(values: java.util.List[T])</li></ul></li><li>获取列表<ul><li>oListState.get() 返回 Iterable[T]</li></ul></li><li>更新列表<ul><li>ListState.update(values: java.util.List[T])</li></ul></li></ul></li><li>MapState[K, V]保存 Key-Value 键值对<ul><li>获取某个key下的value<ul><li>MapState.get(key: K)</li></ul></li><li>对某个key设置value<ul><li>MapState.put(key: K, value: V)</li></ul></li><li>判断某个key是否存在<ul><li>MapState.contains(key: K)</li></ul></li><li>删除某个key以及对应的value<ul><li>MapState.remove(key: K)</li></ul></li><li>返回MapState中所有的元素<ul><li>MapState.entries()</li></ul></li><li>返回一个迭代器<ul><li>MapState.iterator()</li></ul></li></ul></li><li>ReducingState[T]</li><li>AggregatingState[I, O]<ul><li>ReducingState[T]和AggregatingState[IN, OUT]与ListState[T]同属于MergingState[T]。与ListState[T]不同的是，ReducingState[T]只有一个元素，而不是一个列表。它的原理是新元素通过add(value: T)加入后，与已有的状态元素使用ReduceFunction合并为一个元素，并更新到状态里。AggregatingState[IN, OUT]与ReducingState[T]类似，也只有一个元素，只不过AggregatingState[IN, OUT]的输入和输出类型可以不一样。ReducingState[T]和AggregatingState[IN, OUT]与窗口上进行ReduceFunction和AggregateFunction很像，都是将新元素与已有元素做聚合</li></ul></li></ul><p><strong>注意</strong>，Flink的核心代码目前使用Java实现的，而Java的很多类型与Scala的类型不太相同，比如List和Map。这里不再详细解释Java和Scala的数据类型的异同，但是开发者在使用Scala调用这些接口，比如状态的接口，需要注意将Java的类型转为Scala的类型。对于List和Map的转换，只需要需要引用import scala.collection.JavaConversions._，并在必要的地方添加后缀asScala或asJava来进行转换。此外，Scala和Java的空对象使用习惯不太相同，Java一般使用null表示空，Scala一般使用None。</p><h1 id="4-状态一致性">4. 状态一致性</h1><p>当在分布式系统中引入状态时， 自然也引入了一致性问题。一致性实际上是“正确性级别”的另一种说法，也就是说在成功处理故障并恢复之后得到的结果，与没有发生任何故障时得到的结果相比， 前者到底有多正确？<br>在流处理中， 一致性可以分为 3 个级别：</p><ul><li>at-most-once: 这其实是没有正确性保障的委婉说法——故障发生之后， 计数结果可能丢失。同样的还有 udp</li><li>at-least-once: 这表示计数结果可能大于正确值， 但绝不会小于正确值。也就是说， 计数程序在发生故障后可能多算， 但是绝不会少算</li><li>exactly-once: 这指的是系统保证在发生故障后得到的计数结果与正确值一致</li></ul><p>曾经， at-least-once 非常流行。第一代流处理器(如 Storm 和 Samza)刚问世时只保证 at-least-once， 原因有二：</p><ul><li>保证 exactly-once 的系统实现起来更复杂。这在基础架构层(决定什么代表正确， 以及 exactly-once 的范围是什么)和实现层都很有挑战性</li><li>流处理系统的早期用户愿意接受框架的局限性， 并在应用层想办法弥补(例如使应用程序具有幂等性， 或者用批量计算层再做一遍计算)</li></ul><p>最先保证 exactly-once 的系统(Storm Trident 和 Spark Streaming)在性能和表现力这两个方面付出了很大的代价。为了保证 exactly-once，这些系统无法单独地对每条记录运用应用逻辑， 而是同时处理多条(一批)记录， 保证对每一批的处理要么全部成功，要么全部失败。这就导致在得到结果前，必须等待一批记录处理结束。因此，  用户经常不得不使用两个流处理框架(一个用来保证 exactly-once， 另一个用来对每个元素做低延迟处理)， 结果使基础设施更加复杂。曾经， 用户不得不在保证exactly-once 与获得低延迟和效率之间权衡利弊。Flink 避免了这种权衡。<br>Flink 的一个重大价值在于，<strong>它既保证了 exactly-once， 也具有低延迟和高吞吐的处理能力</strong>。</p><br><p><strong>部分内容摘自</strong><a href="https://zhuanlan.zhihu.com/p/104171679">https://zhuanlan.zhihu.com/p/104171679</a></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 命令详解</title>
      <link href="/2021/06/24/redis_6/"/>
      <url>/2021/06/24/redis_6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、全局命令">一、全局命令</h1><ol><li>查看当前所有key</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure><ol start="2"><li>判断某个key是否存在（存在返回1，不存在返回0）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><ol start="3"><li>查看key是什么类型（key不存在返回none）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><ol start="4"><li>删除key（返回成功删除key的个数）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><ol start="5"><li>键重命名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line">renamenx key newkey 只有newkey不存在时才会被覆盖</span><br></pre></td></tr></table></figure><ol start="6"><li>为指定的key设置过期时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key 10单位秒，过期后会自动删除</span><br><span class="line">expireat key 10单位秒，10秒后过期</span><br><span class="line">pexpire key 1000单位毫秒，超过过期时间后会自动删除</span><br><span class="line">pexpireat key 1000单位毫秒，1000毫秒后过期</span><br></pre></td></tr></table></figure><ol start="7"><li>查看还有多少秒过期，-1表示永不过期，-2表示已过期</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure><ol start="8"><li>随机返回一个key</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomkey</span><br></pre></td></tr></table></figure><ol start="9"><li>迁移键</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">（1）move key db （不建议再生产环境中使用）把指定的键从源数据库移动到目标数据库</span><br><span class="line">（2）dump+restore</span><br><span class="line">dump key</span><br><span class="line">Restore key ttl value</span><br><span class="line">Dump+restore可以实现在不同的redis实例之间进行数据迁移的功能，整个迁移的过程分为两步;</span><br><span class="line">1)在源redis上，dump命令会将键值序列化，格式采用的是RDB格式</span><br><span class="line">2)在目标redis上，restore命令将上面序列化的值进行复原，其中ttl参数代表过期时间，ttl=0代表没有过期时间</span><br><span class="line">=======例=======</span><br><span class="line">源redis</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">&quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; dump redis</span><br><span class="line">&quot;\x00\x05world\a\x00\xe6\xe3\xe9w\xd8c\xa7\xd8&quot;</span><br><span class="line">目标redis</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; restore redis 0 &quot;\x00\x05world\a\x00\xe6\xe3\xe9w\xd8c\xa7\xd8&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line">&quot;world&quot;</span><br><span class="line">（3）migrate</span><br><span class="line">migrate实际上是把dump、restore、del 3个命令进行组合，从而简化了操作步骤</span><br><span class="line">源redis中执行</span><br><span class="line">127.0.0.1:6379&gt; migrate xxx.xxx.xxx.xxx 6379 flower 0 1000 replace</span><br><span class="line">（将键flower迁移至目标xxx.xxx.xxx.xxx:6379的库0中，超时时间为1000毫秒，replace表示目标库如果存在键flower，则覆盖）</span><br></pre></td></tr></table></figure><ol start="10"><li>遍历key</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）全量遍历键</span><br><span class="line">keys pattern</span><br><span class="line">（2）渐进式遍历</span><br><span class="line">scan 可以有效的解决keys命令存在的阻塞问题，scan每次的额复杂度是O(1)</span><br></pre></td></tr></table></figure><h1 id="二、数据库管理">二、数据库管理</h1><ol><li>切换数据库（默认16个，根据编号0-15区分不同数据库，进入redis后默认是0库）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 3</span><br></pre></td></tr></table></figure><ol start="2"><li>查看当前数据库的key的数量</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure><ol start="3"><li>清空当前数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure><ol start="4"><li>清空所有数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure><h1 id="三、针对key的操作">三、针对key的操作</h1><ol><li>设置值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex]  [px]  [nx|xx]</span><br><span class="line">ex为键值设置秒级过期时间</span><br><span class="line">px为键值设置毫秒级过期时间</span><br><span class="line">nx键必须不存在，才可以设置成功，用于添加</span><br><span class="line">xx与nx相反，键必须存在，才可以设置成功，用于更新</span><br><span class="line">setnx、setex 与上面的nx、ex作用相同</span><br></pre></td></tr></table></figure><ol start="2"><li>获取值（不存在则返回nil）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key </span><br></pre></td></tr></table></figure><ol start="3"><li>批量设置值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ......]</span><br><span class="line">mset a 1 b 2 c 3 d 4</span><br></pre></td></tr></table></figure><ol start="4"><li>批量获取值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ......]</span><br></pre></td></tr></table></figure><ol start="5"><li>计数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">decr key /inceby key increment /decrby key increment</span><br><span class="line">返回结果分为3中情况：</span><br><span class="line">值不是整数，返回错误；</span><br><span class="line">值是整数，返回自增后的结果；</span><br><span class="line">键不存在，按照值为0自增，返回结果为1。</span><br></pre></td></tr></table></figure><ol start="6"><li>追加值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value 可以向字符串尾部追加值</span><br></pre></td></tr></table></figure><ol start="7"><li>字符串长度</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key每个汉字占用3个字字节</span><br></pre></td></tr></table></figure><ol start="8"><li>设置并返回原值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset key value</span><br></pre></td></tr></table></figure><ol start="9"><li>设置指定位置的字符</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setrange key offeset value</span><br><span class="line">127.0.0.1:6379&gt; get liming</span><br><span class="line">&quot;class4&quot;</span><br><span class="line">127.0.0.1:6379&gt; setrange liming 0 m</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; get liming</span><br><span class="line">&quot;mlass4&quot;</span><br></pre></td></tr></table></figure><ol start="10"><li>获取部分字符串</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end </span><br><span class="line">start和end分别为开始和结束的偏移量，偏移量从0开始</span><br></pre></td></tr></table></figure><h1 id="四、Hash操作">四、Hash操作</h1><ol><li>设置值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br><span class="line">hset user:1 name tom</span><br></pre></td></tr></table></figure><ol start="2"><li>获取值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 name Tom</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget user:1 name</span><br><span class="line">&quot;Tom&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ol start="3"><li>删除field</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field ......]</span><br><span class="line">会删除一个或多个field，返回结果为成功删除fiel的个数</span><br></pre></td></tr></table></figure><ol start="4"><li>计算field的个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><ol start="5"><li>批量设置或获取field-value</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hmget key field [field ......]</span><br><span class="line">Hmset key field value [field value]</span><br></pre></td></tr></table></figure><ol start="6"><li>判断field是否存在</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure><ol start="7"><li>获取所有field</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;grand&quot;</span><br><span class="line">4) &quot;city&quot;</span><br></pre></td></tr></table></figure><ol start="8"><li>获取所有value</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;beijing&quot;</span><br></pre></td></tr></table></figure><ol start="9"><li>获取所有的field、value</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure><ol start="10"><li>计算value字符串的长度</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hstrlen key field</span><br></pre></td></tr></table></figure><h1 id="五、列表List操作">五、列表List操作</h1><h2 id="1-添加">1. 添加</h2><ol><li>从右边插入元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value......]</span><br></pre></td></tr></table></figure><ol start="2"><li>从左边插入元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush key value [value......]</span><br></pre></td></tr></table></figure><ol start="3"><li>向某个元素前或者后插入元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">linsert key before|after pivot value</span><br><span class="line">linsert命令会从列表中找到等于pivot的元素，在其前或者后插入一个新的元素value</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e f b a </span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; linsert mylist after f g</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">4) &quot;d&quot;</span><br><span class="line">5) &quot;e&quot;</span><br><span class="line">6) &quot;f&quot;</span><br><span class="line">7) &quot;g&quot;</span><br><span class="line">8) &quot;b&quot;</span><br><span class="line">9) &quot;a&quot;</span><br></pre></td></tr></table></figure><h2 id="2-查找">2. 查找</h2><ol><li>获取指定范围内的元素列表</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end 索引下标从左到右分别是0到N-1，从右到左分别是-1到-N；end选项包含了自身</span><br><span class="line">lrange key 0 -1 可以从左到右获取列表的所有元素</span><br><span class="line">lrange mylist 1 3 获取列表中第2个到第4个元素</span><br></pre></td></tr></table></figure><ol start="2"><li>获取列表指定下标的元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex key index</span><br></pre></td></tr></table></figure><ol start="3"><li>获取列表长度</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure><h2 id="3-删除">3. 删除</h2><ol><li>从列表右侧弹出元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpop key</span><br></pre></td></tr></table></figure><ol start="2"><li>从列表左侧弹出元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br></pre></td></tr></table></figure><ol start="3"><li>删除指定元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br><span class="line">Lrem命令会从列表中找到=value的元素进行删除，根据count的不同分为3种情况：</span><br><span class="line">1）Count&gt;0,从左到有，删除最多count个元素</span><br><span class="line">2）Count&lt;0,从右到左，删除最多count绝对值个元素</span><br><span class="line">3）Count=0,删除所有  </span><br><span class="line"></span><br><span class="line">列表listaaa为a a a a java php b a b</span><br><span class="line">127.0.0.1:6379&gt; lrem listaaa 5 a</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange listaaa 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;php&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem listaaa 3 php</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange listaaa 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;b&quot;</span><br></pre></td></tr></table></figure><h2 id="4-修改">4. 修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue 修改指定索引下标的元素</span><br><span class="line">Eg：lset listaaa 1 python </span><br></pre></td></tr></table></figure><h2 id="5-阻塞操作">5. 阻塞操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ...] timeout</span><br><span class="line">brpop key [key ...] timeout</span><br><span class="line">blpop和brpop是lpop、rpop的阻塞版本，除了弹出方式不同，使用方法基本相同，timeout阻塞时间</span><br></pre></td></tr></table></figure><ol><li>列表为空</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brpop list:test 3 3秒后返回</span><br><span class="line">brpop list:test 0 一直处于阻塞中</span><br></pre></td></tr></table></figure><ol start="2"><li>列表不为空</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brpop mylist 0 立刻返回</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; brpop mylist 0</span><br><span class="line">1) &quot;mylist&quot;</span><br><span class="line">2) &quot;a&quot;</span><br></pre></td></tr></table></figure><h1 id="六、Set操作（不可重复）">六、Set操作（不可重复）</h1><h2 id="1-集合内的操作">1. 集合内的操作</h2><ol><li>添加元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element .....] 返回结果为添加成功的元素个数</span><br></pre></td></tr></table></figure><ol start="2"><li>删除元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key element [element .....] 返回结果为删除成功的元素个数</span><br></pre></td></tr></table></figure><ol start="3"><li>计算元素个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scard key scard的时间复杂度为O(1),直接用redis内部的变量</span><br></pre></td></tr></table></figure><ol start="4"><li>判断元素是否在集合中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sismember key element 在集合中则返回1，否则返回0</span><br></pre></td></tr></table></figure><ol start="5"><li>随机从集合返回指定个数元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Srandmember key [count] count可不写，默认为1</span><br></pre></td></tr></table></figure><ol start="6"><li>从集合随机弹出元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spop key [count] 3.2版本开始支持[count]</span><br></pre></td></tr></table></figure><ol start="7"><li>获取所有元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Smembers key 它和lrange、hgetall都属于比较重的命令，有时候可以使用sscan来完成</span><br></pre></td></tr></table></figure><h2 id="2-集合间的操作">2. 集合间的操作</h2><ol><li>求多个集合的交集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter key [ key ......]</span><br></pre></td></tr></table></figure><ol start="2"><li>求多个集合的并集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sunion key [key ......]</span><br></pre></td></tr></table></figure><ol start="3"><li>求多个集合的差集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdiff key [key ......]第一个key里面有的，第二个key里面没有的</span><br></pre></td></tr></table></figure><ol start="4"><li>将交集、并集、差集的结果保存</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [ key ......]</span><br><span class="line">sunionstore destination key [ key ......]</span><br><span class="line">sdiffstore destination key [ key ......]</span><br><span class="line">例如：sinterstore user:1_2:inter user:1 user:2 user:1_2:incr也是集合类型</span><br></pre></td></tr></table></figure><h1 id="七、ZADD操作（有序集合）">七、ZADD操作（有序集合）</h1><ol><li>添加成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member[score member .....] 返回结果为添加成功的元素个数</span><br></pre></td></tr></table></figure><ol start="2"><li>计算成员个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard key scard的时间复杂度为O(1),直接用redis内部的变量</span><br></pre></td></tr></table></figure><ol start="3"><li>计算某个成员分数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsore key member</span><br></pre></td></tr></table></figure><ol start="4"><li>计算成员的排名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br></pre></td></tr></table></figure><ol start="5"><li>删除成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member .......]</span><br></pre></td></tr></table></figure><ol start="6"><li>增加成员的分数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure><ol start="7"><li>返回指定排名范围的成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key start end [withscores] 从低分到高分</span><br><span class="line">zrevrange key start end [withscores] 从高分到低分</span><br></pre></td></tr></table></figure><ol start="8"><li>返回指定分数范围的成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrange key min max [withscores] [limit offset count ] 按照分数从低分到高分</span><br><span class="line">zrevrange key max min [withscores] [limit offset count ] 按照分数从高分到低分</span><br></pre></td></tr></table></figure><ol start="9"><li>返回指定分数范围的成员个数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure><ol start="10"><li>删除指定排名内的升序元素</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure><ol start="11"><li>删除指定分数范围的成员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebystore key min max</span><br></pre></td></tr></table></figure><h1 id="八、pub-sub-发布、订阅">八、pub/sub(发布、订阅)</h1><ol><li>发布消息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publish channel message</span><br><span class="line">publish channel:sports &#x27;I want to go eatting&#x27;</span><br></pre></td></tr></table></figure><ol start="2"><li>订阅消息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel .....]</span><br><span class="line">subscribe channel:sports</span><br></pre></td></tr></table></figure><ol start="3"><li>取消订阅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsubscribe channel [channel .....]</span><br></pre></td></tr></table></figure><ol start="4"><li>按照模式订阅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psubscribe pattern [pattern ......]</span><br></pre></td></tr></table></figure><ol start="5"><li>按照模式取消订阅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unpsubscribe pattern [pattern ......]</span><br></pre></td></tr></table></figure><ol start="6"><li>查询订阅</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）查看活跃的频道</span><br><span class="line">pubsub channels</span><br><span class="line">127.0.0.1:6379&gt; pubsub channels</span><br><span class="line">   1) &quot;channel:sports&quot;</span><br><span class="line">   2) &quot;__sentinel__:hello&quot;</span><br><span class="line">（2）查看频道订阅数</span><br><span class="line">pubsub numsub [channel ......]</span><br><span class="line">pubsub numsub channel:sports</span><br><span class="line">（3）查看模式订阅数</span><br><span class="line">pubsub numpat</span><br></pre></td></tr></table></figure><ol start="7"><li>说明：<br>客户端在执行订阅命令之后进入了订阅状态，只能接收四个命令：subscribe、psubscribe、unsubscribe、punsubscribe；<br>新开启的订阅客户端，无法收到该频道之前的消息，因为redis不会对发布的消息进行持久化。</li></ol><h1 id="九、Transaction（事务）">九、Transaction（事务）</h1><ol><li>取消执行事务块内的所有命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure><ol start="2"><li>执行事务块内的命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure><ol start="3"><li>标记一个事务块的开始</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure><ol start="4"><li>取消watch命令对所有key的监视</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure><ol start="5"><li>监视一个或者多个key，如果事务执行之前，这个kye被其它命令所动，则事务被打断</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key [key ...]</span><br></pre></td></tr></table></figure><h1 id="十、Connection（连接）">十、Connection（连接）</h1><ol><li>登录redis时输入密码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure><ol start="2"><li>打印一个特定的信息message，测试时使用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo message</span><br></pre></td></tr></table></figure><ol start="3"><li>测试与服务器的连接，如果正常则返回pong</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping</span><br></pre></td></tr></table></figure><ol start="4"><li>请求服务器关闭与当前客户端的连接</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><ol start="5"><li>切换到指定的数据库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select index</span><br></pre></td></tr></table></figure><h1 id="十一、Server-服务器">十一、Server(服务器)</h1><ol><li>后台异步保存数据到硬盘</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure><ol start="2"><li>为连接设置、获取名字</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client setname/client getname</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭地址为 ip:port的客户端</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client kill ip:port</span><br></pre></td></tr></table></figure><ol start="4"><li>以人类可读的方式，返回所有的连接客户端信息和统计数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client list</span><br></pre></td></tr></table></figure><ol start="5"><li>取得运行redis服务器的配置参数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get parameter</span><br></pre></td></tr></table></figure><ol start="6"><li>设置redis服务器的配置参数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set parameter value</span><br></pre></td></tr></table></figure><ol start="7"><li>重置info命令的某些统计数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config resetstat </span><br></pre></td></tr></table></figure><ol start="8"><li>返回redis服务器的各种信息和统计数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info [section]</span><br></pre></td></tr></table></figure><ol start="9"><li>返回最近一次redis成功将数据保存到磁盘时的时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastsave</span><br></pre></td></tr></table></figure><ol start="10"><li>实时打印出redis服务器接收到的指令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor</span><br></pre></td></tr></table></figure><ol start="11"><li>将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure><ol start="12"><li>将当前服务器转变为指定服务器的从属服务器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof host port</span><br></pre></td></tr></table></figure><ol start="13"><li>Redis 用来记录查询执行时间的日志系统</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog subcommand [argument]</span><br></pre></td></tr></table></figure><p><strong>部分内容摘自<a href="https://segmentfault.com/a/1190000010999677">https://segmentfault.com/a/1190000010999677</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-benchmark 性能测试详解</title>
      <link href="/2021/06/24/redis_5/"/>
      <url>/2021/06/24/redis_5/</url>
      
        <content type="html"><![CDATA[<p>redis-benchmark是Redis自带的压测工具<br><img src="https://img-blog.csdnimg.cn/20210624161259995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>压测命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -c 50 -n 10000</span><br></pre></td></tr></table></figure><p>压测需要一段时间来完成，因为它需要依次压测多个命令的结果：get、set、incr、lpush等等，如果只需要压测某个命令，如：get，那么可以在以上的命令后加一个参数 -t：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.1 -p 6086 -c 50 -n 10000 -t get</span><br></pre></td></tr></table></figure><p>压测出来的结果很长，我这里就不全部截图解释了，只说明一下 set 命令的结果：<br><img src="https://img-blog.csdnimg.cn/20210624162225366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>先看上面的部分，可以看到 0.14s 写入了1w条数据，50个客户端并发，每次只写入 3 个字节，只有一台服务器来处理这些请求；中间的部分就是不同毫秒时处理总数据的百分比以及延迟；最后的部分就是算出的平均吞吐量了。总体来说，吞吐速度还是很不错的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 pip安装第三方库失败，WARNING: You are using pip version 20.2.3； however, version 21.1.2 is available.</title>
      <link href="/2021/06/24/python_7/"/>
      <url>/2021/06/24/python_7/</url>
      
        <content type="html"><![CDATA[<p>在安装clickhouse_driver时报错：<br>WARNING: You are using pip version 20.2.3; however, version 21.1.2 is available.<br>You should consider upgrading via the ‘c:\software\python3.9.2\python.exe -m pip install --upgrade pip’ command.<br><img src="https://img-blog.csdnimg.cn/20210624122613961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>原因是因为pip版本过低导致，所以只需要升级pip即可<br>百度上的 easy_install -U pip 命令已经弃用了，应该使用 python -m pip install -U pip 命令来升级<br><img src="https://img-blog.csdnimg.cn/20210624123222322.png" alt="在这里插入图片描述"><br>可以看到提示安装了新版本并卸载了旧版本，可以通过 pip show pip 命令来查看当前版本<br><img src="https://img-blog.csdnimg.cn/20210624123359189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后就可以正常安装第三方库了</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug记录 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 的简单学习</title>
      <link href="/2021/06/21/redis_4/"/>
      <url>/2021/06/21/redis_4/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Redis是什么？">一. Redis是什么？</h1><p><strong>Redis（<font color=red>Re</font>mote <font color=red>Di</font>ctionary <font color=red>S</font>erver），即<font color=red>远程字典服务</font>。是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供了多种语言的API。</strong><br><strong>当下最热门的 NoSQL 技术之一，也被称为结构化数据库。</strong></p><h1 id="二-Redis能干什么？">二. Redis能干什么？</h1><ul><li><strong>内存存储、持久化数据</strong></li><li><strong>效率高，可配合关系型数据库做高速缓存</strong></li><li><strong>发布订阅系统</strong></li><li><strong>地图信息分析</strong></li><li><strong>计时器、计数器</strong></li></ul><h1 id="三-Redis的特性">三. Redis的特性</h1><ul><li><strong>数据类型的多样化，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）</strong></li><li><strong>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的</strong></li><li><strong>数据可持久化</strong></li><li><strong>数据缓存在内存中，会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</strong></li><li><strong>实现了master-slave(主从)同步</strong></li></ul><h1 id="四-Redis的安装">四. Redis的安装</h1><p><a href="https://blog.csdn.net/weixin_44758876/article/details/117252173">Redis6.2.3安装教程</a></p><h1 id="五-默认的安装文件">五. 默认的安装文件</h1><ul><li><strong>redis-benchmark</strong><ul><li>性能测试工具，可以在自己本子运行，看看自己本子性能如何</li></ul></li><li><strong>redis-check-aof</strong><ul><li>修复有问题的AOF文件</li></ul></li><li><strong>redis-check-dump</strong><ul><li>修复有问题的dump.rdb文件</li></ul></li><li><strong>redis-sentinel</strong><ul><li>Redis集群使用</li></ul></li><li><strong>redis-server</strong><ul><li>Redis服务器启动命令</li></ul></li><li><strong>redis-cli</strong><ul><li>客户端，操作入口</li></ul></li></ul><h1 id="六-Redis的启动">六. Redis的启动</h1><p><a href="https://blog.csdn.net/weixin_44758876/article/details/118087310">Redis6.2.3启动教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6.2.3 启动教程</title>
      <link href="/2021/06/21/redis_3/"/>
      <url>/2021/06/21/redis_3/</url>
      
        <content type="html"><![CDATA[<h1 id="前台启动（不推荐）">前台启动（不推荐）</h1><p><strong>通过 redis-server 命令启动，使用默认配置文件（命令行窗口不能关闭，否则服务停止）</strong><br><img src="https://img-blog.csdnimg.cn/20210621151414295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="后台启动（推荐）">后台启动（推荐）</h1><ol><li><strong>修改 redis.conf 文件，将daemonize no 改成 yes，让服务在后台启动</strong></li><li><strong>通过 redis-server redis.conf 命令启动Redis（不在安装目录下需要指定文件路径）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server 你的reids安装路径/bin/redis.conf</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>用客户端访问 redis-cli（如果更改了端口，使用<code>redis-cli</code>客户端连接时，也需要指定端口，例：redis-cli -p 6380）</strong><br><img src="https://img-blog.csdnimg.cn/20210621152703984.png" alt="在这里插入图片描述"></li><li><strong>通过 ping 测试验证</strong><br><img src="https://img-blog.csdnimg.cn/20210621152940704.png" alt="在这里插入图片描述"></li><li><strong>通过 redis-cli shutdown 关闭服务</strong><br><img src="https://img-blog.csdnimg.cn/20210621153245531.png" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL 数据库简介</title>
      <link href="/2021/06/21/database_1/"/>
      <url>/2021/06/21/database_1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-NoSQL数据库概述">1. NoSQL数据库概述</h1><p><strong>NoSQL(NoSQL = <font color=red>Not Only SQL</font> )，意即“不仅仅是SQL”，泛指<font color=red>非关系型的数据库</font>。<br>NoSQL 不依赖业务逻辑方式存储，而以简单的<font color=red>key-value</font>模式存储（数据存储的类型不需要一个固定形式）。因此大大的增加了数据库的扩展能力。</strong></p><ul><li><strong>不遵循 SQL 标准</strong></li><li><strong>不支持 ACID</strong></li><li><strong>远超于 SQL 的性能</strong></li></ul><h1 id="2-NoSQL特点">2. NoSQL特点</h1><ul><li><strong>方便扩展（数据之间没有关系，很好扩展）</strong></li><li><strong>大数据量高性能（Redis 一秒写8万次，读取11万，NoSQL的缓存记录级是细粒度的缓存，性能会比较高）</strong></li><li><strong>高可用、高可扩</strong></li><li><strong>键值对存储、列存储、文档存储、图形数据库（社交关系）</strong></li></ul><h1 id="3-NoSQL适用场景">3. NoSQL适用场景</h1><ul><li><strong>对数据高并发的读写</strong></li><li><strong>海量数据的读写</strong></li><li><strong>对数据高可扩展性</strong></li></ul><h1 id="4-NoSQL不适用场景">4. NoSQL不适用场景</h1><ul><li><strong>需要事务支持</strong></li><li><strong>基于 sql 的结构化查询存储，处理复杂的关系，需要即席查询</strong></li></ul><h1 id="5-常见的NoSQL四大分类">5. 常见的NoSQL四大分类</h1><h2 id="5-1-Key-Value数据库">5.1 Key-Value数据库</h2><h3 id="5-1-2-Memcache">5.1.2 Memcache</h3><p><img src="https://img-blog.csdnimg.cn/20210621112936999.png" alt="在这里插入图片描述"></p><ul><li><strong>早期出现的 NoSQL 数据库</strong></li><li><strong>数据都在内存中，一般不持久化</strong></li><li><strong>支持简单的 key-value 模式，支持类型单一</strong></li><li><strong>一般是作为缓存数据库辅助持久化的数据库</strong></li></ul><h3 id="5-1-2-Redis">5.1.2 Redis</h3><p><img src="https://img-blog.csdnimg.cn/20210621113126120.png" alt="在这里插入图片描述"></p><ul><li><strong>几乎覆盖了 Mencached 的绝大部分功能</strong></li><li><strong>数据都在内存中，支持持久化，主要用作备份恢复</strong></li><li><strong>除了支持简单的 key-value 模式，还支持多种数据结构的存储，比如 list、set、hash、zset等</strong></li><li><strong>一般是作为缓存数据库辅助持久化的数据库</strong></li></ul><h2 id="5-2-文档型数据库">5.2 文档型数据库</h2><h3 id="5-1-1-MongoDB">5.1.1 MongoDB</h3><p><img src="https://img-blog.csdnimg.cn/20210621113356833.png" alt="在这里插入图片描述"></p><ul><li><strong>高性能、开源、模式自由(schema free)的文档型数据库</strong></li><li><strong>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</strong></li><li><strong>与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容</strong></li><li><strong>虽然是key-value模式，但是对 value（尤其是 json ）提供了丰富的查询功能</strong></li><li><strong>支持二进制数据及大型对象</strong></li><li><strong>可以根据数据的特点替代RDBMS ，成为独立的数据库，或者配合RDBMS，存储特定的数据</strong></li></ul><h2 id="5-3-列存储数据库">5.3 列存储数据库</h2><h3 id="5-3-1-HBase">5.3.1 HBase</h3><p><img src="https://img-blog.csdnimg.cn/20210621140526303.png" alt="在这里插入图片描述"></p><ul><li><strong>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中</strong></li><li><strong>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表</strong></li></ul><h3 id="5-3-2-Cassandra">5.3.2 Cassandra</h3><p><img src="https://img-blog.csdnimg.cn/20210621140645260.png" alt="在这里插入图片描述"></p><ul><li><strong>Apache Cassandra 是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</strong></li></ul><h2 id="5-4-图关系型数据库">5.4 图关系型数据库</h2><p><img src="https://img-blog.csdnimg.cn/20210621140836877.png" alt="在这里插入图片描述"><br><strong>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)</strong><br><img src="https://img-blog.csdnimg.cn/20210621140953565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲲鹏处理器虚拟机免费申请教程</title>
      <link href="/2021/06/17/resource_2/"/>
      <url>/2021/06/17/resource_2/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>注册一个账户</strong><br><a href="https://dw.pcl.ac.cn/cloud/login">https://dw.pcl.ac.cn/cloud/login</a><br><img src="https://img-blog.csdnimg.cn/20210617110656790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210617110802964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210617110843396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>注册成功之后输入用户名和密码登录，然后点击“开发者云”</strong><br><img src="https://img-blog.csdnimg.cn/20210617111140206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>这时候会验证你的邮箱，激活账号</strong></li><li><strong>验证成功之后，登录账号，再点击“开发者云”，会出现下面的页面，然后点击“需求申请”</strong><br><img src="https://img-blog.csdnimg.cn/20210617111402820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>点击之后会出现申请详情，根据自己的需要填入需要申请的资源，填写完毕，点击“提交”</strong><br><img src="https://img-blog.csdnimg.cn/20210617111703570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>提交之后，等待申请通过即可，一般一天之内就会通过（申请1核1G通过会很快）</strong><br><img src="https://img-blog.csdnimg.cn/2021061711211461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>我这里申请的1核1G不到两个小时就通过了，申请通过之后会发邮件通知，然后我们再点击左边菜单的“云主机”，就可以看到已经通过的主机了，再点击右边的“详情”，就可以看到对应的ip和连接端口</strong><br><img src="https://img-blog.csdnimg.cn/20210617112443321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20210617112824623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>然后就可以通过ssh工具连接服务器了，我这里用的是xshell</strong><br><img src="https://img-blog.csdnimg.cn/20210617112945343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>在“云主机”菜单中，还可以点击“更多操作”，这里可以做申请更多端口、关机、重启、删除等操作</strong><img src="https://img-blog.csdnimg.cn/20210617113213256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><p><strong>部分内容摘抄自<a href="https://blog.csdn.net/frdevolcqzyxynjds/article/details/105578249">https://blog.csdn.net/frdevolcqzyxynjds/article/details/105578249</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 资源共享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源共享 </tag>
            
            <tag> 鲲鹏CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink1.12.4 配置文件详解</title>
      <link href="/2021/06/09/flink_12/"/>
      <url>/2021/06/09/flink_12/</url>
      
        <content type="html"><![CDATA[<h1 id="1-flink-conf-yaml">1. flink-conf.yaml</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"># Jobmanager的地址，taskmanager必须要识别并能连上。</span><br><span class="line"># 只有standalone的集群模式起作用，当执行bin/jobmanager.sh --host&lt;hostname&gt;的时候将被覆盖</span><br><span class="line"># 在YARN或者Mesos的集群模式下将自动替换为jobmanager所在节点的hostname</span><br><span class="line"># JobMaster节点IP地址</span><br><span class="line">jobmanager.rpc.address</span><br><span class="line"></span><br><span class="line"># JobMaster端口号，默认6123</span><br><span class="line">jobmanager.rpc.port：6123</span><br><span class="line"></span><br><span class="line"># JobManager能够使用的内存的最大值</span><br><span class="line">jobmanager.heap.size: 1024m</span><br><span class="line"></span><br><span class="line"># taskmanager 能够使用的最大内存大小</span><br><span class="line">taskmanager.memory.process.size: 2048m</span><br><span class="line"></span><br><span class="line"># taskmanager最大内存，不包含虚拟机的metaspace和其他的开销（不能和taskmanager.memory.process.size同时设置）</span><br><span class="line"># taskmanager.memory.flink.size： 2048m</span><br><span class="line"></span><br><span class="line"># 这俩不能和taskmanager.memory.flink.size或taskmanager.memory.process.size同时设置</span><br><span class="line"># 指定JVM堆内存大小</span><br><span class="line"># taskmanager.memory.task.heap.size: 2048m</span><br><span class="line"># 指定JVM托管内存大小</span><br><span class="line"># taskmanager.memory.managed.size: 512m</span><br><span class="line"></span><br><span class="line"># 每个TaskManager提供的slot数量，每个slot上能运行一个并行的pipeline任务。</span><br><span class="line">taskmanager.numberOfTaskSlots: 1</span><br><span class="line"></span><br><span class="line"># 没有指定并行度的情况下，默认的全局并行度</span><br><span class="line">parallelism.default: 1</span><br><span class="line"></span><br><span class="line"># 默认的文件系统的数据结构和授权</span><br><span class="line"># 如果是本地文件，那么格式为: &#x27;file:///&#x27;</span><br><span class="line"># 如果是HDFS文件，那么格式为：&#x27;hdfs://namenode_name:9870&#x27;</span><br><span class="line"># fs.default-scheme</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># 高可用配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># 高可用模型的选择有：&#x27;NONE&#x27; 或者 &#x27;zookeeper&#x27;</span><br><span class="line"># high-availability: zookeeper</span><br><span class="line"></span><br><span class="line"># 指定master恢复所需要的元数据存储的路径。这个路径需要存储像持久化数据流图一样的大对象</span><br><span class="line"># high-availability.storageDir: hdfs:///flink/ha/</span><br><span class="line"></span><br><span class="line"># # ZooKeeper集群的地址，用于协调高可用模型的建立</span><br><span class="line"># high-availability.zookeeper.quorum: localhost:2181</span><br><span class="line"></span><br><span class="line"># 如果zookeeper安全策略开启，那么下面这个值就应该是creator，默认是oepn</span><br><span class="line"># high-availability.zookeeper.client.acl: open</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># 容错和检查点配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># Flink后端会默认存储算子的状态，当checkpointing是开启状态的时候</span><br><span class="line"># Flink支持的后端存储有 &#x27;jobmanager（MemoryStateBackend）&#x27;, &#x27;filesystem&#x27;, &#x27;rocksdb&#x27;, 或者自定的类&lt;class-name-of-factory&gt;.</span><br><span class="line"># state.backend: filesystem</span><br><span class="line"></span><br><span class="line"># 自动存储检查点的数据文件和元数据的默认目录，这个目录必须能被所有的进程、节点访问</span><br><span class="line"># state.checkpoints.dir: hdfs://namenode-host:port/flink-checkpoints</span><br><span class="line"></span><br><span class="line"># 手动保存状态时 savepoints 的目录(可选)，用于状态存储写文件时使用</span><br><span class="line">state.savepoints.dir: hdfs://namenode-host:port/flink-checkpoints</span><br><span class="line"></span><br><span class="line"># 是否开启增量存储(类似RocksDB存储转态的情况)</span><br><span class="line"># state.backend.incremental: false</span><br><span class="line"></span><br><span class="line"># 故障恢复的策略，怎么样从失败的任务重恢复计算。配置可选: full 或者 region</span><br><span class="line"># full: 表示集群中的任务发生故障的时候，所有的task重新启动</span><br><span class="line"># region: 表示集群中的任务发生故障的时候，仅重启被失败失败任务所影响的下游的任务和产生数据的上游任务。</span><br><span class="line">jobmanager.execution.failover-strategy: region</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># REST和前端设置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># Web端运行时监视器端口</span><br><span class="line">rest.port: 8081</span><br><span class="line"></span><br><span class="line"># Web Server的地址配置，用于REST api调用</span><br><span class="line">#rest.address: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 配置REST端口绑定的范围</span><br><span class="line">#rest.bind-port: 8080-8090</span><br><span class="line"></span><br><span class="line"># 配置Server地址并绑定server</span><br><span class="line">#rest.bind-address: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 配置任务提交是否在网页端开启，默认开启</span><br><span class="line">#web.submit.enable: false</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># 高级配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># 指定默认的本地临时目录。Flink在运行时会把临时数据写到本地文件系统，</span><br><span class="line"># 比如 Flink 接收到的JAR、应用程序状态(当用RocksDB存储应用程序状态时)，要避免目录里的数据被服务器自动清空</span><br><span class="line"># 否则 job 重启时可能因找不到元数据导致恢复失败</span><br><span class="line"># 注意：推荐是添加多个文件夹地址(unix系统使用冒号隔开，windows使用逗号隔开)，多个文件夹地址可以是相同的，多文件地址的配置致使Flink创建多个线程来出来，提高读写效率和吞度量</span><br><span class="line"># io.tmp.dirs: /tmp </span><br><span class="line"></span><br><span class="line"># 是否在 TM 启动时预先分配 TM 管理的内存</span><br><span class="line">taskmanager.memory.preallocate: false</span><br><span class="line"></span><br><span class="line"># 类加载顺序的设定，Flink默认是&#x27;child-first&#x27;，还可以选：&#x27;parent-first&#x27;</span><br><span class="line"># &#x27;child-first&#x27;这种加载机制允许用户在自己的应用中使用不同的依赖或者JAR包的版本。</span><br><span class="line"># classloader.resolve-order: child-first</span><br><span class="line"></span><br><span class="line"># 网络堆栈能使用的内存总量的配置。这些配置一般不需要调优。</span><br><span class="line"># 当遇到&quot;Insufficient number of network buffers&quot; 错误的时候就需要调整下面的参数了。</span><br><span class="line"># 默认最小是64MB, 最大值是 1GB</span><br><span class="line"># TM 节点为网络缓冲区分配的内存，默认占JVM堆内存10%</span><br><span class="line"># taskmanager.memory.network.fraction: 0.1</span><br><span class="line"># 网络缓冲区最小值</span><br><span class="line"># taskmanager.memory.network.min: 64mb</span><br><span class="line"># 网络缓冲区最大值</span><br><span class="line"># taskmanager.memory.network.max: 1gb</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># Flink集群安全配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># Kerberos认证，主要用在Hadoop,Zookeeper, connectors上的安全组件</span><br><span class="line"># 通常开启的步骤为：</span><br><span class="line"># 1. 配置本地的krb5.conf文件</span><br><span class="line"># 2. 提供Kerberos的凭证(可以是一个keytab或者一个ticket cache)</span><br><span class="line"># 3. 针对不同的JAAS的登录上下文，激活Kerberos的凭证</span><br><span class="line"># 4. 使用JAAS/SASL配置连接</span><br><span class="line"></span><br><span class="line"># 下面这些配置是说明Kerberos怎么提供安全凭证的。</span><br><span class="line"># 当用户提供了keytab path 和 principal，keytab将用于代贴ticket cache </span><br><span class="line"></span><br><span class="line"># 是否从 Kerberos ticket 缓存中读取</span><br><span class="line"># security.kerberos.login.use-ticket-cache: true</span><br><span class="line"></span><br><span class="line"># 包含用户凭据的 Kerberos 密钥表文件的绝对路径</span><br><span class="line"># security.kerberos.login.keytab: /path/to/kerberos/keytab</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 与 keytab 关联的 Kerberos 主体名称</span><br><span class="line"># security.kerberos.login.principal: flink-user</span><br><span class="line"></span><br><span class="line"># 以逗号分隔的登录上下文列表，用于提供 Kerberos 凭据</span><br><span class="line"># 例如，Client，KafkaClient 使用凭证进行 ZooKeeper 身份验证和 Kafka 身份验证# security.kerberos.login.contexts: Client,KafkaClient</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># Zookeeper 安全配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># 当zookeeper开启了安全模式，下面的配置就是必要的。</span><br><span class="line"></span><br><span class="line"># 如果zookeeper配置了服务名称，就需要修改下面这个配置</span><br><span class="line"># zookeeper.sasl.service-name: zookeeper</span><br><span class="line"></span><br><span class="line"># 该配置必须匹配 security.kerberos.login.contexts 配置中的列表（含有一个）</span><br><span class="line"># zookeeper.sasl.login-context-name: Client</span><br><span class="line"></span><br><span class="line">#==============================================================================</span><br><span class="line"># 历史任务服务器配置</span><br><span class="line">#==============================================================================</span><br><span class="line"></span><br><span class="line"># HistoryServer 通过bin/historyserver.sh (start|stop)开启和关闭</span><br><span class="line"></span><br><span class="line"># 用于上传执行完成的job。也是HistoryServer监控的目录。</span><br><span class="line">#jobmanager.archive.fs.dir: hdfs:///completed-jobs/</span><br><span class="line"></span><br><span class="line"># 基于 Web 的 HistoryServer 的地址</span><br><span class="line">#historyserver.web.address: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 基于 Web 的 HistoryServer 的端口号</span><br><span class="line">#historyserver.web.port: 8082</span><br><span class="line"></span><br><span class="line"># 以逗号分隔的目录列表，指定监控已完成的job所在的地址</span><br><span class="line">#historyserver.archive.fs.dir: hdfs:///completed-jobs/</span><br><span class="line"></span><br><span class="line"># 刷新受监控目录的时间间隔（毫秒）</span><br><span class="line">#historyserver.archive.fs.refresh-interval: 10000</span><br></pre></td></tr></table></figure><h1 id="2-masters">2. masters</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 集群的 master 节点</span><br><span class="line">localhost:8081</span><br></pre></td></tr></table></figure><h1 id="3-workers">3. workers</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 集群中所有的工作节点</span><br><span class="line">localhost</span><br></pre></td></tr></table></figure><h1 id="4-zoo-cfg">4. zoo.cfg</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 每个 tick 的毫秒数</span><br><span class="line">tickTime=2000</span><br><span class="line"> </span><br><span class="line"># 初始同步阶段可以采用的 tick 数</span><br><span class="line">initLimit=10</span><br><span class="line"> </span><br><span class="line"># 在发送请求和获取确认之间可以传递的 tick 数</span><br><span class="line">syncLimit=5</span><br><span class="line"> </span><br><span class="line"># 存储快照的目录</span><br><span class="line"># dataDir=/tmp/zookeeper</span><br><span class="line"> </span><br><span class="line"># 客户端将连接的端口</span><br><span class="line">clientPort=2181</span><br><span class="line"> </span><br><span class="line"># ZooKeeper quorum peers</span><br><span class="line">server.1=localhost:2888:3888</span><br><span class="line"># server.2=host:peer-port:leader-port</span><br></pre></td></tr></table></figure><h1 id="5-日志配置">5. 日志配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在不同平台下Flink运行的日志文件</span><br><span class="line">log4j-cli.properties</span><br><span class="line">log4j-console.properties</span><br><span class="line">log4j-yarn-session.properties</span><br><span class="line">log4j.properties</span><br><span class="line">logback-console.xml</span><br><span class="line">logback-yarn.xml</span><br><span class="line">logback.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 1.12.4 RocksDBStateBackend 优化</title>
      <link href="/2021/06/09/flink_11/"/>
      <url>/2021/06/09/flink_11/</url>
      
        <content type="html"><![CDATA[<p><strong>在使用RocksDB作为state存储之后，发现性能被严重影响，吞吐能力下降了几倍不止，所以根据网上的几篇调优文档做了自己的优化，感谢下面这些博客做出的贡献：</strong><br><a href="https://www.jianshu.com/p/2e61c2c83c57">https://www.jianshu.com/p/2e61c2c83c57</a><br><a href="https://blog.csdn.net/wangshuo2019/article/details/107250801/">https://blog.csdn.net/wangshuo2019/article/details/107250801/</a><br><a href="https://blog.csdn.net/huang358468/article/details/115221066">https://blog.csdn.net/huang358468/article/details/115221066</a><br><a href="https://github.com/apachecn/flink-doc-zh/blob/master/docs/1.7/119.md">https://github.com/apachecn/flink-doc-zh/blob/master/docs/1.7/119.md</a><br><a href="https://www.jianshu.com/p/df98fa755a2d">https://www.jianshu.com/p/df98fa755a2d</a><br><a href="https://blog.csdn.net/weixin_44904816/article/details/105672235">https://blog.csdn.net/weixin_44904816/article/details/105672235</a><br><a href="https://blog.csdn.net/yscoder/article/details/117064790">https://blog.csdn.net/yscoder/article/details/117064790</a></p><p><strong>下面是我自己的flink-conf.yaml文件关于RocksDB的优化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">state.backend: rocksdb</span><br><span class="line"># 激活RocksDB压缩过滤清除</span><br><span class="line">state.backend.rocksdb.ttl.compaction.filter.enabled: true</span><br><span class="line"># block大小，默认4KB</span><br><span class="line">state.backend.rocksdb.block.blocksize: 32kb</span><br><span class="line"># block cache大小，默认8MB，内存余量充足建议128m或256m，提升读的性能</span><br><span class="line">state.backend.rocksdb.block.cache-size: 128m</span><br><span class="line">state.backend.rocksdb.compaction.level.use-dynamic-size: true</span><br><span class="line"># 后台负责 flush 和 compaction 的最大并发线程数，默认为1</span><br><span class="line">state.backend.rocksdb.thread.num: 4</span><br><span class="line"># 指定checkpoint的data files和meta data存储的目录，该目录必须对所有参与的TaskManagers及JobManagers可见</span><br><span class="line">state.checkpoints.dir: file:///ssd/flink2kafka/flink-1.12.4/data</span><br><span class="line"># 用于指定定时器服务的工厂类实现类，默认为“HEAP”</span><br><span class="line">state.backend.rocksdb.timer-service.factory: rocksdb</span><br><span class="line"># 用于指定同时可以操作RocksDBStateBackend的线程数量，默认是1</span><br><span class="line">state.backend.rocksdb.checkpoint.transfer.thread.num: 2</span><br><span class="line"># 配置任务本地恢复</span><br><span class="line">state.backend.local-recovery: true</span><br><span class="line"># 指定RocksDB存储状态数据的本地文件路径，在每个TaskManager提供该路径节点中的状态存储</span><br><span class="line">state.backend.rocksdb.localdir: /ssd/flink2kafka/flink-1.12.4/rocksdb</span><br><span class="line"># 设为 false 禁用 RocksDB 内存托管</span><br><span class="line">state.backend.rocksdb.memory.managed: true</span><br><span class="line"># 限制每个slot的RocksDB内存的使用上限，避免了OOM的风险</span><br><span class="line">state.backend.rocksdb.memory.fixed-per-slot: 20mb</span><br><span class="line"># 默认值 0.5，即 50% 的给定内存会分配给写缓冲区使用</span><br><span class="line">state.backend.rocksdb.memory.write-buffer-ratio: 0.9</span><br><span class="line"># 默认值 0.1，即 10% 的 block cache 内存会优先分配给索引及过滤</span><br><span class="line">state.backend.rocksdb.memory.high-prio-pool-ratio: 0.1</span><br><span class="line">#state.backend.rocksdb.metrics.estimate-num-keys: true</span><br><span class="line">state.backend.rocksdb.metrics.num-running-compactions: true</span><br><span class="line"># 监控当前的实际延迟写入率</span><br><span class="line">state.backend.rocksdb.metrics.background-errors: true</span><br><span class="line"># 启用了Flink RocksDB指标</span><br><span class="line">state.backend.rocksdb.metrics.block-cache-capacity: true</span><br><span class="line">state.backend.rocksdb.metrics.block-cache-pinned-usage: true</span><br><span class="line">state.backend.rocksdb.metrics.block-cache-usage: true</span><br><span class="line">state.backend.rocksdb.metrics.estimate-table-readers-mem: true</span><br><span class="line"># 监控待处理的压缩，如果压缩失败返回1，否则返回0</span><br><span class="line">state.backend.rocksdb.metrics.compaction-pending: true</span><br><span class="line"># L1层单个 sstable 文件的大小阈值，默认值为64MB</span><br><span class="line">state.backend.rocksdb.compaction.level.target-file-size-base: 32m</span><br><span class="line"># L1层的数据总大小阈值，默认值为256MB，建议设为 target_file_size_base 的倍数，且不能太小</span><br><span class="line">state.backend.rocksdb.compaction.level.max-size-level-base: 160m</span><br></pre></td></tr></table></figure><p><strong>调优之前一定要先了解RocksDB的原理，才能根据自己的实际情况去调整参数</strong><br><strong>这是官方对于RocksDBStateBackend配置的解释：</strong><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.12/deployment/config.html#advanced-rocksdb-state-backends-options">https://ci.apache.org/projects/flink/flink-docs-release-1.12/deployment/config.html#advanced-rocksdb-state-backends-options</a></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 下安装 RocksDB</title>
      <link href="/2021/06/08/rocksdb_2/"/>
      <url>/2021/06/08/rocksdb_2/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>安装依赖</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc g++ libsnappy-dev zlib1g-dev libbz2-dev liblz4-dev libzstd-dev libgflags-dev</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>下载安装包并解压（安装包链接放在最后）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf rocksdb-6.16.6.tar.gz</span><br><span class="line">cd rocksdb-6.16.4/</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>编译安装</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 编译静态库</span><br><span class="line">make static_lib</span><br><span class="line">// 编译动态库</span><br><span class="line">make shared_lib</span><br></pre></td></tr></table></figure><p><strong>如果出现下面的错误：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误示例</span><br><span class="line">$DEBUG_LEVEL is 0</span><br><span class="line">GEN util/build_version.cc</span><br><span class="line">CCLD librocksdb.so.6.13.0</span><br><span class="line">/usr/bin/ld: ./memory/concurrent_arena.o: relocation R_X86_64_TPOFF32 against symbol _ZN7rocksdb15ConcurrentArena9tls_cpuidE&#x27; can not be used when making a shared object; recompile with -fPIC /usr/bin/ld: ./monitoring/iostats_context.o: relocation R_X86_64_TPOFF32 against symbol _ZN7rocksdb15iostats_contextE&#x27; can not be used when making a shared object; recompile with -fPIC</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make shared_lib</span><br><span class="line">make static_lib</span><br></pre></td></tr></table></figure><p><strong>编译完成会得到下面几个文件（第一个为静态编译得到的，后四个为动态编译得到的）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">librocksdb.a</span><br><span class="line">librocksdb.so</span><br><span class="line">librocksdb.so.6</span><br><span class="line">librocksdb.so.6.16</span><br><span class="line">librocksdb.so.6.16.4</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>环境配置（我这里软连接创建失败了，但是没有影响安装）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将动态库文件复制到系统库目录下</span><br><span class="line">sudo cp librocksdb.so.6.16.4 /usr/local/lib</span><br><span class="line">// 链接其他动态库</span><br><span class="line">sudo ln -s librocksdb.so.6.16.4 /usr/local/lib/librocksdb.so.6.16</span><br><span class="line">sudo ln -s librocksdb.so.6.16.4 /usr/local/lib/librocksdb.so.6</span><br><span class="line">sudo ln -s librocksdb.so.6.16.4 /usr/local/lib/librocksdb.so</span><br></pre></td></tr></table></figure><p><strong>vi /etc/profile</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</span><br><span class="line">export LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><p><strong>最后source /etc/profile</strong><br><strong>致此安装完毕</strong></p><p><strong>安装包链接：</strong><br>链接：<a href="https://pan.baidu.com/s/1oFANkJPUIQUzwJLF3NF3mw">https://pan.baidu.com/s/1oFANkJPUIQUzwJLF3NF3mw</a><br>提取码：ofwb</p><p><strong>文章摘自</strong><a href="https://www.jianshu.com/p/575b2e27b028">https://www.jianshu.com/p/575b2e27b028</a></p>]]></content>
      
      
      <categories>
          
          <category> RocksDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocksDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 安装 RocksDB</title>
      <link href="/2021/06/08/rocksdb_1/"/>
      <url>/2021/06/08/rocksdb_1/</url>
      
        <content type="html"><![CDATA[<p><strong>安装之前需要确定服务器是否挂yum源，木有的自行百度挂源哈</strong></p><ol><li><strong>安装依赖</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install lrzsz git gcc gcc-c++ lz4-devel</span><br><span class="line">yum -y install snappy snappy-devel zlib zlib-devel bzip2 bzip2-devel lz4 lz4-devel zstd</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>下载安装cmake（所有的安装包都放在文末，环境不通外网的可以直接去下载）（注意下面添加的环境变量路径改成自己的）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl -O   https://cmake.org/files/v3.6/cmake-3.6.0-Linux-x86_64.tar.gz</span><br><span class="line">tar -xvzf cmake-3.6.0-Linux-x86_64.tar.gz </span><br><span class="line">yum remove cmake</span><br><span class="line"></span><br><span class="line">cat &gt;&gt;/etc/profile &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">export PATH=\$PATH:/opt/cmake-3.6.0-Linux-x86_64/bin</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>安装gflags（我这里不知道为什么下载下来的是v2.2.2.tar.gz，这不重要，照常解压就行）</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wget   https://github.com/gflags/gflags/archive/v2.2.2.tar.gz</span><br><span class="line">tar -xvzf gflags-2.2.2.tar.gz</span><br><span class="line">cd gflags-2.2.2/</span><br><span class="line">mkdir build</span><br><span class="line">cd build/</span><br><span class="line">cmake -DBUILD_SHARED_LIBS=ON -DBUILD_STATIC_LIBS=ON -DINSTALL_HEADERS=ON -DINSTALL_SHARED_LIBS=ON -DINSTALL_STATIC_LIBS=ON ..</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cat &gt;&gt;/etc/profile &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/usr/local/lib</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>下载安装RocksDB</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/facebook/rocksdb/archive/v6.14.6.tar.gz</span><br><span class="line">tar -xvzf rocksdb-6.14.6.tar.gz </span><br><span class="line">cd rocksdb-6.14.6/</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/local/rocksdb ..</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cat &gt;&gt;/etc/profile &lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">export CPLUS_INCLUDE_PATH=\$CPLUS_INCLUDE_PATH:/usr/local/rocksdb/include/</span><br><span class="line">export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/usr/local/rocksdb/lib64/</span><br><span class="line">export LIBRARY_PATH=\$LIBRARY_PATH:/usr/local/rocksdb/lib64/</span><br><span class="line"></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>ldb工具进行测试</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">cd rocksdb-6.14.6/build/tools/</span><br><span class="line"></span><br><span class="line">执行./ldb -help，会出现下面的说明</span><br><span class="line"></span><br><span class="line">ldb - RocksDB Tool</span><br><span class="line"></span><br><span class="line">commands MUST specify --db=&lt;full_path_to_db_directory&gt; when necessary</span><br><span class="line"></span><br><span class="line">commands can optionally specify --env_uri=&lt;uri_of_environment&gt; if necessary</span><br><span class="line"></span><br><span class="line">The following optional parameters control if keys/values are input/output as hex or as plain strings:</span><br><span class="line">  --key_hex : Keys are input/output as hex</span><br><span class="line">  --value_hex : Values are input/output as hex</span><br><span class="line">  --hex : Both keys and values are input/output as hex</span><br><span class="line"></span><br><span class="line">The following optional parameters control the database internals:</span><br><span class="line">  --column_family=&lt;string&gt; : name of the column family to operate on. default: default column family</span><br><span class="line">  --ttl with &#x27;put&#x27;,&#x27;get&#x27;,&#x27;scan&#x27;,&#x27;dump&#x27;,&#x27;query&#x27;,&#x27;batchput&#x27; : DB supports ttl and value is internally timestamp-suffixed</span><br><span class="line">  --try_load_options : Try to load option file from DB.</span><br><span class="line">  --disable_consistency_checks : Set options.force_consistency_checks = false.</span><br><span class="line">  --ignore_unknown_options : Ignore unknown options when loading option file.</span><br><span class="line">  --bloom_bits=&lt;int,e.g.:14&gt;</span><br><span class="line">  --fix_prefix_len=&lt;int,e.g.:14&gt;</span><br><span class="line">  --compression_type=&lt;no|snappy|zlib|bzip2|lz4|lz4hc|xpress|zstd&gt;</span><br><span class="line">  --compression_max_dict_bytes=&lt;int,e.g.:16384&gt;</span><br><span class="line">  --block_size=&lt;block_size_in_bytes&gt;</span><br><span class="line">  --auto_compaction=&lt;true|false&gt;</span><br><span class="line">  --db_write_buffer_size=&lt;int,e.g.:16777216&gt;</span><br><span class="line">  --write_buffer_size=&lt;int,e.g.:4194304&gt;</span><br><span class="line">  --file_size=&lt;int,e.g.:2097152&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data Access Commands:</span><br><span class="line">  put &lt;key&gt; &lt;value&gt; [--create_if_missing] [--ttl]</span><br><span class="line">  get &lt;key&gt; [--ttl]</span><br><span class="line">  batchput &lt;key&gt; &lt;value&gt; [&lt;key&gt; &lt;value&gt;] [..] [--create_if_missing] [--ttl]</span><br><span class="line">  scan [--from] [--to]  [--ttl] [--timestamp] [--max_keys=&lt;N&gt;q]  [--start_time=&lt;N&gt;:- is inclusive] [--end_time=&lt;N&gt;:- is exclusive] [--no_value]</span><br><span class="line">  delete &lt;key&gt;</span><br><span class="line">  deleterange &lt;begin key&gt; &lt;end key&gt;</span><br><span class="line">  query [--ttl]</span><br><span class="line">    Starts a REPL shell.  Type help for list of available commands.</span><br><span class="line">  approxsize [--from] [--to] </span><br><span class="line">  checkconsistency</span><br><span class="line">  list_file_range_deletes [--max_keys=&lt;N&gt;] : print tombstones in SST files.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Admin Commands:</span><br><span class="line">  dump_wal --walfile=&lt;write_ahead_log_file_path&gt; [--header]  [--print_value]  [--write_committed=true|false] </span><br><span class="line">  compact [--from] [--to] </span><br><span class="line">  reduce_levels --new_levels=&lt;New number of levels&gt; [--print_old_levels]</span><br><span class="line">  change_compaction_style --old_compaction_style=&lt;Old compaction style: 0 for level compaction, 1 for universal compaction&gt; --new_compaction_style=&lt;New compaction style: 0 for level compaction, 1 for universal compaction&gt;</span><br><span class="line">  dump [--from] [--to]  [--ttl] [--max_keys=&lt;N&gt;] [--timestamp] [--count_only] [--count_delim=&lt;char&gt;] [--stats] [--bucket=&lt;N&gt;] [--start_time=&lt;N&gt;:- is inclusive] [--end_time=&lt;N&gt;:- is exclusive] [--path=&lt;path_to_a_file&gt;]</span><br><span class="line">  load [--create_if_missing] [--disable_wal] [--bulk_load] [--compact]</span><br><span class="line">  manifest_dump [--verbose] [--json] [--path=&lt;path_to_manifest_file&gt;]</span><br><span class="line">  file_checksum_dump [--path=&lt;path_to_manifest_file&gt;]</span><br><span class="line">  list_column_families</span><br><span class="line">  create_column_family --db=&lt;db_path&gt; &lt;new_column_family_name&gt;</span><br><span class="line">  drop_column_family --db=&lt;db_path&gt; &lt;column_family_name_to_drop&gt;</span><br><span class="line">  dump_live_files</span><br><span class="line">  idump [--from] [--to]  [--input_key_hex] [--max_keys=&lt;N&gt;] [--count_only] [--count_delim=&lt;char&gt;] [--stats]</span><br><span class="line">  repair</span><br><span class="line">  backup [--backup_env_uri]  [--backup_dir]  [--num_threads]  [--stderr_log_level=&lt;int (InfoLogLevel)&gt;] </span><br><span class="line">  restore [--backup_env_uri]  [--backup_dir]  [--num_threads]  [--stderr_log_level=&lt;int (InfoLogLevel)&gt;] </span><br><span class="line">  checkpoint [--checkpoint_dir] </span><br><span class="line">  write_extern_sst &lt;output_sst_path&gt;</span><br><span class="line">  ingest_extern_sst &lt;input_sst_path&gt; [--move_files]  [--snapshot_consistency]  [--allow_global_seqno]  [--allow_blocking_flush]  [--ingest_behind]  [--write_global_seqno] </span><br><span class="line">  unsafe_remove_sst_file &lt;SST file number&gt;</span><br><span class="line">    MUST NOT be used on a live DB.</span><br><span class="line"></span><br><span class="line"># ./ldb --db=/tmp/test_db --create_if_missing put a1 b1</span><br><span class="line">OK</span><br><span class="line"># ./ldb --db=/tmp/test_db scan</span><br><span class="line">a1 : b1</span><br><span class="line"># ./ldb --db=/tmp/test_db get a1</span><br><span class="line">b1</span><br><span class="line"># ./ldb --db=/tmp/test_db get a2</span><br><span class="line">Failed: NotFound: </span><br><span class="line"># cd /tmp/test_db/</span><br><span class="line"># ll</span><br><span class="line">-rw-r--r-- 1 root root    26 Jun  9 17:52 000003.log</span><br><span class="line">-rw-r--r-- 1 root root    16 Jun  9 17:52 CURRENT</span><br><span class="line">-rw-r--r-- 1 root root    37 Jun  9 17:52 IDENTITY</span><br><span class="line">-rw-r--r-- 1 root root     0 Jun  9 17:52 LOCK</span><br><span class="line">-rw-r--r-- 1 root root 18821 Jun  9 17:53 LOG</span><br><span class="line">-rw-r--r-- 1 root root 18589 Jun  9 17:52 LOG.old.1623232363821351</span><br><span class="line">-rw-r--r-- 1 root root 18821 Jun  9 17:52 LOG.old.1623232374342461</span><br><span class="line">-rw-r--r-- 1 root root 18821 Jun  9 17:52 LOG.old.1623232385039046</span><br><span class="line">-rw-r--r-- 1 root root    13 Jun  9 17:52 MANIFEST-000001</span><br><span class="line">-rw-r--r-- 1 root root  5793 Jun  9 17:52 OPTIONS-000005</span><br></pre></td></tr></table></figure><p><strong>安装包百度云链接：</strong><br>链接：<a href="https://pan.baidu.com/s/1oFANkJPUIQUzwJLF3NF3mw">https://pan.baidu.com/s/1oFANkJPUIQUzwJLF3NF3mw </a><br>提取码：ofwb</p><p>文章借鉴<a href="https://blog.51cto.com/u_860143/2452514">https://blog.51cto.com/u_860143/2452514</a></p>]]></content>
      
      
      <categories>
          
          <category> RocksDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocksDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 实现字符串 MD5 加密</title>
      <link href="/2021/06/08/java_2/"/>
      <url>/2021/06/08/java_2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Util</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">stringMD5</span><span class="params">(String input)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）</span></span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span>MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line"><span class="comment">//            输入的字符串转换成字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] inputByteArray = input.getBytes();</span><br><span class="line"><span class="comment">//            inputByteArray是输入字符串转换得到的字节数组</span></span><br><span class="line">            messageDigest.update(inputByteArray);</span><br><span class="line"><span class="comment">//            转换并返回结果，也是字节数组，包含16个元素</span></span><br><span class="line">            <span class="type">byte</span>[] resultByteArray = messageDigest.digest();</span><br><span class="line"><span class="comment">//            字符数组转换成字符串返回</span></span><br><span class="line">            <span class="keyword">return</span> byteArrayToHex(resultByteArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    将字节数组换成成16进制的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">byteArrayToHex</span><span class="params">(<span class="type">byte</span>[] byteArray)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        首先初始化一个字符数组，用来存放每个16进制字符</span></span><br><span class="line">        <span class="type">char</span>[] hexDigits = &#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））</span></span><br><span class="line">        <span class="type">char</span>[] resultCharArray =<span class="keyword">new</span> <span class="title class_">char</span>[byteArray.length * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : byteArray) &#123;</span><br><span class="line">            resultCharArray[index++] = hexDigits[b&gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">            resultCharArray[index++] = hexDigits[b&amp; <span class="number">0xf</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        字符数组组合成字符串返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(resultCharArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MD5Util</span> <span class="variable">md5Util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MD5Util</span>();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">in</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> md5Util.stringMD5(in);</span><br><span class="line">            System.out.println(<span class="string">&quot;加密前：&quot;</span> + in);</span><br><span class="line">            System.out.println(<span class="string">&quot;加密后：&quot;</span> + value + <span class="string">&quot;，长度：&quot;</span> + value.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果图：</strong><br><img src="https://img-blog.csdnimg.cn/20210608093502559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码出自<a href="https://www.cnblogs.com/hihtml5/p/6064999.html">https://www.cnblogs.com/hihtml5/p/6064999.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MD5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 1.12.4 TaskManager 的内存调优（standalone 模式）</title>
      <link href="/2021/06/06/flink_10/"/>
      <url>/2021/06/06/flink_10/</url>
      
        <content type="html"><![CDATA[<p>这篇博客是对上篇<a href="https://blog.csdn.net/weixin_44758876/article/details/117448806">《基于Flink&amp;Kafka完成的流式模块》</a>的补充，在上一篇里已经做了很多优化以及详细的注释，这里要补充一下内存方面的优化。<br><strong>因为在生产环境中实际部署之前，还是没有考虑到同时消费多个topic记录的偏移量是很大的，同时模拟的数据量并没有达到实际生产环境的数据量，所以在部署的时候因为TaskManager内存不足，一直处理内存中的数据导致没有及时发送心跳让JobManager以为TaskManager已经挂掉（实际上后来确实是会挂掉），所以就针对内存方面进行了优化。</strong></p><ol><li><strong>我们可以通过修改 flink-conf.yaml 文件，调整TaskManager的最大内存，我这里是改成了4个g</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定TaskManager进程的总内存</span><br><span class="line">taskmanager.memory.process.size: 4096m</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>当然如果我们需要确定自己的内存时，可以通过下面两个参数来指定（我采用的就是这种方式），注意这个不能和上面的方法同时指定</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 指定JVM堆内存大小</span><br><span class="line">taskmanager.memory.task.heap.size: 2048m</span><br><span class="line"># 指定JVM托管内存大小</span><br><span class="line">taskmanager.memory.managed.size: 512m</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>也可以通过下面的参数指定内存大小，第一种和这种方式属于比较简单的，第二种就需要了解自己环境数据的具体生产量来设置了</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定Flink总内存</span><br><span class="line">taskmanager.memory.flink.size</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Error while executing topic command : Replication factor: 2 larger than available brokers: 1</title>
      <link href="/2021/06/03/kafka_2/"/>
      <url>/2021/06/03/kafka_2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210603140034820.png" alt="在这里插入图片描述"><br><strong>创建topic时报错，是因为topic副本数不能超过服务器个数，我用的是单节点kafka，所以这里把命令改成<font color=red>–replication-factor 1</font>即可</strong></p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> Bug记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 1.12.4 Standalone 模式部署</title>
      <link href="/2021/06/03/flink_9/"/>
      <url>/2021/06/03/flink_9/</url>
      
        <content type="html"><![CDATA[<ol><li>这里用三台机器测试，需要jdk1.8支持，没有的可以自己去下载安装，我就不放教程了</li><li>准备好安装包，官网下载地址：<br><a href="https://flink.apache.org/zh/downloads.html">https://flink.apache.org/zh/downloads.html</a></li><li>依次上传到服务器上<br><img src="https://img-blog.csdnimg.cn/20210603115754832.png" alt="在这里插入图片描述"></li><li>解压</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf flink-1.12.4-bin-scala_2.12.tgz</span><br></pre></td></tr></table></figure><ol start="5"><li>依次修改conf目录下的flink-conf.yaml文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobmanager.rpc.address: 主节点ip（JobManager）</span><br></pre></td></tr></table></figure><ol start="6"><li>修改conf下的masters</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主节点ip:8081</span><br></pre></td></tr></table></figure><ol start="7"><li>修改conf下的workers</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从节点ip</span><br><span class="line">从节点ip</span><br></pre></td></tr></table></figure><ol start="8"><li>在主节点上启动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/start-cluster.sh</span><br></pre></td></tr></table></figure><ol start="9"><li>登录web界面，可以看到到这里就安装成功了<br><img src="https://img-blog.csdnimg.cn/20210603132748156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 集群部署教程</title>
      <link href="/2021/06/03/kafka_1/"/>
      <url>/2021/06/03/kafka_1/</url>
      
        <content type="html"><![CDATA[<ol><li>Kafka部署需要Java环境，可以使用CentOS自带的或者自己重新安装新版本</li><li>首先准备好安装包，官网下载地址：<br><a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a></li><li>我这里下载的2.8.0的版本，目前为止最新的版本，一共三台服务器，依次上传上去并解压</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kafka_2.12-2.8.0.tgz</span><br></pre></td></tr></table></figure><ol start="4"><li>解压之后，可以看到下面的内容<br><img src="https://img-blog.csdnimg.cn/20210603110026267.png" alt="在这里插入图片描述"></li><li>然后先建立zookeeper集群，我这里使用的是kafka自带的，修改config目录下的zookeeper.properties文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#自定义的zookeeper数据目录</span><br><span class="line">dataDir=/opt/module/kafka_2.12-2.8.0/zkdata</span><br><span class="line">#端口</span><br><span class="line">clientPort=2181</span><br><span class="line">maxClientCnxns=10</span><br><span class="line">#zk的基本时间单元，毫秒</span><br><span class="line">tickTime=2000</span><br><span class="line">#Leader-Follower初始通信时限 tickTime*10</span><br><span class="line">initLimit=10</span><br><span class="line">#Leader-Follower同步通信时限 tickTime*5</span><br><span class="line">syncLimit=5</span><br><span class="line">#自定义的zookeeper日志目录</span><br><span class="line">dataLogDir=/opt/module/kafka_2.12-2.8.0/zklog</span><br><span class="line">admin.enableServer=false</span><br><span class="line">#broker Id的服务地址</span><br><span class="line">server.1=192.168.44.131:2888:3888</span><br><span class="line">server.2=192.168.44.132:2888:3888</span><br><span class="line">server.3=192.168.44.133:2888:3888</span><br></pre></td></tr></table></figure><ol start="6"><li>创建数据目录及日志目录对应文件夹</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir zkdata</span><br><span class="line">mkdir zklog</span><br></pre></td></tr></table></figure><ol start="7"><li>在zookeeper数据目录下添加myid文件（内容需和zookeeper.properties文件中的server.x一致）<br><img src="https://img-blog.csdnimg.cn/20210603111649868.png" alt="在这里插入图片描述"></li><li>依次修改kafka配置，config下的server.properties文件（<a href="http://xn--broker-9e4jn0gt3hnr2c06kvr8j.id">每台服务器除broker.id</a> 和 本机ip 两个属性需要修改之外，其他属性保持一致）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># broker 的全局唯一编号，不能重复</span><br><span class="line">broker.id=1</span><br><span class="line"># 配置监听,修改为本机ip</span><br><span class="line">listeners=PLAINTEXT://192.168.44.131:9092</span><br><span class="line"># 处理网络请求的线程数量，默认</span><br><span class="line">num.network.threads=3</span><br><span class="line"># 处理磁盘IO的线程数量，默认</span><br><span class="line">num.io.threads=8</span><br><span class="line"># 发送套接字的缓冲区大小，默认</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line"># 接收套接字的缓冲区大小，默认</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line"># 请求套接字的缓冲区大小，默认</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line"># kafka 运行日志存放路径</span><br><span class="line">log.dirs=/opt/module/kafka_2.12-2.8.0/kafka</span><br><span class="line"># topic 在当前broker上的分片个数，与broker保持一致</span><br><span class="line">num.partitions=1</span><br><span class="line"># 允许删除topic</span><br><span class="line">delete.topic.enable=true</span><br><span class="line"># 用来恢复和清理data下数据的线程数量，默认</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=1</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line"># segment文件保留的最长时间，超时将被删除，默认</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line"># 配置三台服务zookeeper连接地址</span><br><span class="line">zookeeper.connect=192.168.44.131:2181,192.168.44.132:2181,192.168.44.133:2181</span><br><span class="line">zookeeper.connection.timeout.ms=30000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br></pre></td></tr></table></figure><ol start="9"><li>依次启动zookeeper</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><ol start="10"><li>依次启动kafka</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure><ol start="11"><li>启动成功使用jps命令，可以看到下面两个进程，到这里就安装完成了<br><img src="https://img-blog.csdnimg.cn/20210603113106801.png" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 实时消费多个 topic 数据</title>
      <link href="/2021/06/02/flink_8/"/>
      <url>/2021/06/02/flink_8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210427105014204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><br></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;10.7.2.20:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topics = <span class="keyword">new</span> util.<span class="type">LinkedList</span>[<span class="type">String</span>]</span><br><span class="line">    topics.add(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    topics.add(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    val stream = env.addSource(new FlinkKafkaConsumer[String](&quot;test&quot;, new SimpleStringSchema(), properties))</span></span><br><span class="line">    <span class="keyword">val</span> stream = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](topics, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">    stream.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>开启两个Kafka生产者，分别是test1、test2两个topic，输入测试数据：</strong><br><img src="https://img-blog.csdnimg.cn/2021060222212277.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210602222309857.png" alt="在这里插入图片描述"><br><br><br><strong>可以看到数据都打印在控制台了：</strong><br><br><br><img src="https://img-blog.csdnimg.cn/20210602222432373.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 查看 CPU 信息、使用率、核数、操作系统、内存使用率、磁盘空间</title>
      <link href="/2021/06/02/linux_2/"/>
      <url>/2021/06/02/linux_2/</url>
      
        <content type="html"><![CDATA[<h1 id="查看CPU信息、使用率、核数">查看CPU信息、使用率、核数</h1><ol><li><strong>查看物理CPU个数</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>查看逻辑CPU个数</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;processor&quot;| wc –l</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>每个物理CPU的核数</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>也可以直接通过 lscpu 命令查看</strong><br><img src="https://img-blog.csdnimg.cn/20210602115655940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这是两个CPU，20核，支持超线程，40个逻辑CPU</p></li><li><p><strong>查看是否支持超线程<br>如果&quot;siblings&quot;和&quot;cpu cores&quot;一致，则说明不支持超线程，或者超线程未打开；<br>如果&quot;siblings&quot;是&quot;cpu cores&quot;的两倍，则说明支持超线程，并且超线程已打开</strong></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;sibling&quot;|uniq</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>查看逻辑CPU个数以及CPU型号</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure><ol start="7"><li><strong>查看CPU是32位运行还是64位运行</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>获取CPU详细信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><ol start="9"><li><strong>top 命令查看CPU使用率</strong><br><img src="https://img-blog.csdnimg.cn/20210602143004722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">第一行（top）</span><br><span class="line">13:44:03 ： 系统当前时间</span><br><span class="line">68 days, 20:13 ： 系统从启动后到现在的运作时间</span><br><span class="line">7 users ： 当前登录到系统的用户数（确切的说是登录到用户的终端数，同一个用户同一时间对系统多个终端的连接将被视为多个用户连接到系统，这里的用户数也将表现为终端的数目）</span><br><span class="line">load average ： 当前系统负载的平均值，后面的三个值分别为1分钟前、5分钟前、15分钟前进程的平均数，一般的可以认为这个数值超过 CPU 数目时，CPU 将比较吃力的负载当前系统所包含的进程</span><br><span class="line">第二行（Tasks）</span><br><span class="line">550 total ： 当前系统进程总数</span><br><span class="line">2 running ： 当前运行中的进程数</span><br><span class="line">557 sleeping ： 当前处于等待状态中的进程数</span><br><span class="line">0 stopped ： 停止的进程数</span><br><span class="line">0 zombie ： 僵尸进程数</span><br><span class="line">第三行（%Cpu）</span><br><span class="line">8.1 us ： 用户空间占用CPU百分比，不包含renice值为负的任务占用的CPU的时间</span><br><span class="line">1.2 sy ： 内核空间占用CPU百分比</span><br><span class="line">0.0 ni ： 用户进程空间内改变过优先级的进程占用CPU百分比</span><br><span class="line">90.4 id ： 空闲CPU百分比</span><br><span class="line">0.0 wa ： 等待I/O的CPU时间百分比</span><br><span class="line">0.0 hi ： CPU硬中断时间百分比</span><br><span class="line">0.2 si ： CPU软中断时间百分比</span><br><span class="line">第四行（Mem）</span><br><span class="line">26403968+total ： 物理内存总量</span><br><span class="line">24978953+used ： 使用的物理内存量</span><br><span class="line">14250160 free ： 空闲的物理内存量</span><br><span class="line">817276 buffers ： 用作内核缓存的物理内存量</span><br><span class="line">第五行（反映着交换分区（Swap）的使用情况，通常，交换分区被频繁使用的情况，将被视作物理内存不足而造成的）</span><br><span class="line">0 total ： 交换区总量</span><br><span class="line">0 used ： 使用的交换区总量</span><br><span class="line">0 free ： 空闲交换区总量</span><br><span class="line">20137419+cached ： 缓冲的交换区总量</span><br><span class="line">进程信息：</span><br><span class="line">PID ： 进程的ID</span><br><span class="line">USER ： 进程的所有者</span><br><span class="line">PR ： 进程的优先级别，越小越优先被执行</span><br><span class="line">NI ： 值</span><br><span class="line">VIRT ： 进程占用的虚拟内存</span><br><span class="line">RES ： 进程占用的物理内存</span><br><span class="line">SHR ： 进程使用的共享内存</span><br><span class="line">S ： 进程的状态；S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数</span><br><span class="line">%CPU ： 进程占用CPU的使用率</span><br><span class="line">%MEN ： 进程使用的物理内存和总内存的百分比</span><br><span class="line">TIME+ ： 该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值</span><br><span class="line">COMMAND ： 进程启动命令名称</span><br><span class="line">top 运行中可以通过 top 的内部命令对进程的显示方式进行控制：</span><br><span class="line">s改变画面更新频率</span><br><span class="line">l关闭或开启第一部分第一行 top 信息的表示</span><br><span class="line">t关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示</span><br><span class="line">m关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示</span><br><span class="line">N以 PID 的大小的顺序排列表示进程列表</span><br><span class="line">P以 CPU 占用率大小的顺序排列进程列表</span><br><span class="line">M以内存占用率大小的顺序排列进程列表</span><br><span class="line">h显示帮助</span><br><span class="line">n设置在进程列表所显示进程的数量</span><br><span class="line">q退出 top</span><br><span class="line">s改变画面更新周期</span><br></pre></td></tr></table></figure><p><strong>总核数 = 物理CPU个数 X 每颗物理CPU的核数</strong><br><strong>总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数</strong></p><h1 id="查看操作系统信息">查看操作系统信息</h1><ol><li><strong>查看操作系统内核信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uname -a显示全部信息</span><br><span class="line">-m 或 --machine显示电脑类型</span><br><span class="line">-r 或 --release显示操作系统的发行编号</span><br><span class="line">-s 或 --sysname显示操作系统名称</span><br><span class="line">-v显示操作系统的版本</span><br><span class="line">-p 或 --processor输出处理器类型或&quot;unknown&quot;</span><br><span class="line">-i 或 --hardware-platform输出硬件平台或&quot;unknown&quot;</span><br><span class="line">-o 或 --operating-system输出操作系统名称</span><br><span class="line">-- help显示帮助</span><br><span class="line">-- version显示版本信息</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>查看操作系统版本</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/issue或cat /etc/centos-release或cat /etc/redhat-release</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>查看操作系统版本信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><h1 id="查看内存使用率">查看内存使用率</h1><ol><li><strong>查看内存详细信息</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>free 查看内存使用情况</strong><br><img src="https://img-blog.csdnimg.cn/20210602150519836.png" alt="在这里插入图片描述"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">total ： 总计物理内存的大小</span><br><span class="line">used ： 已使用内存大小</span><br><span class="line">free ： 可用内存大小</span><br><span class="line">Shared ： 多个进程共享的内存总额</span><br><span class="line">buffers/cached ： 被 buffer 和 cache 使用的物理内存大小</span><br><span class="line"></span><br><span class="line">free -b ： 以bytes为单位来显示内存的信息</span><br><span class="line">free -k ： 以kb为单位来显示内存的信息</span><br><span class="line">free -m ： 以m为单位来显示内存的信息</span><br><span class="line">free -g ： 以G为单位来显示内存的信息</span><br><span class="line">free -h ： 以适于人类可读方式显示内存信息。-h与其他命令最大不同是-h选项会在数字后面加上适于人类可读的单位</span><br><span class="line">free -l ： 显示高低内存的利用率</span><br><span class="line">free -t ： 显示linux的全部内存（如果我们需要每列的总计信息，我们可以在 free 命令后面跟上 -t 选项。这会在字底部额外加入一行显示）</span><br><span class="line">free -s N ： 表示每隔N秒打印一次内存信息，直到用ctrl+c结束</span><br><span class="line">free -c N ： 表示重复打印内存信息N次</span><br><span class="line">free -V ： 显示版本信息</span><br></pre></td></tr></table></figure><h1 id="查看磁盘空间">查看磁盘空间</h1><ol><li><strong>df 查看磁盘使用情况</strong><br><img src="https://img-blog.csdnimg.cn/20210602153116711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Filesystem ： 设备名称，代表该文件系统时哪个分区</span><br><span class="line">1K-blocks ： 总磁盘大小，下面的数字单位是1KB，可利用-h或-m来改变单位大小，也可以用-B来设置</span><br><span class="line">Used ： 已用磁盘大小</span><br><span class="line">Available ： 可用磁盘大小</span><br><span class="line">Use% ： 已用磁盘百分比</span><br><span class="line">Mounted on ： 磁盘挂载的目录，即该磁盘挂载到了哪个目录下面</span><br><span class="line"></span><br><span class="line">-a 或 --all ： 显示所有的文件系统，包括虚拟文件系统</span><br><span class="line">-B 或 --block-size ： 指定单位大小，比如1k，1m等</span><br><span class="line">-h 或 --human-readable ： 以人们易读的GB、MB、KB等格式显示</span><br><span class="line">-H 或 --si ： 和-h参数一样，但是不是以1024，而是1000，即1k=1000，而不是1k=1024</span><br><span class="line">-i 或 --inodes ： 不用硬盘容量，而是以inode的数量来显示</span><br><span class="line">-k ： 以KB的容量显示各文件系统，相当于--block-size=1k</span><br><span class="line">-m ： 以KB的容量显示各文件系统，相当于--block-size=1m</span><br><span class="line">-l ： --local，只显示本地文件系统</span><br><span class="line">--no-sync ： 在统计使用信息之前不调用sync命令(默认)</span><br><span class="line">-sync ： 在统计使用信息之前调用sync命令</span><br><span class="line">-P 或 --portability ： 使用POSIX格式显示，参考示例6</span><br><span class="line">-t 或 --type=TYPE ： 只显示指定类型的文件系统，参考示例7</span><br><span class="line">-T 或 --print-type ： 显示文件系统类型，参考示例8</span><br><span class="line">-x 或 --exclude-type=TYPE ： 不显示指定类型的文件系统</span><br><span class="line">--help ： 显示帮助信息</span><br><span class="line">--version ： 显示版本信息</span><br></pre></td></tr></table></figure><ol start="2"><li>指定一个文件夹，查看该文件夹所在磁盘的使用情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df /home</span><br></pre></td></tr></table></figure><ol start="3"><li>指定一个文件，查看该文件所在磁盘的使用情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df /bin/ls</span><br></pre></td></tr></table></figure><ol start="4"><li>指定多个文件或文件夹，查看所在磁盘的使用情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df /bin/ls /home</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>du 查看文件、目录所占磁盘容量</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [文件或目录名称] （默认情况下，只统计目录的容量大小）</span><br><span class="line">参数：</span><br><span class="line">-a 或 --all ：  列出所有的文件和目录容量大小而不仅仅列出目录容量大小，默认情况只是统计目录的容量大小</span><br><span class="line">-B 或 --block-size=SIZE ： 指定单位大小</span><br><span class="line">-b 或 --bytes ： 以字节为单位列出文件和目录的容量大小</span><br><span class="line">-c 或 --total ： 除了列出文件和目录的容量大小外，列出总的容量大小</span><br><span class="line">-h 或 --human-readable ： 以人们易读的方式(KB,MB,GB)显示容量大小</span><br><span class="line">--si ： 和-h参数类似，但是单位换算时是以1000进行换算，而不是1024</span><br><span class="line">-k ： 和--block-size=1k类似，以KB为单位</span><br><span class="line">-m ： 和--block-size=1m类似，以MB为单位</span><br><span class="line">-s 或 --summarize ： 仅列出总量，而不列出每个目录和文件的大小</span><br><span class="line">-S 或 --separate-dirs ： 和-s参数类似，但是统计时不包含子目录的容量大小</span><br><span class="line">--max-depth=N ： 类似于默认情况的du，但是，递归显示时的递归深度小于等于N。如果--max-depth=0，就相当于-s参数，只统计总量而已。如果--max-depth=1，就相当于du -s 目录/*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Flink &amp; Kafka 完成的流式模块</title>
      <link href="/2021/06/01/flink_7/"/>
      <url>/2021/06/01/flink_7/</url>
      
        <content type="html"><![CDATA[<p><strong>没错，这是基于下面几篇博客完成的功能：</strong><br><a href="https://blog.csdn.net/weixin_44758876/article/details/117447744">Flink基于MapState实时去重</a><br><a href="https://blog.csdn.net/weixin_44758876/article/details/117114785">Flink接收kafka source数据</a><br><a href="https://blog.csdn.net/weixin_44758876/article/details/117448373">Java通过UDP端口发送数据</a><br><strong>我也是在边开发边写博客呀（心累），这篇就是之前说的“flink对接kafka去重加细节优化”的博客，加入了优化部分，解决了kafka丢失数据的问题，当然UDP也会丢少量数据，大概不到千分之一吧，业务不允许的可以通过TCP发送，代码我也会加到下面。<br>等会看到那详细的注释你们就明白我有多细心了（嘿嘿），给个关注我就不心累了-。-</strong><br><strong>不多哔哔了，上代码：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.distinct</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.<span class="type">SocketUDPClient</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.restartstrategy.<span class="type">RestartStrategies</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.&#123;<span class="type">MapState</span>, <span class="type">MapStateDescriptor</span>, <span class="type">StateTtlConfig</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">KeyedProcessFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.runtime.state.filesystem.<span class="type">FsStateBackend</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">CheckpointingMode</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.<span class="type">CheckpointConfig</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.&#123;<span class="type">RichSinkFunction</span>, <span class="type">SinkFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Kafka2flink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="comment">//    开启CheckPointing</span></span><br><span class="line">    env.enableCheckpointing(<span class="number">100000</span>)</span><br><span class="line"><span class="comment">//    设置重启，出现异常重启3次，隔5秒一次（默认固定延迟无限重启）</span></span><br><span class="line">    env.getConfig.setRestartStrategy(<span class="type">RestartStrategies</span>.fixedDelayRestart(<span class="number">2</span>, <span class="type">Time</span>.seconds(<span class="number">2</span>)))</span><br><span class="line"><span class="comment">//    checkpoint最小间隔（确保检查点之间有至少1000 ms的间隔）</span></span><br><span class="line">    env.getCheckpointConfig.setMinPauseBetweenCheckpoints(<span class="number">1000</span>)</span><br><span class="line"><span class="comment">//    checkpoint的超时时间（检查点必须在2分钟内完成，否则被丢弃）</span></span><br><span class="line">    env.getCheckpointConfig.setCheckpointTimeout(<span class="number">120000</span>)</span><br><span class="line"><span class="comment">//    同一时间只允许进行一个检查点</span></span><br><span class="line">    env.getCheckpointConfig.setMaxConcurrentCheckpoints(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//    设置statebackend</span></span><br><span class="line">    <span class="keyword">val</span> stateBackend = <span class="keyword">new</span> <span class="type">FsStateBackend</span>(<span class="string">&quot;file:///ssd/flink2kafka/flink-1.12.4/data&quot;</span>)</span><br><span class="line">    env.setStateBackend(stateBackend)</span><br><span class="line"><span class="comment">//    一旦Flink处理程序被cancel后，会保留Checkpoint数据，以便根据实际需要恢复到指定的Checkpoint</span></span><br><span class="line">    env.getCheckpointConfig.enableExternalizedCheckpoints(<span class="type">CheckpointConfig</span>.<span class="type">ExternalizedCheckpointCleanup</span>.<span class="type">RETAIN_ON_CANCELLATION</span>)</span><br><span class="line"><span class="comment">//    设置Checkpoint模式（与kafka整合，设置Checkpoint模式为exactly-once）</span></span><br><span class="line">    env.getCheckpointConfig.setCheckpointingMode(<span class="type">CheckpointingMode</span>.<span class="type">EXACTLY_ONCE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Kafka props</span></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line"><span class="comment">//    指定Kafka的Broker地址</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;10.7.2.20:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Checkpoint成功后，还会向Kafka特殊的topic中写偏移量（此处不建议改为false）</span></span><br><span class="line"><span class="comment">//    设置为false后，则不会向特殊topic中写偏移量</span></span><br><span class="line"><span class="comment">//    KafkaSource.setCommitOffsetsOnCheckpoints(false)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    创建Kafka DataStream        setStartFromGroupOffsets():从上次消费位点开始消费</span></span><br><span class="line">    <span class="keyword">val</span> stream = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties).setStartFromGroupOffsets())</span><br><span class="line"></span><br><span class="line"><span class="comment">//    val stream: DataStream[String] = env.socketTextStream(&quot;10.7.2.20&quot;, 9999)</span></span><br><span class="line">    <span class="keyword">val</span> streamdata = stream.map(x =&gt; &#123;</span><br><span class="line">      (x, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">      .keyBy(_._1)</span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">Deduplicator</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">//    streamdata</span></span><br><span class="line"><span class="comment">//      .print()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    通过TCP端口发送到第三方</span></span><br><span class="line">    streamdata.map(data =&gt; &#123;data + <span class="string">&quot;\n&quot;</span>&#125;).writeToSocket(<span class="string">&quot;10.7.2.21&quot;</span>, <span class="number">6666</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>())</span><br><span class="line"><span class="comment">//    自定义sink 通过UDP端口发送到第三方</span></span><br><span class="line"><span class="comment">//    streamdata.addSink(new udpSink())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">udpSink</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>[<span class="type">String</span>](<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> socketUDPClient: <span class="type">SocketUDPClient</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    socketUDPClient = <span class="keyword">new</span> <span class="type">SocketUDPClient</span>(<span class="string">&quot;10.7.2.21&quot;</span>, <span class="number">6666</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invoke</span></span>(value: <span class="type">String</span>, context: <span class="type">SinkFunction</span>.<span class="type">Context</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    socketUDPClient.send(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    socketUDPClient.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deduplicator</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>[<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>](<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> state: <span class="type">MapState</span>[<span class="type">String</span>, <span class="type">String</span>] = _</span><br><span class="line">  <span class="keyword">val</span> dec = <span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;state&quot;</span>, classOf[<span class="type">String</span>], classOf[<span class="type">String</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ttlConfig = <span class="type">StateTtlConfig</span></span><br><span class="line">      .newBuilder(<span class="type">Time</span>.seconds(<span class="number">3</span>)) <span class="comment">//这是state存活时间10s</span></span><br><span class="line">      .setUpdateType(<span class="type">StateTtlConfig</span>.<span class="type">UpdateType</span>.<span class="type">OnReadAndWrite</span>)<span class="comment">//设置过期时间更新方式</span></span><br><span class="line">      .setStateVisibility(<span class="type">StateTtlConfig</span>.<span class="type">StateVisibility</span>.<span class="type">NeverReturnExpired</span>)<span class="comment">//永远不要返回过期的状态</span></span><br><span class="line"><span class="comment">//      .cleanupInRocksdbCompactFilter(5)//处理完1000个状态查询时候，会启用一次CompactFilter</span></span><br><span class="line">      .build</span><br><span class="line">    dec.enableTimeToLive(ttlConfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> context = getRuntimeContext</span><br><span class="line">    context.getMapState(dec)</span><br><span class="line">    state = context.getMapState(<span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;state&quot;</span>, classOf[<span class="type">String</span>], classOf[<span class="type">String</span>]))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(i: (<span class="type">String</span>, <span class="type">String</span>), context: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>]#<span class="type">Context</span>, collector: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.contains(i._1)) &#123;</span><br><span class="line">      state.put(i._1, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      state.put(i._1, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">      collector.collect(i._1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这是UDP发送的工具类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketUDPClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketUDPClient</span><span class="params">(String ip, <span class="type">int</span> port)</span> <span class="keyword">throws</span> UnknownHostException, SocketException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ip = InetAddress.getByName(ip);</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line"><span class="comment">//        创建一个UDP套接字，与本地任意一个未使用的UDP端口绑定</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"><span class="comment">//        与本地一个固定的UDP端口绑定</span></span><br><span class="line"><span class="comment">//        socket=new DatagramSocket(9000);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String data)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先准备一个待发送的数据报</span></span><br><span class="line">            <span class="type">byte</span>[] outputData=data.getBytes();</span><br><span class="line">            <span class="comment">//构建一个数据报文。</span></span><br><span class="line">            DatagramPacket outputPacket=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(outputData, outputData.length, ip, port);</span><br><span class="line">            <span class="comment">//给EchoUDPServer发送数据报</span></span><br><span class="line">            socket.send(outputPacket);  <span class="comment">//给EchoUDPServer发送数据报</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)</span><br><span class="line">            socket.close();<span class="comment">//释放本地端口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>哦对，还有pom文件（我可真细心）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink2kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.12.4<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- flink连接器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该插件用于将Scala代码编译成class文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 声明绑定到maven的compile阶段 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><br><p><em>喜欢的小伙伴给个关注吧~~~</em></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 通过 UDP 端口发送数据</title>
      <link href="/2021/06/01/java_1/"/>
      <url>/2021/06/01/java_1/</url>
      
        <content type="html"><![CDATA[<p><strong>其实我是因为flink没有封装好的sink，所以自定义了sink来调用这个类。。。。。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketUDPClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketUDPClient</span><span class="params">(String ip, <span class="type">int</span> port)</span> <span class="keyword">throws</span> UnknownHostException, SocketException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ip = InetAddress.getByName(ip);</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line"><span class="comment">//        创建一个UDP套接字，与本地任意一个未使用的UDP端口绑定</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"><span class="comment">//        与本地一个固定的UDP端口绑定</span></span><br><span class="line"><span class="comment">//        socket=new DatagramSocket(9000);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String data)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先准备一个待发送的数据报</span></span><br><span class="line">            <span class="type">byte</span>[] outputData=data.getBytes();</span><br><span class="line">            <span class="comment">//构建一个数据报文。</span></span><br><span class="line">            DatagramPacket outputPacket=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(outputData, outputData.length, ip, port);</span><br><span class="line">            <span class="comment">//给EchoUDPServer发送数据报</span></span><br><span class="line">            socket.send(outputPacket);  <span class="comment">//给EchoUDPServer发送数据报</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>)</span><br><span class="line">            socket.close();<span class="comment">//释放本地端口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法变量都是封装好的，直接调用完事</strong></p><br>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 基于 MapState 实时去重</title>
      <link href="/2021/06/01/flink_6/"/>
      <url>/2021/06/01/flink_6/</url>
      
        <content type="html"><![CDATA[<p><strong>我这里的业务背景比较复杂，数据是非结构化的且类型很多，更致命的是数据没有唯一ID字段！！！所以只能基于整条数据去分区去重，本来打算用布隆过滤器来实现，可是布隆过滤器的误判太搞人了，业务不允许，所以还是用MapState来做，这里去掉了flink优化的代码，便于学习和观看，后面我会写一个flink对接kafka去重加细节优化的博客，感兴趣的可以给个关注。</strong><br><img src="https://img-blog.csdnimg.cn/20210427105014204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">flinkMapState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    </span><br><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;10.7.2.20&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="keyword">val</span> streamdata = stream.map(x =&gt; &#123;</span><br><span class="line">      (x, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">      .keyBy(_._1)</span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">Deduplicator</span>())</span><br><span class="line">      </span><br><span class="line">    streamdata</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deduplicator</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>[<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>](<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state: <span class="type">MapState</span>[<span class="type">String</span>, <span class="type">String</span>] = _</span><br><span class="line">  <span class="keyword">val</span> dec = <span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;state&quot;</span>, classOf[<span class="type">String</span>], classOf[<span class="type">String</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> ttlConfig = <span class="type">StateTtlConfig</span></span><br><span class="line">      .newBuilder(<span class="type">Time</span>.seconds(<span class="number">3</span>)) <span class="comment">//这是state存活时间10s</span></span><br><span class="line">      .setUpdateType(<span class="type">StateTtlConfig</span>.<span class="type">UpdateType</span>.<span class="type">OnReadAndWrite</span>)<span class="comment">//设置过期时间更新方式</span></span><br><span class="line">      .setStateVisibility(<span class="type">StateTtlConfig</span>.<span class="type">StateVisibility</span>.<span class="type">NeverReturnExpired</span>)<span class="comment">//永远不要返回过期的状态</span></span><br><span class="line"><span class="comment">//      .cleanupInRocksdbCompactFilter(5)//处理完1000个状态查询时候，会启用一次CompactFilter</span></span><br><span class="line">      .build</span><br><span class="line">    dec.enableTimeToLive(ttlConfig)</span><br><span class="line">    <span class="keyword">val</span> context = getRuntimeContext</span><br><span class="line">    context.getMapState(dec)</span><br><span class="line">    state = context.getMapState(<span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;state&quot;</span>, classOf[<span class="type">String</span>], classOf[<span class="type">String</span>]))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(i: (<span class="type">String</span>, <span class="type">String</span>), context: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>), <span class="type">String</span>]#<span class="type">Context</span>, collector: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.contains(i._1)) &#123;</span><br><span class="line">      state.put(i._1, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      state.put(i._1, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">      collector.collect(i._1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果图我就不放了，这代码我已经跑了N+1次了，如果你们运行不动的话，，，，，，那就是你们的问题了哈哈</strong></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 提交任务的两种方式（非 flink on yarn）</title>
      <link href="/2021/06/01/flink_5/"/>
      <url>/2021/06/01/flink_5/</url>
      
        <content type="html"><![CDATA[<p>@<a href="%E7%9B%AE%E5%BD%95">TOC</a></p><h1 id="程序打包">程序打包</h1><ol><li><strong>先在pom里加上插件</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该插件用于将Scala代码编译成class文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 声明绑定到maven的compile阶段 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>按照下面的步骤把程序打包即可</strong><br><img src="https://img-blog.csdnimg.cn/20210529215625732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>到上面的路径下找到自己的包即可</strong><br><img src="https://img-blog.csdnimg.cn/20210529215810563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h1 id="web页面提交">web页面提交</h1><ol><li><strong>到自己的flink web页面，按照下面的步骤依次点击上传自己的程序包</strong><br><img src="https://img-blog.csdnimg.cn/20210529220032675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>再按照下面的步骤提交jar包</strong><br><img src="https://img-blog.csdnimg.cn/20210529222215770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>提交成功之后就会出现下面的页面</strong><br><img src="https://img-blog.csdnimg.cn/20210601165502645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h1 id="命令行提交">命令行提交</h1><p><strong>命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run -m master:8081 -p 4 -c [全类名] [jar包所在路径] --[属性名] 属性值</span><br></pre></td></tr></table></figure><p><strong>命令参数说明：</strong></p><ul><li><strong>-m</strong><ul><li>指定主机名后面的端口为JobManager的 rest 通信端口，而不是 RPC 的端口，RPC通信端口是6123（在提交任务时，是通过 REST 端口号（HTTP端口号），将任务上传到JobManager）</li></ul></li><li><strong>-p</strong><ul><li>指定并行度（即使用几个Task Slots）</li></ul></li><li><strong>-c</strong><ul><li>指定main方法的全类名</li></ul></li><li><strong>-s</strong><ul><li>指定savePoint 的路径（用于任务重启时接上次操作继续进行，恢复数据使用）</li></ul></li><li><strong>–hostname XXX --port XXX</strong><ul><li>传入main方法的参数（以 – 属性名 属性值 的方式）</li></ul></li></ul><p><strong>提交成功之后，web页面会有正在运行的任务：</strong><br><img src="https://img-blog.csdnimg.cn/20210601170904773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><br><p><em>喜欢的小伙伴给个关注吧~~~</em></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之模拟生产环境发送数据到 Kafka</title>
      <link href="/2021/05/31/python_6/"/>
      <url>/2021/05/31/python_6/</url>
      
        <content type="html"><![CDATA[<p><strong>模拟生产环境的速率发送数据到Kafka，仅限于开发环境使用，可以测试平台对数据的吞吐量以及稳定性。</strong><br><strong>KafkaProducer需求下载安装特定库支持，windows开发环境直接cmd打开命令窗口，执行 pip install kafka-python 即可</strong><br>脚本代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个KafkaProducer示例，用于向Kafka投递消息</span></span><br><span class="line">producer = KafkaProducer(</span><br><span class="line">    value_serializer=<span class="keyword">lambda</span> v: json.dumps(v).encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">    bootstrap_servers=[<span class="string">&#x27;10.7.2.20:9092&#x27;</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment">#读取样例数据</span></span><br><span class="line">files = <span class="built_in">open</span>(<span class="string">&quot;样例数据文件的目录&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">content = files.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line">    index = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(content) - <span class="number">1</span>)</span><br><span class="line">    producer.send(<span class="string">&quot;test&quot;</span>, content[index])</span><br><span class="line"></span><br><span class="line">producer.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 在 Linux 上单机部署教程</title>
      <link href="/2021/05/29/flink_4/"/>
      <url>/2021/05/29/flink_4/</url>
      
        <content type="html"><![CDATA[<ol><li><strong>首先需要JDK1.8版本以上的支持，我这里就不放教程了</strong></li><li><strong>先去官网下载flink安装包，官网地址：</strong><br><a href="https://flink.apache.org/zh/downloads.html">https://flink.apache.org/zh/downloads.html</a><br><strong>我这里下载的是flink-1.12.4，scala2.12的版本，不同需求可以下载不同版本，安装步骤都一样</strong></li><li><strong>把包上传到服务器目录下</strong><br><img src="https://img-blog.csdnimg.cn/2021052921251886.png" alt="在这里插入图片描述"></li><li><strong>使用下面的命令解压</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf flink-1.12.4-bin-scala_2.12.tgz</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>然后进入解压后的flink目录下，用下面的命令执行启动脚本</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/start-cluster.sh</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>到这flink就安装完成了，可以通过jps命令查看是否有 TaskManagerRunner 及 StandaloneSessionClusterEntrypoint 这两个进程，有的话就说明启动成功</strong></li><li><strong>flink默认的web访问端口是8081，可以通过浏览器访问flink的 web UI</strong><br><img src="https://img-blog.csdnimg.cn/2021052921335624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode because</title>
      <link href="/2021/05/25/redis_2/"/>
      <url>/2021/05/25/redis_2/</url>
      
        <content type="html"><![CDATA[<p><strong>今天在测试时redis报错：</strong><br>redis.clients.jedis.exceptions.JedisDataException:拒绝redis在保护模式下运行，因为已启用保护模式，未指定绑定地址，未向客户端请求身份验证密码。在这种模式下，只接受来自环回接口的连接。如果您想从外部计算机连接到Redis，您可以采用以下解决方案之一：1）通过从服务器运行的同一主机连接到Redis，只需禁用保护模式，从环回接口发送命令’CONFIG SET protected mode no’，不过，如果你这样做的话，请确保Redis不能从互联网上公开访问。使用CONFIG REWRITE将此更改永久化。2） 或者，您可以通过编辑Redis配置文件，将protectedmode选项设置为no，然后重新启动服务器来禁用protectedmode。3） 如果只是为了测试而手动启动服务器，请使用“-protected mode no”选项重新启动服务器。4） 设置绑定地址或身份验证密码。注意：您只需要执行上述操作之一，服务器就可以开始接受来自外部的连接。</p><p><strong>解决方法：</strong></p><ol><li>修改redis配置文件(redis.conf)</li><li>将protected-mode yes改为protected-mode no<br><img src="https://img-blog.csdnimg.cn/2021052515201035.png" alt="在这里插入图片描述"></li><li>重启redis即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug记录 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6.2.3 安装教程</title>
      <link href="/2021/05/25/redis_1/"/>
      <url>/2021/05/25/redis_1/</url>
      
        <content type="html"><![CDATA[<ol><li>首先在redis官网下载软件包，网址如下：<br><a href="https://redis.io/download">https://redis.io/download</a><br><img src="https://img-blog.csdnimg.cn/20210525112604963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>下载后将包上传到Linux<br><img src="https://img-blog.csdnimg.cn/20210525112816978.png" alt="在这里插入图片描述"></li><li>tar -zxvf redis-6.2.3.tar.gz 解压后并进入解压后的目录<br><img src="https://img-blog.csdnimg.cn/20210525113026292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>使用make命令编译软件<br><img src="https://img-blog.csdnimg.cn/20210525113149934.png" alt="在这里插入图片描述"></li><li>报错是因为缺少部分依赖包<img src="https://img-blog.csdnimg.cn/20210525113341511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>依次执行下面的命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">yum -y  install tcl</span><br><span class="line">yum -y  install kernel-headers</span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line">echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure><ol start="7"><li>清理make</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make distclean</span><br></pre></td></tr></table></figure><ol start="8"><li>再依次执行下面的命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install PREFIX=你想安装的目录</span><br></pre></td></tr></table></figure><ol start="9"><li>然后复制redis.conf到自己的安装目录下</li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf 你的redis安装目录</span><br></pre></td></tr></table></figure><ol start="10"><li>添加环境变量</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#profile文件最后追加：</span><br><span class="line">export REDIS_HOME=你的redis安装目录</span><br><span class="line">export PATH=$PATH:$REDIS_HOME/bin</span><br></pre></td></tr></table></figure><ol start="11"><li>使环境变量生效</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><strong>到这里redis就安装完成了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 发送数据到 Kafka sink</title>
      <link href="/2021/05/21/flink_3/"/>
      <url>/2021/05/21/flink_3/</url>
      
        <content type="html"><![CDATA[<p><strong>前期准备好kafka环境，我这里是1.12.0版本的Flink，Kafka对应版本官方推荐2.4.1，Scala版本2.12，demo里用的是socket文本流做数据源</strong></p><ol><li>在kafka目录下启动zookeeper（我这里用的是kafka自带的）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><ol start="2"><li>启动kafka</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure><ol start="3"><li>开启socket文本流</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lk 9999</span><br></pre></td></tr></table></figure><ol start="4"><li>消费kafka指定topic消息，确认数据是否正常</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server IP:9092 --topic test</span><br></pre></td></tr></table></figure><ol start="5"><li>别忘了添加Kafka连接器依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>上代码</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">DataStream</span>, <span class="type">StreamExecutionEnvironment</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaProducer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaSink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收socket 文本流</span></span><br><span class="line">    <span class="keyword">val</span> textDstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;开启socket服务器的IP&quot;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">    textDstream.addSink(<span class="keyword">new</span> <span class="type">FlinkKafkaProducer</span>[<span class="type">String</span>](<span class="string">&quot;KafkaIP:9092&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>()))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Kafka sink&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>在开启的socket服务中输入测试数据，查看已开启的Kafka消费者窗口是否有测试数据过来</li></ol><br><p><em>喜欢的小伙伴留下你的足迹吧~~~</em></p>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink 接收 kafka source 数据</title>
      <link href="/2021/05/21/flink_2/"/>
      <url>/2021/05/21/flink_2/</url>
      
        <content type="html"><![CDATA[<p><strong>前期准备好kafka环境，我这里是1.12.0版本的Flink，Kafka对应版本官方推荐2.4.1，Scala版本2.12</strong></p><ol><li>在kafka目录下启动zookeeper（我这里用的是kafka自带的）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><ol start="2"><li>启动kafka</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure><ol start="3"><li>别忘了添加Kafka连接器依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>上代码</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流处理环境</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;IP:9092&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;topic名称&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">    stream.print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动executor，执行任务</span></span><br><span class="line">    env.execute(<span class="string">&quot;Kafka Source&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>开启生产者控制台打印数据测试</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list IP:9092 -topic test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> 大数据 </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink：从入门到放弃</title>
      <link href="/2021/05/19/flink_1/"/>
      <url>/2021/05/19/flink_1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Flink简介">一、Flink简介</h1><p><strong>Apache Flink 是一个<font color=red>框架</font>和<font color=red>分布式</font>处理引擎，用于对<font color=red>无界</font>和<font color=red>有界数据流</font>进行<font color=red>状态</font>计算。</strong></p><h2 id="1-Flink组件栈">1. Flink组件栈</h2><p>每一层所包含的组件都提供了特定的抽象，用来服务于上层组件：<br><img src="https://img-blog.csdnimg.cn/20210416153047694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>物理部署层：</strong> Flink 支持本地运行、能在独立集群或者在被 YARN 管理的集群上运行， 也能部署在云上，该层主要涉及Flink的部署模式，目前Flink支持多种部署模式：本地、集群(Standalone、YARN)、云(GCE/EC2)、Kubenetes。Flink能够通过该层能够支持不同平台的部署，用户可以根据需要选择使用对应的部署模式。<br><strong>Runtime核心层：</strong> Runtime层提供了支持Flink计算的全部核心实现，为上层API层提供基础服务，该层主要负责对上层不同接口提供基础服务，也是Flink分布式计算框架的核心实现层，支持分布式Stream作业的执行、JobGraph到ExecutionGraph的映射转换、任务调度等。将DataSteam和DataSet转成统一的可执行的Task Operator，达到在流式引擎下同时处理批量计算和流式计算的目的。<br><strong>API&amp;Libraries层：</strong> Flink 首先支持了 Scala 和 Java 的 API，Python 也正在测试中。DataStream、DataSet、Table、SQL API，作为分布式数据处理框架，Flink同时提供了支撑计算和批计算的接口，两者都提供给用户丰富的数据处理高级API，例如Map、FlatMap操作等，也提供比较低级的Process Function API，用户可以直接操作状态和时间等底层数据。<br><strong>扩展库：</strong> Flink 还包括用于复杂事件处理的CEP，机器学习库FlinkML，图处理库Gelly等。Table 是一种接口化的 SQL 支持，也就是 API 支持(DSL)，而不是文本化的SQL 解析和执行。</p><h2 id="2-Flink基石">2. Flink基石</h2><p><img src="https://img-blog.csdnimg.cn/20210416160638126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>Checkpoint</strong><ul><li>Flink基于Chandy-Lamport算法实现了一个分布式的一致性的快照，从而提供了一致性的语义。</li></ul></li><li><strong>State</strong><ul><li>提供了一致性的语义之后，Flink为了让用户在编程时能够更轻松、更容易地去管理状态，还提供了一套非常简单明了的State API，包括里面的有ValueState、ListState、MapState，近期添加了BroadcastState，使用State API能够自动享受到这种一致性的语义。</li></ul></li><li><strong>Time</strong><ul><li>Flink还实现了Watermark的机制，能够支持基于事件的时间的处理，能够容忍迟到/乱序的数据。</li></ul></li><li><strong>Window</strong><ul><li>流计算中一般在对流数据进行操作之前都会先进行开窗，即基于一个什么样的窗口上做这个计算。Flink提供了开箱即用的各种窗口，比如滑动窗口、滚动窗口、会话窗口以及非常灵活的自定义的窗口。</li></ul></li></ul><h2 id="3-Fink的应用场景">3. Fink的应用场景</h2><h3 id="3-1-Event-driven-Applications【事件驱动】">3.1 Event-driven Applications【事件驱动】</h3><p><strong>事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。</strong> 比较典型的就是以 kafka 为代表的消息队列几乎都是事件驱动型应用。<br>事件驱动型应用是在计算存储分离的传统应用基础上进化而来。<br>在传统架构中，应用需要读写远程事务型数据库。<br>相反，事件驱动型应用是基于<strong>状态化流处理</strong>来完成。在该设计中，数据和计算不会分离，应用只需访问本地(内存或磁盘)即可获取数据。<br>系统容错性的实现依赖于定期向远程持久化存储写入 checkpoint。下图描述了传统应用和事件驱动型应用架构的区别。<br><img src="https://img-blog.csdnimg.cn/20210419161855636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从某种程度上来说，所有的实时的数据处理或者是流式数据处理都应该是属于Data Driven，流计算本质上是Data Driven 计算。应用较多的如风控系统，当风控系统需要处理各种各样复杂的规则时，Data Driven 就会把处理的规则和逻辑写入到Datastream 的API 或者是ProcessFunction 的API 中，然后将逻辑抽象到整个Flink 引擎，当外面的数据流或者是事件进入就会触发相应的规则，这就是Data Driven 的原理。在触发某些规则后，Data Driven 会进行处理或者是进行预警，这些预警会发到下游产生业务通知，这是Data Driven 的应用场景，Data Driven 在应用上更多应用于复杂事件的处理。</p><ul><li>典型实例：<ul><li>欺诈检测(Fraud detection)</li><li>异常检测(Anomaly detection)</li><li>基于规则的告警(Rule-based alerting)</li><li>业务流程监控(Business process monitoring)</li><li>Web应用程序(社交网络)<br><img src="https://img-blog.csdnimg.cn/20210419162232930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="3-2-Data-Analytics-Applications【数据分析】">3.2 Data Analytics Applications【数据分析】</h3><p><strong>数据分析任务需要从原始数据中提取有价值的信息和指标。</strong><br>如下图所示，Apache Flink 同时支持流式及批量分析应用。<br><img src="https://img-blog.csdnimg.cn/20210419162342556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Data Analytics Applications包含<strong>Batch analytics(批处理分析)</strong> 和<strong>Streaming analytics(流处理分析)</strong><br>Batch analytics可以理解为<strong>周期性查询</strong>：Batch Analytics 就是传统意义上使用类似于Map Reduce、Hive、Spark Batch 等，对作业进行分析、处理、生成离线报表。比如Flink应用凌晨从Recorded Events中读取昨天的数据，然后做周期查询运算，最后将数据写入Database或者HDFS，或者直接将数据生成报表供公司上层领导决策使用。<br>Streaming analytics可以理解为<strong>连续性查询</strong>：比如实时展示双十一天猫销售GMV(Gross Merchandise Volume成交总额)，用户下单数据需要实时写入消息队列，Flink 应用源源不断读取数据做实时计算，然后不断的将数据更新至Database或者K-VStore，最后做大屏实时展示。</p><ul><li>典型实例<ul><li>电信网络质量监控</li><li>移动应用中的产品更新及实验评估分析</li><li>消费者技术中的实时数据即席分析</li><li>大规模图分析</li></ul></li></ul><h3 id="3-3-Data-Pipeline-Applications【数据管道】">3.3 Data Pipeline Applications【数据管道】</h3><p>什么是数据管道？<br><strong>提取-转换-加载(ETL)是一种在存储系统之间进行数据转换和迁移的常用方法。</strong><br>ETL 作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库。<br>数据管道和 ETL 作业的用途相似，都可以转换、丰富数据，并将其从某个存储系统移动到另一个。<br>但数据管道是以<strong>持续流</strong>模式运行，而非周期性触发。<br>因此数据管道支持从一个不断生成数据的源头读取记录，并将它们以低延迟移动到终点。<br>例如：数据管道可以用来监控文件系统目录中的新文件，并将其数据写入事件日志；另一个应用可能会将事件流物化到数据库或增量构建和优化查询索引。<br>和周期性 ETL 作业相比，持续数据管道可以明显降低将数据移动到目的端的延迟。<br>此外，由于它能够持续消费和发送数据，因此用途更广，支持用例更多。<br>下图描述了周期性ETL作业和持续数据管道的差异。<br><img src="https://img-blog.csdnimg.cn/20210419162848396.png#pic_center" alt="在这里插入图片描述"><br><strong>Periodic ETL</strong>：比如每天凌晨周期性的启动一个Flink ETL Job，读取传统数据库中的数据，然后做ETL，最后写入数据库和文件系统。<br><strong>Data Pipeline</strong>：比如启动一个Flink 实时应用，数据源(比如数据库、Kafka)中的数据不断的通过Flink Data Pipeline流入或者追加到数据仓库(数据库或者文件系统)，或者Kafka消息队列。<br>Data Pipeline 的核心场景类似于数据搬运并在搬运的过程中进行部分数据清洗或者处理，而整个业务架构图的左边是Periodic ETL，它提供了流式ETL 或者实时ETL，能够订阅消息队列的消息并进行处理，清洗完成后实时写入到下游的Database或File system 中。</p><ul><li>典型实例<ul><li>电子商务中的持续 ETL(实时数仓)<ul><li>当下游要构建实时数仓时，上游则可能需要实时的Stream ETL。这个过程会进行实时清洗或扩展数据，清洗完成后写入到下游的实时数仓的整个链路中，可保证数据查询的时效性，形成实时数据采集、实时数据处理以及下游的实时Query。</li></ul></li><li>电子商务中的实时查询索引构建(搜索引擎推荐)<ul><li>搜索引擎这块以淘宝为例，当卖家上线新商品时，后台会实时产生消息流，该消息流经过Flink 系统时会进行数据的处理、扩展。然后将处理及扩展后的数据生成实时索引，写入到搜索引擎中。这样当淘宝卖家上线新商品时，能在秒级或者分钟级实现搜索引擎的搜索。</li></ul></li></ul></li></ul><h2 id="4-Flink的优点">4. Flink的优点</h2><p><img src="https://img-blog.csdnimg.cn/20210419164216526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>主要优点</strong><ul><li><font color=red>Flink 具备统一的框架处理有界和无界两种数据流的能力</font></li><li><font color=red>部署灵活，Flink 底层支持多种资源调度器</font>，包括Yarn、Kubernetes 等。Flink 自身带的Standalone 的调度器，在部署上也十分灵活</li><li><font color=red>极高的可伸缩性</font>，可伸缩性对于分布式系统十分重要，阿里巴巴双11大屏采用Flink 处理海量数据，使用过程中测得Flink 峰值可达17 亿条/秒。</li><li><font color=red>极致的流式处理性能</font>。Flink 相对于Storm 最大的特点是将状态语义完全抽象到框架中，支持本地状态读取，避免了大量网络IO，可以极大提升状态存取的性能。</li></ul></li><li><strong>其他优点</strong><ul><li><font color=red>同时支持高吞吐、低延迟、高性能</font><ul><li>Flink 是目前开源社区中唯一一套集高吞吐、低延迟、高性能三者于一身的分布式流式数据处理框架</li><li>Spark 只能兼顾高吞吐和高性能特性，无法做到低延迟保障,因为Spark是用批处理来做流处理</li><li>Storm 只能支持低延时和高性能特性，无法满足高吞吐的要求</li></ul></li><li><font color=red>支持事件时间(Event Time)概念</font><ul><li>在流式计算领域中，窗口计算的地位举足轻重，但目前大多数框架窗口计算采用的都是系统时间(Process Time)，也就是事件传输到计算框架处理时，系统主机的当前时间</li><li>Flink 能够支持基于事件时间(Event Time)语义进行窗口计算</li><li>这种基于事件驱动的机制使得事件即使乱序到达甚至延迟到达，流系统也能够计算出精确的结果，保持了事件原本产生时的时序性，尽可能避免网络传输或硬件系统的影响</li></ul></li><li><font color=red>支持有状态计算</font><ul><li>Flink1.4开始支持有状态计算</li><li>所谓状态就是在流式计算过程中将算子的中间结果保存在内存或者文件系统中，等下一个事件进入算子后可以从之前的状态中获取中间结果，计算当前的结果，从而无须每次都基于全部的原始数据来统计结果，极大的提升了系统性能，状态化意味着应用可以维护随着时间推移已经产生的数据聚合</li></ul></li><li><font color=red>支持高度灵活的窗口(Window)操作</font><ul><li>Flink 将窗口划分为基于 Time 、Count 、Session、以及Data-Driven等类型的窗口操作，窗口可以用灵活的触发条件定制化来达到对复杂的流传输模式的支持，用户可以定义不同的窗口触发机制来满足不同的需求</li></ul></li><li><font color=red>基于轻量级分布式快照(Snapshot/Checkpoints)的容错机制</font><ul><li>Flink 能够分布运行在上千个节点上，通过基于分布式快照技术的Checkpoints，将执行过程中的状态信息进行持久化存储，一旦任务出现异常停止，Flink 能够从 Checkpoints 中进行任务的自动恢复，以确保数据处理过程中的一致性</li><li>Flink 的容错能力是轻量级的，允许系统保持高并发，同时在相同时间内提供强一致性保证</li></ul></li><li><font color=red>基于 JVM 实现的独立的内存管理</font><ul><li>Flink 实现了自身管理内存的机制，通过使用散列，索引，缓存和排序有效地进行内存管理，通过序列化/反序列化机制将所有的数据对象转换成二进制在内存中存储，降低数据存储大小的同时，更加有效的利用空间。使其独立于 Java 的默认垃圾收集器，尽可能减少 JVM GC 对系统的影响</li></ul></li><li><font color=red>SavePoints 保存点</font><ul><li>对于 7 * 24 小时运行的流式应用，数据源源不断的流入，在一段时间内应用的终止有可能导致数据的丢失或者计算结果的不准确（比如集群版本的升级，停机运维操作等）</li><li>Flink 通过SavePoints 技术将任务执行的快照保存在存储介质上，当任务重启的时候，可以从事先保存的 SavePoints 恢复原有的计算状态，使得任务继续按照停机之前的状态运行</li><li>Flink 保存点提供了一个状态化的版本机制，使得能以无丢失状态和最短停机时间的方式更新应用或者回退历史数据</li></ul></li><li><font color=red>灵活的部署方式，支持大规模集群</font><ul><li>Flink 被设计成能用上千个点在大规模集群上运行</li><li>除了支持独立集群部署外，Flink 还支持 YARN 和Mesos 方式部署</li></ul></li><li><font color=red>Flink 的程序内在是并行和分布式的</font><ul><li>数据流可以被分区成 stream partitions，operators 被划分为operator subtasks，这些 subtasks 在不同的机器或容器中分不同的线程独立运行</li><li>operator subtasks 的数量就是operator的并行计算数，不同的 operator 阶段可能有不同的并行数</li></ul></li><li><font color=red>丰富的库</font><ul><li>Flink 拥有丰富的库来进行机器学习，图形处理，关系数据处理等</li></ul></li></ul></li></ul><h2 id="5-流处理-批处理">5. 流处理&amp;批处理</h2><p><img src="https://img-blog.csdnimg.cn/20210419171037746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>Batch Analytics 批量计算：</strong> 统一收集数据-&gt;存储到DB-&gt;对数据进行批量处理，就是传统意义上使用类似于 Map Reduce、Hive、Spark Batch 等，对作业进行分析、处理、生成离线报表</li><li><strong>Streaming Analytics 流式计算：</strong> 顾名思义，就是对数据流进行处理，如使用流式分析引擎如 Storm，Flink 实时处理分析数据，应用较多的场景如实时大屏、实时报表</li><li><strong>主要区别</strong><ul><li>与批量计算那样慢慢积累数据不同，流式计算立刻计算，数据持续流动，计算完之后就丢弃</li><li>批量计算是维护一张表，对表进行实施各种计算逻辑。流式计算相反，是必须先定义好计算逻辑，提交到流式计算系统，这个计算作业逻辑在整个运行期间是不可更改的</li><li>计算结果上，批量计算对全部数据进行计算后传输结果，流式计算是每次小批量计算后，结果可以立刻实时化展现</li></ul></li></ul><h2 id="6-流批统一">6. 流批统一</h2><p>在大数据处理领域，批处理任务与流处理任务一般被认为是两种不同的任务，一个大数据框架一般会被设计为只能处理其中一种任务：</p><ul><li>MapReduce只支持批处理任务</li><li>Storm只支持流处理任务</li><li>Spark Streaming采用micro-batch架构，本质上还是基于Spark批处理对流式数据进行处理</li><li>Flink通过灵活的执行引擎，能够同时支持批处理任务与流处理任务<br><img src="https://img-blog.csdnimg.cn/20210419171537108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><p>在执行引擎这一层，流处理系统与批处理系统最大不同在于节点间的<strong>数据传输方式</strong>：</p><ul><li>对于一个流处理系统，其节点间数据传输的标准模型是：当一条数据被处理完成后，序列化到缓存中，然后立刻通过网络传输到下一个节点，由下一个节点继续处理</li><li>对于一个批处理系统，其节点间数据传输的标准模型是：当一条数据被处理完成后，序列化到缓存中，并不会立刻通过网络传输到下一个节点，当缓存写满，就持久化到本地硬盘上，当所有数据都被处理完成后，才开始将处理后的数据通过网络传输到下一个节点</li></ul><p>这两种数据传输模式是两个极端，对应的是流处理系统对低延迟的要求和批处理系统对高吞吐量的要求。<br><strong>Flink的执行引擎采用了一种十分灵活的方式，同时支持了这两种数据传输模型：</strong></p><ul><li>Flink以固定的缓存块为单位进行网络数据传输，用户可以通过设置缓存块超时值指定缓存块的传输时机</li><li>如果缓存块的超时值为0，则Flink的数据传输方式类似上面所提到流处理系统的标准模型，此时系统可以获得最低的处理延迟</li><li>如果缓存块的超时值为无限大/-1，则Flink的数据传输方式类似上文所提到批处理系统的标准模型，此时系统可以获得最高的吞吐量</li><li>同时缓存块的超时值也可以设置为0到无限大之间的任意值。缓存块的超时阈值越小，则Flink流处理执行引擎的数据处理延迟越低，但吞吐量也会降低，反之亦然。通过调整缓存块的超时阈值，用户可根据需求灵活地权衡系统延迟和吞吐量</li></ul><p>默认情况下，流中的元素并不会一个一个的在网络中传输，而是缓存起来伺机一起发送(默认为32KB，通过taskmanager.memory.segment-size设置),这样可以避免导致频繁的网络传输,提高吞吐量，但如果数据源输入不够快的话会导致后续的数据处理延迟，所以可以使用env.setBufferTimeout(默认100ms)，来为缓存填入设置一个最大等待时间。等待时间到了之后，即使缓存还未填满，缓存中的数据也会自动发送</p><ul><li>timeoutMillis &gt; 0 表示最长等待 timeoutMillis 时间，就会flush</li><li>timeoutMillis = 0 表示每条数据都会触发 flush，直接将数据发送到下游，相当于没有Buffer了(避免设置为0，可能导致性能下降)</li><li>timeoutMillis = -1 表示只有等到 buffer满了或 CheckPoint的时候，才会flush。相当于取消了 timeout 策略</li></ul><p><strong>Flink以缓存块为单位进行网络数据传输,用户可以设置缓存块超时时间和缓存块大小来控制缓冲块传输时机,从而控制Flink的延迟性和吞吐量</strong></p><h1 id="二、Flink安装部署">二、Flink安装部署</h1><h2 id="1-Local本地模式">1. Local本地模式</h2><h3 id="1-1-原理">1.1 原理</h3><p><img src="https://img-blog.csdnimg.cn/20210420091847434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>Flink程序由JobClient进行提交</li><li>JobClient将作业提交给JobManager</li><li>JobManager负责协调资源分配和作业执行。资源分配完成后，任务将提交给相应的TaskManager</li><li>TaskManager启动一个线程以开始执行。TaskManager会向JobManager报告状态更改,如开始执行，正在进行或已完成</li><li>作业执行完成后，结果将发送回客户端（JobClient）</li></ol><h3 id="1-2-操作">1.2 操作</h3><ol><li><p>下载安装包<br><a href="https://archive.apache.org/dist/flink/">https://archive.apache.org/dist/flink/</a></p></li><li><p>上传flink-1.12.0-bin-scala_2.12.tgz到指定目录</p></li><li><p>解压</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf flink-1.12.0-bin-scala_2.12.tgz</span><br></pre></td></tr></table></figure></li><li><p>如果出现权限问题，需要修改权限</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R root:root /data/flink-1.12.0</span><br></pre></td></tr></table></figure></li><li><p>改名或创建软链接</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv flink-1.12.0 flink</span><br><span class="line">ln -s /data/flink-1.12.0 /data/flink</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-测试">1.3 测试</h3><ol><li><p>准备文件/data/words.txt</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/words.txt</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello me you her</span><br><span class="line">hello me you</span><br><span class="line">hello me</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li><li><p>启动Flink本地集群</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>使用jps可以查看到下面两个进程</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- TaskManagerRunner</span><br><span class="line">- StandaloneSessionClusterEntrypoint</span><br></pre></td></tr></table></figure></li><li><p>访问Flink的Web UI<br><a href="http://xn--IP-im8ckc:8081/#/overview">http://IP地址:8081/#/overview</a><br><img src="https://img-blog.csdnimg.cn/20210420093806515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>slot在Flink里面可以认为是资源组，Flink是通过将任务分成子任务并且将这些子任务分配到slot来并行执行程序</p></li><li><p>执行官方示例</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run /data/flink/examples/batch/WordCount.jar --input /data/words.txt --output /data/out</span><br></pre></td></tr></table></figure></li><li><p>停止Flink</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/start-scala-shell.sh local</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-Standalone独立集群模式">2. Standalone独立集群模式</h2><h3 id="2-1-原理">2.1 原理</h3><p><img src="https://img-blog.csdnimg.cn/20210420094339920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>client客户端提交任务给JobManager</li><li>JobManager负责申请任务运行所需要的资源并管理任务和资源</li><li>JobManager分发任务给TaskManager执行</li><li>TaskManager定期向JobManager汇报状态</li></ol><h3 id="2-2-操作">2.2 操作</h3><ol><li>集群规划：</li></ol><ul><li>服务器: flink1(Master + Slave): JobManager + TaskManager</li><li>服务器: flink2(Slave): TaskManager</li><li>服务器: flink3(Slave): TaskManager</li></ul><ol start="2"><li><p>修改flink-conf.yaml</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/flink-conf.yaml</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jobmanager.rpc.address: node1</span><br><span class="line">taskmanager.numberOfTaskSlots: 2</span><br><span class="line">web.submit.enable: true</span><br><span class="line"></span><br><span class="line">#历史服务器</span><br><span class="line">jobmanager.archive.fs.dir: hdfs://flink1:8020/flink/completed-jobs/</span><br><span class="line">historyserver.web.address: flink1</span><br><span class="line">historyserver.web.port: 8082</span><br><span class="line">historyserver.archive.fs.dir: hdfs://flink1:8020/flink/completed-jobs/</span><br></pre></td></tr></table></figure></li><li><p>修改masters</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/masters</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flink1:8081</span><br></pre></td></tr></table></figure></li><li><p>修改slaves</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/workers</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flink1</span><br><span class="line">flink2</span><br><span class="line">flink3</span><br></pre></td></tr></table></figure></li><li><p>添加HADOOP_CONF_DIR环境变量</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_CONF_DIR=/data/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure></li><li><p>分发</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r /data/flink flink2:/data/flink</span><br><span class="line">scp -r /data/flink flink3:/data/flink</span><br><span class="line">scp  /etc/profile flink2:/etc/profile</span><br><span class="line">scp  /etc/profile flink3:/etc/profile</span><br></pre></td></tr></table></figure></li><li><p>source</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-测试">2.3 测试</h3><ol><li><p>启动集群，在flink1上执行如下命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure><p>或者单独启动</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/jobmanager.sh ((start|start-foreground) cluster)|stop|stop-all</span><br><span class="line">/data/flink/bin/taskmanager.sh start|start-foreground|stop|stop-all</span><br></pre></td></tr></table></figure></li><li><p>启动历史服务器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/historyserver.sh start</span><br></pre></td></tr></table></figure></li><li><p>访问Flink UI界面或使用jps查看<br><a href="http://flink1:8081/#/overview">http://flink1:8081/#/overview</a><br><a href="http://flink1:8082/#/overview">http://flink1:8082/#/overview</a><br>TaskManager界面：可以查看到当前Flink集群中有多少个TaskManager，每个TaskManager的slots、内存、CPU Core是多少<br><img src="https://img-blog.csdnimg.cn/20210420100505412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>执行官方测试案例</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run  /data/flink/examples/batch/WordCount.jar --input hdfs://flink1:8020/wordcount/input/words.txt --output hdfs://flink1:8020/wordcount/output/result.txt  --parallelism 2</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210420100734236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>查看历史日志<br><a href="http://flink1:50070/explorer.html#/flink/completed-jobs">http://flink1:50070/explorer.html#/flink/completed-jobs</a><br><a href="http://flink1:8082/#/overview">http://flink1:8082/#/overview</a></p></li><li><p>停止Flink集群</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/stop-cluster.sh</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-Standalone-HA高可用集群模式">3. Standalone-HA高可用集群模式</h2><h3 id="3-1-原理">3.1 原理</h3><p><img src="https://img-blog.csdnimg.cn/20210420101230750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从之前的架构中可以很明显的发现 JobManager 有明显的单点问题(SPOF，single point of failure)。JobManager 肩负着任务调度以及资源分配，一旦 JobManager 出现意外，其后果可想而知。<br>在 Zookeeper 的帮助下，一个 Standalone的Flink集群会同时有多个活着的 JobManager，其中只有一个处于工作状态，其他处于 Standby 状态。当工作中的 JobManager 失去连接后(如宕机或 Crash)，Zookeeper 会从 Standby 中选一个新的 JobManager 来接管 Flink 集群。</p><h3 id="3-2-操作">3.2 操作</h3><ol><li>集群规划</li></ol><ul><li>服务器: flink1(Master + Slave): JobManager + TaskManager</li><li>服务器: flink2(Master + Slave): JobManager + TaskManager</li><li>服务器: flink3(Slave): TaskManager</li></ul><ol start="2"><li><p>启动ZooKeeper</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh status</span><br><span class="line">zkServer.sh stop</span><br><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure></li><li><p>启动HDFS</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/hadoop/sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></li><li><p>停止Flink集群</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/stop-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>修改flink-conf.yaml</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/flink-conf.yaml</span><br></pre></td></tr></table></figure><p>增加如下内容</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#开启HA，使用文件系统作为快照存储</span><br><span class="line">state.backend: filesystem</span><br><span class="line">#启用检查点，可以将快照保存到HDFS</span><br><span class="line">state.backend.fs.checkpointdir: hdfs://flink1:8020/flink-checkpoints</span><br><span class="line">#使用zookeeper搭建高可用</span><br><span class="line">high-availability: zookeeper</span><br><span class="line"># 存储JobManager的元数据到HDFS</span><br><span class="line">high-availability.storageDir: hdfs://flink1:8020/flink/ha/</span><br><span class="line"># 配置ZK集群地址</span><br><span class="line">high-availability.zookeeper.quorum: flink1:2181,flink2:2181,flink3:2181</span><br></pre></td></tr></table></figure></li><li><p>修改masters</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/masters</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flink1:8081</span><br><span class="line">flink2:8081</span><br></pre></td></tr></table></figure></li><li><p>同步</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r /data/flink/conf/flink-conf.yaml flink2:/data/flink/conf/</span><br><span class="line">scp -r /data/flink/conf/flink-conf.yaml flink3:/data/flink/conf/</span><br><span class="line">scp -r /data/flink/conf/masters flink2:/data/flink/conf/</span><br><span class="line">scp -r /data/flink/conf/masters flink3:/data/flink/conf/</span><br></pre></td></tr></table></figure></li><li><p>修改flink2上的flink-conf.yaml</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/flink/conf/flink-conf.yaml</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobmanager.rpc.address: flink2</span><br></pre></td></tr></table></figure></li><li><p>重新启动Flink集群,flink1上执行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/stop-cluster.sh</span><br><span class="line">/data/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>使用jps命令查看<br>发现没有Flink相关进程被启动</p></li><li><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /data/flink/log/flink-root-standalonesession-0-node1.log</span><br></pre></td></tr></table></figure><p>发现如下错误<img src="https://img-blog.csdnimg.cn/20210420103648464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因为在Flink1.8版本后,Flink官方提供的安装包里没有整合HDFS的jar</p></li><li><p>下载jar包并在Flink的lib目录下放入该jar包并分发使Flink能够支持对Hadoop的操作<br><a href="https://flink.apache.org/downloads.html">https://flink.apache.org/downloads.html</a><br><img src="https://img-blog.csdnimg.cn/20210420103809956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>依次放入lib目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /data/flink/lib</span><br></pre></td></tr></table></figure></li><li><p>重新启动Flink集群，flink1上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/start-cluster.sh</span><br></pre></td></tr></table></figure></li><li><p>使用jps命令查看,发现三台机器服务已启动</p></li></ol><h3 id="3-3-测试">3.3 测试</h3><ol><li><p>访问WebUI<br><a href="http://flink1:8081/#/job-manager/config">http://flink1:8081/#/job-manager/config</a><br><a href="http://flink2:8081/#/job-manager/config">http://flink2:8081/#/job-manager/config</a></p></li><li><p>执行wordcount</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run  /data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure></li><li><p>kill掉其中一个master</p></li><li><p>重新执行wc,还是可以正常执行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run  /data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure></li><li><p>停止集群</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/stop-cluster.sh</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-Flink-On-Yarn模式">4. Flink On Yarn模式</h2><h3 id="4-1-原理">4.1 原理</h3><p>在实际开发中，使用Flink时，更多的使用方式是Flink On Yarn模式，原因如下：</p><ul><li>Yarn的资源可以按需使用，提高集群的资源利用率</li><li>Yarn的任务有优先级，根据优先级运行作业</li><li>基于Yarn调度系统，能够自动化地处理各个角色的 Failover(容错)<ul><li>JobManager 进程和 TaskManager 进程都由 Yarn NodeManager 监控</li><li>如果 JobManager 进程异常退出，则 Yarn ResourceManager 会重新调度 JobManager 到其他机器</li><li>如果 TaskManager 进程异常退出，JobManager 会收到消息并重新向 Yarn ResourceManager 申请资源，重新启动 TaskManager</li></ul></li></ul><h4 id="4-1-1-Flink如何和Yarn进行交互">4.1.1 Flink如何和Yarn进行交互</h4><p><img src="https://img-blog.csdnimg.cn/20210420105320520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420105324842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>Client上传jar包和配置文件到HDFS集群上</li><li>Client向Yarn ResourceManager提交任务并申请资源</li><li>ResourceManager分配Container资源并启动ApplicationMaster,然后AppMaster加载Flink的Jar包和配置构建环境,启动JobManager<br>JobManager和ApplicationMaster运行在同一个container上。<br>一旦他们被成功启动，AppMaster就知道JobManager的地址(AM它自己所在的机器)。<br>它就会为TaskManager生成一个新的Flink配置文件(他们就可以连接到JobManager)。<br>这个配置文件也被上传到HDFS上。<br>此外，AppMaster容器也提供了Flink的web服务接口。<br>YARN所分配的所有端口都是临时端口，这允许用户并行执行多个Flink</li><li>ApplicationMaster向ResourceManager申请工作资源,NodeManager加载Flink的Jar包和配置构建环境并启动TaskManager</li><li>TaskManager启动后向JobManager发送心跳包，并等待JobManager向其分配任务</li></ol><h4 id="4-1-2-两种方式">4.1.2 两种方式</h4><h5 id="4-1-2-1-Session模式">4.1.2.1 Session模式</h5><p><img src="https://img-blog.csdnimg.cn/20210420105510454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420105514949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>特点：</strong> 需要事先申请资源，启动JobManager和TaskManger<br><strong>优点：</strong> 不需要每次递交作业申请资源，而是使用已经申请好的资源，从而提高执行效率<br><strong>缺点：</strong> 作业执行完成以后，资源不会被释放，因此一直会占用系统资源<br><strong>应用场景：</strong> 适合作业递交比较频繁的场景，小作业比较多的场景</p><h5 id="4-1-2-2-Per-Job模式">4.1.2.2 Per-Job模式</h5><p><img src="https://img-blog.csdnimg.cn/20210420105630609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420105634918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>特点：</strong> 每次递交作业都需要申请一次资源<br><strong>优点：</strong> 作业运行完成，资源会立刻被释放，不会一直占用系统资源<br><strong>缺点：</strong> 每次递交作业都需要申请资源，会影响执行效率，因为申请资源需要消耗时间<br><strong>应用场景：</strong> 适合作业比较少的场景、大作业的场景</p><h3 id="4-2-操作">4.2 操作</h3><ol><li><p>关闭yarn的内存检查</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/hadoop/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure><p>添加：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 关闭yarn内存检查 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>说明:<br>是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是true。<br>在这里面我们需要关闭，因为对于flink使用yarn模式下，很容易内存超标，这个时候yarn会自动杀掉job</p></li><li><p>同步</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r /data/hadoop/etc/hadoop/yarn-site.xml flink2:/data/hadoop/etc/hadoop/yarn-site.xml</span><br><span class="line">scp -r /data/hadoop/etc/hadoop/yarn-site.xml flink3:/data/hadoop/etc/hadoop/yarn-site.xml</span><br></pre></td></tr></table></figure></li><li><p>重启yarn</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/hadoop/sbin/stop-yarn.sh</span><br><span class="line">/data/hadoop/sbin/start-yarn.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-3-测试">4.3 测试</h3><h4 id="4-3-1-Session模式">4.3.1 Session模式</h4><ol><li><p>在yarn上启动一个Flink会话，flink1上执行以下命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/yarn-session.sh -n 2 -tm 800 -s 1 -d</span><br></pre></td></tr></table></figure><p>说明：申请2个CPU、1600M内存<br>-n 表示申请2个容器，这里指的就是多少个taskmanager<br>-tm 表示每个TaskManager的内存大小<br>-s 表示每个TaskManager的slots数量<br>-d 表示以后台程序方式运行</p></li><li><p>查看UI界面<br><a href="http://flink1:8088/cluster">http://flink1:8088/cluster</a><br><img src="https://img-blog.csdnimg.cn/20210420114840343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>使用flink run提交任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run  /data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p>运行完之后可以继续运行其他的小任务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run /data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure></li><li><p>通过上方的ApplicationMaster可以进入Flink的管理界面<br><img src="https://img-blog.csdnimg.cn/20210420115043539.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021042011504793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>关闭yarn-session</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -kill application_1599402747874_0001</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202104201151345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/.yarn-properties-root</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-3-2-Per-Job分离模式">4.3.2 Per-Job分离模式</h4><ol><li><p>直接提交job</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/flink/bin/flink run -m yarn-cluster -yjm 1024 -ytm 1024 </span><br><span class="line">/data/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p>-m  jobmanager的地址<br>-yjm 1024 指定jobmanager的内存信息<br>-ytm 1024 指定taskmanager的内存信息</p></li><li><p>查看UI界面<br><a href="http://flink1:8088/cluster">http://flink1:8088/cluster</a><br><img src="https://img-blog.csdnimg.cn/20210420115506284.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420115515915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>注意<br>在之前版本中如果使用的是flink on yarn方式，想切换回standalone模式的话，如果报错需要删除：【/tmp/.yarn-properties-root】</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/.yarn-properties-root</span><br></pre></td></tr></table></figure><p>因为默认查找当前yarn集群中已有的yarn-session信息中的jobmanager</p></li></ol><h1 id="三、Flink入门案例">三、Flink入门案例</h1><h2 id="1-前置说明">1. 前置说明</h2><h3 id="1-1-API">1.1 API</h3><p>Flink提供了多个层次的API供开发者使用，越往上抽象程度越高，使用起来越方便；越往下越底层，使用起来难度越大<br><img src="https://img-blog.csdnimg.cn/20210427103102655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427103110578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><font color=red><strong>注：</strong></font>在Flink1.12时支持流批一体，DataSet API已经不推荐使用了，后续都会优先使用DataStream流式API，既支持无界数据处理/流处理，也支持有界数据处理/批处理</p><h3 id="1-2-编程模型">1.2 编程模型</h3><p>Flink 应用程序结构主要包含三部分,Source/Transformation/Sink,如下图所示<br><img src="https://img-blog.csdnimg.cn/20210427103511706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427103521568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-准备工作">2. 准备工作</h2><h3 id="2-1-pom文件">2.1 pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink_study_42<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定仓库位置，依次为aliyun、apache和cloudera仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>apache<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.apache.org/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-scala-bridge_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-java-bridge_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- flink执行计划,这是1.9版本之前的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- blink执行计划,1.11+默认的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner-blink_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;flink-cep_2.12&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- flink连接器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-sql-connector-kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-jdbc_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-csv<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">           &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">           &lt;artifactId&gt;flink-connector-filesystem_2.12&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">           &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">       &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;flink-jdbc_2.12&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">              &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">              &lt;artifactId&gt;flink-parquet_2.12&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">              &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;</span></span><br><span class="line"><span class="comment">         &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.avro&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;avro&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;1.9.2&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">        &lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.parquet&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;parquet-avro&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;1.10.0&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bahir<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-redis_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-runtime_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-hive_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-metastore<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-shaded-hadoop-2-uber<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5-10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;version&gt;8.0.20&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 高性能异步组件：Vertx--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-jdbc-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-redis-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 参考：https://blog.csdn.net/f641385712/article/details/84109098--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;4.4&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;libfb303&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;0.9.3&lt;/version&gt;</span></span><br><span class="line"><span class="comment">            &lt;type&gt;pom&lt;/type&gt;</span></span><br><span class="line"><span class="comment">            &lt;scope&gt;provided&lt;/scope&gt;</span></span><br><span class="line"><span class="comment">         &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">           &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">           &lt;artifactId&gt;guava&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">           &lt;version&gt;28.2-jre&lt;/version&gt;</span></span><br><span class="line"><span class="comment">       &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 编译插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--&lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt;--&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">useFile</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useFile</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">disableXmlReport</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disableXmlReport</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Test.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Suite.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 打包插件(会包含所有依赖) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                                        zip -d learn_spark.jar META-INF/*.RSA META-INF/*.DSA META-INF/*.SF --&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.SF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.DSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.RSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="comment">&lt;!-- 设置jar包的入口类(可选) --&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span><span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-log4j-properties">2.2 log4j.properties</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=WARN, console</span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=%d&#123;HH:mm:ss,SSS&#125; %-5p %-60c %x - %m%n</span><br></pre></td></tr></table></figure><h2 id="3-Flink实现WordCount">3. Flink实现WordCount</h2><h3 id="3-1-编码步骤">3.1 编码步骤</h3><ol><li>准备环境-env</li><li>准备数据-source</li><li>处理数据-transformation</li><li>输出结果-sink</li><li>触发执行-execute</li></ol><p>其中创建环境可以使用下面三种方式</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getExecutionEnvironment() <span class="comment">//推荐使用</span></span><br><span class="line">createLocalEnvironment()</span><br><span class="line">createRemoteEnvironment(<span class="type">String</span> host, int port, <span class="type">String</span>... jarFiles)</span><br></pre></td></tr></table></figure><h3 id="3-2-代码实现">3.2 代码实现</h3><p><img src="https://img-blog.csdnimg.cn/20210427105014204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="3-2-1-批处理wordcount">3.2.1 批处理wordcount</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建执行环境</span></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件中读取数据</span></span><br><span class="line"><span class="keyword">val</span> inputPath = <span class="string">&quot;D:\\Projects\\BigData\\TestWC1\\src\\main\\resources\\hello.txt&quot;</span> <span class="keyword">val</span> inputDS: <span class="type">DataSet</span>[<span class="type">String</span>] = env.readTextFile(inputPath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分词之后，对单词进行groupby 分组，然后用sum 进行聚合</span></span><br><span class="line"><span class="keyword">val</span> wordCountDS: <span class="type">AggregateDataSet</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = inputDS.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_, <span class="number">1</span>)).groupBy(<span class="number">0</span>).sum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印输出</span></span><br><span class="line">wordCountDS.print()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-流处理wordcount">3.2.2 流处理wordcount</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从外部命令中获取参数</span></span><br><span class="line"><span class="keyword">val</span> params: <span class="type">ParameterTool</span> = <span class="type">ParameterTool</span>.fromArgs(args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> host: <span class="type">String</span> = params.get(<span class="string">&quot;host&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> port: <span class="type">Int</span> = params.getInt(<span class="string">&quot;port&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建流处理环境</span></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收socket 文本流</span></span><br><span class="line"><span class="keyword">val</span> textDstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMap 和Map 需要引用的隐式转换</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.scala._</span><br><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = textDstream.flatMap(_.split(<span class="string">&quot;\\s&quot;</span>)).filter(_.nonEmpty).map((_, <span class="number">1</span>)).keyBy(<span class="number">0</span>).sum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dataStream.print().setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动executor，执行任务</span></span><br><span class="line">env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、Flink原理">四、Flink原理</h1><h2 id="1-角色分工">1. 角色分工</h2><p>在实际生产中，Flink 都是以集群在运行，在运行的过程中包含了两类进程：</p><ul><li><strong>JobManager</strong><ul><li>它扮演的是集群管理者的角色，负责调度任务、协调 checkpoints、协调故障恢复、收集 Job 的状态信息，并管理 Flink 集群中的从节点 TaskManager</li></ul></li><li><strong>TaskManager</strong><ul><li>实际负责执行计算的 Worker，在其上执行 Flink Job 的一组 Task；TaskManager 还是所在节点的管理员，它负责把该节点上的服务器信息比如内存、磁盘、任务运行情况等向 JobManager 汇报</li></ul></li><li><strong>Client</strong><ul><li>用户在提交编写好的 Flink 工程时，会先创建一个客户端再进行提交，这个客户端就是 Client<br><img src="https://img-blog.csdnimg.cn/20210427112143315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427112153791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul></li></ul><h2 id="2-执行流程">2. 执行流程</h2><h3 id="2-1-Standalone版">2.1 Standalone版</h3><p><img src="https://img-blog.csdnimg.cn/20210427112250878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-On-Yarn版">2.2 On Yarn版</h3><p><img src="https://img-blog.csdnimg.cn/20210427112316946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>Client向HDFS上传Flink的Jar包和配置</li><li>Client向Yarn ResourceManager提交任务并申请资源</li><li>ResourceManager分配Container资源并启动ApplicationMaster,然后AppMaster加载Flink的Jar包和配置构建环境,启动JobManager</li><li>ApplicationMaster向ResourceManager申请工作资源,NodeManager加载Flink的Jar包和配置构建环境并启动TaskManager</li><li>TaskManager启动后向JobManager发送心跳包，并等待JobManager向其分配任务</li></ol><h2 id="3-Flink-Streaming-Dataflow">3. Flink Streaming Dataflow</h2><h3 id="3-1-Dataflow、Operator、Partition、SubTask、Parallelism">3.1 Dataflow、Operator、Partition、SubTask、Parallelism</h3><ul><li>Dataflow<ul><li>Flink程序在执行的时候会被映射成一个数据流模型</li></ul></li><li>Operator<ul><li>数据流模型中的每一个操作被称作Operator,Operator分为:Source/Transform/Sink</li></ul></li><li>Partition<ul><li>数据流模型是分布式的和并行的,执行中会形成1~n个分区</li></ul></li><li>Subtask<ul><li>多个分区任务可以并行,每一个都是独立运行在一个线程中的,也就是一个Subtask子任</li></ul></li><li>Parallelism<ul><li>并行度,就是可以同时真正执行的子任务数/分区数<br><img src="https://img-blog.csdnimg.cn/20210427113503606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="3-2-Operator传递模式">3.2 Operator传递模式</h3><p>数据在两个operator(算子)之间传递的时候有两种模式：</p><ul><li>One to One模式<ul><li>两个operator用此模式传递的时候，会保持数据的分区数和数据的排序；如上图中的Source1到Map1，它就保留的Source的分区特性，以及分区元素处理的有序性（类似于Spark中的窄依赖）</li></ul></li><li>Redistributing模式<ul><li>这种模式会改变数据的分区数；每个一个operator subtask会根据选择transformation把数据发送到不同的目标subtasks,比如keyBy()会通过hashcode重新分区,broadcast()和rebalance()方法会随机重新分区（类似于Spark中的宽依赖）</li></ul></li></ul><h3 id="3-3-Operator-Chain">3.3 Operator Chain</h3><p><img src="https://img-blog.csdnimg.cn/20210427113734406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>客户端在提交任务的时候会对Operator进行优化操作，能进行合并的Operator会被合并为一个Operator，合并后的Operator称为Operator chain，实际上就是一个执行链，每个执行链会在TaskManager上一个独立的线程中执行（就是SubTask）</p><h3 id="3-4-TaskSlot-And-Slot-Sharing">3.4 TaskSlot And Slot Sharing</h3><p><img src="https://img-blog.csdnimg.cn/20210427113853330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>任务槽（TaskSlot）<ul><li>每个TaskManager是一个JVM的进程, 为了控制一个TaskManager(worker)能接收多少个task，Flink通过Task Slot来进行控制<br>TaskSlot数量是用来限制一个TaskManager工作进程中可以同时运行多少个工作线程，TaskSlot 是一个 TaskManager 中的最小资源分配单位，一个 TaskManager 中有多少个 TaskSlot 就意味着能支持多少并发的Task处理</li></ul></li></ul><p>Flink将进程的内存进行了划分到多个slot中，内存被划分到不同的slot之后可以获得如下好处:</p><ul><li>TaskManager最多能同时并发执行的子任务数是可以通过TaskSolt数量来控制的</li><li>TaskSolt有独占的内存空间，这样在一个TaskManager中可以运行多个不同的作业，作业之间不受影响</li></ul><p><img src="https://img-blog.csdnimg.cn/20210427114058889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>槽共享（Slot Sharing）<ul><li>Flink允许子任务共享插槽，即使它们是不同任务(阶段)的子任务(subTask)，只要它们来自同一个作业<br>比如图左下角中的map和keyBy和sink 在一个 TaskSlot 里执行以达到资源共享的目的</li></ul></li></ul><p>允许插槽共享有两个主要好处：</p><ul><li>资源分配更加公平，如果有比较空闲的slot可以将更多的任务分配给它</li><li>有了任务槽共享，可以提高资源的利用率</li></ul><p><font color=red><strong>注：</strong></font><br>slot是静态的概念，是指taskmanager具有的并发执行能力<br>parallelism是动态的概念，是指程序运行时实际使用的并发能力</p><h2 id="4-Flink运行时的组件">4. Flink运行时的组件</h2><p>Flink运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作：</p><ul><li>作业管理器（JobManager）<ul><li>分配任务、调度checkpoint做快照</li></ul></li><li>任务管理器（TaskManager）<ul><li>主要干活的</li></ul></li><li>资源管理器（ResourceManager）<ul><li>管理分配资源</li></ul></li><li>分发器（Dispatcher）<ul><li>方便递交任务的接口，WebUI</li></ul></li></ul><p>因为Flink是用Java和Scala实现的，所以所有组件都会运行在Java虚拟机上。每个组件的职责如下：</p><ul><li><strong>作业管理器（JobManager）</strong><ul><li>控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager 所控制执行</li><li>JobManager 会先接收到要执行的应用程序，这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的JAR包</li><li>JobManager 会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务</li><li>JobManager 会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调</li></ul></li><li><strong>任务管理器（TaskManager）</strong><ul><li>Flink中的工作进程。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量</li><li>启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用。JobManager就可以向插槽分配任务（tasks）来执行了</li><li>在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据</li></ul></li><li><strong>资源管理器（ResourceManager）</strong><ul><li>主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger 插槽是Flink中定义的处理资源单元</li><li>Flink为不同的环境和资源管理工具提供了不同资源管理器，比如YARN、Mesos、K8s，以及standalone部署</li><li>当JobManager申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给JobManager。如果ResourceManager没有足够的插槽来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器</li></ul></li><li><strong>分发器（Dispatcher）</strong><ul><li>可以跨作业运行，它为应用提交提供了REST接口</li><li>当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager</li><li>Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息</li><li>Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式</li></ul></li></ul><h2 id="5-Flink执行图（ExecutionGraph）">5. Flink执行图（ExecutionGraph）</h2><p>由Flink程序直接映射成的数据流图是StreamGraph，也被称为逻辑流图，因为它们表示的是计算逻辑的高级视图。为了执行一个流处理程序，Flink需要将逻辑流图转换为物理数据流图（也叫执行图），详细说明程序的执行方式。<br>Flink 中的执行图可以分成四层：<font color=red>StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图</font><br><img src="https://img-blog.csdnimg.cn/2021042711515181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>原理介绍<ul><li>Flink执行executor会自动根据程序代码生成DAG数据流图</li><li>Flink 中的执行图可以分成四层：StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图<ul><li><strong>StreamGraph：</strong> 是根据用户通过 Stream API 编写的代码生成的最初的图。表示程序的拓扑结构</li><li><strong>JobGraph：</strong> StreamGraph经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。主要的优化为，将多个符合条件的节点 chain 在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗</li><li><strong>ExecutionGraph：</strong> JobManager 根据 JobGraph 生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构</li><li><strong>物理执行图：</strong> JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构</li></ul></li></ul></li><li>简单理解<ul><li><strong>StreamGraph：</strong> 最初的程序执行逻辑流程，也就是算子之间的前后顺序（在Client上生成）</li><li><strong>JobGraph：</strong> 将OneToOne的Operator合并为OperatorChain（在Client上生成）</li><li><strong>ExecutionGraph：</strong> 将JobGraph根据代码中设置的并行度和请求的资源进行并行化规划!（在JobManager上生成）</li><li><strong>物理执行图：</strong> 将ExecutionGraph的并行计划,落实到具体的TaskManager上，将具体的SubTask落实到具体的TaskSlot内进行运行</li></ul></li></ul><h1 id="五、流批一体API">五、流批一体API</h1><h2 id="1-DataStream-API">1. DataStream API</h2><ul><li>DataStream API 支持批执行模式<ul><li>Flink 的核心 API 最初是针对特定的场景设计的，尽管 Table API / SQL 针对流处理和批处理已经实现了统一的 API，但当用户使用较底层的 API 时，仍然需要在批处理（DataSet API）和流处理（DataStream API）这两种不同的 API 之间进行选择。鉴于批处理是流处理的一种特例，将这两种 API 合并成统一的 API，有一些非常明显的好处，比如：<ul><li>可复用性：作业可以在流和批这两种执行模式之间自由地切换，而无需重写任何代码。因此，用户可以复用同一个作业，来处理实时数据和历史数据</li><li>维护简单：统一的 API 意味着流和批可以共用同一组 connector，维护同一套代码，并能够轻松地实现流批混合执行，例如 backfilling 之类的场景</li></ul></li></ul></li></ul><p>考虑到这些优点，社区已朝着流批统一的 DataStream API 迈出了第一步：支持高效的批处理（FLIP-134）。从长远来看，这意味着 DataSet API 将被弃用（FLIP-131），其功能将被包含在 DataStream API 和 Table API / SQL 中。</p><h2 id="2-Source">2. Source</h2><h3 id="2-1-预定义Source">2.1 预定义Source</h3><h4 id="2-1-1-基于集合的Source">2.1.1 基于集合的Source</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义样例类，传感器id，时间戳，温度</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SensorReading</span>(<span class="params">id: <span class="type">String</span>, timestamp: <span class="type">Long</span>, temperature: <span class="type">Double</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sensor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="keyword">val</span> stream1: <span class="type">DataStream</span>[<span class="type">String</span>] = env</span><br><span class="line">.fromCollection(<span class="type">List</span>(</span><br><span class="line"><span class="type">SensorReading</span>(<span class="string">&quot;sensor_1&quot;</span>, <span class="number">1547718199</span>, <span class="number">35.8</span>),</span><br><span class="line"><span class="type">SensorReading</span>(<span class="string">&quot;sensor_6&quot;</span>, <span class="number">1547718201</span>, <span class="number">15.4</span>),</span><br><span class="line"><span class="type">SensorReading</span>(<span class="string">&quot;sensor_7&quot;</span>, <span class="number">1547718202</span>, <span class="number">6.7</span>),</span><br><span class="line"><span class="type">SensorReading</span>(<span class="string">&quot;sensor_10&quot;</span>, <span class="number">1547718205</span>, <span class="number">38.1</span>)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">stream1.print(<span class="string">&quot;stream1:&quot;</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">env.execute()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-基于文件的Source">2.1.2 基于文件的Source</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream2: <span class="type">DataStream</span>[<span class="type">String</span>] = env.readTextFile(<span class="string">&quot;FILE_PATH&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-3-基于Socket的Source">2.1.3 基于Socket的Source</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从外部命令中获取参数</span></span><br><span class="line"><span class="keyword">val</span> params: <span class="type">ParameterTool</span> = <span class="type">ParameterTool</span>.fromArgs(args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> host: <span class="type">String</span> = params.get(<span class="string">&quot;host&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> port: <span class="type">Int</span> = params.getInt(<span class="string">&quot;port&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建流处理环境</span></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收socket 文本流</span></span><br><span class="line"><span class="keyword">val</span> textDstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(host, port)</span><br><span class="line"></span><br><span class="line">textDstream.print().setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动executor，执行任务</span></span><br><span class="line">env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-Kafka-Source">2.1.4 Kafka Source</h4><p>需要引入Kafka连接器的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka-0.11</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.11_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建流处理环境</span></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>)</span><br><span class="line">properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>)</span><br><span class="line">properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> stream = env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer011</span>[<span class="type">String</span>](<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), properties))</span><br><span class="line"></span><br><span class="line">stream.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动executor，执行任务</span></span><br><span class="line">env.execute(<span class="string">&quot;Socket stream word count&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-自定义Source">2.2 自定义Source</h3><p>除了以上的 source 数据来源， 我们还可以自定义 source。需要做的， 只是传入一个 SourceFunction 就可以。具体调用如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream = env.addSource( <span class="keyword">new</span> <span class="type">MySensorSource</span>() )</span><br></pre></td></tr></table></figure><p>我们希望可以随机生成传感器数据， MySensorSource 具体的代码实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySensorSource</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>[<span class="type">SensorReading</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag: 表示数据源是否还在正常运行</span></span><br><span class="line"><span class="keyword">var</span> running: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">running = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(ctx: <span class="type">SourceFunction</span>.<span class="type">SourceContext</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个随机数发生器</span></span><br><span class="line"><span class="keyword">val</span> rand = <span class="keyword">new</span> <span class="type">Random</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curTemp = <span class="number">1.</span>to(<span class="number">10</span>).map(</span><br><span class="line">i =&gt; ( <span class="string">&quot;sensor_&quot;</span> + i, <span class="number">65</span> + rand.nextGaussian() * <span class="number">20</span> )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(running)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新温度值</span></span><br><span class="line">curTemp = curTemp.map(</span><br><span class="line">t =&gt; (t._1, t._2 + rand.nextGaussian() )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前时间戳</span></span><br><span class="line"><span class="keyword">val</span> curTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">curTemp.foreach(</span><br><span class="line">t =&gt; ctx.collect(<span class="type">SensorReading</span>(t._1, curTime, t._2))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span>.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Transformation">3. Transformation</h2><p><img src="https://img-blog.csdnimg.cn/20210427154434759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210427154440564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>整体来说，流式数据上的操作可以分为四类：</p><ol><li>第一类是对于单条记录的操作，比如筛除掉不符合要求的记录（Filter 操作），或者将每条记录都做一个转换（Map 操作）</li><li>第二类是对多条记录的操作。比如说统计一个小时内的订单总成交量，就需要将一个小时内的所有订单记录的成交量加到一起。为了支持这种类型的操作，就得通过 Window 将需要的记录关联到一起进行处理</li><li>第三类是对多个流进行操作并转换为单个流。例如，多个流可以通过 Union、Join 或 Connect 等操作合到一起。这些操作合并的逻辑不同，但是它们最终都会产生了一个新的统一的流，从而可以进行一些跨流的操作</li><li>DataStream 还支持与合并对称的拆分操作，即把一个流按一定规则拆分为多个流（Split 操作），每个流是之前流的一个子集，这样我们就可以对不同的流作不同的处理</li></ol><h3 id="3-1-map">3.1 map</h3><p><strong>map:</strong> 将函数作用在集合中的每一个元素上,并返回作用后的结果<br><img src="https://img-blog.csdnimg.cn/20210427154625112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamMap = stream.map &#123; x =&gt; x * <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-flatMap">3.2 flatMap</h3><p><strong>flatMap:</strong> 将集合中的每个元素变成一个或多个元素,并返回扁平化之后的结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamFlatMap = stream.flatMap&#123;</span><br><span class="line">x =&gt; x.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flatMap 的函数签名：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>,<span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> ⇒ <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatMap(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))(i =&gt; <span class="type">List</span>(i,i))</span><br></pre></td></tr></table></figure><p>结果是 List(1,1,2,2,3,3)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">&quot;a b&quot;</span>, <span class="string">&quot;c d&quot;</span>).flatMap(line =&gt; line.split(<span class="string">&quot; &quot;</span>))</span><br></pre></td></tr></table></figure><p>结果是 List(a, b, c, d)</p><h3 id="3-3-filter">3.3 filter</h3><p><strong>filter:</strong> 按照指定的条件对集合中的元素进行过滤,过滤出返回true/符合条件的元素<br><img src="https://img-blog.csdnimg.cn/20210427155213297.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamFilter = stream.filter&#123;</span><br><span class="line">x =&gt; x == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-keyBy">3.4 keyBy</h3><p><strong>DataStream → KeyedStream：</strong> 逻辑地将一个流拆分成不相交的分区，每个分区包含具有相同 key 的元素，在内部以 hash 的形式实现的。<br><img src="https://img-blog.csdnimg.cn/20210427155521872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong><font color=red>注：</font></strong> 流处理中没有groupBy,而是keyBy</p><h3 id="3-5-滚动聚合算子（Rolling-Aggregation）">3.5 滚动聚合算子（Rolling Aggregation）</h3><p>这些算子可以针对 KeyedStream 的每一个支流做聚合：</p><ul><li>sum()</li><li>min()</li><li>max()</li><li>minBy()</li><li>maxBy()</li></ul><h3 id="3-6-Reduce">3.6 Reduce</h3><p><strong>KeyedStream → DataStream：</strong> 一个分组数据流的聚合操作，合并当前的元素 和上次聚合的结果，产生一个新的值，返回的流中包含每一次聚合的结果，而不是 只返回最后一次聚合的最终结果</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream2 = env.readTextFile(<span class="string">&quot;YOUR_PATH\\sensor.txt&quot;</span>)</span><br><span class="line">.map( data =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125;)</span><br><span class="line">.keyBy(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">.reduce( (x, y) =&gt; <span class="type">SensorReading</span>(x.id, x.timestamp + <span class="number">1</span>, y.temperature) )</span><br></pre></td></tr></table></figure><h3 id="3-7-合并-拆分">3.7 合并&amp;拆分</h3><h4 id="3-7-1-Split-和-Select">3.7.1 Split 和 Select</h4><p><strong>Split：</strong> 根据某些特征把一个 DataStream 拆分成两个或者 多个 DataStream（<strong>DataStream → SplitStream</strong>）<br><img src="https://img-blog.csdnimg.cn/20210427160847349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Select：</strong> 从一个 SplitStream 中获取一个或者多个DataStream（<strong>SplitStream→DataStream</strong>）<br><img src="https://img-blog.csdnimg.cn/20210427160943799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>需求：</strong> 传感器数据按照温度高低（以 30 度为界），拆分成两个流</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> splitStream = stream2</span><br><span class="line">.split( sensorData =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (sensorData.temperature &gt; <span class="number">30</span>) <span class="type">Seq</span>(<span class="string">&quot;high&quot;</span>) <span class="keyword">else</span> <span class="type">Seq</span>(<span class="string">&quot;low&quot;</span>)</span><br><span class="line">&#125; )</span><br><span class="line"><span class="keyword">val</span> high = splitStream.select(<span class="string">&quot;high&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> low = splitStream.select(<span class="string">&quot;low&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> all = splitStream.select(<span class="string">&quot;high&quot;</span>, <span class="string">&quot;low&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="3-7-2-Connect-和-CoMap">3.7.2 Connect 和 CoMap</h4><p><strong>Connect：</strong> 连接两个保持他们类型的数据流， 两个数据流被 Connect 之后， 只是被放在了一个同一个流中， 内部依然保持各自的数据和形式不发生任何变化， 两个流相互独立（<strong>DataStream,DataStream → ConnectedStreams</strong>）<br><img src="https://img-blog.csdnimg.cn/20210427161344411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>CoMap,CoFlatMap：</strong> 作用于 ConnectedStreams 上， 功能与 map 和 flatMap 一样， 对ConnectedStreams 中的每一个 Stream 分别进行 map 和 flatMap 处理（<strong>ConnectedStreams → DataStream</strong>）<br><img src="https://img-blog.csdnimg.cn/20210427162551975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> warning = high.map( sensorData =&gt; (sensorData.id, sensorData.temperature) )</span><br><span class="line"><span class="keyword">val</span> connected = warning.connect(low)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> coMap = connected.map(</span><br><span class="line">warningData =&gt; (warningData._1, warningData._2, <span class="string">&quot;warning&quot;</span>),</span><br><span class="line">lowData =&gt; (lowData.id, <span class="string">&quot;healthy&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="3-7-3-Union">3.7.3 Union</h4><p><strong>DataStream → DataStream：</strong> 对两个或者两个以上的 DataStream 进行 union 操 作，产生一个包含所有 DataStream 元素的新 DataStream<br><img src="https://img-blog.csdnimg.cn/20210427162915472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并以后打印 </span></span><br><span class="line"><span class="keyword">val</span> unionStream: <span class="type">DataStream</span>[<span class="type">StartUpLog</span>] = appStoreStream.union(otherStream) unionStream.print(<span class="string">&quot;union:::&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>Connect 与 Union 区别：</strong></p><ol><li>Union 之前两个流的类型必须是一样，Connect 可以不一样，在之后的 coMap 中再去调整成为一样的</li><li>Connect 只能操作两个流，Union 可以操作多个</li></ol><h3 id="3-8-分区">3.8 分区</h3><h4 id="3-8-1-rebalance重平衡分区">3.8.1 rebalance重平衡分区</h4><p>类似于Spark中的repartition,但是功能更强大,可以直接解决数据倾斜<br>Flink也有数据倾斜的时候，比如当前有数据量大概10亿条数据需要处理，在处理过程中可能会发生如图所示的状况，出现了数据倾斜，其他3台机器执行完毕也要等待机器1执行完毕后才算整体将任务完成：<br><img src="https://img-blog.csdnimg.cn/20210427163401911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以在实际的工作中，出现这种情况比较好的解决方案就是rebalance（内部使用round robin方法将数据均匀打散）<br><img src="https://img-blog.csdnimg.cn/20210427163434122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="3-8-2-其他分区">3.8.2 其他分区</h4><p><img src="https://img-blog.csdnimg.cn/20210427164148326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>recale分区：</strong> 基于上下游Operator的并行度，将记录以循环的方式输出到下游Operator的每个实例<br><strong>举例：</strong> 上游并行度是2，下游是4，则上游一个并行度以循环的方式将记录输出到下游的两个并行度上;上游另一个并行度以循环的方式将记录输出到下游另两个并行度上。若上游并行度是4，下游并行度是2，则上游两个并行度将记录输出到下游一个并行度上；上游另两个并行度将记录输出到下游另一个并行度上。</p><h3 id="3-9-支持的数据类型">3.9 支持的数据类型</h3><p>Flink 流应用程序处理的是以数据对象表示的事件流。所以在 Flink 内部， 我们需要能够处理这些对象。它们需要被序列化和反序列化， 以便通过网络传送它们； 或者从状态后端、检查点和保存点读取它们。为了有效地做到这一点，Flink 需要明确知道应用程序所处理的数据类型。Flink 使用类型信息的概念来表示数据类型，并为每个数据类型生成特定的序列化器、反序列化器和比较器。<br>Flink 还具有一个类型提取系统，该系统分析函数的输入和返回类型，以自动获取类型信息，从而获得序列化器和反序列化器。但是，在某些情况下，例如 lambda 函数或泛型类型， 需要显式地提供类型信息， 才能使应用程序正常工作或提高其性能。</p><h4 id="3-9-1-基础数据类型">3.9.1 基础数据类型</h4><p>Flink 支持所有的 Java 和 Scala 基础数据类型， Int, Double, Long, String, …</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers: <span class="type">DataStream</span>[<span class="type">Long</span>] = env.fromElements(<span class="number">1</span>L, <span class="number">2</span>L, <span class="number">3</span>L, <span class="number">4</span>L)</span><br><span class="line">numbers.map( n =&gt; n + <span class="number">1</span> )</span><br></pre></td></tr></table></figure><h4 id="3-9-2-Java-和Scala-元组（Tuples）">3.9.2 Java 和Scala 元组（Tuples）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> persons: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Integer</span>)] = env</span><br><span class="line">.fromElements( (<span class="string">&quot;Adam&quot;</span>, <span class="number">17</span>), (<span class="string">&quot;Sarah&quot;</span>, <span class="number">23</span>) ) </span><br><span class="line">persons.filter(p =&gt; p._2 &gt; <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h4 id="3-9-3-Scala-样例类（case-classes）">3.9.3 Scala 样例类（case classes）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> persons: <span class="type">DataStream</span>[<span class="type">Person</span>] = env.</span><br><span class="line">fromElements( <span class="type">Person</span>(<span class="string">&quot;Adam&quot;</span>, <span class="number">17</span>), <span class="type">Person</span>(<span class="string">&quot;Sarah&quot;</span>, <span class="number">23</span>) )</span><br><span class="line">persons.filter(p =&gt; p.age &gt; <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h4 id="3-9-4-Java-简单对象（POJOs）">3.9.4 Java 简单对象（POJOs）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">DataStream&lt;Person&gt; persons = env.fromElements(</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alex&quot;</span>, <span class="number">42</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Wendy&quot;</span>, <span class="number">23</span>));</span><br></pre></td></tr></table></figure><h4 id="3-9-5-其它（Arrays-Lists-Maps-Enums-等等）">3.9.5 其它（Arrays, Lists, Maps, Enums, 等等）</h4><p>Flink 对 Java 和 Scala 中的一些特殊目的的类型也都是支持的，比如 Java 的 ArrayList，HashMap，Enum 等等。</p><h2 id="4-Sink">4. Sink</h2><p>Flink 没有类似于 spark 中 foreach 方法， 让用户进行迭代的操作。虽有对外的输出操作都要利用 Sink 完成。最后通过类似如下方式完成整个任务最终输出操作。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.addSink(<span class="keyword">new</span> <span class="type">MySink</span>(xxxx))</span><br></pre></td></tr></table></figure><p>官方提供了一部分的框架的 sink。除此以外， 需要用户自定义实现 sink</p><h3 id="4-1-Kafka">4.1 Kafka</h3><ol><li>pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka-0.11</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.11_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>主函数中添加sink</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> union = high.union(low).map(_.temperature.toString)</span><br><span class="line"></span><br><span class="line">union.addSink(<span class="keyword">new</span> <span class="type">FlinkKafkaProducer011</span>[<span class="type">String</span>](<span class="string">&quot;localhost:9092&quot;</span>,<span class="string">&quot;test&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>()))</span><br></pre></td></tr></table></figure><h3 id="4-2-Redis">4.2 Redis</h3><ol><li>pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.apache.bahir/flink-connector-redis</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.bahir<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-redis_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义一个 redis 的 mapper 类， 用于定义保存到 redis 时调用的命令</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRedisMapper</span> <span class="keyword">extends</span> <span class="title">RedisMapper</span>[<span class="type">SensorReading</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCommandDescription</span></span>: <span class="type">RedisCommandDescription</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">RedisCommandDescription</span>(<span class="type">RedisCommand</span>.<span class="type">HSET</span>, <span class="string">&quot;sensor_temperature&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getValueFromData</span></span>(t: <span class="type">SensorReading</span>): <span class="type">String</span> = t.temperature.toString</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getKeyFromData</span></span>(t: <span class="type">SensorReading</span>): <span class="type">String</span> = t.id</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在主函数中调用</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">FlinkJedisPoolConfig</span>.<span class="type">Builder</span>().setHost(<span class="string">&quot;localhost&quot;</span>).setPort(<span class="number">6379</span>).build() </span><br><span class="line">dataStream.addSink( <span class="keyword">new</span> <span class="type">RedisSink</span>[<span class="type">SensorReading</span>](conf, <span class="keyword">new</span> <span class="type">MyRedisMapper</span>) )</span><br></pre></td></tr></table></figure><h3 id="4-3-Elasticsearch">4.3 Elasticsearch</h3><ol><li>pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch6_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在主函数中调用</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> httpHosts = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">HttpHost</span>]()</span><br><span class="line">httpHosts.add(<span class="keyword">new</span> <span class="type">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> esSinkBuilder = <span class="keyword">new</span> <span class="type">ElasticsearchSink</span>.<span class="type">Builder</span>[<span class="type">SensorReading</span>]( httpHosts,<span class="keyword">new</span> <span class="type">ElasticsearchSinkFunction</span>[<span class="type">SensorReading</span>] &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(t: <span class="type">SensorReading</span>, runtimeContext: <span class="type">RuntimeContext</span>, requestIndexer: <span class="type">RequestIndexer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;saving data: &quot;</span> + t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> json = <span class="keyword">new</span> util.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]() json.put(<span class="string">&quot;data&quot;</span>, t.toString)</span><br><span class="line"><span class="keyword">val</span> indexRequest = <span class="type">Requests</span>.indexRequest().index(<span class="string">&quot;sensor&quot;</span>).`<span class="class"><span class="keyword">type</span>`(<span class="params">&quot;readingData&quot;</span>).<span class="title">source</span>(<span class="params">json</span>)</span></span><br><span class="line">requestIndexer.add(indexRequest)</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;saved successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line">dataStream.addSink( esSinkBuilder.build() )</span><br></pre></td></tr></table></figure><h3 id="4-4-JDBC自定义sink">4.4 JDBC自定义sink</h3><ol><li>pom依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加 MyJdbcSink</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJdbcSink</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>[<span class="type">SensorReading</span>]</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> conn: <span class="type">Connection</span> = _</span><br><span class="line"><span class="keyword">var</span> insertStmt: <span class="type">PreparedStatement</span> = _</span><br><span class="line"><span class="keyword">var</span> updateStmt: <span class="type">PreparedStatement</span> = _</span><br><span class="line"></span><br><span class="line"><span class="comment">// open 主要是创建连接</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>.open(parameters)</span><br><span class="line"></span><br><span class="line">conn = <span class="type">DriverManager</span>.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>,<span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">insertStmt = conn.prepareStatement(<span class="string">&quot;INSERT INTO temperatures (sensor, temp) VALUES (?, ?)&quot;</span>)</span><br><span class="line">updateStmt = conn.prepareStatement(<span class="string">&quot;UPDATE temperatures SET temp = ? WHERE sensor = ?&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用连接，执行sql</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invoke</span></span>(value: <span class="type">SensorReading</span>, context: <span class="type">SinkFunction</span>.<span class="type">Context</span>[_]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">updateStmt.setDouble(<span class="number">1</span>, value.temperature)</span><br><span class="line">updateStmt.setString(<span class="number">2</span>, value.id)</span><br><span class="line"></span><br><span class="line">updateStmt.execute()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (updateStmt.getUpdateCount == <span class="number">0</span>) &#123;</span><br><span class="line">insertStmt.setString(<span class="number">1</span>, value.id)</span><br><span class="line">insertStmt.setDouble(<span class="number">2</span>, value.temperature)</span><br><span class="line">insertStmt.execute()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">insertStmt.close()</span><br><span class="line">updateStmt.close()</span><br><span class="line">conn.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 main 方法中增加</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataStream.addSink(<span class="keyword">new</span> <span class="type">MyJdbcSink</span>())</span><br></pre></td></tr></table></figure><h1 id="六、Flink中的Window">六、Flink中的Window</h1><h2 id="1-Window概述">1. Window概述</h2><ol><li>简介<br>streaming 流式计算是一种被设计用于处理无限数据集的数据处理引擎，而无限数据集是指一种不断增长的本质上无限的数据集， 而 window 是一种<strong>切割无限数据为有限块进行处理</strong>的手段。<br>Window 是无限数据流处理的核心，可以将一个无限的 stream 拆分成有限大小的” buckets” 桶， 我们可以在这些桶上做计算操作。</li><li>为什么需要Window？<br>在流处理应用中，数据是连续不断的，有时我们需要做一些聚合类的处理，例如：在过去的1分钟内有多少用户点击了我们的网页。<br>在这种情况下，我们必须定义一个窗口(window)，用来收集最近1分钟内的数据，并对这个窗口内的数据进行计算。</li></ol><h2 id="2-Window的分类">2. Window的分类</h2><h3 id="2-1-按照time和count分类">2.1 按照time和count分类</h3><p><strong>time-window</strong>:时间窗口，根据时间划分窗口,如:每xx分钟统计最近xx分钟的数据。<br><strong>count-window</strong>:数量窗口，根据数量划分窗口,如:每xx个数据统计最近xx个数据。<br><img src="https://img-blog.csdnimg.cn/20210514102329841.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-2-按照side和size分类">2.2 按照side和size分类</h3><p>窗口有两个重要的属性: 窗口大小size和滑动间隔slide,根据它们的大小关系可分为：<br><img src="https://img-blog.csdnimg.cn/20210514102446708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>tumbling-window</strong>:滚动窗口，size=slide,如:每隔10s统计最近10s的数据<br><strong><font color=red>特点</font></strong>：时间对齐，窗口长度固定，没有重叠<br><strong><font color=red>适用场景</font></strong>：适合做 BI 统计等（做每个时间段的聚合计算）<br><img src="https://img-blog.csdnimg.cn/20210514102627862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>sliding-window</strong>:滑动窗口，size&gt;slide,如:每隔5s统计最近10s的数据<br><strong><font color=red>特点</font></strong>：时间对齐，窗口长度固定，可以有重叠<br><strong><font color=red>适用场景</font></strong>：对最近一个时间段内的统计（求某接口最近 5min 的失败率来决定是 否要报警）<br><img src="https://img-blog.csdnimg.cn/2021051410403539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>session-windows</strong>：会话窗口，size=slide,如:每隔10s统计最近10s的数据<br><strong><font color=red>特点</font></strong>：时间无对齐<br>session 窗口分配器通过 session 活动来对元素进行分组，session 窗口跟滚动窗 口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况，相反，当它 在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关 闭。一个 session 窗口通过一个 session 间隔来配置，这个 session 间隔定义了非活跃 周期的长度，当这个非活跃周期产生，那么当前的 session 将关闭并且后续的元素将 被分配到新的 session 窗口中去</p><p><strong><font color=red>注意</font></strong>：当size&lt;slide的时候,如每隔15s统计最近10s的数据,那么中间5s的数据会丢失,所有开发中不用</p><h3 id="2-3-总结">2.3 总结</h3><p>按照上面窗口的分类方式进行组合,可以得出如下的窗口:</p><ol><li>基于时间的滚动窗口tumbling-time-window——用的较多</li><li>基于时间的滑动窗口sliding-time-window——用的较多</li><li>基于数量的滚动窗口tumbling-count-window——用的较少</li><li>基于数量的滑动窗口sliding-count-window——用的较少</li></ol><p><strong><font color=red>注意</font></strong>：Flink还支持一个特殊的窗口:Session会话窗口,需要设置一个会话超时时间,如30s,则表示30s内没有数据到来,则触发上个窗口的计算</p><h2 id="3-Window-API">3. Window API</h2><h3 id="3-1-TimeWindow">3.1 TimeWindow</h3><p>TimeWindow 是将指定时间范围内的所有数据组成一个 window， 一次对一个window 里面的所有数据进行计算。</p><h4 id="3-1-1-滚动窗口">3.1.1 滚动窗口</h4><p>Flink 默认的时间窗口根据 Processing Time 进行窗口的划分，将 Flink 获取到的数据根据进入 Flink 的时间划分到不同的窗口中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow = dataStream</span><br><span class="line">.map(r =&gt; (r.id, r.temperature))</span><br><span class="line">.keyBy(_._1)</span><br><span class="line">.timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>))</span><br><span class="line">.reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</span><br></pre></td></tr></table></figure><p>时间间隔可以通过 <strong>Time.milliseconds(x)</strong>，<strong>Time.seconds(x)</strong>，<strong>Time.minutes(x)</strong> 等其中的一个来指定。</p><h4 id="3-1-2-滑动窗口">3.1.2 滑动窗口</h4><p>滑动窗口和滚动窗口的函数名是完全一致的， 只是在传参数时需要传入两个参数， 一个是 window_size， 一个是 sliding_size。</p><ul><li>下面代码中的 sliding_size 设置为了 5s，也就是说，每 5s 就计算输出结果一次， 每一次计算的 window 范围是 15s 内的所有元素：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = dataStream</span><br><span class="line">.map(r =&gt; (r.id, r.temperature))</span><br><span class="line">.keyBy(_._1)</span><br><span class="line">.timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>), <span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">.reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// .window(SlidingEventTimeWindows.of(Time.seconds(15),Time.sec onds(5))</span></span><br></pre></td></tr></table></figure><p>时间间隔可以通过 <strong>Time.milliseconds(x)</strong>，<strong>Time.seconds(x)</strong>，<strong>Time.minutes(x)</strong> 等其中的一个来指定。</p><h3 id="3-2-CountWindow">3.2 CountWindow</h3><p>CountWindow 根据窗口中相同 key 元素的数量来触发执行， 执行时只计算元素数量达到窗口大小的 key 对应的结果。<br><strong><font color=red>注：</font></strong> CountWindow 的 window_size 指的是相同 Key 的元素的个数，不是输入的所有元素的总数。</p><h4 id="3-2-1-滚动窗口">3.2.1 滚动窗口</h4><p>默认的 CountWindow 是一个滚动窗口，只需要指定窗口大小即可，当元素数量达到窗口大小时， 就会触发窗口的执行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = dataStream</span><br><span class="line">.map(r =&gt; (r.id, r.temperature))</span><br><span class="line">.keyBy(_._1)</span><br><span class="line">.countWindow(<span class="number">5</span>)</span><br><span class="line">.reduce((r1, r2) =&gt; (r1._1, r1._2.max(r2._2)))</span><br></pre></td></tr></table></figure><h4 id="3-2-2-滑动窗口">3.2.2 滑动窗口</h4><p>滑动窗口和滚动窗口的函数名是完全一致的， 只是在传参数时需要传入两个参数， 一个是 window_size， 一个是 sliding_size。</p><ul><li>下面代码中的 sliding_size 设置为了 2， 也就是说， 每收到两个相同 key 的数据就计算一次， 每一次计算的 window 范围是 10 个元素：</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> keyedStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = dataStream.map(r =&gt; (r.id,r.temperature)).keyBy(<span class="number">0</span>)</span><br><span class="line"><span class="comment">//每当某一个key 的个数达到2 的时候,触发计算，计算最近该key 最近10 个元素的内容</span></span><br><span class="line"><span class="keyword">val</span> windowedStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">GlobalWindow</span>] = keyedStream.countWindow(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> sumDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = windowedStream.sum(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="3-3-window-function">3.3 window function</h3><p>window function 定义了要对窗口中收集的数据做的计算操作，主要可以分为两类：</p><ul><li>增量聚合函数（ incremental aggregation functions）<ul><li>每条数据到来就进行计算， 保持一个简单的状态</li><li>典型的增量聚合函数有ReduceFunction, AggregateFunction</li></ul></li><li>全窗口函数（ full window functions）<ul><li>先把窗口所有数据收集起来， 等到计算的时候会遍历所有数据</li><li>ProcessWindowFunction 就是一个全窗口函数</li></ul></li></ul><h3 id="3-4-其他API">3.4 其他API</h3><ul><li>.trigger() —— 触发器<ul><li>定义 window 什么时候关闭， 触发计算并输出结果</li></ul></li><li>.evitor() —— 移除器<ul><li>定义移除某些数据的逻辑</li></ul></li><li>.allowedLateness() —— 允许处理迟到的数据</li><li>.sideOutputLateData() —— 将迟到的数据放入侧输出流</li><li>.getSideOutput() —— 获取侧输出流<br><img src="https://img-blog.csdnimg.cn/2021051414553022.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><h1 id="七、时间语义与Wartermark">七、时间语义与Wartermark</h1><h2 id="1-Flink中的时间语义">1. Flink中的时间语义</h2><p>在Flink的流式处理中，会涉及到时间的不同概念，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210517094220598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Event Time</strong>： 是事件创建的时间。它通常由事件中的时间戳描述， 例如采集的日志数据中，每一条日志都会记录自己的生成时间，Flink 通过时间戳分配器访问事件时间戳。<br><strong>Ingestion Time</strong>： 是数据进入 Flink 的时间。<br><strong>Processing Time</strong>： 是每一个执行基于时间操作的算子的本地系统时间， 与机器相关， 默认的时间属性就是 Processing Time。</p><h2 id="2-EventTime的重要性">2. EventTime的重要性</h2><p><strong>在 Flink 的流式处理中， 绝大部分的业务都会使用 eventTime</strong>， 一般只在eventTime 无法使用时， 才会被迫使用 ProcessingTime 或者 IngestionTime。<br>如果要使用 EventTime，那么需要引入 EventTime 的时间属性，引入方式如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="comment">// 从调用时刻开始给env 创建的每一个stream 追加时间特征</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br></pre></td></tr></table></figure><h2 id="3-Watermark">3. Watermark</h2><h3 id="3-1-基本概念">3.1 基本概念</h3><p>我们知道，流处理从事件产生，到流经 source，再到 operator，中间是有一个过程和时间的， 虽然大部分情况下， 流到 operator 的数据都是按照事件产生的时间顺序来的， 但是也不排除由于网络、分布式等原因， 导致乱序的产生， 所谓乱序， 就是指 Flink 接收到的事件的先后顺序不是严格按照事件的 Event Time 顺序排列的。<br><img src="https://img-blog.csdnimg.cn/20210517100326243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>那么此时出现一个问题，一旦出现乱序，如果只根据 eventTime 决定 window 的运行， 我们不能明确数据是否全部到位， 但又不能无限期的等下去， 此时必须要有个机制来保证一个特定的时间后， 必须触发 window 去进行计算了， 这个特别的机制， 就是 Watermark。</p><ul><li>Watermark 是一种衡量 Event Time 进展的机制。</li><li>Watermark 是用于处理乱序事件的， 而正确的处理乱序事件， 通常用Watermark 机制结合 window 来实现。</li><li>数据流中的 Watermark 用于表示 timestamp 小于 Watermark 的数据，都已经到达了， 因此， window 的执行也是由 Watermark 触发的。</li><li>Watermark 可以理解成一个延迟触发机制，我们可以设置 Watermark 的延时时长 t，每次系统会校验已经到达的数据中最大的 maxEventTime，然后认定 eventTime小于 maxEventTime - t 的所有数据都已经到达， 如果有窗口的停止时间等于maxEventTime – t， 那么这个窗口被触发执行。</li></ul><p>有序流的 Watermarker 如下图所示（ Watermark 设置为 0）：<img src="https://img-blog.csdnimg.cn/20210517100655646.png#pic_center" alt="在这里插入图片描述"><br>乱序流的 Watermarker 如下图所示（ Watermark 设置为 2）：<br><img src="https://img-blog.csdnimg.cn/20210517100742702.png#pic_center" alt="在这里插入图片描述"><br>当 Flink 接收到数据时， 会按照一定的规则去生成 Watermark， 这条 Watermark 就等于当前所有到达数据中的 maxEventTime - 延迟时长，也就是说，Watermark 是基于数据携带的时间戳生成的， 一旦 Watermark 比当前未触发的窗口的停止时间要晚， 那么就会触发相应窗口的执行。由于 event time 是由数据携带的， 因此， 如果运行过程中无法获取新的数据， 那么没有被触发的窗口将永远都不被触发。<br>上图中，我们设置的允许最大延迟到达时间为 2s，所以时间戳为 7s 的事件对应的 Watermark 是 5s， 时间戳为 12s 的事件的 Watermark 是 10s， 如果我们的窗口 1 是 1s~5s， 窗口 2 是 6s~10s， 那么时间戳为 7s 的事件到达时的 Watermarker 恰好触发窗口 1， 时间戳为 12s 的事件到达时的 Watermark 恰好触发窗口 2。<br>Watermark 就是触发前一窗口的“关窗时间”， 一旦触发关门那么以当前时刻为准在窗口范围内的所有所有数据都会收入窗中。<br>只要没有达到水位那么不管现实中的时间推进了多久都不会触发关窗。</p><h3 id="3-2-Watermark-的引入">3.2 Watermark 的引入</h3><p>watermark 的引入很简单， 对于乱序数据， 最常见的引用方式如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataStream.assignTimestampsAndWatermarks( <span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="type">Time</span>.milliseconds(<span class="number">1000</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">SensorReading</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">element.timestamp * <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure><p>Event Time 的使用一定要指定数据源中的时间戳。否则程序无法知道事件的事件时间是什么(数据源里的数据没有时间戳的话， 就只能使用 Processing Time 了)。我们看到上面的例子中创建了一个看起来有点复杂的类， 这个类实现的其实就是分配时间戳的接口。Flink 暴露了 TimestampAssigner 接口供我们实现， 使我们可以自定义如何从事件数据中抽取时间戳。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从调用时刻开始给env 创建的每一个stream 追加时间特性</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env</span><br><span class="line">.addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>)</span><br><span class="line">.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">MyAssigner</span>())</span><br></pre></td></tr></table></figure><p>MyAssigner 有两种类型</p><ul><li>AssignerWithPeriodicWatermarks</li><li>AssignerWithPunctuatedWatermarks</li></ul><p>以上两个接口都继承自 TimestampAssigner</p><h4 id="Assigner-with-periodic-watermarks">Assigner with periodic watermarks</h4><p>周期性的生成 watermark： 系统会周期性的将 watermark 插入到流中(水位线也是一种特殊的事件)。默认周期是 200 毫秒。可以使用ExecutionConfig.setAutoWatermarkInterval()方法进行设置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔 5 秒产生一个watermark</span></span><br><span class="line">env.getConfig.setAutoWatermarkInterval(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>产生 watermark 的逻辑： 每隔 5 秒钟， Flink 会调用<br>AssignerWithPeriodicWatermarks 的 getCurrentWatermark()方法。如果方法返回一个时间戳大于之前水位的时间戳， 新的 watermark 会被插入到流中。这个检查保证了水位线是单调递增的。如果方法返回的时间戳小于等于之前水位的时间戳，  则不会产生新的 watermark。<br><strong>例：自定义一个周期性的时间戳抽取</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicAssigner</span> <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"><span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span> <span class="comment">// 延时为1 分钟</span></span><br><span class="line"><span class="keyword">var</span> maxTs: <span class="type">Long</span> = <span class="type">Long</span>.<span class="type">MinValue</span> <span class="comment">// 观察到的最大时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Watermark</span>(maxTs - bound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>, previousTS: <span class="type">Long</span>) = &#123;</span><br><span class="line">maxTs = maxTs.max(r.timestamp)</span><br><span class="line">r.timestamp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种简单的特殊情况是， 如果我们事先得知数据流的时间戳是单调递增的， 也就是说没有乱序， 那我们可以使用 assignAscendingTimestamps， 这个方法会直接使用数据的时间戳生成 watermark。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> withTimestampsAndWatermarks = stream</span><br><span class="line">.assignAscendingTimestamps(e =&gt; e.timestamp)</span><br><span class="line"></span><br><span class="line">&gt;&gt; result:<span class="type">E</span>(<span class="number">1</span>), <span class="type">W</span>(<span class="number">1</span>), <span class="type">E</span>(<span class="number">2</span>), <span class="type">W</span>(<span class="number">2</span>), ...</span><br></pre></td></tr></table></figure><p>而对于乱序数据流， 如果我们能大致估算出数据流中的事件的最大延迟时间， 就可以使用如下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> withTimestampsAndWatermarks = stream.assignTimestampsAndWatermarks(</span><br><span class="line"><span class="keyword">new</span> <span class="type">SensorTimeAssigner</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorTimeAssigner</span> <span class="keyword">extends</span> <span class="title">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="params"><span class="type">Time</span>.seconds(5</span>)) </span>&#123;</span><br><span class="line"><span class="comment">// 抽取时间戳</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>): <span class="type">Long</span> = r.timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt; relust:<span class="type">E</span>(<span class="number">10</span>), <span class="type">W</span>(<span class="number">0</span>), <span class="type">E</span>(<span class="number">8</span>), <span class="type">E</span>(<span class="number">7</span>), <span class="type">E</span>(<span class="number">11</span>), <span class="type">W</span>(<span class="number">1</span>), ...</span><br></pre></td></tr></table></figure><h4 id="Assigner-with-punctuated-watermarks">Assigner with punctuated watermarks</h4><p>间断式地生成 watermark。和周期性生成的方式不同，这种方式不是固定时间的， 而是可以根据需要对每条数据进行筛选和处理。直接上代码来举个例子， 我们只给sensor_1 的传感器的数据流插入 watermark：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PunctuatedAssigner</span> <span class="keyword">extends</span> <span class="title">AssignerWithPunctuatedWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"><span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkAndGetNextWatermark</span></span>(r: <span class="type">SensorReading</span>, extractedTS: <span class="type">Long</span>): <span class="type">Watermark</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (r.id == <span class="string">&quot;sensor_1&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Watermark</span>(extractedTS - bound)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>, previousTS: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">r.timestamp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-EventTime-在window-中的使用">4. EventTime 在window 中的使用</h2><h3 id="4-1-滚动窗口（TumblingEventTimeWindows）">4.1 滚动窗口（TumblingEventTimeWindows）</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 环 境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>) env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>,<span class="number">7777</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithTsDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = dstream.map&#123;</span><br><span class="line">text =&gt;</span><br><span class="line"><span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">String</span>] = text.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithEventTimeDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = textWithTsDstream.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)](<span class="type">Time</span>.milliseconds(<span class="number">1000</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: (<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)): <span class="type">Long</span> = &#123;</span><br><span class="line"><span class="keyword">return</span>element._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textKeyStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = textWithEventTimeDstream.keyBy(<span class="number">0</span>)</span><br><span class="line">textKeyStream.print(<span class="string">&quot;textkey:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = textKeyStream.window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> groupDstream: <span class="type">DataStream</span>[mutable.<span class="type">HashSet</span>[<span class="type">Long</span>]] = windowStream.fold(<span class="keyword">new</span> mutable.<span class="type">HashSet</span>[<span class="type">Long</span>]()) &#123;</span><br><span class="line"><span class="keyword">case</span> (set, (key, ts, count)) =&gt;</span><br><span class="line">set += ts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">groupDstream.print(<span class="string">&quot;window::::&quot;</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">env.execute()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是按照 Event Time 的时间窗口计算得出的，而无关系统的时间（包括输入的快慢）。</p><h3 id="4-2-滑动窗口（SlidingEventTimeWindows）">4.2 滑动窗口（SlidingEventTimeWindows）</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 环 境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>,<span class="number">7777</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithTsDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = dstream.map &#123;</span><br><span class="line">text =&gt;</span><br><span class="line"><span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">String</span>] = text.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithEventTimeDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = textWithTsDstream.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)](<span class="type">Time</span>.milliseconds(<span class="number">1000</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: (<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)): <span class="type">Long</span> = &#123;</span><br><span class="line"><span class="keyword">return</span> element._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textKeyStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = textWithEventTimeDstream.keyBy(<span class="number">0</span>)</span><br><span class="line">textKeyStream.print(<span class="string">&quot;textkey:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = textKeyStream.window(<span class="type">SlidingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">2</span>),<span class="type">Time</span>.millis econds(<span class="number">500</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> groupDstream: <span class="type">DataStream</span>[mutable.<span class="type">HashSet</span>[<span class="type">Long</span>]] = windowStream.fold(<span class="keyword">new</span> mutable.<span class="type">HashSet</span>[<span class="type">Long</span>]()) &#123; </span><br><span class="line"><span class="keyword">case</span> (set, (key, ts, count)) =&gt;</span><br><span class="line">set += ts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">groupDstream.print(<span class="string">&quot;window::::&quot;</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">env.execute()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-会话窗口（EventTimeSessionWindows）">4.3 会话窗口（EventTimeSessionWindows）</h3><p>相邻两次数据的 EventTime 的时间差超过指定的时间间隔就会触发执行。如果加入 Watermark，会在符合窗口触发的情况下进行延迟，到达延迟水位再进行窗口触发。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 环 境</span></span><br><span class="line"><span class="keyword">val</span> env: <span class="type">StreamExecutionEnvironment</span> = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>) env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dstream: <span class="type">DataStream</span>[<span class="type">String</span>] = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>,<span class="number">7777</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithTsDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = dstream.map &#123;</span><br><span class="line">text =&gt;</span><br><span class="line"><span class="keyword">val</span> arr: <span class="type">Array</span>[<span class="type">String</span>] = text.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">(arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textWithEventTimeDstream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)] = textWithTsDstream.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)](<span class="type">Time</span>.milliseconds(<span class="number">1000</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: (<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>)): <span class="type">Long</span> = &#123;</span><br><span class="line"><span class="keyword">return</span>element._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> textKeyStream: <span class="type">KeyedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>] = textWithEventTimeDstream.keyBy(<span class="number">0</span>)</span><br><span class="line">textKeyStream.print(<span class="string">&quot;textkey:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> windowStream: <span class="type">WindowedStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>), <span class="type">Tuple</span>, <span class="type">TimeWindow</span>] = textKeyStream.window(<span class="type">EventTimeSessionWindows</span>.withGap(<span class="type">Time</span>.milliseconds(<span class="number">500</span>)))</span><br><span class="line"></span><br><span class="line">windowStream.reduce(</span><br><span class="line">(text1,text2) =&gt; (text1._1,<span class="number">0</span>L,text1._3+text2._3)</span><br><span class="line">) .map(_._3).print(<span class="string">&quot;windows:::&quot;</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">env.execute()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、ProcessFunction-API（底层-API）">八、ProcessFunction API（底层 API）</h1><p>我们之前学习的<strong>转换算子</strong>是无法访问事件的时间戳信息和水位线信息的。而这  在一些应用场景下， 极为重要。例如 MapFunction 这样的 map 转换算子就无法访问时间戳或者当前事件的事件时间。<br>基于此， DataStream API 提供了一系列的 Low-Level 转换算子。可以<strong>访问时间戳、watermark 以及注册定时事件</strong>。还可以输出<strong>特定的一些事件</strong>，例如超时事件等。Process Function 用来构建事件驱动的应用以及实现自定义的业务逻辑(使用之前的window 函数和转换算子无法实现)。例如， Flink SQL 就是使用 Process Function 实现的。<br>Flink 提供了 8 个 Process Function：</p><ul><li>ProcessFunction</li><li>KeyedProcessFunction</li><li>CoProcessFunction</li><li>ProcessJoinFunction</li><li>BroadcastProcessFunction</li><li>KeyedBroadcastProcessFunction</li><li>ProcessWindowFunction</li><li>ProcessAllWindowFunction</li></ul><h2 id="1-KeyedProcessFunction">1. KeyedProcessFunction</h2><p>KeyedProcessFunction 用来操作 KeyedStream。KeyedProcessFunction 会处理流的每一个元素，输出为 0 个、1 个或者多个元素。所有的 Process Function 都继承自RichFunction 接口， 所以都有 open()、close()和 getRuntimeContext()等方法。而KeyedProcessFunction[KEY, IN, OUT] 还额外提供了两个方法：</p><ul><li>processElement(v: IN, ctx: Context, out: Collector[OUT]), 流中的每一个元素都会调用这个方法， 调用结果将会放在 Collector 数据类型中输出。Context 可以访问元素的时间戳，元素的 key，以及 TimerService 时间服务。Context 还可以将结果输出到别的流(side outputs)。</li><li>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])是一个回调函数。当之前注册的定时器触发时调用。参数 timestamp 为定时器所设定的触发的时间戳。Collector 为输出结果的集合。OnTimerContext 和processElement 的 Context 参数一样，提供了上下文的一些信息，例如定时器触发的时间信息(事件时间或者处理时间)。</li></ul><h2 id="2-TimerService-和-定时器（Timers）">2. TimerService 和 定时器（Timers）</h2><p>Context 和 OnTimerContext 所持有的 TimerService 对象拥有以下方法:</p><ul><li>currentProcessingTime(): Long 返回当前处理时间</li><li>currentWatermark(): Long 返回当前 watermark 的时间戳</li><li>registerProcessingTimeTimer(timestamp: Long): Unit 会注册当前 key 的 processing time 的定时器。当 processing time 到达定时时间时， 触发 timer</li><li>registerEventTimeTimer(timestamp: Long): Unit 会注册当前 key 的 event time 定时器。当水位线大于等于定时器注册的时间时，触发定时器执行回调函数</li><li>deleteProcessingTimeTimer(timestamp: Long): Unit 删除之前注册处理时间定时器。如果没有这个时间戳的定时器， 则不执行</li><li>deleteEventTimeTimer(timestamp: Long): Unit 删除之前注册的事件时间定时器， 如果没有此时间戳的定时器， 则不执行</li></ul><p>当定时器 timer 触发时， 会执行回调函数 onTimer()。注意定时器 timer 只能在keyed streams 上面使用。<br>下面举个例子说明 KeyedProcessFunction 如何操作 KeyedStream。</p><ul><li>需求： 监控温度传感器的温度值， 如果温度值在一秒钟之内(processing time)连续上升， 则报警。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> warnings = readings</span><br><span class="line">.keyBy(_.id)</span><br><span class="line">.process(<span class="keyword">new</span> <span class="type">TempIncreaseAlertFunction</span>)</span><br></pre></td></tr></table></figure><p>看一下 TempIncreaseAlertFunction 如何实现, 程序中使用了 ValueState 这样一个 状态变量</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempIncreaseAlertFunction</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存上一个传感器温度值</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> lastTemp: <span class="type">ValueState</span>[<span class="type">Double</span>] = getRuntimeContext.getState(</span><br><span class="line"><span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Double</span>](<span class="string">&quot;lastTemp&quot;</span>, <span class="type">Types</span>.of[<span class="type">Double</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存注册的定时器的时间戳</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> currentTimer: <span class="type">ValueState</span>[<span class="type">Long</span>] = getRuntimeContext.getState(</span><br><span class="line"><span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Long</span>](<span class="string">&quot;timer&quot;</span>, <span class="type">Types</span>.of[<span class="type">Long</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(r: <span class="type">SensorReading</span>,</span><br><span class="line">ctx: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>]#<span class="type">Context</span>,</span><br><span class="line">out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 取出上一次的温度</span></span><br><span class="line"><span class="keyword">val</span> prevTemp = lastTemp.value()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前温度更新到上一次的温度这个变量中</span></span><br><span class="line">lastTemp.update(r.temperature)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> curTimerTimestamp = currentTimer.value()</span><br><span class="line"><span class="keyword">if</span> (prevTemp == <span class="number">0.0</span> || r.temperature &lt; prevTemp) &#123;</span><br><span class="line"><span class="comment">// 温度下降或者是第一个温度值，删除定时器</span></span><br><span class="line">ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp)</span><br><span class="line"><span class="comment">// 清空状态变量</span></span><br><span class="line">currentTimer.clear()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 温度上升且我们并没有设置定时器</span></span><br><span class="line"><span class="keyword">val</span> timerTs = ctx.timerService().currentProcessingTime() + <span class="number">1000</span> ctx.timerService().registerProcessingTimeTimer(timerTs)</span><br><span class="line">currentTimer.update(timerTs)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onTimer</span></span>(ts: <span class="type">Long</span>,</span><br><span class="line">ctx: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>]#<span class="type">OnTimerContext</span>,</span><br><span class="line">out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">out.collect(<span class="string">&quot;传感器 id 为: &quot;</span> + ctx.getCurrentKey + <span class="string">&quot;的传感器温度值已经连续 1s 上升了。&quot;</span>)</span><br><span class="line">currentTimer.clear()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-侧输出流（SideOutput）">3. 侧输出流（SideOutput）</h2><p>大部分的 DataStream API 的算子的输出是单一输出，也就是某种数据类型的流。除了 split 算子， 可以将一条流分成多条流， 这些流的数据类型也都相同。process function 的 side outputs 功能可以产生多条流， 并且这些流的数据类型可以不一样。一个 side output 可以定义为 OutputTag[X]对象， X 是输出流的数据类型。process function 可以通过 Context 对象发射一个事件到一个或者多个 side outputs。<br>下面是一个示例程序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> monitoredReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = readings.process(<span class="keyword">new</span> <span class="type">FreezingMonitor</span>)</span><br><span class="line"></span><br><span class="line">monitoredReadings</span><br><span class="line">.getSideOutput(<span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">&quot;freezing-alarms&quot;</span>))</span><br><span class="line">.print()</span><br><span class="line"></span><br><span class="line">readings.print()</span><br></pre></td></tr></table></figure><p>接下来我们实现 FreezingMonitor 函数，用来监控传感器温度值，将温度值低于32F 的温度输出到 side output</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreezingMonitor</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个侧输出标签</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> freezingAlarmOutput: <span class="type">OutputTag</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">&quot;freezing-alarms&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(r: <span class="type">SensorReading</span>,</span><br><span class="line">ctx: <span class="type">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 温度在32F 以下时，输出警告信息</span></span><br><span class="line"><span class="keyword">if</span> (r.temperature &lt; <span class="number">32.0</span>) &#123;</span><br><span class="line">ctx.output(freezingAlarmOutput, <span class="string">s&quot;Freezing Alarm for <span class="subst">$&#123;r.id&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有数据直接常规输出到主流</span></span><br><span class="line">out.collect(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-CoProcessFunction">4. CoProcessFunction</h2><p>对于两条输入流， DataStream API 提供了 CoProcessFunction 这样的 low-level 操作。CoProcessFunction 提供了操作每一个输入流的方法: processElement1()和processElement2()。<br>类似于 ProcessFunction， 这两种方法都通过 Context 对象来调用。这个 Context 对象可以访问事件数据， 定时器时间戳， TimerService， 以及 side outputs。<br>CoProcessFunction 也提供了 onTimer()回调函数。</p><h1 id="九、状态编程和容错机制">九、状态编程和容错机制</h1><p>流式计算分为无状态和有状态两种情况。无状态的计算观察每个独立事件， 并根据最后一个事件输出结果。例如， 流处理应用程序从传感器接收温度读数， 并在温度超过 90 度时发出警告。有状态的计算则会基于多个事件输出结果。以下是一些例子：</p><ul><li>所有类型的窗口。例如， 计算过去一小时的平均温度，就是有状态的计算</li><li>所有用于复杂事件处理的状态机。例如，若在一分钟内收到两个相差 20 度以上的温度读数， 则发出警告， 这是有状态的计算</li><li>流与流之间的所有关联操作， 以及流与静态表或动态表之间的关联操作， 都是有状态的计算</li></ul><p>下图展示了无状态流处理和有状态流处理的主要区别。无状态流处理分别接收每条数据记录(图中的黑条)，然后根据最新输入的数据生成输出数据(白条)；有状态流处理会维护状态(根据每条输入记录进行更新)， 并基于最新输入的记录和当前的状态值生成输出记录(灰条)<br><img src="https://img-blog.csdnimg.cn/20210519104814423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上图中输入数据由黑条表示。无状态流处理每次只转换一条输入记录， 并且仅根据最新的输入记录输出结果(白条)。有状态流处理维护所有已处理记录的状态值， 并根据每条新输入的记录更新状态，因此输出记录(灰条)反映的是综合考虑多个事件之后的结果。<br>尽管无状态的计算很重要， 但是流处理对有状态的计算更感兴趣。事实上， 正确地实现有状态的计算比实现无状态的计算难得多。旧的流处理系统并不支持有状 态的计算， 而新一代的流处理系统则将状态及其正确性视为重中之重。</p><h2 id="1-有状态的算子和应用程序">1. 有状态的算子和应用程序</h2><p>Flink 内置的很多算子，数据源 source，数据存储 sink 都是有状态的，流中的数据都是 buffer records，会保存一定的元素或者元数据。例如: ProcessWindowFunction 会缓存输入流的数据， ProcessFunction 会保存设置的定时器信息等等。<br>在 Flink 中， 状态始终与特定算子相关联。总的来说， 有两种类型的状态：</p><ul><li>算子状态（ operator state）</li><li>键控状态（ keyed state）</li></ul><h3 id="1-1-算子状态（operator-state）">1.1 算子状态（operator state）</h3><p>算子状态的作用范围限定为算子任务。这意味着由同一并行任务所处理的所有数据都可以访问到相同的状态，  状态对于同一任务而言是共享的。算子状态不能由相同或不同算子的另一个任务访问。<br><img src="https://img-blog.csdnimg.cn/20210519105207400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 为算子状态提供三种基本数据结构：</p><ul><li>列表状态（List state）<ul><li>将状态表示为一组数据的列表</li></ul></li><li>联合列表状态（Union list state）<ul><li>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保 存点（savepoint）启动应用程序时如何恢复</li></ul></li><li>广播状态（Broadcast state）<ul><li>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态</li></ul></li></ul><h3 id="1-2-键控状态（keyed-state）">1.2 键控状态（keyed state）</h3><p>键控状态是根据输入数据流中定义的键（key）来维护和访问的。Flink 为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个 key 对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的 key。因此，具有相同 key 的所有数据都会访问相同的状态。Keyed State 很类似于一个分布式的 key-value map 数据结构，只能用于 KeyedStream（ keyBy 算子处理之后）<br><img src="https://img-blog.csdnimg.cn/20210519105522865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 的 Keyed State 支持以下数据类型：</p><ul><li>ValueState[T]保存单个的值，值的类型为 T<ul><li>get 操作: ValueState.value()</li><li>set 操作: ValueState.update(value: T)</li></ul></li><li>ListState[T]保存一个列表，列表里的元素的数据类型为 T。基本操作如下：<ul><li>ListState.add(value: T)</li><li>ListState.addAll(values: java.util.List[T])</li><li>oListState.get() 返回 Iterable[T]</li><li>ListState.update(values: java.util.List[T])</li></ul></li><li>MapState[K, V]保存 Key-Value 对<ul><li>MapState.get(key: K)</li><li>MapState.put(key: K, value: V)</li><li>MapState.contains(key: K)</li><li>MapState.remove(key: K)</li></ul></li><li>ReducingState[T]</li><li>AggregatingState[I, O]</li></ul><p>State.clear()是清空操作</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sensorData: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> keyedData: <span class="type">KeyedStream</span>[<span class="type">SensorReading</span>, <span class="type">String</span>] = sensorData.keyBy(_.id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> alerts: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)] = keyedData</span><br><span class="line">.flatMap(<span class="keyword">new</span> <span class="type">TemperatureAlertFunction</span>(<span class="number">1.7</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureAlertFunction</span>(<span class="params">val threshold: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>[<span class="type">SensorReading</span>, (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)] </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> lastTempState: <span class="type">ValueState</span>[<span class="type">Double</span>] = _</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lastTempDescriptor = <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Double</span>](<span class="string">&quot;lastTemp&quot;</span>, classOf[<span class="type">Double</span>])</span><br><span class="line"></span><br><span class="line">lastTempState = getRuntimeContext.getState[<span class="type">Double</span>](lastTempDescriptor)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(reading: <span class="type">SensorReading</span>,</span><br><span class="line">out: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lastTemp = lastTempState.value()</span><br><span class="line"><span class="keyword">val</span> tempDiff = (reading.temperature - lastTemp).abs</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tempDiff &gt; threshold) &#123;</span><br><span class="line">out.collect((reading.id, reading.temperature, tempDiff))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.lastTempState.update(reading.temperature)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 RuntimeContext 注册 StateDescriptor。StateDescriptor 以状态 state 的名字和存储的数据类型为参数。<br>在 open()方法中创建 state 变量。注意复习之前的 RichFunction 相关知识。<br>接下来我们使用了 FlatMap with keyed ValueState 的快捷方式 flatMapWithState 实现以上需求：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> alerts: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)] = keyedSensorData</span><br><span class="line">.flatMapWithState[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>), <span class="type">Double</span>] &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (in: <span class="type">SensorReading</span>, <span class="type">None</span>) =&gt;</span><br><span class="line">(<span class="type">List</span>.empty, <span class="type">Some</span>(in.temperature))</span><br><span class="line"><span class="keyword">case</span> (r: <span class="type">SensorReading</span>, lastTemp: <span class="type">Some</span>[<span class="type">Double</span>]) =&gt;</span><br><span class="line"><span class="keyword">val</span> tempDiff = (r.temperature - lastTemp.get).abs</span><br><span class="line"><span class="keyword">if</span> (tempDiff &gt; <span class="number">1.7</span>) &#123;</span><br><span class="line">(<span class="type">List</span>((r.id, r.temperature, tempDiff)), <span class="type">Some</span>(r.temperature))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">(<span class="type">List</span>.empty, <span class="type">Some</span>(r.temperature))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-状态一致性">2. 状态一致性</h2><p>当在分布式系统中引入状态时， 自然也引入了一致性问题。一致性实际上是&quot; 正确性级别&quot;的另一种说法，也就是说在成功处理故障并恢复之后得到的结果，与没  有发生任何故障时得到的结果相比， 前者到底有多正确？ 举例来说， 假设要对最近一小时登录的用户计数。在系统经历故障之后， 计数结果是多少？ 如果有偏差， 是有漏掉的计数还是重复计数？</p><h3 id="2-1-一致性级别">2.1 一致性级别</h3><p>在流处理中， 一致性可以分为 3 个级别：</p><ul><li>at-most-once: 这其实是没有正确性保障的委婉说法——故障发生之后， 计数结果可能丢失。同样的还有 udp</li><li>at-least-once: 这表示计数结果可能大于正确值， 但绝不会小于正确值。也就是说， 计数程序在发生故障后可能多算， 但是绝不会少算</li><li>exactly-once: 这指的是系统保证在发生故障后得到的计数结果与正确值一致</li></ul><p>曾经， at-least-once 非常流行。第一代流处理器(如 Storm 和 Samza)刚问世时只保证 at-least-once， 原因有二：</p><ul><li>保证 exactly-once 的系统实现起来更复杂。这在基础架构层(决定什么代表正确， 以及 exactly-once 的范围是什么)和实现层都很有挑战性</li><li>流处理系统的早期用户愿意接受框架的局限性， 并在应用层想办法弥补(例如使应用程序具有幂等性， 或者用批量计算层再做一遍计算)</li></ul><p>最先保证 exactly-once 的系统(Storm Trident 和 Spark Streaming)在性能和表现力这两个方面付出了很大的代价。为了保证 exactly-once，这些系统无法单独地对每条记录运用应用逻辑， 而是同时处理多条(一批)记录， 保证对每一批的处理要么全部成功，要么全部失败。这就导致在得到结果前，必须等待一批记录处理结束。因此，  用户经常不得不使用两个流处理框架(一个用来保证 exactly-once， 另一个用来对每个元素做低延迟处理)， 结果使基础设施更加复杂。曾经， 用户不得不在保证exactly-once 与获得低延迟和效率之间权衡利弊。Flink 避免了这种权衡。<br>Flink 的一个重大价值在于，<strong>它既保证了 exactly-once， 也具有低延迟和高吞吐的处理能力</strong>。<br>从根本上说，Flink 通过使自身满足所有需求来避免权衡，它是业界的一次意义重大的技术飞跃。尽管这在外行看来很神奇， 但是一旦了解， 就会恍然大悟。</p><h3 id="2-2-端到端（end-to-end）状态一致性">2.2 端到端（end-to-end）状态一致性</h3><p>目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在 Flink 流处理器内部保证的； 而在真实应用中， 流处理应用除了流处理器以外还包含了数据源（ 例如 Kafka） 和输出到持久化系统。<br>端到端的一致性保证， 意味着结果的正确性贯穿了整个流处理应用的始终； 每一个组件都保证了它自己的一致性，  整个端到端的一致性级别取决于所有组件中一致性最弱的组件。具体可以划分如下：</p><ul><li>内部保证 —— 依赖 checkpoint</li><li>source 端 —— 需要外部源可重设数据的读取位置</li><li>sink 端 —— 需要保证从故障恢复时， 数据不会重复写入外部系统</li></ul><p>而对于 sink 端， 又有两种具体的实现方式： 幂等（ Idempotent） 写入和事务性（ Transactional） 写入。</p><ul><li>幂等写入<ul><li>所谓幂等操作，是说一个操作，可以重复执行很多次，但只导致一次结果更改，  也就是说， 后面再重复执行就不起作用了</li></ul></li><li>事务写入<ul><li>需要构建事务来写入外部系统，构建的事务对应着 checkpoint，等到 checkpoint 真正完成的时候， 才把所有对应的结果写入 sink 系统中</li></ul></li></ul><p>对于事务性写入， 具体又有两种实现方式： 预写日志（ WAL） 和两阶段提交（ 2PC）。DataStream API 提供了 GenericWriteAheadSink 模板类和 TwoPhaseCommitSinkFunction 接口， 可以方便地实现这两种方式的事务性写入。<br>不同 Source 和 Sink 的一致性保证可以用下表说明：<br><img src="https://img-blog.csdnimg.cn/20210519111516235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="3-检查点（checkpoint）">3. 检查点（checkpoint）</h2><p>Flink 具体如何保证 exactly-once 呢? 它使用一种被称为&quot;检查点&quot;（checkpoint）的特性，在出现故障时将系统重置回正确状态。下面通过简单的类比来解释检查点 的作用。<br>假设你和两位朋友正在数项链上有多少颗珠子，如下图所示。你捏住珠子，边数边拨，每拨过一颗珠子就给总数加一。你的朋友也这样数他们手中的珠子。当你分神忘记数到哪里时，怎么办呢? 如果项链上有很多珠子，你显然不想从头再数一 遍，尤其是当三人的速度不一样却又试图合作的时候，更是如此(比如想记录前一分钟三人一共数了多少颗珠子，回想一下一分钟滚动窗口)。<br><img src="https://img-blog.csdnimg.cn/20210519111950813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>于是，你想了一个更好的办法：在项链上每隔一段就松松地系上一根有色皮筋，将珠子分隔开；当珠子被拨动的时候，皮筋也可以被拨动； 然后，你安排一个助手， 让他在你和朋友拨到皮筋时记录总数。用这种方法，当有人数错时，就不必从头开始数。相反，你向其他人发出错误警示，然后你们都从上一根皮筋处开始重数，助手则会告诉每个人重数时的起始数值，例如在粉色皮筋处的数值是多少。<br>Flink 检查点的作用就类似于皮筋标记。数珠子这个类比的关键点是：对于指定的皮筋而言，珠子的相对位置是确定的;  这让皮筋成为重新计数的参考点。总状态(珠子的总数)在每颗珠子被拨动之后更新一次，助手则会保存与每根皮筋对应的检查点状态，如当遇到粉色皮筋时一共数了多少珠子，当遇到橙色皮筋时又是多少。当问题出现时，这种方法使得重新计数变得简单。</p><h3 id="3-1-Flink的检查点算法">3.1 Flink的检查点算法</h3><p>Flink 检查点的核心作用是确保状态正确，即使遇到程序中断，也要正确。记住 这一基本点之后，我们用一个例子来看检查点是如何运行的。Flink 为用户提供了用 来定义状态的工具。例如，以下这个 Scala 程序按照输入记录的第一个字段(一个字 符串)进行分组并维护第二个字段的计数状态。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = ... </span><br><span class="line"><span class="keyword">val</span> counts: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = stream</span><br><span class="line">.keyBy(record =&gt; record._1)</span><br><span class="line">.mapWithState((in: (<span class="type">String</span>, <span class="type">Int</span>), state: <span class="type">Option</span>[<span class="type">Int</span>])=&gt; </span><br><span class="line">state <span class="keyword">match</span> &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="type">Some</span>(c) =&gt; ( (in._1, c + in._2), <span class="type">Some</span>(c + in._2) ) </span><br><span class="line"><span class="keyword">case</span> <span class="type">None</span> =&gt; ( (in._1, in._2), <span class="type">Some</span>(in._2) )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该程序有两个算子: keyBy 算子用来将记录按照第一个元素(一个字符串)进行分 组，根据该 key 将数据进行重新分区，然后将记录再发送给下一个算子: 有状态的 map 算子(mapWithState)。map 算子在接收到每个元素后，将输入记录的第二个字段 的数据加到现有总数中，再将更新过的元素发射出去。下图表示程序的初始状态: 输 入流中的 6 条记录被检查点分割线(checkpoint barrier)隔开，所有的 map 算子状态均为 0(计数还未开始)。所有 key 为 a 的记录将被顶层的 map 算子处理，所有 key 为 b 的记录将被中间层的 map 算子处理，所有 key 为 c 的记录则将被底层的 map 算子处理。<br><img src="https://img-blog.csdnimg.cn/20210519112714781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="按 key 累加计数程序初始状态"><br>上图是程序的初始状态。注意，a、b、c 三组的初始计数状态都是 0，即三个圆 柱上的值。ckpt 表示检查点分割线（checkpoint barriers）。每条记录在处理顺序上 严格地遵守在检查点之前或之后的规定，例如[“b”,2]在检查点之前被处理，[“a”,2] 则在检查点之后被处理。<br>当该程序处理输入流中的 6 条记录时，涉及的操作遍布 3 个并行实例(节点、CPU 内核等)。那么，检查点该如何保证 exactly-once 呢?<br>检查点分割线和普通数据记录类似。它们由算子处理，但并不参与计算，而是 会触发与检查点相关的行为。当读取输入流的数据源(在本例中与 keyBy 算子内联) 遇到检查点屏障时，它将其在输入流中的位置保存到持久化存储中。如果输入流来 自消息传输系统(Kafka)，这个位置就是偏移量。Flink 的存储机制是插件化的，持久 化存储可以是分布式文件系统，如 HDFS。下图展示了这个过程（遇到 checkpoint barrier 时， 保存其在输入流中的位置）<br><img src="https://img-blog.csdnimg.cn/20210519113405164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当 Flink 数据源(在本例中与 keyBy 算子内联)遇到检查点分界线（barrier）时， 它会将其在输入流中的位置保存到持久化存储中。这让 Flink 可以根据该位置重启。<br>检查点像普通数据记录一样在算子之间流动。当 map 算子处理完前 3 条数据并 收到检查点分界线时，它们会将状态以异步的方式写入持久化存储，如下图所示（保存 map 算子状态， 也就是当前各个 key 的计数值）<br><img src="https://img-blog.csdnimg.cn/20210519113643798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>位于检查点之前的所有记录([“b”,2]、[“b”,3]和[“c”,1])被 map 算子处理之后的情 况。此时，持久化存储已经备份了检查点分界线在输入流中的位置(备份操作发生在 barrier 被输入算子处理的时候)。map 算子接着开始处理检查点分界线，并触发将状 态异步备份到稳定存储中这个动作。<br>当 map 算子的状态备份和检查点分界线的位置备份被确认之后，该检查点操作 就可以被标记为完成，如下图所示。我们在无须停止或者阻断计算的条件下，在一 个逻辑时间点(对应检查点屏障在输入流中的位置)为计算状态拍了快照。通过确保 备份的状态和位置指向同一个逻辑时间点，后文将解释如何基于备份恢复计算，从 而保证 exactly-once。值得注意的是，当没有出现故障时，Flink 检查点的开销极小， 检查点操作的速度由持久化存储的可用带宽决定。回顾数珠子的例子: 除了因为数 错而需要用到皮筋之外，皮筋会被很快地拨过。<br><img src="https://img-blog.csdnimg.cn/20210519113733345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>检查点操作完成，状态和位置均已备份到稳定存储中。输入流中的所有数据记 录都已处理完成。值得注意的是，备份的状态值与实际的状态值是不同的。备份反 映的是检查点的状态。<br>如果检查点操作失败，Flink 可以丢弃该检查点并继续正常执行，因为之后的某 一个检查点可能会成功。虽然恢复时间可能更长，但是对于状态的保证依旧很有力。 只有在一系列连续的检查点操作失败之后，Flink 才会抛出错误，因为这通常预示着 发生了严重且持久的错误。<br>现在来看看下图所示的情况：检查点操作已经完成，但故障紧随其后（故障紧跟检查点， 导致最底部的实例丢失）<br><img src="https://img-blog.csdnimg.cn/20210519113827989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在这种情况下（故障时的状态恢复），Flink 会重新拓扑(可能会获取新的执行资源)，将输入流倒回到 上一个检查点，然后恢复状态值并从该处开始继续计算。在本例中，[“a”,2]、[“a”,2] 和[“c”,2]这几条记录将被重播。<br>下图展示了这一重新处理过程。从上一个检查点开始重新计算，可以保证在剩 下的记录被处理之后，得到的 map 算子的状态值与没有发生故障时的状态值一致。<br><img src="https://img-blog.csdnimg.cn/20210519114227718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Flink 将输入流倒回到上一个检查点屏障的位置，同时恢复 map 算子的状态值。 然后，Flink 从此处开始重新处理。这样做保证了在记录被处理之后，map 算子的状 态值与没有发生故障时的一致。<br>Flink 检查点算法的正式名称是异步分界线快照(asynchronous barrier snapshotting)。该算法大致基于 Chandy-Lamport 分布式快照算法。<br>检查点是 Flink 最有价值的创新之一，因为<strong>它使 Flink 可以保证 exactly-once， 并且不需要牺牲性能</strong>。</p><h3 id="3-2-Flink-Kafka-如何实现端到端的-exactly-once-语义">3.2 Flink+Kafka 如何实现端到端的 exactly-once 语义</h3><p>我们知道，端到端的状态一致性的实现，需要每一个组件都实现，对于 Flink + Kafka 的数据管道系统（Kafka 进、Kafka 出）而言，各组件怎样保证 exactly-once 语义呢？</p><ul><li>内部 —— 利用 checkpoint 机制，把状态存盘，发生故障的时候可以恢复，保证内部的状态一致性</li><li>source —— kafka consumer 作为 source，可以将偏移量保存下来，如果后续任务出现了故障，恢复的时候可以由连接器重置偏移量，重新消费数据，保证一致性</li><li>sink —— kafka producer 作为 sink，采用两阶段提交 sink，需要实现一个 TwoPhaseCommitSinkFunction</li></ul><p>内部的 checkpoint 机制我们已经有了了解，那 source 和 sink 具体又是怎样运行 的呢？接下来我们逐步做一个分析。<br>我们知道 Flink 由 JobManager 协调各个 TaskManager 进行 checkpoint 存储， checkpoint 保存在 StateBackend 中，默认 StateBackend 是内存级的，也可以改为文件级的进行持久化保存。<br><img src="https://img-blog.csdnimg.cn/20210519114544418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当 checkpoint 启动时，JobManager 会将检查点分界线（barrier）注入数据流； barrier 会在算子间传递下去。<br><img src="https://img-blog.csdnimg.cn/20210519114628309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>每个算子会对当前的状态做个快照，保存到状态后端。对于 source 任务而言， 就会把当前的 offset 作为状态保存起来。下次从 checkpoint 恢复时，source 任务可以重新提交偏移量，从上次保存的位置开始重新消费数据。<br><img src="https://img-blog.csdnimg.cn/20210519114708854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>每个内部的 transform 任务遇到 barrier 时，都会把状态存到 checkpoint 里。<br>sink 任务首先把数据写入外部 kafka，这些数据都属于预提交的事务（还不能被消费）；当遇到 barrier 时，把状态保存到状态后端，并开启新的预提交事务。<br><img src="https://img-blog.csdnimg.cn/20210519114806911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当所有算子任务的快照完成，也就是这次的 checkpoint 完成时，JobManager 会向所有任务发通知，确认这次 checkpoint 完成。<br>当 sink 任务收到确认通知，就会正式提交之前的事务，kafka 中未确认的数据 就改为“已确认”，数据就真正可以被消费了。<br><img src="https://img-blog.csdnimg.cn/20210519114847109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>所以我们看到，执行过程实际上是一个两段式提交，每个算子执行完成，会进 行“预提交”，直到执行完 sink 操作，会发起“确认提交”，如果执行失败，预提 交会放弃掉。<br>具体的两阶段提交步骤总结如下：</p><ul><li>第一条数据来了之后，开启一个 kafka 的事务（transaction），正常写入 kafka 分区日志但标记为未提交，这就是“预提交”</li><li>jobmanager 触发 checkpoint 操作，barrier 从 source 开始向下传递，遇到 barrier 的算子将状态存入状态后端，并通知 jobmanager</li><li>sink 连接器收到 barrier，保存当前状态，存入 checkpoint，通知 jobmanager，并开启下一阶段的事务，用于提交下个检查点的数据</li><li>jobmanager 收到所有任务的通知，发出确认信息，表示 checkpoint 完成</li><li>sink 任务收到 jobmanager 的确认信息，正式提交这段时间的数据</li><li>外部 kafka 关闭事务，提交的数据可以正常消费了</li></ul><p>所以我们也可以看到，如果宕机需要通过 StateBackend 进行恢复，只能恢复所有确认提交的操作。</p><h2 id="4-选择一个状态后端（state-backend）">4. 选择一个状态后端（state backend）</h2><ul><li><strong>MemoryStateBackend</strong><ul><li>内存级的状态后端，会将键控状态作为内存中的对象进行管理，将它们存储在 TaskManager 的 JVM 堆上；而将 checkpoint 存储在 JobManager 的内存中</li></ul></li><li><strong>FsStateBackend</strong><ul><li>将 checkpoint 存到远程的持久化文件系统（FileSystem）上。而对于本地状态，跟 MemoryStateBackend 一样，也会存在 TaskManager 的 JVM 堆上</li></ul></li><li><strong>RocksDBStateBackend</strong><ul><li>将所有状态序列化后，存入本地的 RocksDB 中存储</li></ul></li></ul><p><font color=red>注：</font>RocksDB 的支持并不直接包含在 flink 中，需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置状态后端为 FsStateBackend：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="keyword">val</span> checkpointPath: <span class="type">String</span> = ???</span><br><span class="line"><span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">RocksDBStateBackend</span>(checkpointPath)</span><br><span class="line"></span><br><span class="line">env.setStateBackend(backend)</span><br><span class="line"></span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> <span class="type">FsStateBackend</span>(<span class="string">&quot;file:///tmp/checkpoints&quot;</span>))</span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置重启策略</span></span><br><span class="line">env.setRestartStrategy(<span class="type">RestartStrategies</span>.fixedDelayRestart(<span class="number">60</span>, <span class="type">Time</span>.of(<span class="number">10</span>, <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>)))</span><br></pre></td></tr></table></figure><h2 id="4-Savepoint">4. Savepoint</h2><h3 id="4-1-Savepoint介绍">4.1 Savepoint介绍</h3><p>Savepoint：保存点，类似于以前玩游戏的时候,遇到难关了/遇到boss了,赶紧手动存个档,然后接着玩,如果失败了,赶紧从上次的存档中恢复,然后接着玩。<br><strong>在实际开发中,可能会遇到这样的情况：如要对集群进行停机维护/扩容</strong><br>那么这时候需要执行一次Savepoint也就是执行一次手动的Checkpoint/也就是手动的发一个barrier栅栏，那么这样的话，程序的所有状态都会被执行快照并保存，当维护/扩容完毕之后,可以从上一次Savepoint的目录中进行恢复！</p><h3 id="4-2-Savepoint-VS-Checkpoint">4.2 Savepoint VS Checkpoint</h3><p><img src="https://img-blog.csdnimg.cn/20210519143126143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>目标</strong><ul><li>从概念上讲，Savepoints和Checkpoints的不同之处类似于传统数据库中备份和恢复日志的不同。Checkpoints的作用是确保程序有潜在失败可能的情况下（如网络暂时异常），可以正常恢复。相反，Savepoints的作用是让用户手动触发备份后，通过重启来恢复程序</li></ul></li><li><strong>实现</strong><ul><li>Checkpoints和Savepoints在实现上有所不同。Checkpoints轻量并且快速，它可以利用底层状态存储的各种特性，来实现快速备份和恢复。例如，以RocksDB作为状态存储，状态将会以RocksDB的格式持久化而不是Flink原生的格式，同时利用RocksDB的特性实现了增量Checkpoints。这个特性加速了checkpointing的过程，也是Checkpointing机制中第一个更轻量的实现。相反，Savepoints更注重数据的可移植性，并且支持任何对任务的修改，同时这也让Savepoints的备份和恢复成本相对更高。</li></ul></li><li><strong>生命周期</strong><ul><li>Checkpoints本身是定时自动触发的。它们的维护、创建和删除都由Flink自身来操作，不需要任何用户的干预。相反，Savepoints的触发、删除和管理等操作都需要用户手动触发。</li></ul></li></ul><table><tr align=center><th>维度</th><th>Checkpoints</th><th>Savepoints</th></tr><tr align=center><td>目标</td><td>任务失败的恢复/故障转移机制</td><td>手动备份/重启/恢复任务</td></tr><tr align=center><td>实现</td><td>轻量快速</td><td>注重可移植性，成本较高</td></tr><tr align=center><td>生命周期</td><td>Flink自身控制</td><td>用户手动控制</td></tr></table><h3 id="4-3-Savepoint演示">4.3 Savepoint演示</h3><ol><li>启动yarn session<br>/export/server/flink/bin/yarn-session.sh -n 2 -tm 800 -s 1 -d</li><li>运行job-会自动执行Checkpoint<br>/export/server/flink/bin/flink run --class cn.itcast.checkpoint.CheckpointDemo01 /root/ckp.jar</li><li>手动创建savepoint–相当于手动做了一次Checkpoint<br>/export/server/flink/bin/flink savepoint702b872ef80f08854c946a544f2ee1a5 hdfs://node1:8020/flink-checkpoint/savepoint/</li><li>停止job<br>/export/server/flink/bin/flink cancel 702b872ef80f08854c946a544f2ee1a5</li><li>重新启动job,手动加载savepoint数据<br>/export/server/flink/bin/flink run -s hdfs://node1:8020/flink-checkpoint/savepoint/savepoint-702b87-0a11b997fa70 --class cn.itcast.checkpoint.CheckpointDemo01 /root/ckp.jar</li><li>停止yarn session<br>yarn application -kill application_1607782486484_0014</li></ol><h2 id="5-关于并行度">5. 关于并行度</h2><p>一个Flink程序由多个Operator组成(source、transformation和 sink)。<br>一个Operator由多个并行的Task(线程)来执行，一个Operator的并行Task(线程)数目就被称为该Operator(任务)的并行度(Parallel)<br>并行度可以有如下几种指定方式：</p><ol><li>Operator Level（算子级别）(可以使用)<br>一个算子、数据源和sink的并行度可以通过调用 setParallelism()方法来指定<br><img src="https://img-blog.csdnimg.cn/20210519145653361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>Execution Environment Level（Env级别）(可以使用)<br>执行环境(任务)的默认并行度可以通过调用setParallelism()方法指定。为了以并行度3来执行所有的算子、数据源和data sink， 可以通过如下的方式设置执行环境的并行度：<br>执行环境的并行度可以通过显式设置算子的并行度而被重写<br><img src="https://img-blog.csdnimg.cn/20210519145823848.png" alt="在这里插入图片描述"></li><li>Client Level（客户端级别,推荐使用）（可以使用）<br>并行度可以在客户端将job提交到Flink时设定<br>对于CLI客户端，可以通过-p参数指定并行度：<br>./bin/flink run -p 10 WordCount-java.jar</li><li>System Level（系统默认级别,尽量不使用）<br>在系统级可以通过设置flink-conf.yaml文件中的parallelism.default属性来指定所有执行环境的默认并行度<br><img src="https://img-blog.csdnimg.cn/20210519150030632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210519150138860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><ul><li>Example1：<ul><li>在fink-conf.yaml中 taskmanager.numberOfTaskSlots 默认值为1，即每个Task Manager上只有一个Slot ，此处是3</li><li>Example1中，WordCount程序设置了并行度为1，意味着程序 Source、Reduce、Sink在一个Slot中，占用一个Slot</li></ul></li><li>Example2：<ul><li>通过设置并行度为2后，将占用2个Slot</li></ul></li><li>Example3：<ul><li>通过设置并行度为9，将占用9个Slot</li></ul></li><li>Example4：<ul><li>通过设置并行度为9，并且设置sink的并行度为1，则Source、Reduce将占用9个Slot，但是Sink只占用1个Slot</li></ul></li></ul><p><strong><font color=red>注：</font></strong></p><ul><li>并行度的优先级：算子级别 &gt; env级别 &gt; Client级别 &gt; 系统默认级别  (越靠前具体的代码并行度的优先级越高)</li><li>如果source不可以被并行执行，即使指定了并行度为多个，也不会生效</li><li>在实际生产中，我们推荐在算子级别显示指定各自的并行度，方便进行显示和精确的资源控制</li><li>slot是静态的概念，是指taskmanager具有的并发执行能力; parallelism是动态的概念，是指程序运行时实际使用的并发能力</li></ul><h1 id="十、Table-API-与SQL">十、Table API 与SQL</h1><p>Table API 是流处理和批处理通用的关系型 API，Table API 可以基于流输入或者批输入来运行而不需要进行任何修改。Table API 是 SQL 语言的超集并专门为 Apache Flink 设计的，Table API 是 Scala 和 Java 语言集成式的 API。与常规 SQL 语言中将查询指定为字符串不同，Table API 查询是以 Java 或 Scala 中的语言嵌入样式来定义的， 具有 IDE 支持如:自动完成和语法检测。</p><h2 id="1-Table-API-SQL的特点">1. Table API &amp; SQL的特点</h2><p>Flink之所以选择将 Table API &amp; SQL 作为未来的核心 API，是因为其具有一些非常重要的特点：<br><img src="https://img-blog.csdnimg.cn/20210519152722120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li>声明式:属于设定式语言，用户只要表达清楚需求即可，不需要了解底层执行</li><li>高性能:可优化，内置多种查询优化器，这些查询优化器可为 SQL 翻译出最优执行计划</li><li>简单易学:易于理解，不同行业和领域的人都懂，学习成本较低</li><li>标准稳定:语义遵循SQL标准，非常稳定，在数据库 30 多年的历史中，SQL 本身变化较少</li><li>流批统一:可以做到API层面上流与批的统一，相同的SQL逻辑，既可流模式运行，也可批模式运行，Flink底层Runtime本身就是一个流与批统一的引擎</li></ol><h2 id="2-Table-API-SQL发展历程">2. Table API &amp; SQL发展历程</h2><h3 id="2-1-架构升级">2.1 架构升级</h3><p>自 2015 年开始，阿里巴巴开始调研开源流计算引擎，最终决定基于 Flink 打造新一代计算引擎，针对 Flink 存在的不足进行优化和改进，并且在 2019 年初将最终代码开源，也就是Blink。Blink 在原来的 Flink 基础上最显著的一个贡献就是 Flink SQL 的实现。随着版本的不断更新，API 也出现了很多不兼容的地方。<br>在 Flink 1.9 中，Table 模块迎来了核心架构的升级，引入了阿里巴巴Blink团队贡献的诸多功能<br><img src="https://img-blog.csdnimg.cn/20210519153027176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在Flink 1.9 之前，Flink API 层 一直分为DataStream API 和 DataSet API，Table API &amp; SQL 位于 DataStream API 和 DataSet API 之上。可以看处流处理和批处理有各自独立的api (流处理DataStream，批处理DataSet)。而且有不同的执行计划解析过程，codegen过程也完全不一样，完全没有流批一体的概念，面向用户不太友好。<br>在Flink1.9之后新的架构中，有两个查询处理器：Flink Query Processor，也称作Old Planner和Blink Query Processor，也称作Blink Planner。为了兼容老版本Table及SQL模块，插件化实现了Planner，Flink原有的Flink Planner不变，后期版本会被移除。新增加了Blink Planner，新的代码及特性会在Blink planner模块上实现。批或者流都是通过解析为Stream Transformation来实现的，不像Flink Planner，批是基于Dataset，流是基于DataStream。</p><h3 id="2-2-查询处理器的选择">2.2 查询处理器的选择</h3><p>查询处理器是 Planner 的具体实现，通过parser、optimizer、codegen(代码生成技术)等流程将 Table API &amp; SQL作业转换成 Flink Runtime 可识别的 Transformation DAG，最终由 Flink Runtime 进行作业的调度和执行。<br>Flink Query Processor查询处理器针对流计算和批处理作业有不同的分支处理，流计算作业底层的 API 是 DataStream API， 批处理作业底层的 API 是 DataSet API<br>Blink Query Processor查询处理器则实现流批作业接口的统一，底层的 API 都是Transformation，这就意味着我们和Dataset完全没有关系了<br>Flink1.11之后Blink Query Processor查询处理器已经是默认的了</p><ul><li>了解-Blink planner和Flink Planner具体区别如下：<ul><li>Blink将批处理作业视为流式处理的特殊情况。因此，表和数据集之间的转换也不受支持，批处理作业不会转换为数据集程序，而是转换为数据流程序，与流作业相同</li><li>Blink planner不支持Batch TableSource</li><li>old planner和Blink planner的FilterableSource实现不兼容</li><li>基于字符串的键值配置选项仅用于Blink planner</li><li>PlannerConfig在两个planners中的实现（CalciteConfig）是不同的</li><li>Blink planner将在TableEnvironment和StreamTableEnvironment上将多个汇优化为一个DAG。旧的计划者总是将每个水槽优化为一个新的DAG，其中所有DAG彼此独立</li><li>旧的计划期现在不支持目录统计，而Blink计划器支持</li></ul></li></ul><h3 id="2-3-注意">2.3 注意</h3><ul><li><strong>API 稳定性</strong><br><img src="https://img-blog.csdnimg.cn/20210519154342961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>性能对比</strong><ul><li>目前FlinkSQL性能不如SparkSQL，未来FlinkSQL可能会越来越好（下图是Hive、Spark、Flink的SQL执行速度对比）<br><img src="https://img-blog.csdnimg.cn/20210519154428147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h2 id="3-需要引入的pom依赖">3. 需要引入的pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-scala-bridge_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-简单了解TableAPI">4. 简单了解TableAPI</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment env.setParallelism(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> inputStream = env.readTextFile(<span class="string">&quot;..\\sensor.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dataStream = inputStream</span><br><span class="line">.map( data =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 基于env 创建 tableEnv</span></span><br><span class="line"><span class="keyword">val</span> settings: <span class="type">EnvironmentSettings</span> = <span class="type">EnvironmentSettings</span>.newInstance().useOldPlanner().inStreamingMode().build()</span><br><span class="line"><span class="keyword">val</span> tableEnv: <span class="type">StreamTableEnvironment</span> = <span class="type">StreamTableEnvironment</span>.create(env, settings)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一条流创建一张表</span></span><br><span class="line"><span class="keyword">val</span> dataTable: <span class="type">Table</span> = tableEnv.fromDataStream(dataStream)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从表里选取特定的数据</span></span><br><span class="line"><span class="keyword">val</span> selectedTable: <span class="type">Table</span> = dataTable.select(&#x27;id, &#x27;temperature).filter(<span class="string">&quot;id = &#x27;sensor_1&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> selectedStream: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = selectedTable.toAppendStream[(<span class="type">String</span>, <span class="type">Double</span>)] </span><br><span class="line"></span><br><span class="line">selectedStream.print()</span><br><span class="line"></span><br><span class="line">env.execute(<span class="string">&quot;table test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-动态表">4.1 动态表</h3><p>如果流中的数据类型是 case class 可以直接根据 case class 的结构生成 table</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.fromDataStream(dataStream)</span><br></pre></td></tr></table></figure><p>或者根据字段顺序单独命名</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.fromDataStream(dataStream,’id,’timestamp........)</span><br></pre></td></tr></table></figure><p>最后的动态表可以转换为流进行输出</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.toAppendStream[(<span class="type">String</span>,<span class="type">String</span>)]</span><br></pre></td></tr></table></figure><h3 id="4-2-字段">4.2 字段</h3><p>用一个单引放到字段前面来标识字段名, 如 ‘name , ‘id ,’amount 等。</p><h2 id="5-TableAPI-的窗口聚合操作">5. TableAPI 的窗口聚合操作</h2><h3 id="5-1-案例演示">5.1 案例演示</h3><ul><li>统计每10 秒中每个传感器温度值的个数</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计每10 秒中每个传感器温度值的个数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> inputStream = env.readTextFile(<span class="string">&quot;..\\sensor.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> dataStream = inputStream</span><br><span class="line">.map( data =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125;)</span><br><span class="line">.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="type">Time</span>.seconds(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">SensorReading</span>): <span class="type">Long</span> = element.timestamp * <span class="number">1000</span>L</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于env 创建 tableEnv</span></span><br><span class="line"><span class="keyword">val</span> settings: <span class="type">EnvironmentSettings</span> = <span class="type">EnvironmentSettings</span>.newInstance().useOldPlanner().inStreamingMode().build()</span><br><span class="line"><span class="keyword">val</span> tableEnv: <span class="type">StreamTableEnvironment</span> = <span class="type">StreamTableEnvironment</span>.create(env, settings)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一条流创建一张表，按照字段去定义，并指定事件时间的时间字段</span></span><br><span class="line"><span class="keyword">val</span> dataTable: <span class="type">Table</span> = tableEnv.fromDataStream(dataStream, &#x27;id, &#x27;temperature, &#x27;ts.rowtime)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照时间开窗聚合统计</span></span><br><span class="line"><span class="keyword">val</span> resultTable: <span class="type">Table</span> = dataTable</span><br><span class="line">.window( <span class="type">Tumble</span> over <span class="number">10.</span>seconds on &#x27;ts as &#x27;tw )</span><br><span class="line">.groupBy(&#x27;id, &#x27;tw)</span><br><span class="line">.select(&#x27;id, &#x27;id.count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> selectedStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = resultTable.toRetractStream[(<span class="type">String</span>, <span class="type">Long</span>)]</span><br><span class="line"></span><br><span class="line">selectedStream.print()</span><br><span class="line">env.execute(<span class="string">&quot;table window test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-关于-group-by">5.2 关于 group by</h3><ol><li>如果了使用 groupby， table 转换为流的时候只能用 toRetractDstream</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = table</span><br><span class="line">.toRetractStream[(<span class="type">String</span>,<span class="type">Long</span>)]</span><br></pre></td></tr></table></figure><ol start="2"><li>toRetractDstream 得到的第一个 boolean 型字段标识 true 就是最新的数据(Insert)， false 表示过期老数据(Delete)</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = table</span><br><span class="line">.toRetractStream[(<span class="type">String</span>,<span class="type">Long</span>)]</span><br><span class="line">dataStream.filter(_._1).print()</span><br></pre></td></tr></table></figure><ol start="3"><li>如果使用的 api 包括时间窗口， 那么窗口的字段必须出现在 groupBy 中</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultTable: <span class="type">Table</span> = dataTable</span><br><span class="line">.window( <span class="type">Tumble</span> over <span class="number">10.</span>seconds on &#x27;ts as &#x27;tw )</span><br><span class="line">.groupBy(&#x27;id, &#x27;tw)</span><br><span class="line">.select(&#x27;id, &#x27;id.count)</span><br></pre></td></tr></table></figure><h3 id="5-3-关于时间窗口">5.3 关于时间窗口</h3><ol><li>用到时间窗口， 必须提前声明时间字段， 如果是 processTime 直接在创建动态表时进行追加就可以</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>dataTable: <span class="type">Table</span> = tableEnv.fromDataStream(dataStream, &#x27;id, &#x27;temperature, &#x27;ps.proctime)</span><br></pre></td></tr></table></figure><ol start="2"><li>如果是 EventTime 要在创建动态表时声明</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>dataTable: <span class="type">Table</span> = tableEnv.fromDataStream(dataStream, &#x27;id, &#x27;temperature, &#x27;ts.rowtime)</span><br></pre></td></tr></table></figure><ol start="3"><li>滚动窗口可以使用 Tumble over 10000.millis on 来表示</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resultTable: <span class="type">Table</span> = dataTable</span><br><span class="line">.window( <span class="type">Tumble</span> over <span class="number">10.</span>seconds on &#x27;ts as &#x27;tw )</span><br><span class="line">.groupBy(&#x27;id, &#x27;tw)</span><br><span class="line">.select(&#x27;id, &#x27;id.count)</span><br></pre></td></tr></table></figure><h2 id="6-SQL-如何编写">6. SQL 如何编写</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计每10 秒中每个传感器温度值的个数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment env.setParallelism(<span class="number">1</span>)</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> inputStream = env.readTextFile(<span class="string">&quot;..\\sensor.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> dataStream = inputStream</span><br><span class="line">.map( data =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> dataArray = data.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="type">SensorReading</span>(dataArray(<span class="number">0</span>).trim, dataArray(<span class="number">1</span>).trim.toLong, dataArray(<span class="number">2</span>).trim.toDouble)</span><br><span class="line">&#125;)</span><br><span class="line">.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="type">Time</span>.seconds(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">SensorReading</span>): <span class="type">Long</span> = element.timestamp * <span class="number">1000</span>L</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于env 创建 tableEnv</span></span><br><span class="line"><span class="keyword">val</span> settings: <span class="type">EnvironmentSettings</span> = <span class="type">EnvironmentSettings</span>.newInstance().useOldPlanner().inStreamingMode().build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tableEnv: <span class="type">StreamTableEnvironment</span> = <span class="type">StreamTableEnvironment</span>.create(env, settings)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一条流创建一张表，按照字段去定义，并指定事件时间的时间字段</span></span><br><span class="line"><span class="keyword">val</span>dataTable:<span class="type">Table</span>=tableEnv.fromDataStream(dataStream,&#x27;id, &#x27;temperature, &#x27;ts.rowtime)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接写sql 完成开窗统计</span></span><br><span class="line"><span class="keyword">val</span> resultSqlTable: <span class="type">Table</span> = tableEnv.sqlQuery(<span class="string">&quot;select id, count(id) from &quot;</span> + dataTable + <span class="string">&quot; group by id, tumble(ts, interval &#x27;15&#x27; second)&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> selectedStream: <span class="type">DataStream</span>[(<span class="type">Boolean</span>, (<span class="type">String</span>, <span class="type">Long</span>))] = resultSqlTable.toRetractStream[(<span class="type">String</span>, <span class="type">Long</span>)]</span><br><span class="line"></span><br><span class="line">selectedStream.print()</span><br><span class="line">env.execute(<span class="string">&quot;table window test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-相关概念">7. 相关概念</h2><h3 id="7-1-Dynamic-Tables-Continuous-Queries">7.1 Dynamic Tables &amp; Continuous Queries</h3><p>在Flink中，它把针对无界流的表称之为Dynamic Table（动态表），是Flink Table API和SQL的核心概念。顾名思义，它表示了Table是不断变化的。<br>我们可以这样来理解，当我们用Flink的API，建立一个表，其实把它理解为建立一个逻辑结构，这个逻辑结构需要映射到数据上去。Flink source源源不断的流入数据，就好比每次都往表上新增一条数据。表中有了数据，我们就可以使用SQL去查询了。要注意一下，流处理中的数据是只有新增的，所以看起来数据会源源不断地添加到表中。<br>动态表也是一种表，既然是表，就应该能够被查询。我们来回想一下原先我们查询表的场景：</p><ol><li>将SQL语句放入到mysql的终端执行</li><li>查看结果</li><li>再编写一条SQL语句</li><li>再放入到终端执行</li><li>再查看结果<br>…如此反复</li></ol><p>而针对动态表，Flink的source端肯定是源源不断地会有数据流入，然后我们基于这个数据流建立了一张表，再编写SQL语句查询数据，进行处理。这个SQL语句一定是不断地执行的。而不是只执行一次。注意：针对流处理的SQL绝对不会像批式处理一样，执行一次拿到结果就完了。而是会不停地执行，不断地查询获取结果处理。所以，官方给这种查询方式取了一个名字，叫Continuous Query，中文翻译过来叫连续查询。而且每一次查询出来的数据也是不断变化的。<br><img src="https://img-blog.csdnimg.cn/20210519162930496.png#pic_center" alt="在这里插入图片描述"><br>这是一个非常简单的示意图。该示意图描述了：我们通过建立动态表和连续查询来实现在无界流中的SQL操作。大家也可以看到，在Continuous上面有一个State，表示查询出来的结果会存储在State中，再下来Flink最终还是使用流来进行处理。<br>所以，我们可以理解为Flink的Table API和SQL，是一个逻辑模型，通过该逻辑模型可以让我们的数据处理变得更加简单。<br><img src="https://img-blog.csdnimg.cn/20210519163021191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210519163033602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="7-2-Table-to-Stream-Conversion">7.2 Table to Stream Conversion</h3><h4 id="7-2-1-表中的Update和Delete">7.2.1 表中的Update和Delete</h4><p>我们前面提到的表示不断地Append，表的数据是一直累加的，因为表示对接Source的，Source是不会有update的。但如果我们编写了一个SQL。这个SQL看起来是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">sum</span>(money) <span class="keyword">FROM</span> <span class="keyword">order</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>当执行一条SQL语句之后，这条语句的结果还是一个表，因为在Flink中执行的SQL是Continuous Query，这个表的数据是不断变化的。新创建的表存在Update的情况。仔细看下下面的示例，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条数据，张三,2000，执行这条SQL语句的结果是，张三,2000</span><br><span class="line">第二条数据，李四,1500，继续执行这条SQL语句，结果是，张三,2000 | 李四,1500</span><br><span class="line">第三条数据，张三,300，继续执行这条SQL语句，结果是，张三,2300 | 李四,1500</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>大家发现了吗，现在数据结果是有Update的。张三一开始是2000，但后面变成了2300。<br>那还有删除的情况吗？有的。看一下下面这条SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.`<span class="keyword">user</span>`, <span class="built_in">SUM</span>(t1.`money`) <span class="keyword">FROM</span> t_order t1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> T2.`<span class="keyword">user</span>`<span class="keyword">AS</span> TOTAL_MONEY <span class="keyword">FROM</span> t_order t2 <span class="keyword">WHERE</span> T2.`<span class="keyword">user</span>` <span class="operator">=</span> T1.`<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t2.`<span class="keyword">user</span>` <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(T2.`money`) <span class="operator">&gt;</span> <span class="number">3000</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.`<span class="keyword">user</span>`<span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.`<span class="keyword">user</span>`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一条数据，张三,2000，执行这条SQL语句的结果是，张三,2000</span><br><span class="line">第二条数据，李四,1500，继续执行这条SQL语句，结果是，张三,2000 | 李四,1500</span><br><span class="line">第三条数据，张三,300，继续执行这条SQL语句，结果是，张三,2300 | 李四,1500</span><br><span class="line">第四条数据，张三,800，继续执行这条SQL语句，结果是，李四,1500</span><br></pre></td></tr></table></figure><p>因为张三的消费的金额已经超过了3000，所以SQL执行完后，张三是被处理掉了。从数据的角度来看，它不就是被删除了吗？</p><p>通过上面的两个示例，给大家演示了，在Flink SQL中，对接Source的表都是Append-only的，不断地增加。执行一些SQL生成的表，这个表可能是要UPDATE的、也可能是要INSERT的。</p><h4 id="7-2-2-对表的编码操作">7.2.2 对表的编码操作</h4><p>我们前面说到过，表是一种逻辑结构。而Flink中的核心还是Stream。所以，Table最终还是会以Stream方式来继续处理。如果是以Stream方式处理，最终Stream中的数据有可能会写入到其他的外部系统中，例如：将Stream中的数据写入到MySQL中。<br>我们前面也看到了，表是有可能会UPDATE和DELETE的。那么如果是输出到MySQL中，就要执行UPDATE和DELETE语句了。而DataStream我们在学习Flink的时候就学习过了，DataStream是不能更新、删除事件的。<br>如果对表的操作是INSERT，这很好办，直接转换输出就好，因为DataStream数据也是不断递增的。但如果一个TABLE中的数据被UPDATE了、或者被DELETE了，如果用流来表达呢？因为流不可变的特征，我们肯定要对这种能够进行UPDATE/DELETE的TABLE做特殊操作。<br>我们可以针对每一种操作，INSERT/UPDATE/DELETE都用一个或多个经过编码的事件来表示。<br>例如：针对UPDATE，我们用两个操作来表达，[DELETE] 数据+  [INSERT]数据。也就是先把之前的数据删除，然后再插入一条新的数据。针对DELETE，我们也可以对流中的数据进行编码，[DELETE]数据。</p><p>总体来说，我们通过对流数据进行编码，也可以告诉DataStream的下游，[DELETE]表示发出MySQL的DELETE操作，将数据删除。用 [INSERT]表示插入新的数据。</p><h4 id="7-2-3-将表转换为三种不同编码方式的流">7.2.3 将表转换为三种不同编码方式的流</h4><p>Flink中的Table API或者SQL支持三种不同的编码方式。分别是：</p><ul><li><p>Append-only流</p><ul><li>跟INSERT操作对应。这种编码类型的流针对的是只会不断新增的Dynamic Table。这种方式好处理，不需要进行特殊处理，源源不断地往流中发送事件即可</li></ul></li><li><p>Retract流</p><ul><li>这种流就和Append-only不太一样。上面的只能处理INSERT，如果表会发生DELETE或者UPDATE，Append-only编码方式的流就不合适了。Retract流有几种类型的事件类型：<ul><li>ADD MESSAGE：这种消息对应的就是INSERT操作</li><li>RETRACT MESSAGE：直译过来叫取消消息。这种消息对应的就是DELETE操作</li></ul></li><li>我们可以看到通过ADD MESSAGE和RETRACT MESSAGE可以很好的向外部系统表达删除和插入操作。那如何进行UPDATE呢？好办！RETRACT MESSAGE + ADD MESSAGE即可。先把之前的数据进行删除，然后插入一条新的。完美~<br><img src="https://img-blog.csdnimg.cn/20210519163916523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li><li><p>Upsert流</p><ul><li>前面我们看到的RETRACT编码方式的流，实现UPDATE是使用DELETE + INSERT模式的。大家想一下：在MySQL中我们更新数据的时候，肯定不会先DELETE掉一条数据，然后再插入一条数据，肯定是直接发出UPDATE语句执行更新。而Upsert编码方式的流，是能够支持Update的，这种效率更高。它同样有两种类型的消息：<ul><li>UPSERT MESSAGE：这种消息可以表示要对外部系统进行Update或者INSERT操作</li><li>DELETE MESSAGE：这种消息表示DELETE操作</li></ul></li><li>Upsert流是要求必须指定Primary Key的，因为Upsert操作是要有Key的。Upsert流针对UPDATE操作用一个UPSERT MESSAGE就可以描述，所以效率会更高<br><img src="https://img-blog.csdnimg.cn/20210519164013878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h1 id="十一、Flink-CEP-简介">十一、Flink CEP 简介</h1><h2 id="1-什么是复杂事件处理CEP">1.  什么是复杂事件处理CEP</h2><p>一个或多个由简单事件构成的事件流通过一定的规则匹配， 然后输出用户想得到的数据， 满足规则的复杂事件。<br><strong>特征：</strong></p><ul><li>目标<ul><li>从有序的简单事件流中发现一些高阶特征</li></ul></li><li>输入<ul><li>一个或多个由简单事件构成的事件流</li></ul></li><li>处理<ul><li>识别简单事件之间的内在联系， 多个符合一定规则的简单事件构成复杂事件</li></ul></li><li>输出<ul><li>满足规则的复杂事件</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20210519165155380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CEP 用于分析低延迟、频繁产生的不同来源的事件流。CEP 可以帮助在复杂的、不相关的事件流中找出有意义的模式和复杂的关系，以接近实时或准实时的获得通知并阻止一些行为。<br>CEP 支持在流上进行模式匹配， 根据模式的条件不同， 分为连续的条件或不连续的条件；模式的条件允许有时间的限制，当在条件范围内没有达到满足的条件时，  会导致模式匹配超时。<br>看起来很简单， 但是它有很多不同的功能：</p><ul><li>输入的流数据， 尽快产生结果</li><li>在 2 个 event 流上， 基于时间进行聚合类的计算</li><li>提供实时/准实时的警告和通知</li><li>在多样的数据源中产生关联并分析模式</li><li>高吞吐、低延迟的处理</li></ul><p>市场上有多种 CEP 的解决方案， 例如 Spark、Samza、Beam 等， 但他们都没有提供专门的 library 支持。但是 Flink 提供了专门的 CEP library。</p><h2 id="2-Flink-CEP">2. Flink CEP</h2><p>Flink 为 CEP 提供了专门的 Flink CEP library， 它包含如下组件：</p><ul><li>Event Stream</li><li>pattern 定义</li><li>pattern 检测</li><li>生成 Alert</li></ul><p><img src="https://img-blog.csdnimg.cn/20210519165438959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先， 开发人员要在 DataStream 流上定义出模式条件， 之后 Flink CEP 引擎进行模式检测， 必要时生成告警。<br>为了使用 Flink CEP， 我们需要导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-cep_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-1-Event-Streams">2.1 Event Streams</h3><p>以登陆事件流为例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginEvent</span>(<span class="params">userId: <span class="type">String</span>, ip: <span class="type">String</span>, eventType: <span class="type">String</span>, eventTi me: <span class="type">String</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">env.setParallelism(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> loginEventStream = env.fromCollection(<span class="type">List</span>(</span><br><span class="line"><span class="type">LoginEvent</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="string">&quot;1558430842&quot;</span>),</span><br><span class="line"><span class="type">LoginEvent</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;192.168.0.2&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="string">&quot;1558430843&quot;</span>),</span><br><span class="line"><span class="type">LoginEvent</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;192.168.0.3&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="string">&quot;1558430844&quot;</span>),</span><br><span class="line"><span class="type">LoginEvent</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;192.168.10.10&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="string">&quot;1558430845&quot;</span>)</span><br><span class="line">)).assignAscendingTimestamps(_.eventTime.toLong)</span><br></pre></td></tr></table></figure><h3 id="2-2-Pattern-API">2.2 Pattern API</h3><p>每个 Pattern 都应该包含几个步骤，或者叫做 state。从一个 state 到另一个 state， 通常我们需要定义一些条件， 例如下列的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> loginFailPattern = <span class="type">Pattern</span>.begin[<span class="type">LoginEvent</span>](<span class="string">&quot;begin&quot;</span>)</span><br><span class="line">.where(_.eventType.equals(<span class="string">&quot;fail&quot;</span>))</span><br><span class="line">.next(<span class="string">&quot;next&quot;</span>)</span><br><span class="line">.where(_.eventType.equals(<span class="string">&quot;fail&quot;</span>))</span><br><span class="line">.within(<span class="type">Time</span>.seconds(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>每个 state 都应该有一个标示： 例如.begin<a href="%22begin%22">LoginEvent</a>中的&quot;begin&quot;<br>每个 state 都需要有一个唯一的名字， 而且需要一个 filter 来过滤条件， 这个过滤条件定义事件需要符合的条件， 例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.where(_.eventType.equals(<span class="string">&quot;fail&quot;</span>))</span><br></pre></td></tr></table></figure><p>我们也可以通过 subtype 来限制 event 的子类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start.subtype(<span class="type">SubEvent</span>.<span class="keyword">class</span>).where(...);</span><br></pre></td></tr></table></figure><p>事实上，你可以多次调用 subtype 和 where 方法；而且如果 where 条件是不相关 的，你可以通过 or 来指定一个单独的 filter 函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.where(...).or(...);</span><br></pre></td></tr></table></figure><p>之后，我们可以在此条件基础上，通过 next 或者 followedBy 方法切换到下一个 state，next 的意思是说上一步符合条件的元素之后紧挨着的元素；而 followedBy 并 不要求一定是挨着的元素。这两者分别称为严格近邻和非严格近邻。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strictNext = start.next(<span class="string">&quot;middle&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> nonStrictNext = start.followedBy(<span class="string">&quot;middle&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后，我们可以将所有的 Pattern 的条件限定在一定的时间范围内：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next.within(<span class="type">Time</span>.seconds(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>这个时间可以是 Processing Time，也可以是 Event Time。</p><h3 id="2-3-Pattern-检测">2.3 Pattern 检测</h3><p>通过一个 input DataStream 以及刚刚我们定义的 Pattern， 我们可以创建一个PatternStream：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> input = ...</span><br><span class="line"><span class="keyword">val</span> pattern = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> patternStream = <span class="type">CEP</span>.pattern(input, pattern)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> patternStream = <span class="type">CEP</span>.pattern(loginEventStream.keyBy(_.userId), loginFail <span class="type">Pattern</span>)</span><br></pre></td></tr></table></figure><p>一旦获得 PatternStream，我们就可以通过 select 或 flatSelect，从一个 Map 序列 找到我们需要的警告信息。</p><h3 id="2-4-select">2.4 select</h3><p>select 方法需要实现一个 PatternSelectFunction， 通过 select 方法来输出需要的警告。它接受一个 Map 对，包含 string/event，其中 key 为 state 的名字， event 则为真实的 Event。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> loginFailDataStream = patternStream</span><br><span class="line">.select((pattern: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">LoginEvent</span>]]) =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> first = pattern.getOrElse(<span class="string">&quot;begin&quot;</span>, <span class="literal">null</span>).iterator.next()</span><br><span class="line"><span class="keyword">val</span> second = pattern.getOrElse(<span class="string">&quot;next&quot;</span>, <span class="literal">null</span>).iterator.next()</span><br><span class="line"><span class="type">Warning</span>(first.userId, first.eventTime, second.eventTime, <span class="string">&quot;warning&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其返回值仅为 1 条记录。</p><h3 id="2-5-flatSelect">2.5 flatSelect</h3><p>通过实现 PatternFlatSelectFunction，实现与 select 相似的功能。唯一的区别就 是 flatSelect 方法可以返回多条记录，它通过一个 Collector[OUT]类型的参数来将要 输出的数据传递到下游。</p><h3 id="2-6-超时事件的处理">2.6 超时事件的处理</h3><p>通过 within 方法，我们的 parttern 规则将匹配的事件限定在一定的窗口范围内。 当有超过窗口时间之后到达的 event，我们可以通过在 select 或 flatSelect 中，实现 PatternTimeoutFunction 和 PatternFlatTimeoutFunction 来处理这种情况。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> patternStream: <span class="type">PatternStream</span>[<span class="type">Event</span>] = <span class="type">CEP</span>.pattern(input, pattern)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> outputTag = <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">&quot;side-output&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">SingleOutputStreamOperator</span>[<span class="type">ComplexEvent</span>] = patternStream.select(outputTag)&#123;</span><br><span class="line">(pattern: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Event</span>]], timestamp: <span class="type">Long</span>) =&gt; <span class="type">TimeoutEvent</span>()</span><br><span class="line">&#125; &#123;</span><br><span class="line">pattern: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Event</span>]] =&gt; <span class="type">ComplexEvent</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> timeoutResult: <span class="type">DataStream</span>&lt;<span class="type">TimeoutEvent</span>&gt; = result.getSideOutput(outputTa g)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据开发必备技能，Scala 零基础笔记</title>
      <link href="/2021/04/10/scala_1/"/>
      <url>/2021/04/10/scala_1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、scala的定义">一、scala的定义</h1><h2 id="语言特点">语言特点</h2><p><strong>Scala是一门以Java虚拟机（JVM）为运行环境并将<font color=red >面向对象</font>和<font color=red >函数式编程</font>的最佳特性结合在一起的<font color=red >静态类型编程语言</font>（静态语言需要提前编译的如：Java、c、c++等，动态语言如：js）</strong></p><ul><li><strong>Scala是一门<font color=red >多范式</font>的编程语言，支持面向对象和函数式编程（多范式，就是多种编程方法的意思。有面向过程、面向对象、泛型、函数式四种程序设计方法）</strong></li><li><strong>Scala源代码（.scala）会被编译成Java字节码（.class），然后运行于JVM之上，<font color=red >并可以调用现有的Java类库，实现两种语言的无缝对接</font></strong></li><li><strong>Scala单作为一门语言来看，非常的<font color=red >简洁高效</font></strong></li><li><strong>Scala在设计时，马丁·奥德斯基是参考了Java的设计思想，可以说Scala是源于Java，同时马丁·奥德斯基也加入了自己的思想，将<font color=red >函数式编程语言的特点融合到Java中</font>, 因此，对于学习过Java的同学，只要在学习Scala的过程中，搞清楚Scala和Java相同点和不同点，就可以快速的掌握Scala这门语言</strong></li></ul><h2 id="环境搭建及插件安装">环境搭建及插件安装</h2><h3 id="1-环境搭建">1.环境搭建</h3><ul><li><strong>首先确保JDK1.8安装成功</strong></li><li><strong>下载对应的 Scala 安装文件并解压</strong></li><li><strong>配置Scala的环境变量</strong></li></ul><h3 id="2-插件安装">2.插件安装</h3><ul><li><strong>在线安装（推荐）</strong><ul><li>在搜索插件框里面输入 Scala-&gt;点击 Install-&gt;点击 ok-&gt;点击 apply</li></ul></li><li><strong>离线安装</strong><ul><li>将插件放在Scala的安装目录下（这里就不放资源了，有需要的小伙伴可上网下载，网上的这种资源一搜就有）</li><li>打开IDEA，点击左上角File-&gt;点击下拉框的Settings…-&gt;点击Plugins-&gt;点击右下角Install plugin from disk… ， 找到自己对应的插件存储路径，最后点击ok即可</li></ul></li></ul><h2 id="HelloWorld案例">HelloWorld案例</h2><ul><li><strong>打开 IDEA-&gt;点击左侧的 Flie-&gt;选择 New-&gt;选择 Project…</strong></li><li><strong>创建一个 Maven 工程，并点击 next</strong></li><li><strong>输入自定义的GroupId和ArtifactId，然后点击Next（<font color=red >工程存储路径一定不能有中文和空格</font>）</strong></li><li><strong>指定项目工作目录空间</strong></li><li><strong>Maven默认不支持Scala的开发，需要引入Scala的框架</strong><ul><li>在自己创建的项目上，右击键-&gt;Add Framework Support…-&gt;选择Scala-&gt;点击OK（如果是第一次引入需要选择自己的Scala安装目录，工具就会自动识别）</li></ul></li><li><strong>创建项目的源文件目录</strong><ul><li>右键点击main目录-&gt;New-&gt;点击Diretory-&gt;写个名字（比如 scala）</li><li>右键点击scala目录-&gt;Mark Directory as-&gt;选择Sources root，可以看到文件夹颜色发生了变化</li></ul></li><li><strong>在scala包下，创建包com.demo包名和Hello类名</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  object:关键字，声明一个单例对象（伴生对象）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      main方法：从外部可以直接调用执行的方法</span></span><br><span class="line"><span class="comment">      def 方法名称(参数名称 : 参数类型): 返回值类型 = &#123;方法体&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;hello word&quot;</span>)</span><br><span class="line">    <span class="type">System</span>.out.println(<span class="string">&quot;hello word&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello word</span><br><span class="line">hello word</span><br></pre></td></tr></table></figure><h1 id="二、变量和数据类型">二、变量和数据类型</h1><h2 id="注释">注释</h2><p><strong>Scala注释使用和Java完全一样</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文档注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="变量和常量">变量和常量</h2><p><strong>常量指在程序执行的过程中，其值不会被改变的变量</strong></p><ul><li><strong>基本语法</strong><ul><li>var 变量名 [: 变量类型] = 初始值<ul><li>var i : Int = 10</li></ul></li><li>val 常量名 [: 常量类型] = 初始值<ul><li>val j : Int = 20</li></ul></li><li><font color=red >Scala中能用常量的地方不用变量</font></li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//    声明一个变量的通用语法</span></span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">//    1)声明变量时，类型可以省略，编译器自动推导，即类型推导</span></span><br><span class="line">    <span class="keyword">var</span> a1 = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> b1 = <span class="number">20</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    2)类型确定后，就不能修改，说明Scala是强数据类型语言</span></span><br><span class="line">    <span class="keyword">var</span> a2 = <span class="number">15</span> <span class="comment">//a2类型为Int</span></span><br><span class="line"><span class="comment">//    a2 = &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    3）变量声明时，必须有初始值</span></span><br><span class="line"><span class="comment">//    var a3: Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    4)在声明/定义一个变量时，可以使用var或者val来修饰，var修饰的变量可改变，val修饰的变量不可改</span></span><br><span class="line">    a1 = <span class="number">12</span></span><br><span class="line"><span class="comment">//    b1 = 21</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alice = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;alice&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    alice = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    alice = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> bob = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;bob&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    bob.age = <span class="number">24</span></span><br><span class="line">    bob.printInfo()</span><br><span class="line"><span class="comment">//    bob = new Student(&quot;Bob&quot;, 20)</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bob 24 atguigu</span><br></pre></td></tr></table></figure><h2 id="标识符的命名规范">标识符的命名规范</h2><p><strong>Scala 对各种变量、方法、函数等命名时使用的字符序列称为标识符（凡是自己可以起名字的地方都叫标识符）</strong></p><ul><li>以字母或者下划线开头，后接字母、数字、下划线</li><li>以操作符开头，且只包含操作符（+ - * / # !等）</li><li>用反引号`…`包括的任意字符串，即使是 Scala 关键字（39 个）也可以</li></ul><h2 id="字符串输出">字符串输出</h2><ul><li><strong>基本语法</strong><ul><li>字符串，通过+号连接</li><li>printf 用法：字符串，通过%传值</li><li>字符串模板（插值字符串）：通过$获取变量值</li></ul></li><li><strong>案例实操</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    1)字符串，通过+号连接</span></span><br><span class="line">    <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;alice&quot;</span></span><br><span class="line">    <span class="keyword">val</span> age: <span class="type">Int</span> = <span class="number">18</span></span><br><span class="line">    println(age + <span class="string">&quot;岁的&quot;</span> + name)</span><br><span class="line"><span class="comment">//    *用于将一个字符串复制多次并拼接</span></span><br><span class="line">    println(name * <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    2)printf用法：字符串，通过%传值</span></span><br><span class="line">    printf(<span class="string">&quot;%d岁的%s在学习&quot;</span>, age, name)</span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line"><span class="comment">//    3)字符串模板（插值字符串）：通过$获取变量值</span></span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$&#123;age&#125;</span>岁的<span class="subst">$&#123;name&#125;</span>在学习&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> num: <span class="type">Double</span> = <span class="number">2.345</span></span><br><span class="line">    println(<span class="string">f&quot;The num is <span class="subst">$&#123;num&#125;</span>%2.2f&quot;</span>)   <span class="comment">//格式化模板字符串</span></span><br><span class="line">    println(<span class="string">raw&quot;The num is <span class="subst">$&#123;num&#125;</span>%2.2f&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    三引号表示字符串，保持多行字符串的原格式输出</span></span><br><span class="line">    <span class="keyword">val</span> sql = <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">       |select *</span></span><br><span class="line"><span class="string">       |from</span></span><br><span class="line"><span class="string">       |  student</span></span><br><span class="line"><span class="string">       |where</span></span><br><span class="line"><span class="string">       |  name = $&#123;name&#125;</span></span><br><span class="line"><span class="string">       |and</span></span><br><span class="line"><span class="string">       |  age &gt; $&#123;age&#125;</span></span><br><span class="line"><span class="string">       |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin</span><br><span class="line">    println(sql)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">18岁的alice</span><br><span class="line">alicealicealice</span><br><span class="line">18岁的alice在学习</span><br><span class="line">18岁的alice在学习</span><br><span class="line">The num is 2.35</span><br><span class="line">The num is 2.345%2.2f</span><br><span class="line"></span><br><span class="line">select *</span><br><span class="line">from</span><br><span class="line">  student</span><br><span class="line">where</span><br><span class="line">  name = alice</span><br><span class="line">and</span><br><span class="line">  age &gt; 18</span><br></pre></td></tr></table></figure><h2 id="键盘输入">键盘输入</h2><p><strong>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取</strong></p><ul><li><strong>基本语法</strong><ul><li>StdIn.readLine()、StdIn.readShort()、StdIn.readDouble()</li></ul></li><li><strong>案例实操</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    输入信息</span></span><br><span class="line">    println(<span class="string">&quot;请输入您的姓名：&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> name: <span class="type">String</span> = <span class="type">StdIn</span>.readLine()</span><br><span class="line">    println(<span class="string">&quot;请输入您的年龄：&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> age: <span class="type">Int</span> = <span class="type">StdIn</span>.readInt()</span><br><span class="line"></span><br><span class="line"><span class="comment">//    控制台打印输出</span></span><br><span class="line">    println(<span class="string">s&quot;欢迎<span class="subst">$&#123;age&#125;</span>岁的<span class="subst">$&#123;name&#125;</span>来到直播间&quot;</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入您的姓名：</span><br><span class="line">张三</span><br><span class="line">请输入您的年龄：</span><br><span class="line">31</span><br><span class="line">欢迎31岁的张三来到直播间</span><br></pre></td></tr></table></figure><h2 id="文件的读写操作">文件的读写操作</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    1)从文件中读取数据</span></span><br><span class="line">    <span class="type">Source</span>.fromFile(<span class="string">&quot;src/main/resources/test.txt&quot;</span>).foreach(print)</span><br><span class="line"></span><br><span class="line"><span class="comment">//    2）将数据写入文件</span></span><br><span class="line">    <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;src/main/resources/inputtest.txt&quot;</span>))</span><br><span class="line">    writer.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello scala</span><br><span class="line">okok</span><br></pre></td></tr></table></figure><h2 id="数据类型">数据类型</h2><ul><li><strong>Scala中一切数据都是对象，都是Any的子类</strong></li><li><strong>Scala中数据类型分为两大类：数值类型（AnyVal）、引用类型（AnyRef），<font color=red >不管是值类型还是引用类型都是对象</font></strong></li><li><strong>Scala数据类型仍然遵守，<font color=red >低精度的值类型向高精度值类型自动转换</font>（隐式转换）</strong></li><li><strong>Scala中的StringOps是对Java中的String增强</strong></li><li><strong>Unit：对应Java中的void，用于方法返回值的位置，表示方法没有返回值。<font color=red >Unit是 一个数据类型</font>，只有一个对象就是<font color=red >()</font>。Void不是数据类型，只是一个关键字</strong></li><li><strong><font color=red >Null是一个类型</font>，只有一个对象就 是null。<font color=red >它是所有引用类型（AnyRef）的子类</font></strong></li><li><strong><font color=red >Nothing是所有数据类型的子类</font>，主要用在一个函数没有明确返回值时使用，因为这样我们可以把抛出的返回值，返回给任何的变量或者函数</strong></li></ul><h3 id="1-整数类型（Byte、Short、Int、Long）">1.整数类型（Byte、Short、Int、Long）</h3><p><strong>Scala的整数类型就是用于存放整数值的，比如12，30，3456等</strong></p><table><tr align=center><th>数据类型</th><th>描述</th></tr><tr align=center><td>Byte[1]</td><td align=left>8位有符号补码整数,数值区间为 -128到127</td></tr><tr align=center><td>Short[2]</td><td align=left>16位有符号补码整数，数值区间为 -32768到32767</td></tr><tr align=center><td>Int[4]</td><td align=left>32位有符号补码整数，数值区间为 -2147483648到2147483647</td></tr><tr align=center><td>Long[8]</td><td align=left>64位有符号补码整数，数值区间为 -9223372036854775808 到 9223372036854775807 = 2 的(64-1)次方-1</td></tr></table><ul><li><strong>Scala各整数类型有固定的表示范围和字段长度，不受具体操作的影响，以保证<br>Scala 程序的可移植性</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> n1:<span class="type">Byte</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">var</span> n2:<span class="type">Byte</span> = <span class="number">-128</span></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// var n3:Byte = 128</span></span><br><span class="line"><span class="comment">// var n4:Byte = -129</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Scala 的整型，默认为Int型，声明Long型，须后加‘l’或‘L’</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">var</span> n5 = <span class="number">10</span></span><br><span class="line">println(n5)</span><br><span class="line"><span class="keyword">var</span> n6 = <span class="number">9223372036854775807</span>L</span><br><span class="line">println(n6)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">9223372036854775807</span><br></pre></td></tr></table></figure><ul><li><strong>Scala程序中变量常声明为Int型，除非不足以表示大数，才使用Long</strong></li></ul><h3 id="2-浮点类型（Float、Double）">2.浮点类型（Float、Double）</h3><p><strong>Scala的浮点类型可以表示一个小数，比如 123.4f，7.8，0.12 等等</strong></p><table><tr align=center><th>数据类型</th><th>描述</th></tr><tr align=center><td>Float [4]</td><td align=left>32位, IEEE 754 标准的单精度浮点数</td></tr><tr align=center><td>Double [8]</td><td align=left>64位 IEEE 754 标准的双精度浮点数</td></tr></table><ul><li><strong>Scala 的浮点型常量默认为 Double 型，声明 Float 型常量，须后加“f”或“F”</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 在开发中需要高精度小数时，请选择 Double</span></span><br><span class="line"><span class="keyword">var</span> n7 = <span class="number">2.2345678912</span>f</span><br><span class="line"><span class="keyword">var</span> n8 = <span class="number">2.2345678912</span></span><br><span class="line">println(<span class="string">&quot;n7=&quot;</span> + n7)</span><br><span class="line">println(<span class="string">&quot;n8=&quot;</span> + n8)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n7=2.2345679</span><br><span class="line">n8=2.2345678912</span><br></pre></td></tr></table></figure><h3 id="3-字符类型（Char）">3.字符类型（Char）</h3><p><strong>字符类型（Char）可以表示单个字符</strong></p><ul><li><strong>字符常量是用单引号 ’ ’ 括起来的单个字符</strong></li><li><strong>\t ：一个制表位，实现对齐的功能</strong></li><li><strong>\n ：换行符</strong></li><li><strong>\\ ：表示 \</strong></li><li><strong>\&quot; ：表示&quot;</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//1）字符常量是用单引号 &#x27; &#x27; 括起来的单个字符。</span></span><br><span class="line">    <span class="keyword">var</span> c1: <span class="type">Char</span> = &#x27;a&#x27;</span><br><span class="line">    println(<span class="string">&quot;c1=&quot;</span> + c1)</span><br><span class="line">    <span class="comment">//注意：这里涉及自动类型提升，其实编译器可以自定判断是否超出范围，</span></span><br><span class="line">    <span class="comment">//不过 idea 提示报错</span></span><br><span class="line"><span class="comment">//    var c2:Char = &#x27;a&#x27; + 1</span></span><br><span class="line"><span class="comment">//    println(c2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2）\t ：一个制表位，实现对齐的功能</span></span><br><span class="line">    println(<span class="string">&quot;姓名\t 年龄&quot;</span>)</span><br><span class="line">    <span class="comment">//3）\n ：换行符</span></span><br><span class="line">    println(<span class="string">&quot;西门庆\n 潘金莲&quot;</span>)</span><br><span class="line">    <span class="comment">//4）\\ ：表示\</span></span><br><span class="line">    println(<span class="string">&quot;c:\\user\\local&quot;</span>)</span><br><span class="line">    <span class="comment">//5）\&quot; ：表示&quot;</span></span><br><span class="line">    println(<span class="string">&quot;同学们都说：\&quot;hello scala\&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c1=a</span><br><span class="line">姓名 年龄</span><br><span class="line">西门庆</span><br><span class="line"> 潘金莲</span><br><span class="line">c:\user\local</span><br><span class="line">同学们都说：&quot;hello scala&quot;</span><br></pre></td></tr></table></figure><h3 id="4-布尔类型（Boolean）">4.布尔类型（Boolean）</h3><ul><li><strong>布尔类型也叫Boolean类型，Boolean类型数据只允许取值true和false</strong></li><li><strong>Boolean类型占1个字节</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> isResult : <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> isResult2 : <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="5-Unit类型、Null类型和Nothing类型">5.Unit类型、Null类型和Nothing类型</h3><table><tr align=center><th>数据类型</th><th>描述</th></tr><tr align=center><td>Unit</td><td align=left>表示无值，和其他语言中 void 等同。用作不返回任何结果的方法的结果类型。Unit 只有一个实例值，写成()</td></tr><tr align=center><td>Null</td><td align=left>null , Null 类型只有一个实例值 null</td></tr><tr align=center><td>Nothing</td><td align=left>Nothing 类型在 Scala 的类层级最低端；它是任何其他类型的子类型。当一个函数，我们确定没有正常的返回值，可以用 Nothing 来指定返回类型，这样有一个好处，就是我们可以把返回的值（异常）赋给其它的函数或者变量（兼容性）</td></tr></table><ul><li><strong>Unit 类型用来标识过程，也就是没有明确返回值的函数</strong></li><li><strong>由此可见，Unit 类似于 Java 里的 void，Unit 只有一个实例——( )，这个实例也没有实质意义</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayOk</span> </span>: <span class="type">Unit</span> = &#123;<span class="comment">// unit 表示没有返回值，即 void</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">println(sayOk)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()</span><br></pre></td></tr></table></figure><ul><li><strong>Null 类只有一个实例对象，Null 类似于 Java 中的 null 引用。Null 可以赋值给任意引用类型（AnyRef），但是不能赋值给值类型（AnyVal）</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//null 可以赋值给任意引用类型（AnyRef），但是不能赋值给值类型</span></span><br><span class="line">（<span class="type">AnyVal</span>）</span><br><span class="line"> <span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="type">Cat</span>();</span><br><span class="line"> cat = <span class="literal">null</span> <span class="comment">// 正确</span></span><br><span class="line"> <span class="keyword">var</span> n1: <span class="type">Int</span> = <span class="literal">null</span> <span class="comment">// 错误</span></span><br><span class="line"> println(<span class="string">&quot;n1:&quot;</span> + n1)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Nothing，可以作为没有正常返回值的方法的返回类型，非常直观的告诉你这个方法不会正常返回，而且由于 Nothing 是其他任意类型的子类，他还能跟要求返回值的方法兼容</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>() : <span class="type">Nothing</span>=&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>()</span><br><span class="line">&#125;</span><br><span class="line">test</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换">类型转换</h2><h3 id="1-类型自动转换">1.类型自动转换</h3><p><strong>当 Scala 程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数值类型，这个就是自动类型转换（隐式转换）。数据类型按精度（容量）大小排序为：</strong><br><img src="https://img-blog.csdnimg.cn/2021033015285326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>自动提升原则：有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度大的那种数据类型，然后再进行计算</strong></li><li><strong>把精度大的数值类型赋值给精度小的数值类型时，就会报错，反之就会进行自动类型转换</strong></li><li><strong>（byte，short）和 char 之间不会相互自动转换</strong></li><li><strong>byte，short，char 这三者可以计算，在计算时首先转换为 int 类型</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//1）自动提升原则：有多种类型的数据混合运算时，系统首先自动将所有数据转换成精度大的那种数值类型，然后再进行计算</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span> + <span class="number">2.0</span></span><br><span class="line">println(n) <span class="comment">// n 就是 Double</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2）把精度大的数值类型赋值给精度小的数值类型时，就会报错，反之就会进行自动类型转换</span></span><br><span class="line"><span class="keyword">var</span> n2 : <span class="type">Double</span>= <span class="number">1.0</span></span><br><span class="line"><span class="comment">//var n3 : Int = n2 //错误，原因不能把高精度的数据直接赋值和低精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3）（byte，short）和 char 之间不会相互自动转换</span></span><br><span class="line"><span class="keyword">var</span> n4 : <span class="type">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//var c1 : Char = n4 //错误</span></span><br><span class="line"><span class="keyword">var</span> n5:<span class="type">Int</span> = n4</span><br><span class="line"></span><br><span class="line"><span class="comment">//4）byte，short，char 他们三者可以计算，在计算时首先转换为 int类型</span></span><br><span class="line"><span class="keyword">var</span> n6 : <span class="type">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> c2 : <span class="type">Char</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// var n : Short = n6 + c2 //当 n6 + c2 结果类型就是 int</span></span><br><span class="line"><span class="comment">// var n7 : Short = 10 + 90 //错误</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br></pre></td></tr></table></figure><h3 id="2-强制类型转换">2.强制类型转换</h3><p><strong>自动类型转换的逆过程，将精度大的数值类型转换为精度小的数值类型。使用时要加上强制转函数，但可能造成精度降低或溢出</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1）将数据由高精度转换为低精度，就需要使用到强制转换</span></span><br><span class="line">    <span class="keyword">var</span> n1: <span class="type">Int</span> = <span class="number">2.5</span>.toInt <span class="comment">// 这个存在精度损失</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2）强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</span></span><br><span class="line">    <span class="keyword">var</span> r1: <span class="type">Int</span> = <span class="number">10</span> * <span class="number">3.5</span>.toInt + <span class="number">6</span> * <span class="number">1.5</span>.toInt <span class="comment">// 10 *3 + 6*1 = 36</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> r2: <span class="type">Int</span> = (<span class="number">10</span> * <span class="number">3.5</span> + <span class="number">6</span> * <span class="number">1.5</span>).toInt <span class="comment">// 44.0.toInt = 44</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;r1=&quot;</span> + r1 + <span class="string">&quot; r2=&quot;</span> + r2)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r1=36 r2=44</span><br></pre></td></tr></table></figure><h3 id="3-数值类型和String类型转换">3.数值类型和String类型转换</h3><p><strong>在程序开发中，经常需要将基本数值类型转成 String 类型，或者将 String 类型转成基本数值类型</strong></p><ul><li><strong>基本类型转 String 类型（语法：将基本类型的值+“” 即可）</strong></li><li><strong>String 类型转基本数值类型（语法：s1.toInt、s1.toFloat、s1.toDouble、s1.toByte、s1.toLong、s1.toShort）</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（1）基本类型转 String 类型（语法：将基本类型的值+&quot;&quot; 即可）</span></span><br><span class="line">    <span class="keyword">var</span> str1 : <span class="type">String</span> = <span class="literal">true</span> + <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> str2 : <span class="type">String</span> = <span class="number">4.5</span> + <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> str3 : <span class="type">String</span> = <span class="number">100</span> +<span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（2）String 类型转基本数值类型（语法：调用相关 API）</span></span><br><span class="line">    <span class="keyword">var</span> s1 : <span class="type">String</span> = <span class="string">&quot;12&quot;</span></span><br><span class="line">    <span class="keyword">var</span> n1 : <span class="type">Byte</span> = s1.toByte</span><br><span class="line">    <span class="keyword">var</span> n2 : <span class="type">Short</span> = s1.toShort</span><br><span class="line">    <span class="keyword">var</span> n3 : <span class="type">Int</span> = s1.toInt</span><br><span class="line">    <span class="keyword">var</span> n4 : <span class="type">Long</span> = s1.toLong</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong><font color=red >注意事项：</font>在将 String 类型转成基本数值类型时，要确保 String 类型能够转成有效的数据，比如我们可以把&quot;123&quot;，转成一个整数，但是不能把&quot;hello&quot;转成一个整数</strong></p><h1 id="三、运算符">三、运算符</h1><h2 id="算术运算符">算术运算符</h2><table><tr align=center><th>运算符</th><th>运算</th><th>范例</th><th>结果</th></tr><tr align=center><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr align=center><td>-</td><td>负号</td><td>b=4; -b</td><td>-4</td></tr><tr align=center><td>+</td><td>加</td><td>5+5</td><td>10</td></tr><tr align=center><td>-</td><td>减</td><td>6-4</td><td>2</td></tr><tr align=center><td>*</td><td>乘</td><td>3*4</td><td>12</td></tr><tr align=center><td>/</td><td>除</td><td>5/5</td><td>1</td></tr><tr align=center><td>%</td><td>取模（取余）</td><td>7%5</td><td>2</td></tr><tr align=center><td>+</td><td>字符串相加</td><td>"He"+"llo"</td><td>"hello"</td></tr></table><h2 id="关系运算符">关系运算符</h2><table><tr align=center><th>运算符</th><th>运算</th><th>范例</th><th>结果</th></tr><tr align=center><td>==</td><td>相等于</td><td>4==3</td><td>false</td></tr><tr align=center><td>!=</td><td>不等于</td><td>4 != 3</td><td>true</td></tr><tr align=center><td><</td><td>小于</td><td>4<3</td><td>false</td></tr><tr align=center><td>></td><td>大于</td><td>4>3</td><td>true</td></tr><tr align=center><td><=</td><td>小于等于</td><td>4<=3</td><td>false</td></tr><tr align=center><td>>=</td><td>大于等于</td><td>4>=3</td><td>true</td></tr></table><ul><li><strong>Java</strong><ul><li>==比较两个变量本身的值，即两个对象在内存中的首地址</li><li>equals比较字符串中所包含的内容是否相同</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><ul><li><strong>Scala</strong><ul><li>==更类似于Java中equals</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> s1 = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="keyword">new</span> <span class="type">String</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">println(s1 == s2)</span><br><span class="line">println(s1.eq(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符">逻辑运算符</h2><p><strong>用于连接多个条件（一般来讲就是关系表达式），最终的结果也是一个Boolean值</strong><br><font color=#999AAA ><strong>设：变量A为true，B为false</strong></font></p><table><tr align=center><th>运算符</th><th>描述</th><th>实例</th></tr><tr align=center><td>&&</td><td>逻辑与</td><td>(A && B) 运算结果为 false</td></tr><tr align=center><td>||</td><td>逻辑或</td><td>(A || B) 运算结果为 true</td></tr><tr align=center><td>!</td><td>逻辑非</td><td>!(A && B) 运算结果为 true</td></tr></table><h2 id="赋值运算符">赋值运算符</h2><p><strong>赋值运算符就是将某个运算后的值，赋给指定的变量</strong></p><table><tr align=center><th>运算符</th><th align="left">描述</th><th align="left">实例</th></tr><tr align=center><td>=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td align="left">C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr align=center><td>+=</td><td align="left">相加后再赋值</td><td align="left">C += A 等于 C = C + A</td></tr><tr align=center><td>-=</td><td align="left">相减后再赋值</td><td align="left">C -= A 等于 C = C - A</td></tr><tr align=center><td>*=</td><td align="left">相乘后再赋值</td><td align="left">C *= A 等于 C = C * A</td></tr><tr align=center><td>/=</td><td align="left">相除后再赋值</td><td align="left">C /= A 等于 C = C / A</td></tr><tr align=center><td>%=</td><td align="left">求余后再赋值</td><td align="left">C %= A 等于 C = C % A</td></tr><tr align=center><td><<=</td><td align="left">左移后赋值</td><td align="left">C <<= 2 等于 C = C << 2</td></tr><tr align=center><td>>>=</td><td align="left">右移后赋值</td><td align="left">C >>= 2 等于 C = C >> 2</td></tr><tr align=center><td>&=</td><td align="left">按位与后赋值</td><td align="left">C &= 2 等于 C = C & 2</td></tr><tr align=center><td>^=</td><td align="left">按位异或后赋值</td><td align="left">C ^= 2 等于 C = C ^ 2</td></tr><tr align=center><td>|=</td><td align="left">按位或后赋值</td><td align="left">C |= 2 等于 C = C | 2</td></tr></table><p><font color=red><strong>注：</strong></font>Scala中没有++、–操作符，可以通过+=、-=来实现同样的效果</p><h2 id="位运算符">位运算符</h2><p><font color=#999AAA ><strong>设：表中变量a为60，b为13</strong></font></p><table><tr align=center><th>运算符</th><th align="left">描述</th><th align="left">实例</th></tr><tr align=center><td>&</td><td align="left">按位与运算符</td><td align="left">(a & b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr align=center><td>|</td><td align="left">按位或运算符</td><td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr align=center><td>^</td><td align="left">按位异或运算符</td><td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr align=center><td>~</td><td align="left">按位取反运算符</td><td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式</td></tr><tr align=center><td><<</td><td align="left">左移动运算符</td><td align="left">a << 2 输出结果 240 ，二进制解释： 0011 0000</td></tr><tr align=center><td>>></td><td align="left">右移动运算符</td><td align="left">a >> 2 输出结果 15 ，二进制解释： 0000 1111</td></tr><tr align=center><td>>>></td><td align="left">无符号右移</td><td align="left">a >>>2 输出结果 15, 二进制解释: 0000 1111</td></tr></table><h2 id="运算符的本质">运算符的本质</h2><p><strong>在Scala中其实是没有运算符的，所有运算符都是方法</strong></p><ul><li><strong>当调用对象的方法时，<font color=red>点.</font>可以省略</strong></li><li><strong>如果函数参数只有一个，或者没有参数，()可以省略</strong></li></ul><h1 id="四、if、for及while循环">四、if、for及while循环</h1><h2 id="if分支控制">if分支控制</h2><h3 id="1-单分支">1.单分支</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：当条件表达式为true时，就会执行{ }的代码</strong></p><ul><li><strong>案例</strong><ul><li>输入人的年龄，如果年龄小于 18 岁，则输出“未成年”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age:&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readShort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age:</span><br><span class="line">16</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure><h3 id="2-双分支">2.双分支</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">执行代码块 <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">执行代码块 <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>输入年龄，如果年龄小于 18 岁，则输出“未成年”，否则，输出“成年”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age:&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readShort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      println(<span class="string">&quot;成年&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age:</span><br><span class="line">20</span><br><span class="line">成年</span><br></pre></td></tr></table></figure><h3 id="3-多分支">3.多分支</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式 <span class="number">1</span>) &#123;</span><br><span class="line">执行代码块 <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件表达式 <span class="number">2</span>) &#123;</span><br><span class="line">执行代码块 <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">执行代码块 n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例1</strong><ul><li>输入年龄，如果年龄小于 18 岁，则输出“未成年”，如果年龄大于等于 18 且小于等于 30，则输出“中年”，否则，输出“老年”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;未成年&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;=<span class="number">18</span> &amp;&amp; age&lt;<span class="number">30</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;中年&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      println(<span class="string">&quot;老年&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">45</span><br><span class="line">老年</span><br></pre></td></tr></table></figure><ul><li><strong>案例2</strong><ul><li>Scala 中 if-else 表达式其实是有返回值的，具体返回值取决于满足条件的代码体的最后一行内容</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">val</span> res :<span class="type">String</span> = <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      <span class="string">&quot;未成年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;=<span class="number">18</span> &amp;&amp; age&lt;<span class="number">30</span>)&#123;</span><br><span class="line">      <span class="string">&quot;中年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="string">&quot;老年&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">26</span><br><span class="line">中年</span><br></pre></td></tr></table></figure><ul><li><strong>案例3</strong><ul><li>Scala 中返回值类型不一致，取它们共同的祖先类型</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">val</span> res:<span class="type">Any</span> = <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      <span class="string">&quot;未成年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;=<span class="number">18</span> &amp;&amp; age&lt;<span class="number">30</span>)&#123;</span><br><span class="line">      <span class="string">&quot;中年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="number">120</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">66</span><br><span class="line">120</span><br></pre></td></tr></table></figure><ul><li><strong>案例4</strong><ul><li>可以用 if-else 实现Java中的三元运算符</li><li><font color=red>如果大括号{}内的逻辑代码只有一行，大括号可以省略，省略后，if 只对最近的一行逻辑代码起作用</font></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Java</span></span><br><span class="line"><span class="comment">//    int result = flag?1:0</span></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">val</span> res:<span class="type">Any</span> = <span class="keyword">if</span> (age &lt; <span class="number">18</span>) <span class="string">&quot;童年&quot;</span> <span class="keyword">else</span> <span class="string">&quot;成年&quot;</span></span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">23</span><br><span class="line">成年</span><br></pre></td></tr></table></figure><h3 id="4-嵌套分支">4.嵌套分支</h3><p><strong>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层，分支外面的分支结构称为外层分支（嵌套分支不要超过3层）</strong></p><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>如果输入的年龄小于 18，返回“未成年”，如果输入的年龄大于等于 18，需要再判断：如果年龄大于等于 18 且小于 30，返回“中年”，如果其他，返回“老年”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;input age：&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> age = <span class="type">StdIn</span>.readInt()</span><br><span class="line">    <span class="keyword">val</span> res :<span class="type">String</span> = <span class="keyword">if</span> (age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">      <span class="string">&quot;未成年&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(age&gt;=<span class="number">18</span> &amp;&amp; age&lt;<span class="number">30</span>)&#123;</span><br><span class="line">        <span class="string">&quot;中年&quot;</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="string">&quot;老年&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input age：</span><br><span class="line">99</span><br><span class="line">老年</span><br></pre></td></tr></table></figure><h2 id="for循环控制">for循环控制</h2><h3 id="1-范围数据循环（To）">1.范围数据循环（To）</h3><ul><li><strong>基本语法</strong><ul><li>i 表示循环的变量，&lt;-规定to</li><li>i 将会从1-3循环，前后闭合</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>)&#123;</span><br><span class="line">print(i + <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>输出 5 句 “编程怎么这么难”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">5</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;编程怎么这么难&quot;</span>+i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编程怎么这么难1</span><br><span class="line">编程怎么这么难2</span><br><span class="line">编程怎么这么难3</span><br><span class="line">编程怎么这么难4</span><br><span class="line">编程怎么这么难5</span><br></pre></td></tr></table></figure><h3 id="2-范围数据循环（Until）">2.范围数据循环（Until）</h3><ul><li><strong>基本语法</strong><ul><li>和前面的区别在于 i 是从 1 到 3-1</li><li>即前闭合后开的范围</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>)&#123;</span><br><span class="line">print(i + <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 </span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>输出 5 句 “编程怎么这么难”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">1</span> until <span class="number">6</span>)&#123;</span><br><span class="line">      println(<span class="string">&quot;编程怎么这么难&quot;</span> + i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编程怎么这么难1</span><br><span class="line">编程怎么这么难2</span><br><span class="line">编程怎么这么难3</span><br><span class="line">编程怎么这么难4</span><br><span class="line">编程怎么这么难5</span><br></pre></td></tr></table></figure><h3 id="3-循环守卫">3.循环守卫</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span> <span class="keyword">if</span> i != <span class="number">2</span>) &#123;</span><br><span class="line"> print(i + <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 </span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>循环守卫，即循环保护式（也称条件判断式守卫），保护式为 true 则进入循环体内部，为 false 则跳过，类似于 continue</li></ul></li><li><strong>案例</strong><ul><li>输出 1 到 5 中，不等于 3 的值</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">5</span> <span class="keyword">if</span> i != <span class="number">3</span>) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="4-循环步长">4.循环步长</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span> by <span class="number">2</span>) &#123;</span><br><span class="line">println(<span class="string">&quot;i=&quot;</span> + i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">i=3</span><br><span class="line">i=5</span><br><span class="line">i=7</span><br><span class="line">i=9</span><br></pre></td></tr></table></figure><p><strong>说明：by表示步长</strong></p><ul><li><strong>案例</strong><ul><li>输出 1 到 10 以内的所有奇数</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span> by <span class="number">2</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;i=&quot;</span> + i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">i=3</span><br><span class="line">i=5</span><br><span class="line">i=7</span><br><span class="line">i=9</span><br></pre></td></tr></table></figure><h3 id="5-嵌套循环">5.嵌套循环</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>; j &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot; i =&quot;</span> + i + <span class="string">&quot; j = &quot;</span> + j)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i =1 j = 1</span><br><span class="line">i =1 j = 2</span><br><span class="line">i =1 j = 3</span><br><span class="line">i =2 j = 1</span><br><span class="line">i =2 j = 2</span><br><span class="line">i =2 j = 3</span><br><span class="line">i =3 j = 1</span><br><span class="line">i =3 j = 2</span><br><span class="line">i =3 j = 3</span><br></pre></td></tr></table></figure><p><strong>说明：没有关键字，所以范围后一定要加 ; 来隔断逻辑</strong></p><ul><li><strong>与上面的代码等价</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (j &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line">println(<span class="string">&quot;i =&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-引入变量">6.引入变量</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span>; j = <span class="number">4</span> - i) &#123;</span><br><span class="line">println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=1 j=3</span><br><span class="line">i=2 j=2</span><br><span class="line">i=3 j=1</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>for 推导式一行中有多个表达式时，所以要加 ; 来隔断逻辑</li><li>for 推导式有一个不成文的约定：当 for 推导式仅包含单一表达式时使用圆括号，当包含多个表达式时，一般每行一个表达式，并用花括号代替圆括号</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i &lt;- <span class="number">1</span> to <span class="number">3</span></span><br><span class="line">j = <span class="number">4</span> - i</span><br><span class="line">&#125; &#123;</span><br><span class="line">println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>等价于上面的代码</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">4</span> - i</span><br><span class="line">println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot; j=&quot;</span> + j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-循环返回值">7.循环返回值</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> res = <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> i</span><br><span class="line">println(res)</span><br></pre></td></tr></table></figure><p><strong>说明：将遍历过程中处理的结果返回到一个新 Vector 集合中，使用 yield 关键字（开发中很少使用）</strong></p><ul><li><strong>案例</strong><ul><li>将原数据中所有值乘以 2，并把数据返回到一个新的集合中</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">for</span>(i &lt;<span class="number">-1</span> to <span class="number">10</span>) <span class="keyword">yield</span> &#123;</span><br><span class="line">      i * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(res)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)</span><br></pre></td></tr></table></figure><h3 id="8-倒叙打印">8.倒叙打印</h3><ul><li><strong>如果想倒序打印一组数据，可以用 reverse</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span> reverse)&#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="while和do…while循环控制">while和do…while循环控制</h2><h3 id="1-while循环控制">1.while循环控制</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (循环条件) &#123;</span><br><span class="line">循环体(语句) 循环变量迭代</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>循环条件是返回一个布尔值的表达式</li><li>while 循环是先判断再执行语句</li><li>与 for 语句不同，while 语句没有返回值，即整个 while 语句的结果是<font color=red>Unit 类型()</font></li><li>因为 while 中没有返回值，所以当要用该语句来计算并返回结果时，就不可避免的使用变量，而变量需要声明在while 循环的外部，那么就等同于循环的内部对外部的变量造成了影响，所以不推荐使用，而是推荐使用 for 循环</li></ul></li><li><strong>案例</strong><ul><li>输出 10 句 “努力搬砖，从我做起”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">println(<span class="string">&quot;努力搬砖，从我做起&quot;</span> + i)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">努力搬砖，从我做起0</span><br><span class="line">努力搬砖，从我做起1</span><br><span class="line">努力搬砖，从我做起2</span><br><span class="line">努力搬砖，从我做起3</span><br><span class="line">努力搬砖，从我做起4</span><br><span class="line">努力搬砖，从我做起5</span><br><span class="line">努力搬砖，从我做起6</span><br><span class="line">努力搬砖，从我做起7</span><br><span class="line">努力搬砖，从我做起8</span><br><span class="line">努力搬砖，从我做起9</span><br></pre></td></tr></table></figure><h3 id="2-do…while循环控制"><a href="http://2.do">2.do</a>…while循环控制</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体(语句)</span><br><span class="line">循环变量迭代</span><br><span class="line">&#125; <span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>循环条件是返回一个布尔值的表达式</li><li>do…while 循环是先执行，再判断</li></ul></li><li><strong>案例</strong><ul><li>输出 10 句 “活到老，搬到老”</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">println(<span class="string">&quot;活到老，搬到老&quot;</span> + i)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">活到老，搬到老0</span><br><span class="line">活到老，搬到老1</span><br><span class="line">活到老，搬到老2</span><br><span class="line">活到老，搬到老3</span><br><span class="line">活到老，搬到老4</span><br><span class="line">活到老，搬到老5</span><br><span class="line">活到老，搬到老6</span><br><span class="line">活到老，搬到老7</span><br><span class="line">活到老，搬到老8</span><br><span class="line">活到老，搬到老9</span><br></pre></td></tr></table></figure><h3 id="3-循环中断">3.循环中断</h3><ul><li><strong>基本说明</strong><ul><li>Scala 内置控制结构特地去掉了 break 和 continue，是为了更好的适应函数式编程，推荐使用函数式的风格解决break 和continue 的功能，而不是一个关键字。Scala 中使用<font color=red>breakable 控制结构</font>来实现 break 和 continue 功能</li></ul></li><li><strong>案例1</strong><ul><li>采用异常的方式退出循环</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123; println(elem)</span><br><span class="line"><span class="keyword">if</span> (elem == <span class="number">5</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e =&gt;</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;正常结束循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">正常结束循环</span><br></pre></td></tr></table></figure><ul><li><strong>案例2</strong><ul><li>采用 Scala 自带的函数，退出循环</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="type">Breaks</span>.breakable(</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">      println(elem)</span><br><span class="line">      <span class="keyword">if</span> (elem == <span class="number">5</span>) <span class="type">Breaks</span>.<span class="keyword">break</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  println(<span class="string">&quot;正常结束循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">正常结束循环</span><br></pre></td></tr></table></figure><ul><li><strong>案例3</strong><ul><li>对break 进行省略</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.control.<span class="type">Breaks</span>._</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  breakable &#123;</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">      println(elem)</span><br><span class="line">      <span class="keyword">if</span> (elem == <span class="number">5</span>) <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">&quot;正常结束循环&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">正常结束循环</span><br></pre></td></tr></table></figure><ul><li><strong>案例4</strong><ul><li>循环遍历 10 以内的所有数据，奇数打印，偶数跳过（continue）</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line">  <span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elem % <span class="number">2</span> == <span class="number">1</span>) &#123; </span><br><span class="line">      println(elem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      println(<span class="string">&quot;continue&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">continue</span><br><span class="line">3</span><br><span class="line">continue</span><br><span class="line">5</span><br><span class="line">continue</span><br><span class="line">7</span><br><span class="line">continue</span><br><span class="line">9</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><h3 id="4-多重循环">4.多重循环</h3><ul><li><strong>基本说明</strong><ul><li>将 一 个 循 环 放 在 另 一 个 循 环 体 内 ， 就 形 成 了 嵌 套 循 环 。 其 中 ，for，while，do…while均可以作为外层循环和内层循环</li><li>设外层循环次数为m 次，内层为 n 次，则内层循环体实际上需要执行<font color=red> m*n </font>次</li></ul></li><li><strong>案例</strong><ul><li>打印九九乘法表</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j &lt;- <span class="number">1</span> to i) &#123;</span><br><span class="line">      print(j + <span class="string">&quot;*&quot;</span> + i + <span class="string">&quot;=&quot;</span> + (i * j) + <span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=22*2=4</span><br><span class="line">1*3=32*3=63*3=9</span><br><span class="line">1*4=42*4=83*4=124*4=16</span><br><span class="line">1*5=52*5=103*5=154*5=205*5=25</span><br><span class="line">1*6=62*6=123*6=184*6=245*6=306*6=36</span><br><span class="line">1*7=72*7=143*7=214*7=285*7=356*7=427*7=49</span><br><span class="line">1*8=82*8=163*8=244*8=325*8=406*8=487*8=568*8=64</span><br><span class="line">1*9=92*9=183*9=274*9=365*9=456*9=547*9=638*9=729*9=81</span><br></pre></td></tr></table></figure><h1 id="五、函数式编程">五、函数式编程</h1><ul><li><strong>面向对象编程</strong><ul><li>解决问题，分解对象，行为，属性，然后通过对象的关系以及行为的调用来解决问题</li><li>对象：用户</li><li>行为：登录、连接JDBC、读取数据库</li><li>属性：用户名、密码</li><li>Scala 语言是一个完全面向对象编程语言：<font color=red>万物皆对象</font></li><li><font color=red>对象的本质：对数据和行为的一个封装</font></li></ul></li><li><strong>函数式编程</strong><ul><li>解决问题时，将问题分解成一个一个的步骤，将每个步骤进行封装（函数），通过调用这些封装好的步骤，解决问题<ul><li>例：请求-&gt;用户名、密码-&gt;连接 JDBC-&gt;读取数据库</li></ul></li><li><font color=red>Scala 语言是一个完全函数式编程语言：万物皆函数</font></li><li><font color=red>函数的本质：函数可以当做一个值进行传递</font></li></ul></li><li><strong>Scala中函数式编程和面向对象编程完美的融合在一起了</strong></li></ul><h2 id="函数基础">函数基础</h2><h3 id="1-函数基本语法">1.函数基本语法</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span> </span>( x: <span class="type">Int</span> , y: <span class="type">Int</span>) : <span class="type">Int</span> = &#123;</span><br><span class="line">x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>def：定义函数的关键字</li><li>sum：函数名</li><li>x，y：参数名</li><li>Int：参数类型</li><li>Int：函数返回值类型</li><li>x + y：函数体</li></ul></li><li><strong>案例</strong><ul><li>定义一个函数，将传入的名称打印出来</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （1）函数定义</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(arg: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// （2）函数调用</span></span><br><span class="line">  <span class="comment">// 函数名（参数）</span></span><br><span class="line">  f(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="2-函数与方法的区别">2.函数与方法的区别</h3><ul><li><strong>核心概念</strong><ul><li>为完成某一功能的程序语句的集合，称为函数</li><li>类中的函数称之方法</li></ul></li><li><strong>区别</strong><ul><li>Scala 可以在任何的语法结构中声明任何的语法</li><li>函数没有重载和重写的概念，而方法可以进行重载和重写</li><li>Scala 中函数可以嵌套定义</li></ul></li></ul><h3 id="3-函数的定义">3.函数的定义</h3><ul><li><strong>函数的定义</strong><ul><li>函数 1：无参，无返回值</li><li>函数 2：无参，有返回值</li><li>函数 3：有参，无返回值</li><li>函数 4：有参，有返回值</li><li>函数 5：多参，无返回值</li><li>函数 6：多参，有返回值</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数 1：无参，无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">      println(<span class="string">&quot;无参，无返回值&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    test1()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数 2：无参，有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span></span>():<span class="type">String</span>=&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;无参，有返回值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(test2())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数 3：有参，无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test3</span></span>(s:<span class="type">String</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">      println(s)</span><br><span class="line">    &#125;</span><br><span class="line">    test3(<span class="string">&quot;jinlian&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数 4：有参，有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test4</span></span>(s:<span class="type">String</span>):<span class="type">String</span>=&#123;</span><br><span class="line">      <span class="keyword">return</span> s+<span class="string">&quot;有参，有返回值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(test4(<span class="string">&quot;hello &quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数 5：多参，无返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test5</span></span>(name:<span class="type">String</span>, age:<span class="type">Int</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">      println(<span class="string">s&quot;<span class="subst">$name</span>, <span class="subst">$age</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    test5(<span class="string">&quot;dalang&quot;</span>,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无参，无返回值</span><br><span class="line">无参，有返回值</span><br><span class="line">jinlian</span><br><span class="line">hello 有参，有返回值</span><br><span class="line">dalang, 40</span><br></pre></td></tr></table></figure><h3 id="4-函数的参数">4.函数的参数</h3><ul><li><strong>案例</strong><ul><li>可变参数</li><li>如果参数列表中存在多个参数，那么可变参数一般放置在最后</li><li>参数默认值，一般将有默认值的参数放置在参数列表的后面</li><li>带名参数</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （1）可变参数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>( s : <span class="type">String</span>* ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(s)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有输入参数：输出 Array</span></span><br><span class="line">  test(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Scala&quot;</span>)</span><br><span class="line">  <span class="comment">// 无输入参数：输出 List()</span></span><br><span class="line">  test()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (2)如果参数列表中存在多个参数，那么可变参数一般放置在最后</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test2</span></span>( name : <span class="type">String</span>, s: <span class="type">String</span>* ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(name + <span class="string">&quot;,&quot;</span> + s)</span><br><span class="line">  &#125;</span><br><span class="line">  test2(<span class="string">&quot;jinlian&quot;</span>, <span class="string">&quot;dalang&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (3)参数默认值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test3</span></span>( name : <span class="type">String</span>, age : <span class="type">Int</span> = <span class="number">30</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$name</span>, <span class="subst">$age</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果参数传递了值，那么会覆盖默认值</span></span><br><span class="line">  test3(<span class="string">&quot;jinlian&quot;</span>, <span class="number">20</span>)</span><br><span class="line">  <span class="comment">// 如果参数有默认值，在调用的时候，可以省略这个参数</span></span><br><span class="line">  test3(<span class="string">&quot;dalang&quot;</span>)</span><br><span class="line">  <span class="comment">// 一般情况下，将有默认值的参数放置在参数列表的后面</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test4</span></span>( sex : <span class="type">String</span> = <span class="string">&quot;男&quot;</span>, name : <span class="type">String</span> ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">s&quot;<span class="subst">$name</span>, <span class="subst">$sex</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Scala 函数中参数传递是，从左到右</span></span><br><span class="line">  <span class="comment">//test4(&quot;wusong&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//（4）带名参数</span></span><br><span class="line">  test4(name=<span class="string">&quot;ximenqing&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WrappedArray(Hello, Scala)</span><br><span class="line">List()</span><br><span class="line">jinlian,WrappedArray(dalang)</span><br><span class="line">jinlian, 20</span><br><span class="line">dalang, 30</span><br><span class="line">ximenqing, 男</span><br></pre></td></tr></table></figure><h3 id="5-至简原则">5.至简原则</h3><ul><li><strong>函数至简原则：能省就省</strong><ul><li>return 可以省略，Scala 会使用函数体的最后一行代码作为返回值</li><li>如果函数体只有一行代码，可以省略花括号</li><li>返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）</li><li>如果有 return，则不能省略返回值类型，必须指定</li><li>如果函数明确声明 unit，那么即使函数体中使用 return 关键字也不起作用</li><li>Scala 如果期望是无返回值类型，可以省略等号</li><li>如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</li><li>如果函数没有参数列表，那么小括号可以省略，调用时小括号必须省略</li><li>如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数标准写法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>( s : <span class="type">String</span> ): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> s + <span class="string">&quot; jinlian&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 至简原则:能省则省</span></span><br><span class="line">  <span class="comment">//（1） return 可以省略,Scala 会使用函数体的最后一行代码作为返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>( s : <span class="type">String</span> ): <span class="type">String</span> = &#123;</span><br><span class="line">    s + <span class="string">&quot; jinlian&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f1(<span class="string">&quot;Hello&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（2）如果函数体只有一行代码，可以省略花括号</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(s:<span class="type">String</span>):<span class="type">String</span> = s + <span class="string">&quot; jinlian&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//（3）返回值类型如果能够推断出来，那么可以省略（:和返回值类型一起省略）</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>( s : <span class="type">String</span> ) = s + <span class="string">&quot; jinlian&quot;</span></span><br><span class="line">  println(f3(<span class="string">&quot;Hello3&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（4）如果有 return，则不能省略返回值类型，必须指定。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f4</span></span>() :<span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ximenqing4&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f4())</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（5）如果函数明确声明 unit，那么即使函数体中使用 return 关键字也不起作用</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f5</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;dalang5&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f5())</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（6）Scala 如果期望是无返回值类型,可以省略等号</span></span><br><span class="line">  <span class="comment">// 将无返回值的函数称之为过程</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f6</span></span>() &#123;</span><br><span class="line">    <span class="string">&quot;dalang6&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(f6())</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（7）如果函数无参，但是声明了参数列表，那么调用时，小括号，可加可不加</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f7</span></span>() = <span class="string">&quot;dalang7&quot;</span></span><br><span class="line">  println(f7())</span><br><span class="line">  println(f7)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//（8）如果函数没有参数列表，那么小括号可以省略,调用时小括号必须省略</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f8</span> </span>= <span class="string">&quot;dalang&quot;</span></span><br><span class="line">  <span class="comment">//println(f8())</span></span><br><span class="line">  println(f8)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//（9）如果不关心名称，只关心逻辑处理，那么函数名（def）可以省略</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f9</span> </span>= (x:<span class="type">String</span>)=&gt;&#123;println(<span class="string">&quot;wusong&quot;</span>)&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f10</span></span>(f:<span class="type">String</span>=&gt;<span class="type">Unit</span>) = &#123;</span><br><span class="line">    f(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  f10(f9)</span><br><span class="line">  println(f10((x:<span class="type">String</span>)=&gt;&#123;println(<span class="string">&quot;wusong&quot;</span>)&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hello jinlian</span><br><span class="line">Hello jinlian</span><br><span class="line">Hello3 jinlian</span><br><span class="line">ximenqing4</span><br><span class="line">()</span><br><span class="line">()</span><br><span class="line">dalang7</span><br><span class="line">dalang7</span><br><span class="line">dalang</span><br><span class="line">wusong</span><br><span class="line">wusong</span><br><span class="line">()</span><br></pre></td></tr></table></figure><h2 id="函数进阶">函数进阶</h2><h3 id="1-高阶函数">1.高阶函数</h3><ul><li><strong>函数可以作为值进行传递</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//（1）调用 foo 函数，把返回值给变量 f</span></span><br><span class="line">  <span class="comment">//val f = foo()</span></span><br><span class="line">  <span class="keyword">val</span> f = foo</span><br><span class="line">  println(f)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//（2）在被调用函数 foo 后面加上 _，相当于把函数 foo 当成一个整体，传递给变量 f1</span></span><br><span class="line">  <span class="keyword">val</span> f1 = foo _</span><br><span class="line">  foo()</span><br><span class="line">  f1()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//（3）如果明确变量类型，那么不使用下划线也可以将函数作为整体传递给变量</span></span><br><span class="line">  <span class="keyword">var</span> f2:()=&gt;<span class="type">Int</span> = foo</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>():<span class="type">Int</span> = &#123;</span><br><span class="line">  println(<span class="string">&quot;foo...&quot;</span>)</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo...</span><br><span class="line">1</span><br><span class="line">foo...</span><br><span class="line">foo...</span><br></pre></td></tr></table></figure><ul><li><strong>函数可以作为参数进行传递</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （1）定义一个函数，函数参数还是一个函数签名；f 表示函数名称;(Int,Int)表示输入两个 Int 参数；Int 表示函数返回值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(f: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    f(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （2）定义一个函数，参数和返回值类型和 f1 的输入参数一致</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （3）将 add 函数作为参数传递给 f1 函数，如果能够推断出来不是调用，_可以省略</span></span><br><span class="line">  println(f1(add))</span><br><span class="line">  println(f1(add _))</span><br><span class="line">  <span class="comment">//可以传递匿名函数</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure><ul><li><strong>函数可以作为函数返回值返回</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>() = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>() = &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f2 _</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> f = f1()</span><br><span class="line">  <span class="comment">// 因为 f1 函数的返回值依然为函数，所以可以变量 f 可以作为函数继续调用</span></span><br><span class="line">  f()</span><br><span class="line">  <span class="comment">// 上面的代码可以简化为</span></span><br><span class="line">  f1()()</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-匿名函数">2.匿名函数</h3><ul><li><strong>说明</strong><ul><li>没有名字的函数就是匿名函数</li><li>(x:Int)=&gt;{函数体}</li><li>x：表示输入参数类型；Int：表示输入参数类型；函数体：表示具体代码逻辑</li></ul></li><li><strong>案例1</strong><ul><li>传递的函数有一个参数<ul><li><font color=red>传递匿名函数至简原则</font></li><li><font color=red>参数的类型可以省略，会根据形参进行自动的推导</font></li><li><font color=red>类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过 1 的永远不能省略圆括号</font></li><li><font color=red>匿名函数如果只有一行，则大括号也可以省略</font></li><li><font color=red>如果参数只出现一次，则参数省略且后面参数可以用_代替</font></li></ul></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// （1）定义一个函数：参数包含数据和逻辑函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">operation</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], op: <span class="type">Int</span> =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- arr) <span class="keyword">yield</span> op(elem)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （2）定义逻辑函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(ele: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    ele + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （3）标准函数调用</span></span><br><span class="line">  <span class="keyword">val</span> arr = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), op)</span><br><span class="line">  println(arr.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （4）采用匿名函数</span></span><br><span class="line">  <span class="keyword">val</span> arr1 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (ele: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">    ele + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  println(arr1.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （4.1）参数的类型可以省略，会根据形参进行自动的推导;</span></span><br><span class="line">  <span class="keyword">val</span> arr2 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (ele) =&gt; &#123;</span><br><span class="line">    ele + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  println(arr2.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// （4.2）类型省略之后，发现只有一个参数，则圆括号可以省略；其他情况：没有参数和参数超过 1 的永远不能省略圆括号。</span></span><br><span class="line">  <span class="keyword">val</span> arr3 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), ele =&gt; &#123;</span><br><span class="line">    ele + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  println(arr3.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// (4.3) 匿名函数如果只有一行，则大括号也可以省略</span></span><br><span class="line">  <span class="keyword">val</span> arr4 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), ele =&gt; ele + <span class="number">1</span>)</span><br><span class="line">  println(arr4.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//（4.4）如果参数只出现一次，则参数省略且后面参数可以用_代替</span></span><br><span class="line">  <span class="keyword">val</span> arr5 = operation(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), _ + <span class="number">1</span>)</span><br><span class="line">  println(arr5.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br><span class="line">2,3,4,5</span><br></pre></td></tr></table></figure><ul><li><strong>案例2</strong><ul><li>传递的函数有两个参数</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">calculator</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>, op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    op(a, b)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// （1）标准版</span></span><br><span class="line">  println(calculator(<span class="number">2</span>, <span class="number">3</span>, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;x + y&#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （2）如果只有一行，则大括号也可以省略</span></span><br><span class="line">  println(calculator(<span class="number">2</span>, <span class="number">3</span>, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （3）参数的类型可以省略，会根据形参进行自动的推导;</span></span><br><span class="line">  println(calculator(<span class="number">2</span>, <span class="number">3</span>, (x , y) =&gt; x + y))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （4）如果参数只出现一次，则参数省略且后面参数可以用_代替</span></span><br><span class="line">  println(calculator(<span class="number">2</span>, <span class="number">3</span>, _ + _))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="3-高阶函数案例">3.高阶函数案例</h3><ul><li><strong>模拟 Map 映射、Filter 过滤、Reduce 聚合</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （1）map 映射</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], op: <span class="type">Int</span> =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- arr) <span class="keyword">yield</span> op(elem)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> arr = map(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (x: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">    x * x</span><br><span class="line">  &#125;)</span><br><span class="line">  println(arr.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （2）filter 过滤。有参数，且参数再后面只使用一次，则参数省略且后面参数用_表示</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(arr:<span class="type">Array</span>[<span class="type">Int</span>],op:<span class="type">Int</span> =&gt;<span class="type">Boolean</span>) =&#123;</span><br><span class="line">    <span class="keyword">var</span> arr1:<span class="type">ArrayBuffer</span>[<span class="type">Int</span>] = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span>(elem &lt;- arr <span class="keyword">if</span> op(elem))&#123;</span><br><span class="line">      arr1.append(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    arr1.toArray</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> arr1 = filter(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), _ % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">  println(arr1.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// （3）reduce 聚合。有多个参数，且每个参数再后面只使用一次，则参数省略且后面参数用_表示，第n 个_代表第n 个参数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], op: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">var</span> init: <span class="type">Int</span> = arr(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (elem &lt;- <span class="number">1</span> until arr.length) &#123; </span><br><span class="line">      init = op(init, elem)</span><br><span class="line">    &#125;</span><br><span class="line">    init</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//val arr2 = reduce(Array(1, 2, 3, 4), (x, y) =&gt; x * y)</span></span><br><span class="line">  <span class="keyword">val</span> arr2 = reduce(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), _ * _)</span><br><span class="line">  println(arr2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,4,9,16</span><br><span class="line">1,3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="4-函数柯里化-闭包">4.函数柯里化&amp;闭包</h3><ul><li><strong>说明</strong><ul><li><font color=red>闭包：</font>如果一个函数，访问到了它的外部（局部）变量的值，那么这个函数和他所处的环境，称为闭包</li><li><font color=red>函数柯里化：</font>把一个参数列表的多个参数，变成多个参数列表</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>()=&#123;</span><br><span class="line">    <span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span></span>(b:<span class="type">Int</span>)=&#123;</span><br><span class="line">      a + b</span><br><span class="line">    &#125;</span><br><span class="line">    f2 _</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在调用时，f1 函数执行完毕后，局部变量 a 应该随着栈空间释放掉</span></span><br><span class="line">  <span class="keyword">val</span> f = f1()</span><br><span class="line">  <span class="comment">// 但是在此处，变量 a 其实并没有释放，而是包含在了 f2 函数的内部，形成了闭合的效果</span></span><br><span class="line">  println(f(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">  println(f1()(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数柯里化，其实就是将复杂的参数逻辑变得简单化,函数柯里化一定存在闭包</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f3</span></span>()(b:<span class="type">Int</span>)=&#123;</span><br><span class="line">    <span class="keyword">var</span> a:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">    a + b</span><br><span class="line">  &#125;</span><br><span class="line">  println(f3()(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">13</span><br><span class="line">13</span><br></pre></td></tr></table></figure><h3 id="5-递归">5.递归</h3><ul><li><strong>说明</strong><ul><li>一个函数/方法在函数/方法体内又调用了本身，我们称之为递归调用</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阶乘</span></span><br><span class="line">  <span class="comment">// 递归算法</span></span><br><span class="line">  <span class="comment">// 1) 方法调用自身</span></span><br><span class="line">  <span class="comment">// 2) 方法必须要有跳出的逻辑</span></span><br><span class="line">  <span class="comment">// 3) 方法调用自身时，传递的参数应该有规律</span></span><br><span class="line">  <span class="comment">// 4) scala 中的递归必须声明函数返回值类型</span></span><br><span class="line">  println(test(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(i : <span class="type">Int</span>) : <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i * test(i - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120</span><br></pre></td></tr></table></figure><h3 id="6-控制抽象">6.控制抽象</h3><ul><li><strong>值调用：把计算后的值传递过去</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span> </span>= ()=&gt;&#123;</span><br><span class="line">    println(<span class="string">&quot;f...&quot;</span>)</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo(f())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: <span class="type">Int</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">  println(a)</span><br><span class="line">  println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f...</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><ul><li><strong>名调用：把代码传递过去</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f</span> </span>= ()=&gt;&#123;</span><br><span class="line">    println(<span class="string">&quot;f...&quot;</span>)</span><br><span class="line">    <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  foo(f())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//def foo(a: Int):Unit = &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: =&gt;<span class="type">Int</span>):<span class="type">Unit</span> = &#123;<span class="comment">//注意这里变量 a 没有小括号了</span></span><br><span class="line">  println(a)</span><br><span class="line">  println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f...</span><br><span class="line">10</span><br><span class="line">f...</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong><font color=red>注：</font>Java 只有值调用；Scala 既有值调用，又有名调用</strong></p><ul><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// （1）传递代码块</span></span><br><span class="line">  foo(&#123;</span><br><span class="line">    println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// （2）小括号可以省略</span></span><br><span class="line">  foo&#123;</span><br><span class="line">    println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(a: =&gt;<span class="type">Unit</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">  println(a)</span><br><span class="line">  println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">()</span><br><span class="line">aaa</span><br><span class="line">()</span><br><span class="line">aaa</span><br><span class="line">()</span><br><span class="line">aaa</span><br><span class="line">()</span><br></pre></td></tr></table></figure><p><strong>自定义一个 While 循环</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> i:<span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">  myWhile(i &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">    i +=<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myWhile</span></span>(condition: =&gt;<span class="type">Boolean</span>)(op: =&gt;<span class="type">Unit</span>):<span class="type">Unit</span>=&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition)&#123;</span><br><span class="line">    op</span><br><span class="line">    myWhile(condition)(op)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="7-惰性加载">7.惰性加载</h3><ul><li><strong>说明</strong><ul><li>当函数返回值被声明为 lazy 时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行。这种函数我们称之为惰性函数</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> res = sum(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line">  println(<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line">  println(<span class="string">&quot;res=&quot;</span> + res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n1: <span class="type">Int</span>, n2: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  println(<span class="string">&quot;sum 被执行。。。&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">sum 被执行。。。</span><br><span class="line">res=40</span><br></pre></td></tr></table></figure><p><strong><font color=red>注：</font>lazy 不能修饰 var 类型的变量</strong></p><h1 id="六、面向对象">六、面向对象</h1><h2 id="Scala包">Scala包</h2><ul><li><strong>基本语法</strong><ul><li>package 包 名</li></ul></li><li><strong>Scala包的三大作用（同Java相同）</strong><ul><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类</li><li>控制访问范围</li></ul></li></ul><h3 id="1-包的命名">1.包的命名</h3><ul><li><strong>命名规则</strong><ul><li>只能包含数字、字母、下划线、小圆点.，但不能用数字开头，也不要使用关键字</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.<span class="keyword">class</span>.exec1<span class="comment">//错误，因为 class 关键字</span></span><br><span class="line">demo<span class="number">.12</span>a<span class="comment">//错误，数字开头</span></span><br></pre></td></tr></table></figure><ul><li><strong>命名规范</strong><ul><li>一般是小写字母+小圆点</li><li>com.公司名.项目名.业务模块名</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.atguigu.oa.model</span><br><span class="line">com.atguigu.oa.controller</span><br><span class="line">com.sohu.bank.order</span><br></pre></td></tr></table></figure><h3 id="2-包语句">2.包语句</h3><ul><li><strong>说明</strong><ul><li>Scala 有两种包的管理风格，一种方式和 Java 的包管理风格相同，每个源文件一个包（包名和源文件所在路径不要求必须一致），包名用“.”进行分隔以表示包的层级关系，如com.atguigu.scala。另一种风格，通过嵌套的风格表示层级关系，如下</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span></span><br><span class="line">com&#123; <span class="keyword">package</span></span><br><span class="line">atguigu&#123;</span><br><span class="line"><span class="keyword">package</span> scala&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第二种风格有以下特点</strong><ul><li>一个源文件中可以声明多个 package</li><li>子包中的类可以直接访问父包中的内容，而无需导包</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.<span class="type">Inner</span> <span class="comment">//父包访问子包需要导包</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> out: <span class="type">String</span> = <span class="string">&quot;out&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="type">Inner</span>.in)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> atguigu &#123;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> in: <span class="type">String</span> = <span class="string">&quot;in&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="type">Outer</span>.out) <span class="comment">//子包访问父包无需导包</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> other &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-包对象">3.包对象</h3><p><strong>在 Scala 中可以为每个包定义一个同名的包对象，定义在包对象中的成员，作为其对应包下所有 class 和 object 的共享变量，可以被直接访问</strong></p><ul><li><strong>定义</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">com</span></span>&#123;</span><br><span class="line"><span class="keyword">val</span> shareValue=<span class="string">&quot;share&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shareMethod</span></span>()=&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>若使用 Java 的包管理风格，则包对象一般定义在其对应包下的 package.scala文件中，包对象名与包名保持一致</li><li>如采用嵌套方式管理包，则包对象可与包定义在同一文件中，但是要保证包对象与包声明在同一作用域中</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com &#123;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> out: <span class="type">String</span> = <span class="string">&quot;out&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(name)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">com</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;com&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-导包说明">4.导包说明</h3><ul><li><strong>Scala和 Java 一样，可以在顶部使用 import 导入，在这个文件中的所有类都可以使用</strong></li><li><strong>局部导入：</strong> 什么时候使用，什么时候导入</li><li><strong>通配符导入：</strong> import java.util._</li><li><strong>给类起名：</strong> import java.util.{ArrayList=&gt;JL}</li><li><strong>导入相同包的多个类：</strong> import java.util.{HashSet, ArrayList}</li><li><strong>屏蔽类：</strong> import java.util.{ArrayList =&gt;<em>,</em>}</li><li><strong>导入包的绝对路径：</strong> new _root_.java.util.HashMap</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java </span><br><span class="line">&#123; <span class="keyword">package</span> util </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong></li></ul><table><tr align=center><td align=left>import com.atguigu.Fruit</td><td align=left>引入 com.atguigu 包下Fruit（class 和 object）</td></tr><tr align=center><td align=left>import com.atguigu._</td><td align=left>引入 com.atguigu 下的所有成员</td></tr><tr align=center><td align=left>import com.atguigu.Fruit._</td><td align=left>引入 Fruit(object)的所有成员</td></tr><tr align=center><td align=left>import com.atguigu.{Fruit,Vegetable}</td><td align=left>引入 com.atguigu 下的Fruit 和 Vegetable</td></tr><tr align=center><td align=left>import com.atguigu.{Fruit=>Shuiguo}</td><td align=left>引入 com.atguigu 包下的 Fruit 并更名为 Shuiguo</td></tr><tr align=center><td align=left>import com.atguigu.{Fruit=>Shuiguo,_}</td><td align=left>引入 com.atguigu 包下的所有成员，并将 Fruit 更名为 Shuiguo</td></tr><tr align=center><td align=left>import com.atguigu.{Fruit=>_,_}</td><td align=left>引入 com.atguigu 包下屏蔽 Fruit 类</td></tr><tr align=center><td align=left>new _root_.java.util.HashMap</td><td align=left>引入的 Java 的绝对路径</td></tr></table><p><strong><font color=red>注：</font>Scala 中的三个默认导入分别是</strong></p><ul><li>import java.lang._</li><li>import scala._</li><li>import scala.Predef._</li></ul><h2 id="类和对象">类和对象</h2><p><strong>类：</strong> 可以看成一个模板<br><strong>对象：</strong> 表示具体的事物</p><h3 id="1-类的定义">1.类的定义</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> <span class="title">类名</span> </span>&#123;</span><br><span class="line">类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>Scala 语法中，类并不声明为 public，所有这些类都具有公有可见性（即默认就是public）</li><li>一个 Scala 源文件可以包含多个类</li></ul></li></ul><h3 id="2-属性">2.属性</h3><p><strong>属性是类的一个组成部分</strong></p><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="keyword">var</span>|<span class="keyword">val</span> 属性名称 [：类型] = 属性值</span><br></pre></td></tr></table></figure><p><font color=red><strong>注：</strong></font>Bean 属性（@BeanPropetry），可以自动生成规范的 setXxx/getXxx 方法</p><ul><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.beans.<span class="type">BeanProperty</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;bobo&quot;</span> <span class="comment">//定义属性</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = _ <span class="comment">// _表示给属性一个默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean 属性（@BeanProperty）</span></span><br><span class="line"><span class="meta">@BeanProperty</span> <span class="keyword">var</span> sex: <span class="type">String</span> = <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="comment">//val 修饰的属性不能赋默认值，必须显示指定</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">println(person.name)</span><br><span class="line"></span><br><span class="line">person.setSex(<span class="string">&quot;女&quot;</span>)</span><br><span class="line">println(person.getSex)</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bobo</span><br><span class="line">女</span><br></pre></td></tr></table></figure><h3 id="3-访问权限">3.访问权限</h3><ul><li><strong>说明</strong><ul><li>在 Java 中，访问权限分为：public，private，protected 和默认。在 Scala 中，可以通过类似的修饰符达到同样的效果，但是使用上有区别</li><li>（1）Scala 中属性和方法的默认访问权限为 public，但 Scala 中无 public 关键字</li><li>（2）private 为私有权限，只在类的内部和伴生对象中可用</li><li>（3）<font color=red>protected 为受保护权限，Scala 中受保护权限比 Java 中更严格，同类、子类可以访问，同包无法访问</font></li><li>（4）<font color=red>private[包名]增加包访问权限，包名下的其他类也可以使用</font></li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;bobo&quot;</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">18</span> </span><br><span class="line"><span class="keyword">private</span>[demo] <span class="keyword">var</span> sex: <span class="type">String</span> = <span class="string">&quot;男&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123; </span><br><span class="line">println(name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span> </span><br><span class="line">person.say()</span><br><span class="line">println(person.name)</span><br><span class="line">println(person.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">this</span>.age </span><br><span class="line"><span class="keyword">this</span>.sex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>: <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">new</span> <span class="type">Person</span>().sex</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bobo</span><br><span class="line">bobo</span><br><span class="line">18</span><br></pre></td></tr></table></figure><h3 id="4-方法">4.方法</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数列表) [：返回值类型] = &#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(n1:<span class="type">Int</span>, n2:<span class="type">Int</span>) : <span class="type">Int</span> = &#123; </span><br><span class="line">n1 + n2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>() </span><br><span class="line">println(person.sum(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="5-创建对象">5.创建对象</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> | <span class="keyword">var</span> 对象名 [：类型]= <span class="keyword">new</span> 类型()</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>val 修饰对象，不能改变对象的引用（即：内存地址），可以改变对象属性的值</li><li>var 修饰对象，可以修改对象的引用和修改对象的属性值</li><li>自动推导变量类型不能多态，所以多态需要显示声明</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;canglaoshi&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//val 修饰对象，不能改变对象的引用（即：内存地址），可以改变对象属性的值</span></span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>() </span><br><span class="line">person.name = <span class="string">&quot;bobo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person = new Person()// 错误的</span></span><br><span class="line"></span><br><span class="line">println(person.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bobo</span><br></pre></td></tr></table></figure><h3 id="6-构造器">6.构造器</h3><p>和 Java 一样，Scala 构造对象也需要调用构造方法，并且可以有任意多个构造方法。<br>Scala 类的构造器包括：<strong>主构造器和辅助构造器</strong></p><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">类名</span>(<span class="params">形参列表</span>) </span>&#123;<span class="comment">// 主构造器</span></span><br><span class="line"><span class="comment">// 类 体</span></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">this</span></span>(形参列表) &#123;<span class="comment">// 辅助构造器</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span><span class="title">this</span></span>(形参列表) &#123;<span class="comment">//辅助构造器可以有多个</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>辅助构造器，函数的名称 this，可以有多个，编译器通过参数的个数及类型来区分</li><li>辅助构造方法不能直接构建对象，必须直接或者间接调用主构造方法</li><li><font color=red>构造器调用其他另外的构造器，要求被调用构造器必须提前声明</font></li></ul></li><li><strong>案例</strong><ul><li>如果主构造器无参数，小括号可省略，构建对象时调用的构造方法的小括号也可以省略</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）如果主构造器无参数，小括号可省略</span></span><br><span class="line"><span class="comment">//class Person ()&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = _</span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(age: <span class="type">Int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>()</span><br><span class="line"><span class="keyword">this</span>.age = age</span><br><span class="line">println(<span class="string">&quot;辅助构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(age: <span class="type">Int</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>(age)</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;主构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> person2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="number">18</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主构造器</span><br><span class="line">辅助构造器</span><br></pre></td></tr></table></figure><h3 id="7-构造器参数">7.构造器参数</h3><ul><li><strong>说明</strong><ul><li>Scala 类的主构造器函数的形参包括三种类型：未用任何修饰、var 修饰、val 修饰</li><li>（1）未用任何修饰符修饰，这个参数就是一个局部变量</li><li>（2）var 修饰参数，作为类的成员属性使用，可以修改</li><li>（3）val 修饰参数，作为类只读属性使用，不能修改</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, var age: <span class="type">Int</span>, val sex: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;bobo&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// （1）未用任何修饰符修饰，这个参数就是一个局部变量</span></span><br><span class="line"><span class="comment">// printf(person.name)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）var 修饰参数，作为类的成员属性使用，可以修改</span></span><br><span class="line">person.age = <span class="number">19</span></span><br><span class="line">println(person.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）val 修饰参数，作为类的只读属性使用，不能修改</span></span><br><span class="line"><span class="comment">// person.sex = &quot;女&quot;</span></span><br><span class="line">println(person.sex)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19</span><br><span class="line">男</span><br></pre></td></tr></table></figure><h2 id="封装、继承和多态">封装、继承和多态</h2><h3 id="1-封装">1.封装</h3><p><strong>封装就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作（成员方法），才能对数据进行操作。Java 封装操作如下：</strong></p><ul><li><strong>将属性进行私有化</strong></li><li><strong>提供一个公共的 set 方法，用于对属性赋值</strong></li><li><strong>提供一个公共的 get 方法，用于获取属性的值</strong></li></ul><p><strong>Scala 中的 <font color=red>public </font>属性，底层实际为 private，并通过 get 方法（<font color=red>obj.field()</font>）和 set 方法（<font color=red>obj.field_=(value)</font>）对其进行操作。所以 Scala 并不推荐将属性设为 private，再为其设置public 的 get 和 set 方法的做法。但由于很多 Java 框架都利用反射调用 getXXX 和 setXXX 方法，有时候为了和这些框架兼容，也会为 Scala 的属性设置 getXXX 和 setXXX 方法（通过<font color=red>@BeanProperty </font>注解实现）</strong></p><h3 id="2-继承和多态">2.继承和多态</h3><ul><li><strong>基本语法</strong><ul><li>子类继承父类的属性和方法</li><li>scala 是单继承</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">子类名</span> <span class="keyword">extends</span> <span class="title">父类名</span> </span>&#123; 类体 &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>继承的调用顺序：父类构造器-&gt;子类构造器</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">nameParam: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = nameParam</span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(nameParam: <span class="type">String</span>, ageParam: <span class="type">Int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>(nameParam)</span><br><span class="line"><span class="keyword">this</span>.age = ageParam</span><br><span class="line">println(<span class="string">&quot;父类辅助构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;父类主构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span>(<span class="params">nameParam: <span class="type">String</span>, ageParam: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">nameParam, ageParam</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> empNo: <span class="type">Int</span> = _</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(nameParam: <span class="type">String</span>, ageParam: <span class="type">Int</span>, empNoParam: <span class="type">Int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>(nameParam, ageParam)</span><br><span class="line"><span class="keyword">this</span>.empNo = empNoParam</span><br><span class="line">println(<span class="string">&quot;子类的辅助构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;子类主构造器&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Emp</span>(<span class="string">&quot;z3&quot;</span>, <span class="number">11</span>,<span class="number">1001</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父类主构造器</span><br><span class="line">父类辅助构造器</span><br><span class="line">子类主构造器</span><br><span class="line">子类的辅助构造器</span><br></pre></td></tr></table></figure><ul><li><strong>动态绑定</strong><ul><li>Scala 中属性和方法都是动态绑定，而 Java 中只有方法为动态绑定</li></ul></li><li><strong>案例（对比Java与Scala的重写）</strong><ul><li>Scala</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;person&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;hello person&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;hello teacher&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> teacher: <span class="type">Teacher</span> = <span class="keyword">new</span> <span class="type">Teacher</span>()</span><br><span class="line">println(teacher.name)</span><br><span class="line">teacher.hello()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teacher1:<span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Teacher</span></span><br><span class="line">println(teacher1.name)</span><br><span class="line">teacher1.hello()</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">teacher</span><br><span class="line">hello teacher</span><br><span class="line">teacher</span><br><span class="line">hello teacher</span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;person&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello person&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;teacher&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hello teacher&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDynamic</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">teacher1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"></span><br><span class="line">System.out.println(teacher.name);</span><br><span class="line">teacher.hello();</span><br><span class="line"></span><br><span class="line">System.out.println(teacher1.name);</span><br><span class="line">teacher1.hello();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">teacher</span><br><span class="line">hello teacher</span><br><span class="line">person</span><br><span class="line">hello teacher</span><br></pre></td></tr></table></figure><h2 id="抽象类">抽象类</h2><h3 id="1-抽象属性和抽象方法">1.抽象属性和抽象方法</h3><ul><li><strong>基本语法</strong><ul><li><strong>定义抽象类：</strong> abstract class Person{} //通过 abstract 关键字标记抽象类</li><li><strong>定义抽象属性：</strong> val|var name:String //一个属性没有初始化，就是抽象属性</li><li><strong>定义抽象方法：</strong> def hello():String //只声明而没有实现的方法，就是抽象方法</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;hello teacher&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>继承&amp;重写</strong><ul><li>如果父类为抽象类，那么子类需要将抽象的属性和方法实现，否则子类也需声明为抽象类</li><li>重写非抽象方法需要用 override 修饰，重写抽象方法则可以不加 override</li><li>子类中调用父类的方法使用 super 关键字</li><li>子类对抽象属性进行实现，父类抽象属性可以用 var 修饰</li><li>子类对非抽象属性重写，父类非抽象属性只支持 val 类型，而不支持 var，<font color=red>因为 var 修饰的为可变变量，子类继承之后就可以直接使用，没有必要重写</font></li></ul></li></ul><h3 id="2-匿名子类">2.匿名子类</h3><ul><li><strong>说明</strong><ul><li>和 Java 一样，可以通过包含带有定义或重写的代码块的方式创建一个匿名的子类</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span> &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> name: <span class="type">String</span> = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(): <span class="type">Unit</span> = println(<span class="string">&quot;hello teacher&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例对象（伴生对象）">单例对象（伴生对象）</h2><p><strong>Scala语言是<font color=red>完全面向对象</font>的语言，所以并没有静态的操作（即在Scala中没有静态的概念）。但是为了能够和Java语言交互（因为Java中有静态概念），就产生了一种特殊的对象来<font color=red>模拟类对象</font>，该对象为<font color=red>单例对象</font>。若单例对象名与类名一致，则称该单例对象这个类的<font color=red>伴生对象</font>，这个类的所有“静态”内容都可以<font color=red>放置在它的伴生对象</font>中声明</strong></p><h3 id="1-单例对象语法">1.单例对象语法</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> country:<span class="type">String</span>=<span class="string">&quot;China&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>单例对象采用<font color=red>object </font>关键字声明</li><li>单例对象对应的类称之为<font color=red>伴生类</font>，伴生对象的名称应该和伴生类名一致</li><li>单例对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）伴生对象采用 object 关键字声明</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> country: <span class="type">String</span> = <span class="string">&quot;China&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）伴生对象对应的类称之为伴生类，伴生对象的名称应该和伴生类名一致</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;bobo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（3）伴生对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问</span></span><br><span class="line">println(<span class="type">Person</span>.country)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-apply方法">2.apply方法</h3><ul><li><strong>说明</strong><ul><li>通过<font color=red>伴生对象</font>的 <font color=red>apply </font>方法，实现不使用 new 方法创建对象</li><li>如果想让主构造器变成私有的，可以在()之前加上 private</li><li>apply 方法可以重载</li><li>Scala 中<font color=red> obj(arg)</font>的语句实际是在调用该对象的<font color=red> apply </font>方法，即 obj.apply(arg)。用以统一面向对象编程和函数式编程的风格</li><li>当使用 new 关键字构建对象时，调用的其实是类的构造方法，当直接使用类名构建对象时，调用的其实时伴生对象的 apply 方法</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）通过伴生对象的 apply 方法，实现不使用 new 关键字创建对象</span></span><br><span class="line"><span class="keyword">val</span> p1 = <span class="type">Person</span>() </span><br><span class="line">println(<span class="string">&quot;p1.name=&quot;</span> + p1.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> p2 = <span class="type">Person</span>(<span class="string">&quot;bobo&quot;</span>) </span><br><span class="line">println(<span class="string">&quot;p2.name=&quot;</span> + p2.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）如果想让主构造器变成私有的，可以在()之前加上 private </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">private</span>(<span class="params">cName: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = cName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Person</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;apply 空参被调用&quot;</span>) </span><br><span class="line"><span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Person</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;apply 有参被调用&quot;</span>) </span><br><span class="line"><span class="keyword">new</span> <span class="type">Person</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：也可以创建其它类型对象，并不一定是伴生类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply 空参被调用</span><br><span class="line">p1.name=xx</span><br><span class="line">apply 有参被调用</span><br><span class="line">p2.name=bobo</span><br></pre></td></tr></table></figure><h2 id="特质">特质</h2><p><strong><font color=red>Scala 语言中，采用特质 trait（特征）来代替接口的概念</font>，也就是说，多个类具有相同的特质（特征）时，就可以将这个特质（特征）独立出来，采用关键字 trait 声明<br>Scala 中的 trait 中即<font color=red>可以有抽象属性和方法，也可以有具体的属性和方法，一个类可以混入（mixin）多个特质</font>。这种感觉<font color=red>类似于 Java 中的抽象类</font><br>Scala 引入 trait 特征，第一可以替代 Java 的接口，第二个也是对单继承机制的一种补充</strong></p><h3 id="1-特质声明">1.特质声明</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">特质名</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">主体</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明属性</span></span><br><span class="line"><span class="keyword">var</span> name:<span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象属性</span></span><br><span class="line"><span class="keyword">var</span> age:<span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span></span>():<span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-特质基本语法">2.特质基本语法</h3><p><strong>一个类具有某种特质（特征），就意味着这个类满足了这个特质（特征）的所有要素， 所以在使用时，也采用了<font color=red>extends 关键字</font>，如果有多个特质或存在父类，那么需要采用<font color=red>with 关键字</font>连接</strong></p><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有父类：<span class="class"><span class="keyword">class</span><span class="title">类名</span> <span class="keyword">extends</span><span class="title">特质</span> 1<span class="keyword">with</span><span class="title">特质</span> 2<span class="keyword">with</span><span class="title">特质</span> 3 <span class="title">…</span></span></span><br><span class="line">有父类：<span class="class"><span class="keyword">class</span><span class="title">类名</span><span class="keyword">extends</span><span class="title">父类</span><span class="keyword">with</span><span class="title">特质</span> 1<span class="keyword">with</span><span class="title">特质</span> 2<span class="keyword">with</span>  <span class="title">特质</span> 3<span class="title">…</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>类和特质的关系：使用继承的关系</li><li>当一个类去继承特质时，第一个连接词是 extends，后面是with</li><li>如果一个类在同时继承特质和父类时，应当把父类写在 extends 后</li></ul></li><li><strong>案例</strong><ul><li>特质可以同时拥有抽象方法和具体方法</li><li>一个类可以混入（mixin）多个特质</li><li>所有的 Java 接口都可以当做Scala 特质使用</li><li><strong>动态混入</strong>：可灵活的扩展类的功能<ul><li><font color=red>动态混入：创建对象时混入 trait，而无需使类混入该 trait</font></li><li>如果混入的 trait 中有未实现的方法，则需要实现</li></ul></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）特质可以同时拥有抽象方法和具体方法</span></span><br><span class="line"><span class="comment">// 声明属性</span></span><br><span class="line"><span class="keyword">var</span> name: <span class="type">String</span> = _</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象属性</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SexTrait</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> sex: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//（2）一个类可以实现/继承多个特质</span></span><br><span class="line"><span class="comment">//（3）所有的 Java 接口都可以当做 Scala 特质使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">PersonTrait</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;say&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> age: <span class="type">Int</span> = _</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span></span><br><span class="line"></span><br><span class="line">teacher.say()</span><br><span class="line">teacher.eat()</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）动态混入：可灵活的扩展类的功能</span></span><br><span class="line"><span class="keyword">val</span> t2 = <span class="keyword">new</span> <span class="type">Teacher</span> <span class="keyword">with</span> <span class="type">SexTrait</span> &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> sex: <span class="type">String</span> = <span class="string">&quot;男&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用混入 trait 的属性</span></span><br><span class="line">println(t2.sex)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">say</span><br><span class="line">eat</span><br><span class="line">男</span><br></pre></td></tr></table></figure><h3 id="3-特质叠加">3.特质叠加</h3><p><strong>由于一个类可以混入（mixin）多个 trait，且 trait 中可以有具体的属性和方法，若混入的特质中具有相同的方法（方法名，参数列表，返回值均相同），必然会出现继承冲突问题。<br>冲突分为以下两种：</strong></p><ul><li>一个类（Sub）混入的两个 trait（TraitA，TraitB）中具有相同的具体方法，且两个 trait 之间没有任何关系，解决这类冲突问题，直接在类（Sub）中重写冲突方法<br><img src="https://img-blog.csdnimg.cn/2021040715005761.png" alt="在这里插入图片描述"></li><li>一个类（Sub）混入的两个 trait（TraitA，TraitB）中具有相同的具体方法，且两个 trait 继承自相同的 trait（TraitC），及所谓的“钻石问题”，解决这类冲突问题，Scala 采用了特质叠加的策略<br><img src="https://img-blog.csdnimg.cn/20210407150151294.png" alt="在这里插入图片描述"></li><li><strong>案例</strong><ul><li>所谓的特质叠加，就是将混入的多个 trait 中的冲突方法叠加起来</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123; </span><br><span class="line"><span class="string">&quot;ball&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123; </span><br><span class="line"><span class="string">&quot;blue-&quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Category</span> <span class="keyword">extends</span> <span class="title">Ball</span> </span>&#123; </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line"><span class="string">&quot;foot-&quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBall</span> <span class="keyword">extends</span> <span class="title">Category</span> <span class="keyword">with</span> <span class="title">Color</span> </span>&#123; </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line"><span class="string">&quot;my ball is a &quot;</span> + <span class="keyword">super</span>.describe()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line">println(<span class="keyword">new</span> <span class="type">MyBall</span>().describe())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my ball is a blue-foot-ball</span><br></pre></td></tr></table></figure><h3 id="4-特质叠加执行顺序">4.特质叠加执行顺序</h3><p>上面案例中的 super.describe()调用的是父 trait 中的方法吗？<br><strong>当一个类混入多个特质的时候，scala 会对所有的特质及其父特质按照一定的顺序进行排序，而此案例中的 super.describe()调用的实际上是排好序后的下一个特质中的 describe() 方法。排序规则如下：</strong><br><img src="https://img-blog.csdnimg.cn/2021040909110545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>结论</strong><ul><li>案例中的 super，不是表示其父特质对象，而是表示上述叠加顺序中的下一个特质，即，<font color=red>MyClass 中的 super 指代 Color，Color 中的 super 指代 Category，Category 中的 super指代 Ball</font></li><li>如果想要调用某个指定的混入特质中的方法，可以增加约束：super[]，例如super[Category].describe()</li></ul></li></ul><h3 id="5-特质自身类型">5.特质自身类型</h3><ul><li><strong>说明</strong><ul><li>自身类型可实现依赖注入的功能</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(user: <span class="type">User</span>) = &#123;</span><br><span class="line">    println(<span class="string">&quot;insert into database :&quot;</span> + user.name)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">APP</span> </span>&#123;</span><br><span class="line">  _: <span class="type">Dao</span> =&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">login</span></span>(user: <span class="type">User</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">&quot;login :&quot;</span> + user.name)</span><br><span class="line">    insert(user)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">APP</span> <span class="keyword">with</span> <span class="title">Dao</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    login(<span class="keyword">new</span> <span class="type">User</span>(<span class="string">&quot;bobo&quot;</span>, <span class="number">11</span>))</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login :bobo</span><br><span class="line">insert into database :bobo</span><br></pre></td></tr></table></figure><h3 id="6-特质和抽象类的区别">6.特质和抽象类的区别</h3><ul><li><strong>优先使用特质：一个类扩展多个特质是很方便的，但却只能扩展一个抽象类</strong></li><li><strong>如果你需要构造函数参数，使用抽象类。因为抽象类可以定义<font color=red>带参数</font>的构造函数，而特质不行（有无参构造）</strong></li></ul><h2 id="扩展">扩展</h2><h3 id="1-类型转换和检查">1.类型转换和检查</h3><ul><li><strong>说明</strong><ul><li>obj.isInstanceOf[T]：判断 obj 是不是T 类型</li><li>obj.asInstanceOf[T]：将 obj 强转成 T 类型</li><li>classOf 获取对象的类名</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; </span><br><span class="line"><span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）判断对象是否为某个类型的实例</span></span><br><span class="line"><span class="keyword">val</span> bool: <span class="type">Boolean</span> = person.isInstanceOf[<span class="type">Person</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( bool ) &#123;</span><br><span class="line"><span class="comment">//（2）将对象转换为某个类型的实例</span></span><br><span class="line"><span class="keyword">val</span> p1: <span class="type">Person</span> = person.asInstanceOf[<span class="type">Person</span>] </span><br><span class="line">println(p1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）获取类的信息</span></span><br><span class="line"><span class="keyword">val</span> pClass: <span class="type">Class</span>[<span class="type">Person</span>] = classOf[<span class="type">Person</span>] </span><br><span class="line">println(pClass)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.demo.Person@16c0663d</span><br><span class="line">class com.demo.Person</span><br></pre></td></tr></table></figure><h3 id="2-枚举类和应用类">2.枚举类和应用类</h3><ul><li><strong>说明</strong><ul><li>枚举类：需要继承 Enumeration</li><li>应用类：需要继承App</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="type">Color</span>.<span class="type">RED</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">RED</span> = <span class="type">Value</span>(<span class="number">1</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">YELLOW</span> = <span class="type">Value</span>(<span class="number">2</span>, <span class="string">&quot;yellow&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">BLUE</span> = <span class="type">Value</span>(<span class="number">3</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用类</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test20</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  println(<span class="string">&quot;xxxxxxxxxxx&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">red</span><br></pre></td></tr></table></figure><h3 id="3-Type定义新类型">3.Type定义新类型</h3><ul><li><strong>说明</strong><ul><li>使用 type 关键字可以定义新的数据数据类型名称，本质上就是类型的一个别名</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; <span class="class"><span class="keyword">type</span> <span class="title">S=String</span></span></span><br><span class="line">    <span class="keyword">var</span> v:<span class="type">S</span>=<span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>():<span class="type">S</span>=<span class="string">&quot;xyz&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、集合">七、集合</h1><h2 id="集合简介">集合简介</h2><ul><li><strong>Scala的集合有三大类：序列Seq、集合Set、映射Map，所有的集合都扩展自Iterable特质</strong></li><li><strong>对于几乎所有的集合类，Scala 都同时提供了<font color=red>可变</font>和<font color=red>不可变</font>的版本，分别位于以下两个包</strong><ul><li>不可变集合：scala.collection.immutable</li><li>可变集合： scala.collection.mutable</li></ul></li><li><strong>Scala 不可变集合，就是指该集合对象不可修改，每次修改就会返回一个新对象，而<br>不会对原对象进行修改。类似于 java 中的 String 对象</strong></li><li><strong>可变集合，就是这个集合可以直接对原对象进行修改，而不会返回新的对象。类似<br>于 java 中 StringBuilder 对象</strong></li></ul><p><strong><font color=red>注：</font>建议在操作集合时，不可变用符号，可变用方法</strong></p><h3 id="1-不可变集合继承图">1.不可变集合继承图</h3><p><img src="https://img-blog.csdnimg.cn/20210409095846298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>Set、Map 是 Java 中也有的集合</strong></li><li><strong>Seq 是 Java 没有的，我们发现 List 归属到 Seq 了，因此这里的 List 就和 Java 不是同一个概念了</strong></li><li><strong>前面的 for 循环有一个 1 to 3，就是 IndexedSeq 下的 Range</strong></li><li><strong>String 也是属于 IndexedSeq</strong></li><li><strong>经典的数据结构比如 Queue 和 Stack 被归属到 LinearSeq(线性序列)</strong></li><li><strong>Scala 中的 Map 体系有一个 SortedMap，说明 Scala 的 Map 可以支持排序</strong></li><li><strong>IndexedSeq 和 LinearSeq 的区别：</strong><ul><li>IndexedSeq 是通过索引来查找和定位，因此速度快，比如 String 就是一个索引集合，通过索引即可定位</li><li>LinearSeq 是线型的，即有头尾的概念，这种数据结构一般是通过遍历来查找</li></ul></li></ul><h2 id="2-可变集合继承图">2.可变集合继承图</h2><p><img src="https://img-blog.csdnimg.cn/20210409100309773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="数组">数组</h2><h3 id="1-不可变数组">1.不可变数组</h3><ul><li><strong>定义数组（方式一）</strong><ul><li>new 是关键字</li><li>[Int]是指定可以存放的数据类型，如果希望存放任意数据类型，则指定 Any</li><li>(10)，表示数组的大小，确定后就不可以变化</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr1 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArray</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）数组定义</span></span><br><span class="line"><span class="keyword">val</span> arr01 = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">4</span>)</span><br><span class="line">println(arr01.length) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）数组赋值</span></span><br><span class="line"><span class="comment">//（2.1）修改某个元素的值</span></span><br><span class="line">arr01(<span class="number">3</span>) = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2.2）采用方法的形式给数组赋值</span></span><br><span class="line">arr01.update(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历数组</span></span><br><span class="line"><span class="comment">//（3.1）查看数组</span></span><br><span class="line">println(arr01.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.2）普通遍历</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.3）简化遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printx</span></span>(elem:<span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(elem)</span><br><span class="line">&#125;</span><br><span class="line">arr01.foreach(printx)</span><br><span class="line"><span class="comment">// arr01.foreach((x)=&gt;&#123;println(x)&#125;)</span></span><br><span class="line"><span class="comment">// arr01.foreach(println(_))</span></span><br><span class="line">arr01.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）增加元素（由于创建的是不可变数组，增加元素，其实是产生新的数组）</span></span><br><span class="line">println(arr01)</span><br><span class="line"><span class="keyword">val</span> ints: <span class="type">Array</span>[<span class="type">Int</span>] = arr01 :+ <span class="number">5</span></span><br><span class="line">println(ints)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1,0,0,10</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br><span class="line">[I@1cd072a9</span><br><span class="line">[I@2812cbfa</span><br></pre></td></tr></table></figure><ul><li><strong>定义数组（方式二）</strong><ul><li>在定义数组时，直接赋初始值</li><li>使用 apply 方法创建数组对象</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArray</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">var</span> arr02 = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;bobo&quot;</span>)</span><br><span class="line">println(arr02.length)</span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr02) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">bobo</span><br></pre></td></tr></table></figure><h3 id="2-可变数组">2.可变数组</h3><ul><li><strong>定义可变数组</strong><ul><li>[Any]存放任意数据类型</li><li>(3, 2, 5)初始化好的三个元素</li><li>ArrayBuffer 需要引入 scala.collection.mutable.ArrayBuffer</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr01 = <span class="type">ArrayBuffer</span>[<span class="type">Any</span>](<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong><ul><li>ArrayBuffer 是有序的集合</li><li>增加元素使用的是 append 方法()，支持可变参数</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ArrayBuffer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArrayBuffer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）创建并初始赋值可变数组</span></span><br><span class="line"><span class="keyword">val</span> arr01 = <span class="type">ArrayBuffer</span>[<span class="type">Any</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">println(arr01.length) <span class="comment">// 3</span></span><br><span class="line">println(<span class="string">&quot;arr01.hash=&quot;</span> + arr01.hashCode())</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）增加元素</span></span><br><span class="line"><span class="comment">//（3.1）追加数据</span></span><br><span class="line">arr01.+=(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.2）向数组最后追加数据</span></span><br><span class="line">arr01.append(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.3）向指定的位置插入数据</span></span><br><span class="line">arr01.insert(<span class="number">0</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">println(<span class="string">&quot;arr01.hash=&quot;</span> + arr01.hashCode())</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）修改元素</span></span><br><span class="line">arr01(<span class="number">1</span>) = <span class="number">9</span> <span class="comment">//修改第 2 个元素的值</span></span><br><span class="line">println(<span class="string">&quot;--------------------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr01) &#123;</span><br><span class="line">println(i)</span><br><span class="line">&#125;</span><br><span class="line">println(arr01.length) <span class="comment">// 5</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">arr01.hash=387518613</span><br><span class="line">arr01.hash=-253706129</span><br><span class="line">--------------------------</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="3-不可变数组与可变数组的转换">3.不可变数组与可变数组的转换</h3><ul><li><strong>说明</strong><ul><li>arr2.toArray 返回结果才是一个不可变数组，arr2 本身没有变化</li><li>arr1.toBuffer 返回结果才是一个可变数组，arr1 本身没有变化</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1.toBuffer <span class="comment">//不可变数组转可变数组</span></span><br><span class="line">arr2.toArray <span class="comment">//可变数组转不可变数组</span></span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestArrayBuffer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）创建一个空的可变数组</span></span><br><span class="line"><span class="keyword">val</span> arr2 = <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）追加值</span></span><br><span class="line">arr2.append(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">println(arr2) <span class="comment">// 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）ArrayBuffer ==&gt; Array</span></span><br><span class="line"><span class="comment">//（3.1）arr2.toArray 返回的结果是一个新的定长数组集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（3.2）arr2 它没有变化</span></span><br><span class="line"><span class="keyword">val</span> newArr = arr2.toArray</span><br><span class="line">println(newArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）Array ===&gt; ArrayBuffer</span></span><br><span class="line"><span class="comment">//（4.1）newArr.toBuffer 返回一个变长数组 newArr2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（4.2）newArr 没有任何变化，依然是定长数组</span></span><br><span class="line"><span class="keyword">val</span> newArr2 = newArr.toBuffer</span><br><span class="line">newArr2.append(<span class="number">123</span>)</span><br><span class="line">println(newArr2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBuffer(1, 2, 3)</span><br><span class="line">[I@6e8dacdf</span><br><span class="line">ArrayBuffer(1, 2, 3, 123)</span><br></pre></td></tr></table></figure><h3 id="4-多维数组">4.多维数组</h3><ul><li><strong>定义</strong><ul><li>二维数组中有三个一维数组，每个一维数组中有四个元素</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>.ofDim[<span class="type">Double</span>](<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）创建了一个二维数组, 有三个元素，每个元素是，含有 4 个元素一维数组()</span></span><br><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">arr(<span class="number">1</span>)(<span class="number">2</span>) = <span class="number">88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- arr) &#123; <span class="comment">//i 就是一维数组</span></span><br><span class="line"><span class="keyword">for</span> (j &lt;- i) &#123;</span><br><span class="line">print(j + <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println()</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 </span><br><span class="line">0 0 88 0 </span><br><span class="line">0 0 0 0 </span><br></pre></td></tr></table></figure><h2 id="列表List">列表List</h2><h3 id="1-不可变List">1.不可变List</h3><ul><li><strong>说明</strong><ul><li>List 默认为不可变集合</li><li>数据有顺序，可重复</li><li>集合间合并：将一个整体拆成一个一个的个体，称为扁平化</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//List 默认为不可变集合</span></span><br><span class="line"><span class="comment">//创建一个 List（数据有顺序，可重复）</span></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//空集合 Nil</span></span><br><span class="line"><span class="keyword">val</span> list5 = <span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="number">4</span>::<span class="type">Nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//List 增加数据</span></span><br><span class="line"><span class="comment">//（1）::的运算规则从右向左</span></span><br><span class="line"><span class="comment">//val list1 = 5::list</span></span><br><span class="line"><span class="keyword">val</span> list1 = <span class="number">7</span>::<span class="number">6</span>::<span class="number">5</span>::list</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）添加到第一个元素位置</span></span><br><span class="line"><span class="keyword">val</span> list2 = list.+:(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合间合并：将一个整体拆成一个一个的个体，称为扁平化</span></span><br><span class="line"><span class="keyword">val</span> list3 = <span class="type">List</span>(<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line"><span class="comment">//val list4 = list3::list1</span></span><br><span class="line"><span class="keyword">val</span> list4 = list3:::list1</span><br><span class="line"></span><br><span class="line"><span class="comment">//取指定数据</span></span><br><span class="line">println(list(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 List</span></span><br><span class="line"><span class="comment">//list.foreach(println)</span></span><br><span class="line"><span class="comment">//list1.foreach(println)</span></span><br><span class="line"><span class="comment">//list3.foreach(println)</span></span><br><span class="line"><span class="comment">//list4.foreach(println)</span></span><br><span class="line">list5.foreach(println)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="2-可变ListBuffer">2.可变ListBuffer</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">ListBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）创建一个可变集合</span></span><br><span class="line"><span class="keyword">val</span> buffer = <span class="type">ListBuffer</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）向集合中添加数据</span></span><br><span class="line">buffer.+=(<span class="number">5</span>)</span><br><span class="line">buffer.append(<span class="number">6</span>)</span><br><span class="line">buffer.insert(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）打印集合数据</span></span><br><span class="line">buffer.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）修改数据</span></span><br><span class="line">buffer(<span class="number">1</span>) = <span class="number">6</span></span><br><span class="line">buffer.update(<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（5）删除数据</span></span><br><span class="line">buffer.-(<span class="number">5</span>)</span><br><span class="line">buffer.-=(<span class="number">5</span>)</span><br><span class="line">buffer.remove(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="Set集合">Set集合</h2><p><strong>默认情况下，Scala 使用的是不可变集合，如果要使用可变集合，需要引用scala.collection.mutable.Set 包</strong></p><h3 id="1-不可变Set">1.不可变Set</h3><ul><li><strong>说明</strong><ul><li>Set 默认是不可变集合，数据无序</li><li>数据不可重复</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）Set 默认是不可变集合，数据无序</span></span><br><span class="line"><span class="keyword">val</span> set = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）数据不可重复</span></span><br><span class="line"><span class="keyword">val</span> set1 = <span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(x&lt;-set1)&#123;</span><br><span class="line">println(x)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="2-可变-mutable-Set">2.可变 mutable.Set</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）创建可变集合</span></span><br><span class="line"><span class="keyword">val</span> set = mutable.<span class="type">Set</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）集合添加元素</span></span><br><span class="line">set += <span class="number">8</span></span><br><span class="line"><span class="comment">//（3）向集合中添加元素，返回一个新的 Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ints = set.+(<span class="number">9</span>)</span><br><span class="line">println(ints)</span><br><span class="line">println(<span class="string">&quot;set2=&quot;</span> + set)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）删除数据</span></span><br><span class="line">set-=(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">set.foreach(println)</span><br><span class="line">println(set.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set(9, 1, 5, 2, 6, 3, 4, 8)</span><br><span class="line">set2=Set(1, 5, 2, 6, 3, 4, 8)</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">1,2,6,3,4,8</span><br></pre></td></tr></table></figure><h2 id="Map集合">Map集合</h2><p><strong>Scala 中的 Map 和 Java 类似，也是一个散列表，它存储的内容也是键值对（key-value）映射</strong></p><h3 id="1-不可变Map">1.不可变Map</h3><ul><li><strong>说明</strong><ul><li>如果 key 不存在，返回 0</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建不可变集合 Map</span></span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>( <span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问数据</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- map.keys) &#123;</span><br><span class="line"><span class="comment">// 使用 get 访问 map 集合的数据，会返回特殊类型 Option(选项):有值（Some），无值(None)</span></span><br><span class="line">println(elem + <span class="string">&quot;=&quot;</span> + map.get(elem).get)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 key 不存在，返回 0</span></span><br><span class="line">println(map.get(<span class="string">&quot;d&quot;</span>).getOrElse(<span class="number">0</span>))</span><br><span class="line">println(map.getOrElse(<span class="string">&quot;d&quot;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">map.foreach((kv)=&gt;&#123;println(kv)&#125;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">(a,1)</span><br><span class="line">(b,2)</span><br><span class="line">(c,3)</span><br></pre></td></tr></table></figure><h3 id="2-可变Map">2.可变Map</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestSet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建可变集合</span></span><br><span class="line"><span class="keyword">val</span> map = mutable.<span class="type">Map</span>( <span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">//向集合增加数据</span></span><br><span class="line">map.+=(<span class="string">&quot;d&quot;</span>-&gt;<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值 4 添加到集合，并把集合中原值 1 返回</span></span><br><span class="line"><span class="keyword">val</span> maybeInt: <span class="type">Option</span>[<span class="type">Int</span>] = map.put(<span class="string">&quot;a&quot;</span>, <span class="number">4</span>)</span><br><span class="line">println(maybeInt.getOrElse(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">map.-=(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改数据</span></span><br><span class="line">map.update(<span class="string">&quot;d&quot;</span>,<span class="number">5</span>)</span><br><span class="line">map(<span class="string">&quot;d&quot;</span>) = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">map.foreach((kv)=&gt;&#123;println(kv)&#125;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">(d,5)</span><br><span class="line">(a,4)</span><br></pre></td></tr></table></figure><h2 id="元组">元组</h2><ul><li><strong>说明</strong><ul><li>元组也是可以理解为一个容器，可以存放各种相同或不同类型的数据。说的简单点，就是将多个无关的数据封装为一个整体，称为元组</li></ul></li><li><strong>演示</strong><ul><li>Map 中的键值对其实就是元组,只不过元组的元素个数为 2，称之为对偶</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTuple</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）声明元组的方式：(元素 1，元素 2，元素 3)</span></span><br><span class="line"><span class="keyword">val</span> tuple: (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Boolean</span>) = (<span class="number">40</span>,<span class="string">&quot;bobo&quot;</span>,<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）访问元组</span></span><br><span class="line"><span class="comment">//（2.1）通过元素的顺序进行访问，调用方式：_顺序号</span></span><br><span class="line">println(tuple._1)</span><br><span class="line">println(tuple._2)</span><br><span class="line">println(tuple._3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2.2）通过索引访问数据</span></span><br><span class="line">println(tuple.productElement(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2.3）通过迭代器访问数据</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- tuple.productIterator) &#123;</span><br><span class="line">println(elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）Map 中的键值对其实就是元组,只不过元组的元素个数为 2，称之为对偶</span></span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> map1 = <span class="type">Map</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>), (<span class="string">&quot;b&quot;</span>,<span class="number">2</span>), (<span class="string">&quot;c&quot;</span>,<span class="number">3</span>))</span><br><span class="line">map.foreach(tuple=&gt;&#123;println(tuple._1 + <span class="string">&quot;=&quot;</span> + tuple._2)&#125;)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">40</span><br><span class="line">bobo</span><br><span class="line">true</span><br><span class="line">40</span><br><span class="line">40</span><br><span class="line">bobo</span><br><span class="line">true</span><br><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">c=3</span><br></pre></td></tr></table></figure><h2 id="集合常用函数">集合常用函数</h2><h3 id="1-基本属性和常用操作">1.基本属性和常用操作</h3><ul><li><strong>需求</strong><ul><li>获取集合长度</li><li>获取集合大小</li><li>循环遍历</li><li>迭代器</li><li>生成字符串</li><li>是否包含</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）获取集合长度</span></span><br><span class="line">println(list.length)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）获取集合大小,等同于 length</span></span><br><span class="line">println(list.size)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）循环遍历</span></span><br><span class="line">list.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）迭代器</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- list.itera tor) &#123;</span><br><span class="line">println(elem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（5）生成字符串</span></span><br><span class="line">println(list.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//（6）是否包含</span></span><br><span class="line">println(list.contains(<span class="number">3</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-衍生集合">2.衍生集合</h3><ul><li><strong>需求</strong><ul><li>获取集合的头</li><li>获取集合的尾（不是头的就是尾）</li><li>集合最后一个数据</li><li>集合初始数据（不包含最后一个）</li><li>反转</li><li>取前（后）n 个元素</li><li>去掉前（后）n 个元素</li><li>并集</li><li>交集</li><li>差集</li><li>拉链</li><li>滑窗</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">val</span> list2: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合的头</span></span><br><span class="line">println(list1.head)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取集合的尾（不是头的就是尾）</span></span><br><span class="line">println(list1.tail)</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合最后一个数据</span></span><br><span class="line">println(list1.last)</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合初始数据（不包含最后一个）</span></span><br><span class="line">println(list1.init)</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转</span></span><br><span class="line">println(list1.reverse)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取前（后）n 个元素</span></span><br><span class="line">println(list1.take(<span class="number">3</span>))</span><br><span class="line">println(list1.takeRight(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//去掉前（后）n 个元素</span></span><br><span class="line">println(list1.drop(<span class="number">3</span>))</span><br><span class="line">println(list1.dropRight(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line">println(list1.union(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line">println(list1.intersect(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line">println(list1.diff(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉链 注:如果两个集合的元素个数不相等，那么会将同等数量的数据进行拉链，多余的数据省略不用</span></span><br><span class="line">println(list1.zip(list2))</span><br><span class="line"></span><br><span class="line"><span class="comment">//滑窗</span></span><br><span class="line">list1.sliding(<span class="number">2</span>, <span class="number">5</span>).foreach(println)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">List(2, 3, 4, 5, 6, 7)</span><br><span class="line">7</span><br><span class="line">List(1, 2, 3, 4, 5, 6)</span><br><span class="line">List(7, 6, 5, 4, 3, 2, 1)</span><br><span class="line">List(1, 2, 3)</span><br><span class="line">List(5, 6, 7)</span><br><span class="line">List(4, 5, 6, 7)</span><br><span class="line">List(1, 2, 3, 4)</span><br><span class="line">List(1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 8, 9, 10)</span><br><span class="line">List(4, 5, 6, 7)</span><br><span class="line">List(1, 2, 3)</span><br><span class="line">List((1,4), (2,5), (3,6), (4,7), (5,8), (6,9), (7,10))</span><br><span class="line">List(1, 2)</span><br><span class="line">List(6, 7)</span><br></pre></td></tr></table></figure><h3 id="3-集合计算简单函数">3.集合计算简单函数</h3><ul><li><strong>需求</strong><ul><li>求和</li><li>求乘积</li><li>最大值</li><li>最小值</li><li>排序</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">-7</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">println(list.sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">//求乘积</span></span><br><span class="line">println(list.product)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值</span></span><br><span class="line">println(list.max)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小值</span></span><br><span class="line">println(list.min)</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">// （1）按照元素大小排序</span></span><br><span class="line">println(list.sortBy(x =&gt; x))</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）按照元素的绝对值大小排序</span></span><br><span class="line">println(list.sortBy(x =&gt; x.abs))</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）按元素大小升序排序</span></span><br><span class="line">println(list.sortWith((x, y) =&gt; x &lt; y))</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）按元素大小降序排序</span></span><br><span class="line">println(list.sortWith((x, y) =&gt; x &gt; y))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">5040</span><br><span class="line">6</span><br><span class="line">-7</span><br><span class="line">List(-7, -3, 1, 2, 4, 5, 6)</span><br><span class="line">List(1, 2, -3, 4, 5, 6, -7)</span><br><span class="line">List(-7, -3, 1, 2, 4, 5, 6)</span><br><span class="line">List(6, 5, 4, 2, 1, -3, -7)</span><br></pre></td></tr></table></figure><ul><li><strong>sorted</strong><ul><li>对一个集合进行自然排序，通过传递隐式的 Ordering</li></ul></li><li><strong>sortBy</strong><ul><li>对一个属性或多个属性进行排序，通过它的类型</li></ul></li><li><strong>sortWith</strong><ul><li>基于函数的排序，通过一个 comparator 函数，实现自定义排序的逻辑</li></ul></li></ul><h3 id="4-集合计算高级函数">4.集合计算高级函数</h3><ul><li><strong>需求</strong><ul><li>过滤<ul><li>遍历一个集合并从中获取满足指定条件的元素组成一个新的集合</li></ul></li><li>转化/映射（map）<ul><li>将集合中的每一个元素映射到某一个函数</li></ul></li><li>扁平化</li><li>扁平化+映射 （flatMap 相当于先进行 map 操作，在进行 flatten 操作集合中的每个元素的子元素映射到某个函数并返回新集合）</li><li>分组(group)<ul><li>按照指定的规则对集合的元素进行分组</li></ul></li><li>简化（归约）</li><li>折叠</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">val</span> nestedList: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="type">List</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line"><span class="keyword">val</span> wordList: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello atguigu&quot;</span>, <span class="string">&quot;hello scala&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤</span></span><br><span class="line">println(list.filter(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化/映射</span></span><br><span class="line">println(list.map(x =&gt; x + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//扁平化</span></span><br><span class="line">println(nestedList.flatten)</span><br><span class="line"></span><br><span class="line"><span class="comment">//扁平化+映射 注：flatMap 相当于先进行 map 操作，在进行 flatten操作</span></span><br><span class="line">println(wordList.flatMap(x =&gt; x.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line">println(list.groupBy(x =&gt; x % <span class="number">2</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List(2, 4, 6, 8)</span><br><span class="line">List(2, 3, 4, 5, 6, 7, 8, 9, 10)</span><br><span class="line">List(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line">List(hello, world, hello, atguigu, hello, scala)</span><br><span class="line">Map(1 -&gt; List(1, 3, 5, 7, 9), 0 -&gt; List(2, 4, 6, 8))</span><br></pre></td></tr></table></figure><ul><li><strong>Reduce 方法</strong><ul><li>Reduce 简化（归约） ：通过指定的逻辑将集合中的数据进行聚合，从而减少数据，最终获取结果</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestReduce</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据两两结合，实现运算规则</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="type">Int</span> = list.reduce( (x,y) =&gt; x-y )</span><br><span class="line">println(<span class="string">&quot;i = &quot;</span> + i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从源码的角度，reduce 底层调用的其实就是 reduceLeft</span></span><br><span class="line"><span class="comment">//val i1 = list.reduceLeft((x,y) =&gt; x-y)</span></span><br><span class="line"><span class="comment">// ((4-3)-2-1) = -2</span></span><br><span class="line"><span class="keyword">val</span> i2 = list.reduceRight((x,y) =&gt; x-y)</span><br><span class="line">println(i2)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = -8</span><br><span class="line">-2</span><br></pre></td></tr></table></figure><ul><li><strong>Fold 方法</strong><ul><li>Fold 折叠：化简的一种特殊情况</li></ul></li><li><strong>演示1</strong><ul><li>fold 基本使用</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFold</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fold 方法使用了函数柯里化，存在两个参数列表</span></span><br><span class="line"><span class="comment">// 第一个参数列表为 ： 零值（初始值）</span></span><br><span class="line"><span class="comment">// 第二个参数列表为： 简化规则</span></span><br><span class="line"><span class="comment">// fold 底层其实为 foldLeft</span></span><br><span class="line"><span class="keyword">val</span> i = list.foldLeft(<span class="number">1</span>)((x,y)=&gt;x-y)</span><br><span class="line"><span class="keyword">val</span> i1 = list.foldRight(<span class="number">10</span>)((x,y)=&gt;x-y)</span><br><span class="line">println(i)</span><br><span class="line">println(i1)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-9</span><br><span class="line">8</span><br></pre></td></tr></table></figure><ul><li><strong>演示2</strong><ul><li>两个集合合并</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestFold</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 两个 Map 的数据合并</span></span><br><span class="line"><span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">2</span>, <span class="string">&quot;c&quot;</span>-&gt;<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> map2 = mutable.<span class="type">Map</span>(<span class="string">&quot;a&quot;</span>-&gt;<span class="number">4</span>, <span class="string">&quot;b&quot;</span>-&gt;<span class="number">5</span>, <span class="string">&quot;d&quot;</span>-&gt;<span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> map3: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = map2.foldLeft(map1) &#123;</span><br><span class="line">(map, kv) =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> k = kv._1</span><br><span class="line"><span class="keyword">val</span> v = kv._2</span><br><span class="line">map(k) = map.getOrElse(k, <span class="number">0</span>) + v</span><br><span class="line">map</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">println(map3)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map(b -&gt; 7, d -&gt; 6, a -&gt; 5, c -&gt; 3)</span><br></pre></td></tr></table></figure><h3 id="5-普通wordcount案例">5.普通wordcount案例</h3><ul><li><strong>需求</strong><ul><li>单词计数：将集合中出现的相同的单词，进行计数，取计数排名前三的结果</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestWordCount</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单词计数：将集合中出现的相同的单词，进行计数，取计数排名前三的结果</span></span><br><span class="line"><span class="keyword">val</span> stringList = <span class="type">List</span>(<span class="string">&quot;Hello Scala Hbase kafka&quot;</span>, <span class="string">&quot;Hello Scala Hbase&quot;</span>, <span class="string">&quot;Hello Scala&quot;</span>, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) 将每一个字符串转换成一个一个单词</span></span><br><span class="line"><span class="keyword">val</span> wordList: <span class="type">List</span>[<span class="type">String</span>] = stringList.flatMap(str=&gt;str.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="comment">//println(wordList)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 将相同的单词放置在一起</span></span><br><span class="line"><span class="keyword">val</span> wordToWordsMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">String</span>]] = wordList.groupBy(word=&gt;word)</span><br><span class="line"><span class="comment">//println(wordToWordsMap)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 对相同的单词进行计数</span></span><br><span class="line"><span class="comment">// (word, list) =&gt; (word, count)</span></span><br><span class="line"><span class="keyword">val</span> wordToCountMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = wordToWordsMap.map(tuple=&gt;(tuple._1, tuple._2.size))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4) 对计数完成后的结果进行排序（降序）</span></span><br><span class="line"><span class="keyword">val</span> sortList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToCountMap.toList.sortWith &#123;</span><br><span class="line">(left, right) =&gt; &#123;</span><br><span class="line">left._2 &gt; right._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5) 对排序后的结果取前 3 名</span></span><br><span class="line"><span class="keyword">val</span> resultList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = sortList.take(<span class="number">3</span>)</span><br><span class="line">println(resultList)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List((Hello,4), (Scala,3), (Hbase,2))</span><br></pre></td></tr></table></figure><h3 id="6-复杂wordcount案例">6.复杂wordcount案例</h3><ul><li><strong>方式一（不通用）</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestWordCount</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tupleList = <span class="type">List</span>((<span class="string">&quot;Hello Scala Spark World &quot;</span>, <span class="number">4</span>), (<span class="string">&quot;Hello Scala Spark&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;Hello Scala&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> stringList: <span class="type">List</span>[<span class="type">String</span>] = tupleList.map(t=&gt;(t._1 + <span class="string">&quot; &quot;</span>) * t._2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//val words: List[String] = stringList.flatMap(s=&gt;s.split(&quot; &quot;))</span></span><br><span class="line"><span class="keyword">val</span> words: <span class="type">List</span>[<span class="type">String</span>] = stringList.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 map 中，如果传进来什么就返回什么，不要用_省略</span></span><br><span class="line"><span class="keyword">val</span> groupMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">String</span>]] = words.groupBy(word=&gt;word)</span><br><span class="line"><span class="comment">//val groupMap: Map[String, List[String]] = words.groupBy(_)</span></span><br><span class="line"><span class="comment">// (word, list) =&gt; (word, count)</span></span><br><span class="line"><span class="keyword">val</span> wordToCount: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = groupMap.map(t=&gt;(t._1, t._2.size))</span><br><span class="line"><span class="keyword">val</span> wordCountList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToCount.toList.sortWith &#123;</span><br><span class="line">(left, right) =&gt; &#123;</span><br><span class="line">left._2 &gt; right._2</span><br><span class="line">&#125;</span><br><span class="line">&#125;.take(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//tupleList.map(t=&gt;(t._1 + &quot; &quot;) * t._2).flatMap(_.split(&quot; &quot;)).groupBy(word=&gt;word).map(t=&gt;(t._1, t._2.size))</span></span><br><span class="line">println(wordCountList)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List((Hello,10), (Scala,9), (Spark,7))</span><br></pre></td></tr></table></figure><ul><li><strong>方式二</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestWordCount</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> tuples = <span class="type">List</span>((<span class="string">&quot;Hello Scala Spark World&quot;</span>, <span class="number">4</span>), (<span class="string">&quot;Hello Scala Spark&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;Hello Scala&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// (Hello,4),(Scala,4),(Spark,4),(World,4)</span></span><br><span class="line"><span class="comment">// (Hello,3),(Scala,3),(Spark,3)</span></span><br><span class="line"><span class="comment">// (Hello,2),(Scala,2)</span></span><br><span class="line"><span class="comment">// (Hello,1)</span></span><br><span class="line"><span class="keyword">val</span> wordToCountList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = tuples.flatMap &#123;</span><br><span class="line">t =&gt; &#123;</span><br><span class="line"><span class="keyword">val</span> strings: <span class="type">Array</span>[<span class="type">String</span>] = t._1.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">strings.map(word =&gt; (word, t._2))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello, List((Hello,4), (Hello,3), (Hello,2), (Hello,1))</span></span><br><span class="line"><span class="comment">// Scala, List((Scala,4), (Scala,3), (Scala,2)</span></span><br><span class="line"><span class="comment">// Spark, List((Spark,4), (Spark,3)</span></span><br><span class="line"><span class="comment">// Word, List((Word,4))</span></span><br><span class="line"><span class="keyword">val</span> wordToTupleMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = wordToCountList.groupBy(t=&gt;t._1)</span><br><span class="line"><span class="keyword">val</span> stringToInts: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">List</span>[<span class="type">Int</span>]] = wordToTupleMap.mapValues &#123;</span><br><span class="line">datas =&gt; datas.map(t =&gt; t._2)</span><br><span class="line">&#125;</span><br><span class="line">stringToInts</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">val wordToCountMap: Map[String, List[Int]] = wordToTupleMap.map &#123;</span></span><br><span class="line"><span class="comment">t =&gt; &#123;</span></span><br><span class="line"><span class="comment">(t._1, t._2.map(t1 =&gt; t1._2))</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">val wordToTotalCountMap: Map[String, Int] = wordToCountMap.map(t=&gt;(t._1, t._2.sum))</span></span><br><span class="line"><span class="comment">println(wordToTotalCountMap)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-队列">8.队列</h3><ul><li><strong>说明</strong><ul><li>Scala 也提供了队列（Queue）的数据结构，队列的特点就是先进先出。进队和出队的方法分别为 enqueue 和 dequeue</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestQueue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> que = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">String</span>]()</span><br><span class="line">que.enqueue(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line">println(que.dequeue())</span><br><span class="line">println(que.dequeue())</span><br><span class="line">println(que.dequeue())</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h3 id="9-并行集合">9.并行集合</h3><ul><li><strong>说明</strong><ul><li>Scala 为了充分使用<font color=red>多核 CPU</font>，提供了并行集合（有别于前面的串行集合），用于多核环境的并行计算</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestPar</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result1 = (<span class="number">0</span> to <span class="number">100</span>).map&#123;</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="type">Thread</span>.currentThread.getName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> result2 = (<span class="number">0</span> to <span class="number">100</span>).par.map&#123;</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="type">Thread</span>.currentThread.getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(result1)</span><br><span class="line">println(result2)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector(main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main, main)</span><br><span class="line">ParVector(scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-12, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-13, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-17, scala-execution-context-global-14, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-18, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-15, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-19, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-16, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14, scala-execution-context-global-14)</span><br></pre></td></tr></table></figure><h1 id="八、模式匹配">八、模式匹配</h1><p><strong>Scala 中的模式匹配类似于 Java 中的 switch 语法，补充了更多的功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span> :</span><br><span class="line">System.out.println(<span class="string">&quot;10&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span> : </span><br><span class="line">System.out.println(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> : </span><br><span class="line">System.out.println(<span class="string">&quot;other number&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本语法">基本语法</h2><p><strong>模式匹配语法中，采用 match 关键字声明，每个分支采用 case 关键字进行声明，当需要匹配时，会从第一个 case 分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。如果所有 case 都不匹配，那么会执行 case _分支，类似于 Java 中 default 语句</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchCase</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> operator: <span class="type">Char</span> = &#x27;d&#x27;</span><br><span class="line"><span class="keyword">var</span> result = operator <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &#x27;+&#x27; =&gt; a + b</span><br><span class="line"><span class="keyword">case</span> &#x27;-&#x27; =&gt; a - b</span><br><span class="line"><span class="keyword">case</span> &#x27;*&#x27; =&gt; a * b</span><br><span class="line"><span class="keyword">case</span> &#x27;/&#x27; =&gt; a / b</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;illegal&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(result)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">illegal</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>如果所有 case 都不匹配，那么会执行 case _ 分支，类似于 Java 中 default 语句，若此时没有 case _ 分支，那么会抛出 MatchError</li><li>每个 case 中，不需要使用 break 语句，自动中断 case</li><li>match case 语句可以匹配任何类型，而不只是字面量</li><li>=&gt; 后面的代码块，直到下一个 case 语句之前的代码是<font color=red>作为一个整体执行</font>，可以使用{}括起来，也可以不括</li></ul></li></ul><h2 id="模式守卫">模式守卫</h2><ul><li><strong>说明</strong><ul><li>如果想要表达匹配某个范围的数据，就需要在模式匹配中增加条件守卫</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchGuard</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span></span>(x: <span class="type">Int</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i: <span class="type">Int</span> <span class="keyword">if</span> i &gt;= <span class="number">0</span> =&gt; i</span><br><span class="line"><span class="keyword">case</span> j: <span class="type">Int</span> <span class="keyword">if</span> j &lt; <span class="number">0</span> =&gt; -j</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;type illegal&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(abs(<span class="number">-5</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="模式匹配类型">模式匹配类型</h2><h3 id="1-匹配常量">1.匹配常量</h3><ul><li><strong>说明</strong><ul><li>Scala 中，模式匹配可以匹配所有的字面量，包括字符串，字符，数字，布尔值等等</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchVal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(describe(<span class="number">6</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> =&gt; <span class="string">&quot;Int five&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> =&gt; <span class="string">&quot;String hello&quot;</span></span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="string">&quot;Boolean true&quot;</span></span><br><span class="line"><span class="keyword">case</span> &#x27;+&#x27; =&gt; <span class="string">&quot;Char +&quot;</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String hello</span><br></pre></td></tr></table></figure><h3 id="2-匹配类型">2.匹配类型</h3><ul><li><strong>说明</strong><ul><li>需要进行类型判断时，可以使用前文所学的 isInstanceOf[T]和 asInstanceOf[T]，也可使用模式匹配实现同样的功能</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe</span></span>(x: <span class="type">Any</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i: <span class="type">Int</span> =&gt; <span class="string">&quot;Int&quot;</span></span><br><span class="line"><span class="keyword">case</span> s: <span class="type">String</span> =&gt; <span class="string">&quot;String hello&quot;</span></span><br><span class="line"><span class="keyword">case</span> m: <span class="type">List</span>[_] =&gt; <span class="string">&quot;List&quot;</span></span><br><span class="line"><span class="keyword">case</span> c: <span class="type">Array</span>[<span class="type">Int</span>] =&gt; <span class="string">&quot;Array[Int]&quot;</span></span><br><span class="line"><span class="keyword">case</span> someThing =&gt; <span class="string">&quot;something else &quot;</span> + someThing</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//泛型擦除</span></span><br><span class="line">println(describe(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)))</span><br><span class="line"><span class="comment">//数组例外，可保留泛型</span></span><br><span class="line">println(describe(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)))</span><br><span class="line">println(describe(<span class="type">Array</span>(<span class="string">&quot;abc&quot;</span>)))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List</span><br><span class="line">Array[Int]</span><br><span class="line">something else [Ljava.lang.String;@7cf10a6f</span><br></pre></td></tr></table></figure><h3 id="3-匹配数组">3.匹配数组</h3><ul><li><strong>说明</strong><ul><li>scala 模式匹配可以对集合进行精确的匹配，例如匹配只有两个元素的、且第一个元素为 0 的数组</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">for</span> (arr &lt;- <span class="type">Array</span>(<span class="type">Array</span>(<span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="type">Array</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="type">Array</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">90</span>))) &#123; <span class="comment">// 对一个数组集合进行遍历</span></span><br><span class="line"><span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="string">&quot;0&quot;</span> <span class="comment">//匹配 Array(0) 这个数组</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Array</span>(x, y) =&gt; x + <span class="string">&quot;,&quot;</span> + y <span class="comment">//匹配有两个元素的数组，然后将将元素值赋给对应的 x,y</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">&quot;以 0 开头的数组&quot;</span> <span class="comment">//匹配以 0 开头和数组</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;result = &quot;</span> + result)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = 0</span><br><span class="line">result = 1,0</span><br><span class="line">result = 以 0 开头的数组</span><br><span class="line">result = something else</span><br><span class="line">result = something else</span><br><span class="line">result = hello,90</span><br></pre></td></tr></table></figure><h3 id="4-匹配列表">4.匹配列表</h3><ul><li><strong>方式一</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//list 是一个存放 List 集合的数组</span></span><br><span class="line"><span class="comment">//请思考，如果要匹配 List(88) 这样的只含有一个元素的列表,并原值返回.应该怎么写</span></span><br><span class="line"><span class="keyword">for</span> (list &lt;- <span class="type">Array</span>(<span class="type">List</span>(<span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="type">List</span>(<span class="number">88</span>))) &#123;</span><br><span class="line"><span class="keyword">val</span> result = list <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>) =&gt; <span class="string">&quot;0&quot;</span> <span class="comment">//匹配 List(0)</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">List</span>(x, y) =&gt; x + <span class="string">&quot;,&quot;</span> + y <span class="comment">//匹配有两个元素的 List</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">List</span>(<span class="number">0</span>, _*) =&gt; <span class="string">&quot;0 ...&quot;</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1,0</span><br><span class="line">0 ...</span><br><span class="line">something else</span><br><span class="line">something else</span><br></pre></td></tr></table></figure><ul><li><strong>方式二</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchList</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">list <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> first :: second :: rest =&gt; println(first + <span class="string">&quot;-&quot;</span> + second + <span class="string">&quot;-&quot;</span> + rest)</span><br><span class="line"><span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;something else&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-2-List(5, 6, 7)</span><br></pre></td></tr></table></figure><h3 id="5-匹配元组">5.匹配元组</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchTuple</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//对一个元组集合进行遍历</span></span><br><span class="line"><span class="keyword">for</span> (tuple &lt;- <span class="type">Array</span>((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))) &#123;</span><br><span class="line"><span class="keyword">val</span> result = tuple <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">&quot;0 ...&quot;</span> <span class="comment">//是第一个元素是 0 的元组</span></span><br><span class="line"><span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; <span class="string">&quot;&quot;</span> + y + <span class="string">&quot;0&quot;</span> <span class="comment">// 匹配后一个元素是 0 的对偶元组</span></span><br><span class="line"><span class="keyword">case</span> (a, b) =&gt; <span class="string">&quot;&quot;</span> + a + <span class="string">&quot; &quot;</span> + b</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;something else&quot;</span> <span class="comment">//默认</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 ...</span><br><span class="line">10</span><br><span class="line">1 1</span><br><span class="line">something else</span><br></pre></td></tr></table></figure><ul><li><strong>扩展案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的模式匹配 1 打印元组第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">println(elem._1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ((word,count) &lt;- <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">println(word)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ((word,_) &lt;- <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">println(word)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ((<span class="string">&quot;a&quot;</span>,count) &lt;- <span class="type">Array</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">println(count)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的模式匹配 2 给元组元素命名</span></span><br><span class="line"><span class="keyword">var</span> (id,name,age): (<span class="type">Int</span>, <span class="type">String</span>, <span class="type">Int</span>) = (<span class="number">100</span>, <span class="string">&quot;zs&quot;</span>, <span class="number">20</span>)</span><br><span class="line">println((id,name,age))</span><br><span class="line">println(<span class="string">&quot;--------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊的模式匹配 3 遍历集合中的元组，给 count * 2</span></span><br><span class="line"><span class="keyword">var</span> list: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">//println(list.map(t =&gt; (t._1, t._2 * 2)))</span></span><br><span class="line">println(</span><br><span class="line">list.map&#123;</span><br><span class="line"><span class="keyword">case</span> (word,count)=&gt;(word,count*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> list1 = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, (<span class="string">&quot;a&quot;</span>, <span class="number">1</span>)), (<span class="string">&quot;b&quot;</span>, (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>)), (<span class="string">&quot;c&quot;</span>, (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">println(</span><br><span class="line">list1.map&#123;</span><br><span class="line"><span class="keyword">case</span> (groupkey,(word,count))=&gt;(word,count*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">1</span><br><span class="line">--------------</span><br><span class="line">(100,zs,20)</span><br><span class="line">--------------</span><br><span class="line">List((a,2), (b,4), (c,6))</span><br><span class="line">List((a,2), (b,4), (c,6))</span><br></pre></td></tr></table></figure><h3 id="6-匹配对象及样例类">6.匹配对象及样例类</h3><ul><li><strong>基本语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">User</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>): <span class="type">User</span> = <span class="keyword">new</span> <span class="type">User</span>(name, age)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(user: <span class="type">User</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = &#123;</span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line"><span class="type">None</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="type">Some</span>(user.name, user.age)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchUnapply</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> user: <span class="type">User</span> = <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> result = user <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>) =&gt; <span class="string">&quot;yes&quot;</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;no&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure><ul><li><strong>小结</strong><ul><li>val user = User(“zhangsan”,11)，该语句在执行时，实际调用的是 User 伴生对象中的apply 方法，因此不用 new 关键字就能构造出相应的对象</li><li>当将 User(“zhangsan”, 11)写在 case 后时[case User(“zhangsan”, 11) =&gt; “yes”]，会默认调用 unapply 方法(对象提取器)，<font color=red>user 作为 unapply 方法的参数</font>，unapply 方法将 user 对象的 name 和 age 属性提取出来，与 User(“zhangsan”, 11)中的属性值进行匹配</li><li>case 中对象的 unapply 方法(提取器)返回 Some，且所有属性均一致，才算匹配成功,属性不一致，或返回 None，则匹配失败</li><li>若只提取对象的一个属性，则提取器为 <font color=red>unapply</font>(obj:Obj):<font color=red>Option[</font>T<font color=red>]</font><br>若提取对象的多个属性，则提取器为 <font color=red>unapply</font>(obj:Obj):<font color=red>Option[</font>(T1,T2,T3…)<font color=red>]</font><br>若提取对象的可变个属性，则提取器为<font color=red> unapplySeq</font>(obj:Obj):<font color=red>Option[</font>Seq[T]<font color=red>]</font></li></ul></li><li><strong>样例类</strong><ul><li><strong>语法</strong></li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>样例类仍然是类，和普通类相比，只是其自动生成了伴生对象，并且伴生对象中<br>自动提供了一些常用的方法，如 apply、unapply、toString、equals、hashCode 和 copy</li><li>样例类是为模式匹配而优化的类，因为其默认提供了 unapply 方法，因此，样例<br>类可以直接使用模式匹配，而无需自己实现 unapply 方法</li><li>构造器中的每一个参数都成为 val，除非它被显式地声明为 var（不建议这样做）</li></ul></li><li><strong>演示</strong><ul><li>上述匹配对象的案例使用样例类会节省大量代码</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchUnapply</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> user: <span class="type">User</span> = <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="keyword">val</span> result = user <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">11</span>) =&gt; <span class="string">&quot;yes&quot;</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">&quot;no&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure><h3 id="4-变量声明中的模式匹配">4.变量声明中的模式匹配</h3><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchVariable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">println(<span class="string">s&quot;x=<span class="subst">$x</span>,y=<span class="subst">$y</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(first, second, _*) = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line">println(<span class="string">s&quot;first=<span class="subst">$first</span>,second=<span class="subst">$second</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> <span class="type">Person</span>(name, age) = <span class="type">Person1</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">16</span>)</span><br><span class="line">println(<span class="string">s&quot;name=<span class="subst">$name</span>,age=<span class="subst">$age</span>&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=1,y=2</span><br><span class="line">first=1,second=7</span><br><span class="line">name=zhangsan,age=16</span><br></pre></td></tr></table></figure><h3 id="5-for-表达式中的模式匹配">5.for 表达式中的模式匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestMatchFor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">&quot;A&quot;</span> -&gt; <span class="number">1</span>, <span class="string">&quot;B&quot;</span> -&gt; <span class="number">0</span>, <span class="string">&quot;C&quot;</span> -&gt; <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map) &#123; <span class="comment">//直接将 map 中的 k-v 遍历出来</span></span><br><span class="line">println(k + <span class="string">&quot; -&gt; &quot;</span> + v) <span class="comment">//3 个</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="comment">//遍历 value=0 的 k-v ,如果 v 不是 0,过滤</span></span><br><span class="line"><span class="keyword">for</span> ((k, <span class="number">0</span>) &lt;- map) &#123;</span><br><span class="line">println(k + <span class="string">&quot; --&gt; &quot;</span> + <span class="number">0</span>) <span class="comment">// B-&gt;0</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;----------------------&quot;</span>)</span><br><span class="line"><span class="comment">//if v == 0 是一个过滤的条件</span></span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map <span class="keyword">if</span> v &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">println(k + <span class="string">&quot; ---&gt; &quot;</span> + v) <span class="comment">// A-&gt;1 和 c-&gt;33</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 0</span><br><span class="line">C -&gt; 3</span><br><span class="line">----------------------</span><br><span class="line">B --&gt; 0</span><br><span class="line">----------------------</span><br><span class="line">A ---&gt; 1</span><br><span class="line">C ---&gt; 3</span><br></pre></td></tr></table></figure><h3 id="6-偏函数中的模式匹配">6.偏函数中的模式匹配</h3><p><strong>偏函数也是函数的一种，通过偏函数我们可以方便的对输入参数做更精确的检查。例如该偏函数的输入类型为 List[Int]，而我们需要的是第一个元素是 0 的集合，这就是通过模式匹配实现的</strong></p><ul><li><strong>偏函数定义</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> second: <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line"><span class="keyword">case</span> x :: y :: _ =&gt; <span class="type">Some</span>(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210410114442398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注</strong>：该偏函数的功能是返回输入的 List 集合的第二个元素</p><ul><li><strong>偏函数原理</strong><ul><li>上述代码会被 scala 编译器翻译成以下代码，与普通函数相比，只是多了一个用于参数检查的函数——isDefinedAt，其返回值类型为 Boolean</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> second = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">List</span>[<span class="type">Int</span>], <span class="type">Option</span>[<span class="type">Int</span>]] &#123;</span><br><span class="line"><span class="comment">//检查输入参数是否合格</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = list <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x :: y :: _ =&gt; <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行函数逻辑</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Option</span>[<span class="type">Int</span>] = list <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x :: y :: _ =&gt; <span class="type">Some</span>(y)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>偏函数使用</strong><ul><li>偏函数不能像 second(List(1,2,3))这样直接使用，因为这样会直接调用 apply 方法，而应该调用 applyOrElse 方法，如下面的代码</li><li>applyOrElse 方法的逻辑为 if (ifDefinedAt(list)) apply(list) else default。如果输入参数满足条件，即 isDefinedAt 返回 true，则执行 apply 方法，否则执行 defalut 方法，default 方法为参数不满足要求的处理逻辑</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">second.applyOrElse(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), (_: <span class="type">List</span>[<span class="type">Int</span>]) =&gt; <span class="type">None</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>案例</strong><ul><li>将 List(1,2,3,4,5,6,“test”)中的 Int 类型的元素加一，并去掉字符串</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> list1 = list.map &#123;</span><br><span class="line">a =&gt;</span><br><span class="line">a <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i + <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> s: <span class="type">String</span> =&gt;s + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">println(list1.filter(a=&gt;a.isInstanceOf[<span class="type">Int</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(2, 3, 4, 5, 6, 7)</span><br></pre></td></tr></table></figure><ul><li><strong>偏函数实现</strong><ul><li>方法一</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="string">&quot;test&quot;</span>).filter(_.isInstanceOf[<span class="type">Int</span>]).map(_.asInstanceOf[<span class="type">Int</span>] + <span class="number">1</span>).foreach(println)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&quot;test&quot;</span>).collect &#123; <span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x + <span class="number">1</span> &#125;.foreach(println)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="九、异常">九、异常</h1><h2 id="Java异常处理">Java异常处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">&#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line"><span class="comment">// catch 时，需要将范围小的写到前面</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>注意事项</strong><ul><li>Java 语言按照 try—catch—finally 的方式来处理异常</li><li>不管有没有异常捕获，都会执行 finally，因此通常可以在 finally 代码块中释放资<br>源</li><li>可以有多个 catch，分别捕获对应的异常，这时需要把范围小的异常类写在前面，把范围大的异常类写在后面，否则编译错误</li></ul></li></ul><h2 id="Scala异常处理">Scala异常处理</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> n= <span class="number">10</span> / <span class="number">0</span></span><br><span class="line">&#125;<span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ex: <span class="type">ArithmeticException</span>=&gt;&#123;</span><br><span class="line"><span class="comment">// 发生算术异常</span></span><br><span class="line">println(<span class="string">&quot;发生算术异常&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ex: <span class="type">Exception</span>=&gt;&#123;</span><br><span class="line"><span class="comment">// 对异常处理</span></span><br><span class="line">println(<span class="string">&quot;发生了异常 1&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;发生了异常 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">println(<span class="string">&quot;finally&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们将可疑代码封装在 try 块中。在 try 块之后使用了一个 catch 处理程序来捕获异<br>常；如果发生任何异常，catch 处理程序将处理它，程序将不会异常终止</li><li>Scala 的异常的工作机制和 Java 一样，但是<font color=red> Scala 没有“checked（编译期）”异常</font>， 即 Scala 没有编译异常这个概念，异常都是在运行的时候捕获处理</li><li>异常捕捉的机制与其他语言中一样，如果有异常发生，catch 子句是按次序捕捉的。<br>因此，在 catch 子句中，越具体的异常越要靠前，越普遍的异常越靠后，如果把越普遍的异常写在前，把具体的异常写在后，在 Scala 中也不会报错，但这样是非常不好的编程风格</li><li>finally 子句用于执行不管是正常处理还是有异常发生时都需要执行的步骤，一般用<br>于对象的清理工作，这点和 Java 一样</li><li>用 throw 关键字，抛出一个异常对象。所有<font color=red>异常都是 Throwable 的子类型。throw 表达式是有类型的，就是 Nothing</font>，因为 Nothing 是所有类型的子类型，所以 throw 表达式可以用在需要类型的地方</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>():<span class="type">Nothing</span> = &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;不对&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java 提供了 throws 关键字来声明异常。可以使用方法定义声明异常。它向调用者函<br>数提供了此方法可能引发此异常的信息。它有助于调用函数处理并将该代码包含在 try-catch块中，以避免程序异常终止。在 Scala 中，可以使用 throws 注解来声明异常</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">f11()</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@throws</span>(classOf[<span class="type">NumberFormatException</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f11</span></span>()=&#123;</span><br><span class="line"><span class="string">&quot;abc&quot;</span>.toInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十、隐式转换">十、隐式转换</h1><p><strong><font color=red>当编译器第一次编译失败的时候，会在当前的环境中查找能让代码编译通过的方法，用于将类型进行转换，实现二次编译</font></strong></p><h2 id="隐式函数">隐式函数</h2><ul><li><strong>说明</strong><ul><li>隐式转换可以在不需改任何代码的情况下，扩展某个类的功能</li></ul></li><li><strong>演示</strong><ul><li>通过隐式转化为 Int 类型增加方法</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRichInt</span>(<span class="params">val self: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMax</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (self &lt; i) i <span class="keyword">else</span> self</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMin</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (self &lt; i) self <span class="keyword">else</span> i</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicitFunction</span> </span>&#123;</span><br><span class="line"><span class="comment">// 使用 implicit 关键字声明的函数称之为隐式函数</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convert</span></span>(arg: <span class="type">Int</span>): <span class="type">MyRichInt</span> = &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="type">MyRichInt</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">// 当想调用对象功能时，如果编译错误，那么编译器会尝试在当前作用域范围内查找能调用对应功能的转换规则，这个调用过程是由编译器完成的，所以称之为隐式转换。也称之为自动转换</span></span><br><span class="line">println(<span class="number">2.</span>myMax(<span class="number">6</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="隐式参数">隐式参数</h2><p><strong>普通方法或者函数中的参数可以通过<font color=red> implicit </font>关键字声明为隐式参数，调用该方法时，就可以传入该参数，编译器会在相应的作用域寻找符合条件的隐式值</strong></p><ul><li><strong>说明</strong><ul><li>同一个作用域中，相同类型的隐式值只能有一个</li><li>编译器按照隐式参数的类型去寻找对应类型的隐式值，与隐式值的名称无关</li><li>隐式参数优先于默认参数</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicitParameter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">&quot;hello world!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(<span class="keyword">implicit</span> arg: <span class="type">String</span>=<span class="string">&quot;good bey world!&quot;</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">hello</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure><h2 id="隐式类">隐式类</h2><p><strong>在 Scala2.10 后提供了隐式类，可以使用 <font color=red>implicit </font>声明类，隐式类的非常强大，同样可以扩展类的功能，在集合中隐式类会发挥重要的作用</strong></p><ul><li><strong>说明</strong><ul><li>其所带的构造参数有且只能有一个</li><li>隐式类必须被定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是 <font color=red>顶级</font>的</li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestImplicitClass</span> </span>&#123;</span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRichInt</span>(<span class="params">arg: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMax</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (arg &lt; i) i <span class="keyword">else</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMin</span></span>(i: <span class="type">Int</span>) = &#123;</span><br><span class="line"><span class="keyword">if</span> (arg &lt; i) arg <span class="keyword">else</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="number">1.</span>myMax(<span class="number">3</span>))</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="隐式解析机制">隐式解析机制</h2><ul><li><strong>说明</strong><ul><li>首先会在当前代码作用域下查找隐式实体（隐式方法、隐式类、隐式对象） <font color=red>（一般情况下） </font></li><li>如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与<font color=red>该类型相关联的全部伴生对象 </font>以及<font color=red>该类型所在包的包对象 </font></li></ul></li><li><strong>案例</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.chapter10.<span class="type">Scala05_Transform4</span>.<span class="type">Teacher</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果第一条规则查找隐式实体失败，会继续在隐式参数的类型的作用域里查找。类型的作用域是指与该类型相关联的全部伴生模块，</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTransform</span> <span class="keyword">extends</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//（1）首先会在当前代码作用域下查找隐式实体</span></span><br><span class="line"><span class="keyword">val</span> teacher = <span class="keyword">new</span> <span class="type">Teacher</span>()</span><br><span class="line">teacher.eat()</span><br><span class="line">teacher.say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;eat...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PersonTrait</span> </span>&#123;</span><br><span class="line"><span class="comment">// 隐式类 : 类型 1 =&gt; 类型 2</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">Person5</span>(<span class="params">user:<span class="type">Teacher</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">println(<span class="string">&quot;say...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十一、泛型">十一、泛型</h1><h2 id="协变和逆变">协变和逆变</h2><ul><li><strong>语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">T</span>]</span>&#123; <span class="comment">//协变</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[-<span class="type">T</span>]</span>&#123; <span class="comment">//逆变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[<span class="type">T</span>] <span class="comment">//不变</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>协变：Son 是 Father 的<font color=red>子类</font>，则 MyList[Son] 也作为 MyList[Father]的<font color=red>“子类”</font></li><li>逆变：Son 是 Father 的<font color=red>子类</font>，则 MyList[Son]作为 MyList[Father]的<font color=red>“父类”</font></li><li>不变：Son 是 Father 的<font color=red>子类</font>，则 MyList[Father]与 MyList[Son]<font color=red>“无父子关系”</font></li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型模板</span></span><br><span class="line"><span class="comment">//class MyList&lt;T&gt;&#123;&#125;</span></span><br><span class="line"><span class="comment">//不变</span></span><br><span class="line"><span class="comment">//class MyList[T]&#123;&#125;</span></span><br><span class="line"><span class="comment">//协变</span></span><br><span class="line"><span class="comment">//class MyList[+T]&#123;&#125;</span></span><br><span class="line"><span class="comment">//逆变</span></span><br><span class="line"><span class="comment">//class MyList[-T]&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubChild</span> <span class="keyword">extends</span> <span class="title">Child</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala_TestGeneric</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//var s:MyList[Child] = new MyList[SubChild]</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型上下限">泛型上下限</h2><ul><li><strong>语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="type">PersonList</span>[<span class="type">T</span> &lt;: <span class="type">Person</span>]&#123; <span class="comment">//泛型上限</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Class</span> <span class="type">PersonList</span>[<span class="type">T</span> &gt;: <span class="type">Person</span>]&#123; <span class="comment">//泛型下限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>泛型的上下限的作用是对传入的泛型进行限定</li></ul></li><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubChild</span> <span class="keyword">extends</span> <span class="title">Child</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala_TestGeneric</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//test(classOf[SubChild])</span></span><br><span class="line"><span class="comment">//test[Child](new SubChild)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型通配符之上限</span></span><br><span class="line"><span class="comment">//def test[A &lt;: Child](a:Class[A]): Unit =&#123;</span></span><br><span class="line"><span class="comment">// println(a)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//泛型通配符之下限</span></span><br><span class="line"><span class="comment">//def test[A &gt;: Child](a:Class[A]): Unit =&#123;</span></span><br><span class="line"><span class="comment">// println(a)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//泛型通配符之下限 形式扩展</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>[<span class="type">A</span> &gt;: <span class="type">Child</span>](a:<span class="type">A</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">println(a.getClass.getName)</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下文限定">上下文限定</h2><ul><li><strong>语法</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>[<span class="type">A</span> : <span class="type">B</span>](a: <span class="type">A</span>) = println(a) <span class="comment">//等同于 def f[A](a:A)(implicit arg:B[A])=println(a)</span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong><ul><li>上下文限定是将泛型和隐式转换的结合产物，以下两者功能相同，使用上下文限定[A : Ordering]之后，方法内无法使用隐式参数名调用隐式参数，需要通过 <font color=red>implicitly[Ordering[A]]</font>获取隐式变量，如果此时无法查找到对应类型的隐式变量，会发生出错误</li></ul></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> y = implicitly[<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">val</span> z = implicitly[<span class="type">Double</span>]</span><br></pre></td></tr></table></figure><ul><li><strong>演示</strong></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>[<span class="type">A</span>:<span class="type">Ordering</span>](a:<span class="type">A</span>,b:<span class="type">A</span>) =implicitly[<span class="type">Ordering</span>[<span class="type">A</span>]].compare(a,b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>[<span class="type">A</span>](a: <span class="type">A</span>, b: <span class="type">A</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">A</span>]) = ord.compare(a, b)</span><br></pre></td></tr></table></figure><h1 id="十二、IDEA快捷键">十二、IDEA快捷键</h1><ul><li>快速生成程序入口：main</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入 main-&gt;回车</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动补全变量：.var</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入 <span class="number">1.</span><span class="keyword">var</span>-&gt;回车</span><br><span class="line"><span class="keyword">val</span> i: <span class="type">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>快速打印：.sout</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入 <span class="number">1.</span>sout-&gt;回车</span><br><span class="line">println(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>快速生成 for 循环：遍历对象.for</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入 <span class="number">1</span> to <span class="number">3.</span><span class="keyword">for</span></span><br><span class="line"><span class="keyword">for</span> (elem &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看当前文件的结构：Ctrl + F12</li><li>格式化当前代码：Ctrl + Shift + L</li><li>自动为当前代码补全变量声明：Ctrl + Shift + V<br><img src="https://img-blog.csdnimg.cn/20210410144515501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210410144525572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210410144534672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210410144542691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 离线安装 pymysql（适用于所有库）</title>
      <link href="/2021/03/29/python_5/"/>
      <url>/2021/03/29/python_5/</url>
      
        <content type="html"><![CDATA[<p><strong>首先获取到想要的库的包，我这里安装的是pymysql，从下面链接下载的资源</strong><br><a href="https://pypi.doubanio.com/simple/pymysql/">https://pypi.doubanio.com/simple/pymysql/</a><br><strong>然后把包上传到服务器，解压到当前目录（PyMySQL-1.0.2.tar是你的包名）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf PyMySQL-1.0.2.tar</span><br></pre></td></tr></table></figure><p><strong>进入到解压后的目录，执行安装命令（python3指安装的目录，如果python3执行失败，可能是环境变量没有配置，改成绝对路径执行即可，linux配置python环境变量我的另一篇文章有写：<a href="https://blog.csdn.net/weixin_44758876/article/details/115221146">https://blog.csdn.net/weixin_44758876/article/details/115221146</a>）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><p><strong>到这里就安装成功了，import pymysql不报错就代表没有问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>suse12 sp4，sp5 镜像资源分享</title>
      <link href="/2021/03/26/resource_1/"/>
      <url>/2021/03/26/resource_1/</url>
      
        <content type="html"><![CDATA[<p><strong>之前在网上找suse12的资源，结果发现他们连这点积分都赚，很是无语，这里分享sp4和sp5的镜像资源，博主也是花钱买来的，免费分享给大家，觉得有帮助的点个关注就行</strong><br><br><br><strong>SLE-12-SP4-Server-DVD-x86_64-GM-DVD.iso百度云永久资源：</strong><br>链接：<a href="https://pan.baidu.com/s/11OdnRMavXGslTcEy1YKcVQ">https://pan.baidu.com/s/11OdnRMavXGslTcEy1YKcVQ</a><br>提取码：h5z0<br><br><br><strong>SLE-12-SP5-Server-DVD-x86_64-GM-DVD.iso百度云永久资源：</strong><br>链接：<a href="https://pan.baidu.com/s/1zjKmNqhZjR_k-ghxhrgUSQ">https://pan.baidu.com/s/1zjKmNqhZjR_k-ghxhrgUSQ</a><br>提取码：1351</p>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SUSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装 Python3 教程</title>
      <link href="/2021/03/25/python_4/"/>
      <url>/2021/03/25/python_4/</url>
      
        <content type="html"><![CDATA[<p><strong>我这里用的是CentOS7.2系统以及python3.9.2版本</strong><br><strong>首先在python官网下载安装包放在服务器上，我这里就不放链接了</strong></p><p><img src="https://img-blog.csdnimg.cn/20210325230309910.png" alt="在这里插入图片描述"><br><strong>使用命令把安装包解压到当前目录</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python-3.9.2.tgz</span><br></pre></td></tr></table></figure><p><strong>下载需要的依赖包</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc patch libffi-devel python-devel  zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br></pre></td></tr></table></figure><p><strong>创建安装目录</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/python3</span><br></pre></td></tr></table></figure><p><strong>编译安装，依次执行下面三个命令（注意/data/python3是我们的安装目录，和我的安装目录不一样的话别忘了修改命令）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/data/python3</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong>建立软连接（这里的/data/python3是安装目录）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /data/python3 /usr/bin/python3</span><br></pre></td></tr></table></figure><p><strong>配置环境变量，修改/etc/profile文件</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p><strong>增加以下内容（/data/python3是python的安装目录）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PYTHON_HOME=/data/python3</span><br><span class="line">export PATH=$PATH:$PYTHON_HOME/bin:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p><strong>source一下/etc/profile文件</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><strong>到这里python就安装完成了，可以用python3 -V查看版本</strong></p><p><img src="https://img-blog.csdnimg.cn/2021032523183498.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>耗时两周，纯手敲 python 入门级基础笔记</title>
      <link href="/2021/03/23/python_3/"/>
      <url>/2021/03/23/python_3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、输出函数及转义字符">一、输出函数及转义字符</h1><h2 id="输出函数">输出函数</h2><p><strong>和java一样，使用print函数控制输出，输出字符串示例:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure><p><strong>也可以输出含有运算符的表达式，会直接打印表达式结果：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3</span> + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="转义字符">转义字符</h2><p><font color=#999AAA><strong>反斜杠+想要实现的转义功能首字母既为转义字符</strong></font><br><strong>当字符串中包含反斜杠、单引号、双引号时等有特殊作用的字符时，必须使用反斜杠对这些字符进行转义：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反斜杠：\\</span><br><span class="line">单引号：\&#x27;</span><br><span class="line">双引号：\&quot;</span><br></pre></td></tr></table></figure><p><strong>当字符串中包含换行、回车、水平制表符或退格等无法直接表示的特殊字符时，也可以使用转义字符：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">换行：\n</span><br><span class="line">回车：\r</span><br><span class="line">水平制表符：\t</span><br><span class="line">退格：\b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\nworld&quot;</span>)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\tworld&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\rworld&quot;</span>)   <span class="comment">#world将hello进行了覆盖</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello\bworld&quot;</span>)   <span class="comment">#\b是退一个格，将o退没了</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">helloworld</span><br><span class="line">world</span><br><span class="line">hellworld</span><br></pre></td></tr></table></figure><p><font color=red><strong>原字符</strong></font><strong>：不希望字符串中的转义字符起作用，在字符串前面加上r或R</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;hello\nworld&quot;</span>)   </span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello\nworld</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意事项</strong></font><strong>：最后一个字符不能是反斜线</strong></p><h1 id="二、变量">二、变量</h1><h2 id="变量的定义与赋值">变量的定义与赋值</h2><h3 id="1-定义一个变量">1.定义一个变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;变量&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(word)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量</span><br></pre></td></tr></table></figure><h3 id="2-变量的多次赋值">2.变量的多次赋值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">李四</span><br></pre></td></tr></table></figure><h2 id="常用的数据类型">常用的数据类型</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">整数类型-&gt;int-&gt;97</span><br><span class="line">浮点类型-&gt;float-&gt;3.1415</span><br><span class="line">布尔类型-&gt;bool-&gt;True,False</span><br><span class="line">字符串类型-&gt;str-&gt;&#x27;人生苦短&#x27;</span><br></pre></td></tr></table></figure><h3 id="1-整数类型">1.整数类型</h3><p><strong>整数可以表示正数、负数和零，也可以表示为二进制、十进制、八进制、十六进制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="number">90</span></span><br><span class="line">n2 = -<span class="number">76</span></span><br><span class="line">n3 = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(n1,<span class="built_in">type</span>(n1))</span><br><span class="line"><span class="built_in">print</span>(n2,<span class="built_in">type</span>(n2))</span><br><span class="line"><span class="built_in">print</span>(n3,<span class="built_in">type</span>(n3))</span><br><span class="line"><span class="comment">#整数可以表示为二进制、十进制、八进制、十六进制</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十进制&#x27;</span>,<span class="number">118</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;二进制&#x27;</span>,<span class="number">0b1010111</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;八进制&#x27;</span>,<span class="number">0o176</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十六进制&#x27;</span>,<span class="number">0x1EAF</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">90 &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">-76 &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">0 &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">十进制 118</span><br><span class="line">二进制 87</span><br><span class="line">八进制 126</span><br><span class="line">十六进制 7855</span><br></pre></td></tr></table></figure><p><strong>整数的不同进制表示方式：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">十进制-&gt;默认的进制</span><br><span class="line">二进制-&gt;以0b开头</span><br><span class="line">八进制-&gt;以0o开头</span><br><span class="line">十六进制-&gt;以0x开头</span><br></pre></td></tr></table></figure><h3 id="2-浮点类型">2.浮点类型</h3><p><strong>浮点数由整数部分和小数部分组成</strong></p><h4 id="浮点数存储不精确性">浮点数存储不精确性</h4><p><strong>使用浮点数进行计算时，可能会出现小数位数不确定的情况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3.1415</span></span><br><span class="line"><span class="built_in">print</span>(a,<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1.1</span> + <span class="number">2.2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.1415 &lt;class &#x27;float&#x27;&gt;</span><br><span class="line">3.3000000000000003</span><br></pre></td></tr></table></figure><p><strong>导入模块decimal</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="string">&#x27;1.1&#x27;</span>) + Decimal(<span class="string">&#x27;2.2&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.3</span><br></pre></td></tr></table></figure><h3 id="3-布尔类型">3.布尔类型</h3><p><strong>用来表示真或假的值，True表示真，False表示假</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1 = <span class="literal">True</span></span><br><span class="line">f2 = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(f1,<span class="built_in">type</span>(f1))</span><br><span class="line"><span class="built_in">print</span>(f2,<span class="built_in">type</span>(f2))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True &lt;class &#x27;bool&#x27;&gt;</span><br><span class="line">False &lt;class &#x27;bool&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>布尔值可以转化为整数，True表示1，False表示0</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span> + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="4-字符串类型">4.字符串类型</h3><p><strong>字符串又称为不可变的字符序列，可以用单引号、双引号、三引号来定义，单引号和双引号定义的字符串必须在一行，三引号定义的字符串可以分布在连续的多行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这是一个段落</span></span><br><span class="line"><span class="string">    可以由多行组成</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(word)</span><br><span class="line"><span class="built_in">print</span>(sentence)</span><br><span class="line"><span class="built_in">print</span>(paragraph)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串 &lt;class &#x27;str&#x27;&gt;</span><br><span class="line">这是一个句子 &lt;class &#x27;str&#x27;&gt;</span><br><span class="line"></span><br><span class="line">    这是一个段落</span><br><span class="line">    可以由多行组成</span><br><span class="line"> &lt;class &#x27;str&#x27;&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="数据类型转换">数据类型转换</h2><p><strong>将不同数据类型的数据拼接在一起时会报错</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name),<span class="built_in">type</span>(age))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我叫&#x27;</span> + name + <span class="string">&#x27;,今年&#x27;</span> + age + <span class="string">&#x27;岁&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 128, in &lt;module&gt;</span><br><span class="line">    print(&#x27;我叫&#x27; + name + &#x27;,今年&#x27; + age + &#x27;岁&#x27;)</span><br><span class="line">TypeError: can only concatenate str (not &quot;int&quot;) to str</span><br><span class="line">&lt;class &#x27;str&#x27;&gt; &lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>使用函数将int转换成str类型不会报错</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name),<span class="built_in">type</span>(age))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我叫&#x27;</span> + name + <span class="string">&#x27;,今年&#x27;</span> + <span class="built_in">str</span>(age) + <span class="string">&#x27;岁&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;str&#x27;&gt; &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">我叫张三,今年20岁</span><br></pre></td></tr></table></figure><table>    <tr align="center">        <th>函数名</th>        <th>作用</th>        <th>注意事项</th>        <th>举例</th>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">str()</td>        <td rowspan="2" bgcolor="white">将其他数据类型转换成字符串</td>        <td rowspan="2" bgcolor="white">也可用引号转换</td>        <td bgcolor="white">str(123)</td>    </tr>    <tr align="center">    <td>'123'</td>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">int()</td>        <td rowspan="2" bgcolor="white">将其他数据类型转换成整数</td>        <td bgcolor="white">文字类和小数类字符串，无法转化成整数</td>        <td bgcolor="white">int('123')</td>    </tr>    <tr align="center">    <td bgcolor="white">浮点数转化成整数：抹零取整</td>    <td>int(9.8)</td>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">float()</td>        <td rowspan="2" bgcolor="white">将其他数据类型转换成浮点数</td>        <td bgcolor="white">文字类无法转成整数</td>        <td bgcolor="white">float(‘9.9’)</td>    </tr>    <tr align="center">    <td>整数转成浮点数，末尾为.0</td>    <td>float(9)</td>    </tr></table><h2 id="进阶学习">进阶学习</h2><p><strong>结合%s%d打印变量，%s代表字符串，%d代表数字</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这是%d&quot;</span>%a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这是%s&quot;</span>%b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%d和%s&quot;</span>%(a,b))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是123</span><br><span class="line">这是abc</span><br><span class="line">123和abc</span><br></pre></td></tr></table></figure><p><strong>结合下标打印字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;beijing&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:<span class="number">3</span>])     <span class="comment">#[起始位置:结束为止:步进值]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:<span class="built_in">len</span>(<span class="built_in">str</span>):<span class="number">2</span>])<span class="comment">#len()表示字符串的长度</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beijing</span><br><span class="line">bei</span><br><span class="line">beijing</span><br><span class="line">beiji</span><br><span class="line">biig</span><br></pre></td></tr></table></figure><p><strong>拼接字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;beijing&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:])      <span class="comment">#beijing</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[:<span class="number">5</span>])      <span class="comment">#beiji</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&quot;,你好&quot;</span>)  <span class="comment">#beijing,你好</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">3</span>)       <span class="comment">#beijingbeijingbeijing</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beijing</span><br><span class="line">beiji</span><br><span class="line">beijing,你好</span><br><span class="line">beijingbeijingbeijing</span><br></pre></td></tr></table></figure><h1 id="三、运算符">三、运算符</h1><h2 id="input-函数的使用">input()函数的使用</h2><p><strong>接收来自用户的输入，输入的值类型为str，也可以使用=对输入的值进行存储</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">present = <span class="built_in">input</span>(<span class="string">&#x27;想要什么礼物呢？&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(present)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">想要什么礼物呢？钱</span><br><span class="line">钱</span><br></pre></td></tr></table></figure><h2 id="常用运算符">常用运算符</h2><h3 id="1-算术运算符">1.算术运算符</h3><table><thead><tr><th style="text-align:center">算术运算符</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">标准算术运算符</td><td style="text-align:center">加（+）、减（-）、乘（*）、除（/）、整除（//）</td></tr><tr><td style="text-align:center">取余运算符</td><td style="text-align:center">%</td></tr><tr><td style="text-align:center">幂运算符</td><td style="text-align:center">**</td></tr></tbody></table><table>    <tr align="center">        <th>运算符</th>        <th>表示</th>        <th>例子</th>        <th>结果</th>    </tr>    <tr align="center">        <td bgcolor="white">+</td>        <td bgcolor="white">加</td>        <td bgcolor="white">1+1</td>        <td bgcolor="white">2</td>    </tr>    <tr align="center">        <td bgcolor="white">-</td>        <td bgcolor="white">减</td>        <td bgcolor="white">1-1</td>        <td bgcolor="white">0</td>    </tr>    <tr align="center">        <td bgcolor="white">*</td>        <td bgcolor="white">乘</td>        <td bgcolor="white">2*4</td>        <td bgcolor="white">8</td>    </tr>    <tr align="center">        <td bgcolor="white">/</td>        <td bgcolor="white">除</td>        <td bgcolor="white">1/2</td>        <td bgcolor="white">0.5</td>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">%</td>        <td bgcolor="white">取余（一正一负要公式）</td>        <td bgcolor="white">9%4</td>        <td bgcolor="white">1</td>    </tr>    <tr align="center">    <td>余数=被除数-除数*商</td>    <td>9%-4<br>9-(-4)*(-3)</td>    <td>-3</td>    </tr>    <tr align="center">        <td bgcolor="white">**</td>        <td bgcolor="white">幂运算</td>        <td bgcolor="white">2**3</td>        <td bgcolor="white">8</td>    </tr>    <tr align="center">        <td rowspan="3" bgcolor="white">//</td>        <td rowspan="3" bgcolor="white">整数（一正一负向下取整）</td>        <td bgcolor="white">11//2</td>        <td bgcolor="white">5</td>    </tr>    <tr align="center">    <td bgcolor="white">9//-4</td>    <td bgcolor="white">-3</td>    </tr>    <tr align="center">    <td bgcolor="white">-9//4</td>    <td bgcolor="white">-3</td>    </tr></table><h3 id="2-赋值运算符">2.赋值运算符</h3><p><strong>赋值运算符的执行顺序为从右向左，支持链式赋值（a=b=c=20）、参数赋值（+=，-=，*=，/=，//=，%=），以及系列解包赋值（a,b,c=20,30,40）</strong></p><h3 id="3-比较运算符">3.比较运算符</h3><p><strong>比较运算符有大于（&gt;）、小于（&lt;）、大于或等于（&gt;=）、小于或等于（&lt;=）、不等于（!=）以及对象value的比较（==），还有is和is not这种比较对象id的比较运算符</strong></p><h3 id="4-布尔运算符">4.布尔运算符</h3><table>    <tr>        <th>运算符</th>        <th colspan="2">运算数</th>        <th>运算结果</th>        <th>备注</th>    </tr>    <tr align="center">        <td rowspan="4" bgcolor="white">and</td>        <td bgcolor="white">True</td>        <td bgcolor="white">True</td>        <td bgcolor="white">True</td>        <td rowspan="4" bgcolor="white">当两个运算数都为True时，运算结果才为True</td>    </tr>    <tr align="center">    <td bgcolor="white">True</td>    <td bgcolor="white">False</td>    <td rowspan="3" bgcolor="white">False</td>    </tr>     <tr align="center">    <td bgcolor="white">False</td>    <td bgcolor="white">True</td>    </tr>    <tr align="center">    <td bgcolor="white">False</td>    <td bgcolor="white">False</td>    </tr>    <tr align="center">        <td rowspan="4" bgcolor="white">or</td>        <td bgcolor="white">True</td>        <td bgcolor="white">True</td>        <td rowspan="3" bgcolor="white">True</td>        <td rowspan="4" bgcolor="white">只要有一个运算数为True，运算结果就为True</td>    </tr>    <tr align="center">    <td bgcolor="white">True</td>    <td bgcolor="white">False</td>    </tr>    <tr align="center">    <td bgcolor="white">False</td>    <td bgcolor="white">True</td>    </tr>    <tr align="center">    <td bgcolor="white">False</td>    <td bgcolor="white">False</td>    <td bgcolor="white">False</td>    </tr>    <tr align="center">        <td rowspan="2" bgcolor="white">not</td>        <td colspan="2" bgcolor="white">True</td>        <td bgcolor="white">False</td>        <td bgcolor="white">如果运算数为True，运算结果为False</td>    </tr>    <tr align="center">    <td colspan="2" bgcolor="white">False</td>    <td bgcolor="white">True</td>    <td bgcolor="white">如果运算数为False，运算结果为True</td>    </tr>    <tr align="center">    <td rowspan="2" bgcolor="white">in</td>    <td colspan="2" bgcolor="white">'e' in 'hello'</td>    <td bgcolor="white">True</td>    <td bgcolor="white">如果字符串中包含指定字符，运算结果为True</td>    </tr>    <tr align="center">    <td colspan="2" bgcolor="white">'i' in 'hello'</td>    <td bgcolor="white">False</td>    <td bgcolor="white">如果字符串中不包含指定字符，运算结果为False</td>    </tr>    <tr align="center">    <td rowspan="2" bgcolor="white">not in</td>    <td colspan="2" bgcolor="white">'e' not in 'hello'</td>    <td bgcolor="white">False</td>    <td bgcolor="white">如果字符串中包含指定字符，运算结果为False</td>    </tr>    <tr align="center">    <td colspan="2" bgcolor="white">'i' in 'hello'</td>    <td bgcolor="white">True</td>    <td bgcolor="white">如果字符串中不包含指定字符，运算结果为True</td>    </tr></table><h3 id="5-位运算符">5.位运算符</h3><table><tr><th>运算符</th>        <th>备注</th></tr><tr align="center"><td>位与&</td>        <td>对应数位都是1，结果数位才是1，否则为0</td></tr><tr align="center"><td>位或 |</td>        <td>对应数位都是0，结果数位才是0，否则为1</td></tr><tr align="center"><td>左移位运算符 <<</td>        <td>高位溢出舍弃，低位补0</td></tr><tr align="center"><td>右移位运算符 >></td>        <td>低位溢出舍弃，高位补0</td></tr></table><h2 id="运算符的优先级">运算符的优先级</h2><p><strong>括号()&gt;算术运算符&gt;位运算符&gt;比较运算符&gt;布尔运算符&gt;赋值运算符</strong></p><h1 id="四、if判断以及for、while循环">四、if判断以及for、while循环</h1><h2 id="if条件判断">if条件判断</h2><p><strong>判断符合条件既执行语句：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;符合&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;不符合&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">符合</span><br></pre></td></tr></table></figure><h3 id="1-案例">1.案例</h3><p><strong>结合input()函数实现查询成绩系统：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的成绩：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span> <span class="keyword">and</span> score &lt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为B&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span> <span class="keyword">and</span> score &lt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为C&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span> <span class="keyword">and</span> score &lt;= <span class="number">70</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为D&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;本次考试，等级为E&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入你的成绩：89</span><br><span class="line">本次考试，等级为B</span><br></pre></td></tr></table></figure><h3 id="2-pass语句">2.pass语句</h3><p><strong>语句什么都不做，只是一个占位符，用在语法上需要语句的地方（一般在还没想好代码怎么写，先搭建语法结构的时候使用），可以和if语句的条件执行体、for-in语句的循环体以及定义函数时的函数体一起使用</strong></p><h3 id="3-range函数的使用">3.range函数的使用</h3><p><strong>range()函数用于生成一个整数序列，返回值是一个迭代器对象。</strong><br><strong>创建range对象的三种方式：</strong></p><table><tr><td>range(stop)</td>        <td>创建一个[0,stop)之间的整数序列，步长为1</td></tr><tr><td>range(start,stop)</td>        <td>创建一个[start,stop)之间的整数序列，步长为1</td></tr><tr><td>range(start,stop,step)</td>        <td>创建一个[start,stop)之间的整数序列，步长为step</td></tr></table><p><strong>优点：不管range对象表示的整数序列有多长，所有range对象占用的内存空间都是相同的，因为仅仅需要存储start，stop和step，只有当用到range对象时，才会去计算序列中的相关元素</strong></p><h2 id="for循环">for循环</h2><p><strong>循环5次：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>以3递增打印从0到10：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p><strong>负数同样也可以递增：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>,-<span class="number">100</span>,-<span class="number">30</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-10</span><br><span class="line">-40</span><br><span class="line">-70</span><br></pre></td></tr></table></figure><p><strong>也可以循环打印字符串：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&quot;beijing&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(x,end=<span class="string">&quot;\t&quot;</span>)<span class="comment">#end表示以什么为结尾，默认为\n</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beijing</span><br></pre></td></tr></table></figure><h2 id="while循环">while循环</h2><p><strong>循环5次：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前是第%d次执行循环&quot;</span>%(i+<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i=%d&quot;</span>%i)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当前是第1次执行循环</span><br><span class="line">i=0</span><br><span class="line">当前是第2次执行循环</span><br><span class="line">i=1</span><br><span class="line">当前是第3次执行循环</span><br><span class="line">i=2</span><br><span class="line">当前是第4次执行循环</span><br><span class="line">i=3</span><br><span class="line">当前是第5次执行循环</span><br><span class="line">i=4</span><br></pre></td></tr></table></figure><h3 id="1-案例-2">1.案例</h3><p><strong>1-100求和：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">sum</span> += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1-100求和结果:%d&quot;</span>%<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-100求和结果:5050</span><br></pre></td></tr></table></figure><h3 id="2-while和else结合使用">2.while和else结合使用</h3><p><strong>while也可以和else结合使用：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span> :</span><br><span class="line">    <span class="built_in">print</span>(count,<span class="string">&quot;小于5&quot;</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(count,<span class="string">&quot;大于或等于5&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 小于5</span><br><span class="line">1 小于5</span><br><span class="line">2 小于5</span><br><span class="line">3 小于5</span><br><span class="line">4 小于5</span><br><span class="line">5 大于或等于5</span><br></pre></td></tr></table></figure><h2 id="break和continue">break和continue</h2><h3 id="1-break">1.break</h3><p><strong>使用break结束此次循环：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span> :</span><br><span class="line">    i = i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> :</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span>*<span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">------------------------------</span><br><span class="line">1</span><br><span class="line">------------------------------</span><br><span class="line">2</span><br><span class="line">------------------------------</span><br><span class="line">3</span><br><span class="line">------------------------------</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="2-continue">2.continue</h3><p><strong>使用continue跳过当前循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span> :</span><br><span class="line">    i = i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">------------------------------</span><br><span class="line">1</span><br><span class="line">------------------------------</span><br><span class="line">2</span><br><span class="line">------------------------------</span><br><span class="line">3</span><br><span class="line">------------------------------</span><br><span class="line">4</span><br><span class="line">------------------------------</span><br><span class="line">6</span><br><span class="line">------------------------------</span><br><span class="line">7</span><br><span class="line">------------------------------</span><br><span class="line">8</span><br><span class="line">------------------------------</span><br><span class="line">9</span><br><span class="line">------------------------------</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="九九乘法表的实现">九九乘法表的实现</h2><p><strong>经典案例：九九乘法表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span> :</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> x &lt;= j :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d*%d=%d&quot;</span>%(i,x,i*x),end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">2*1=22*2=4</span><br><span class="line">3*1=33*2=63*3=9</span><br><span class="line">4*1=44*2=84*3=124*4=16</span><br><span class="line">5*1=55*2=105*3=155*4=205*5=25</span><br><span class="line">6*1=66*2=126*3=186*4=246*5=306*6=36</span><br><span class="line">7*1=77*2=147*3=217*4=287*5=357*6=427*7=49</span><br><span class="line">8*1=88*2=168*3=248*4=328*5=408*6=488*7=568*8=64</span><br><span class="line">9*1=99*2=189*3=279*4=369*5=459*6=549*7=639*8=729*9=81</span><br></pre></td></tr></table></figure><h1 id="五、列表">五、列表</h1><h2 id="列表的定义">列表的定义</h2><p><strong>列表相当于其他语言中的数组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist = []   <span class="comment">#定义一个空的列表</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namelist = [<span class="string">&quot;李&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;张&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(namelist[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(namelist[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(namelist[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br></pre></td></tr></table></figure><h2 id="列表的创建">列表的创建</h2><p><strong>使用中括号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst=[<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>使用内置函数list()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lst=<span class="built_in">list</span>([<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="列表的特点">列表的特点</h2><ul><li><strong>列表元素按顺序有序排序</strong></li><li><strong>索引映射唯一一个数据</strong></li><li><strong>列表可以存储重复数据</strong></li><li><strong>任意数据类型混存</strong></li><li><strong>根据需要动态分配和回收内存</strong></li></ul><p><strong>存储混合类型：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist = []   <span class="comment">#定义一个空的列表</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testlist = [<span class="number">1</span>,<span class="string">&quot;测试&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(testlist[<span class="number">0</span>]))<span class="comment">#type()能辨别字符串的类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(testlist[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>结合循环打印列表元素：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namelist = [<span class="string">&quot;李&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;张&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> namelist :</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="built_in">len</span>(namelist) :</span><br><span class="line">    <span class="built_in">print</span>(namelist[i])</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br><span class="line">------------------------------</span><br><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br></pre></td></tr></table></figure><p><strong>多维列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#a = [[],[],[]]      #三个元素的空列表，每个元素都是一个空列表</span></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4]]</span><br><span class="line">[1, 2]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="增删改查">增删改查</h2><h3 id="1-增">1.增</h3><p><font color=#999AAA><strong>列表增加元素使用extend或append方法</strong></font><br><strong>extend:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namelist = [<span class="string">&quot;李&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;张&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----增加前数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> namelist :</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line">namelist.append(<span class="built_in">input</span>(<span class="string">&quot;请输入添加的姓：&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----增加后数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> namelist :</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-----增加前数据-----</span><br><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br><span class="line">请输入添加的姓：魏</span><br><span class="line">-----增加后数据-----</span><br><span class="line">李</span><br><span class="line">王</span><br><span class="line">张</span><br><span class="line">魏</span><br></pre></td></tr></table></figure><p><strong>append：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">a.append(b)     <span class="comment">#将列表当作一个元素，加入到另一列表中</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, 4]]</span><br></pre></td></tr></table></figure><h3 id="2-删">2.删</h3><p><font color=#999AAA><strong>删除列表的元素</strong></font><br><strong>del、pop、remove均可：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----删除前数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"><span class="comment">#del a[1]    #删除指定下标的数据</span></span><br><span class="line"><span class="comment">#a.pop()      #弹出末尾最后一个元素</span></span><br><span class="line">a.remove(<span class="number">2</span>)   <span class="comment">#直接删除指定内容的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----删除后数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----删除前数据-----</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">-----删除后数据-----</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="3-改">3.改</h3><p><strong>修改列表元素：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----修改前数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">5</span>    <span class="comment">#修改指定下标的元素内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----修改后数据-----&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----修改前数据-----</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">-----修改后数据-----</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="4-查">4.查</h3><p><font color=#999AAA><strong>查询指定元素：</strong></font><br><strong>in或not in：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你要查找的数字：&quot;</span>)) <span class="keyword">in</span> a :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入你要查找的数字：3</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p><strong>查找指定下标范围的元素，并返回对应元素的下标：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(a.index(<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">#print(a.index(4,1,3))   #找不到会报错     范围区间：左闭右开   [1,3)</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="列表常用方法">列表常用方法</h2><p><strong>统计：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(a.count(<span class="number">2</span>))   <span class="comment">#统计某个元素出现过几次</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>将所有元素反转：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.reverse()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 5, 2, 3, 4, 1]</span><br></pre></td></tr></table></figure><p><strong>升序：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><p><strong>降序：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><h2 id="列表生成式">列表生成式</h2><p><strong>[i*i for i in range(1,10)]</strong><br><font color=red><strong>注意事项</strong></font><strong>：i表示列表元素的表达式（通常包含自定义变量），for-in中的i表示自定义变量，range(1,10)表示可迭代对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst=[i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(lst)</span><br><span class="line">lst2=[i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)]</span><br><span class="line"><span class="built_in">print</span>(lst2)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure><h2 id="案例">案例</h2><p><strong>8个老师随机分到三个学校里：</strong><br><font color=#999AAA><strong>随机数用random.randint()方法生成，需要import random：</strong></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">offices = [[],[],[]]</span><br><span class="line"></span><br><span class="line">names = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;G&quot;</span>,<span class="string">&quot;H&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names :</span><br><span class="line">    index = random.randint(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">    offices[index].append(name)</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> office <span class="keyword">in</span> offices :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;办公室%d的人数为：%d&quot;</span>%(i,<span class="built_in">len</span>(office)))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> office :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span>%name,end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">办公室1的人数为：5</span><br><span class="line">ABDFH</span><br><span class="line">办公室2的人数为：2</span><br><span class="line">EG</span><br><span class="line">办公室3的人数为：1</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p><strong>购物车：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">products = [[<span class="string">&quot;iphone&quot;</span>,<span class="number">6888</span>],[<span class="string">&quot;MacPro&quot;</span>,<span class="number">14800</span>],[<span class="string">&quot;小米6&quot;</span>,<span class="number">2499</span>],[<span class="string">&quot;Coffee&quot;</span>,<span class="number">31</span>],[<span class="string">&quot;Book&quot;</span>,<span class="number">60</span>],[<span class="string">&quot;Nike&quot;</span>,<span class="number">699</span>]]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------\t商品列表\t------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> product <span class="keyword">in</span> products :</span><br><span class="line">    <span class="built_in">print</span>(products.index(product),end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(product[<span class="number">0</span>],end=<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(product[<span class="number">1</span>])</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">cars = []</span><br><span class="line"><span class="keyword">while</span> num != <span class="string">&quot;q&quot;</span> :</span><br><span class="line">    num = <span class="built_in">input</span>(<span class="string">&quot;请输入您要购买商品的编号：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> num == <span class="string">&quot;q&quot;</span> :</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cars.append(products[<span class="built_in">int</span>(num)])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;您购物车的商品有：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> car <span class="keyword">in</span> cars :</span><br><span class="line">    <span class="built_in">print</span>(car)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">------商品列表------</span><br><span class="line">0iphone6888</span><br><span class="line">1MacPro14800</span><br><span class="line">2小米62499</span><br><span class="line">3Coffee31</span><br><span class="line">4Book60</span><br><span class="line">5Nike699</span><br><span class="line">请输入您要购买商品的编号：1</span><br><span class="line">请输入您要购买商品的编号：4</span><br><span class="line">请输入您要购买商品的编号：3</span><br><span class="line">请输入您要购买商品的编号：0</span><br><span class="line">请输入您要购买商品的编号：q</span><br><span class="line">您购物车的商品有：</span><br><span class="line">[&#x27;MacPro&#x27;, 14800]</span><br><span class="line">[&#x27;Book&#x27;, 60]</span><br><span class="line">[&#x27;Coffee&#x27;, 31]</span><br><span class="line">[&#x27;iphone&#x27;, 6888]</span><br></pre></td></tr></table></figure><p><strong>使用enumerate()枚举函数可以同时拿到列表中的下标和元素：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">enumerate</span>(mylist))    <span class="comment">#&lt;enumerate object at 0x000001F711412C00&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(mylist):</span><br><span class="line">    <span class="built_in">print</span>(i,x)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;enumerate object at 0x000001C3B09A8E00&gt;</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br><span class="line">4 e</span><br></pre></td></tr></table></figure><p><strong>可以使用枚举函数优化上面的购物车案例</strong></p><h1 id="六、字典">六、字典</h1><h2 id="字典的定义">字典的定义</h2><p><strong>字典的实现原理与查字典类似，查字典是先根据部首或拼音查找对应的页码，Python中的字典是根据key查找value所在的位置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure><h2 id="字典的创建">字典的创建</h2><p><strong>使用花括号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores=&#123;<span class="string">&#x27;张三&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;李四&#x27;</span>:<span class="number">98</span>,<span class="string">&#x27;王五&#x27;</span>:<span class="number">45</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>使用内置函数dict():</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>(name=<span class="string">&#x27;张三&#x27;</span>,age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="字典的特点">字典的特点</h2><ul><li><strong>字典中的所有元素都是一个key-value对，key不允许重复，value可以重复</strong></li><li><strong>字典中的元素是无序的</strong></li><li><strong>字典中的key必须是不可变对象</strong></li><li><strong>字典也可以根据需要动态地伸缩</strong></li><li><strong>字典会浪费较大的内存，是一种使用空间换时间的数据结构</strong></li></ul><h2 id="增删改查-2">增删改查</h2><h3 id="1-增-2">1.增</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">info[<span class="string">&quot;id&quot;</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(info[<span class="string">&quot;id&quot;</span>])   <span class="comment">#1</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="2-删-2">2.删</h3><p><strong>del：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除前：%s&quot;</span>%info[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="keyword">del</span> info[<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除后：%s&quot;</span>%info[<span class="string">&quot;name&quot;</span>])    <span class="comment">#删除了指定键值对后，再次访问会报错</span></span><br><span class="line"><span class="keyword">del</span> info</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除后：%s&quot;</span>%info)    <span class="comment">#删除字典后再访问，报错</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyError: &#x27;name&#x27;</span><br><span class="line">NameError: name &#x27;info&#x27; is not defined</span><br></pre></td></tr></table></figure><p><strong>clear：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;清空前：%s&quot;</span>%info)    <span class="comment">#清空前：&#123;&#x27;name&#x27;: &#x27;吴彦祖&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br><span class="line"></span><br><span class="line">info.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;清空后：%s&quot;</span>%info)    <span class="comment">#清空后：&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">清空前：&#123;&#x27;name&#x27;: &#x27;吴彦祖&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">清空后：&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-改-2">3.改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line">info[<span class="string">&quot;age&quot;</span>] = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(info[<span class="string">&quot;age&quot;</span>])  <span class="comment">#20</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="4-查-2">4.查</h3><p><strong>通过get()方法或直接[中括号]获取value</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(info[<span class="string">&#x27;id&#x27;</span>])<span class="comment">#获取key为id的value</span></span><br><span class="line"><span class="built_in">print</span>(info.get(<span class="string">&quot;name&quot;</span>))<span class="comment">#获取key为name的value</span></span><br><span class="line"><span class="built_in">print</span>(info.keys())  <span class="comment">#得到所有键（列表）</span></span><br><span class="line"><span class="built_in">print</span>(info.values())    <span class="comment">#得到所有的值（列表）</span></span><br><span class="line"><span class="built_in">print</span>(info.items())     <span class="comment">#得到所有的项（列表），每个键值对是一个元组</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">吴彦祖</span><br><span class="line">dict_keys([&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;])</span><br><span class="line">dict_values([&#x27;1&#x27;, &#x27;吴彦祖&#x27;, 18])</span><br><span class="line">dict_items([(&#x27;id&#x27;, &#x27;1&#x27;), (&#x27;name&#x27;, &#x27;吴彦祖&#x27;), (&#x27;age&#x27;, 18)])</span><br></pre></td></tr></table></figure><p><strong>遍历所有的键</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> info.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">name</span><br><span class="line">age</span><br></pre></td></tr></table></figure><p><strong>遍历所有的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> info.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">吴彦祖</span><br><span class="line">18</span><br></pre></td></tr></table></figure><p><strong>遍历所有的键值对</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> info.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;key=%s,value=%s&quot;</span>%(key,value))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key=id,value=1</span><br><span class="line">key=name,value=吴彦祖</span><br><span class="line">key=age,value=18</span><br></pre></td></tr></table></figure><p><strong>访问字典不存在的key时：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;吴彦祖&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="comment">#print(info[&quot;gender&quot;])   #直接访问   报错</span></span><br><span class="line"><span class="built_in">print</span>(info.get(<span class="string">&quot;age&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(info.get(<span class="string">&quot;gender&quot;</span>))   <span class="comment">#使用get方法没有找到对应的键，默认返回None</span></span><br><span class="line"><span class="built_in">print</span>(info.get(<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;m&quot;</span>))   <span class="comment">#m   没找到的时候，可以设定默认值</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18</span><br><span class="line">None</span><br><span class="line">m</span><br></pre></td></tr></table></figure><h2 id="字典生成式">字典生成式</h2><p><strong>内置函数zip()，用于将可迭代的对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;Fruits&#x27;</span>,<span class="string">&#x27;Books&#x27;</span>,<span class="string">&#x27;Others&#x27;</span>]</span><br><span class="line">b=[<span class="number">96</span>,<span class="number">78</span>,<span class="number">85</span>]</span><br><span class="line">lst=<span class="built_in">zip</span>(a,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(lst))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&#x27;Fruits&#x27;, 96), (&#x27;Books&#x27;, 78), (&#x27;Others&#x27;, 85)]</span><br></pre></td></tr></table></figure><h1 id="七、元组">七、元组</h1><h2 id="元组的定义">元组的定义</h2><p><strong>Python内置的数据结构之一，是一个不可变序列</strong></p><ul><li><strong>不可变序列：字符串、元组</strong><ul><li><strong>不可变序列：没有增、删、改的操作</strong></li></ul></li><li><strong>可变序列：列表、字典</strong><ul><li><strong>可变序列：可以对序列执行增、删、改操作，对象地址不发生改变</strong></li></ul></li></ul><h2 id="元组的创建">元组的创建</h2><p><strong>直接使用小括号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1=()   <span class="comment">#创建空的元组</span></span><br><span class="line">t2=(<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>使用内置函数tuple()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup1=<span class="built_in">tuple</span>(<span class="string">&#x27;Python&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>只包含一个元素的元组需要使用逗号和小括号：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1=(<span class="number">10</span>,)</span><br></pre></td></tr></table></figure><h2 id="元组为不可变序列的原因">元组为不可变序列的原因</h2><p><strong>在多任务环境下，同时操作对象时不需要加锁</strong><br><font color=red><strong>注意事项：</strong></font><br><strong>如果元组中对象本身是不可变对象，则不能再引用其他对象</strong><br><strong>如果元组中的对象是可变对象，则可变对象的引用不允许改变，但数据可以改变</strong></p><h2 id="增删改查-3">增删改查</h2><h3 id="1-增（连接）">1.增（连接）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>)</span><br><span class="line">tup2 = (<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>)</span><br><span class="line"></span><br><span class="line">tup = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(12, 34, 56, &#x27;abc&#x27;, &#x27;def&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-删-3">2.删</h3><p><strong>del，删除会删掉整个元组：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1)     <span class="comment">#(12, 34, 56)</span></span><br><span class="line"><span class="keyword">del</span> tup1        <span class="comment">#删除了整个元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除后：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1)     <span class="comment">#报错</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: name &#x27;tup1&#x27; is not defined</span><br></pre></td></tr></table></figure><h3 id="3-改（元组不允许修改）">3.改（元组不允许修改）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>)</span><br><span class="line">tup1[<span class="number">0</span>] = <span class="number">10</span>    <span class="comment">#报错，不允许修改</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure><h3 id="4-查-3">4.查</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="number">2000</span>,<span class="number">2001</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(tup1[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(tup1[<span class="number">0</span>:<span class="number">2</span>])    <span class="comment">#(&#x27;abc&#x27;, &#x27;def&#x27;)     左闭右开</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">2001</span><br><span class="line">def</span><br><span class="line">(&#x27;abc&#x27;, &#x27;def&#x27;)</span><br></pre></td></tr></table></figure><p><font color=red><strong>注：元组没有生成式</strong></font></p><h1 id="八、集合">八、集合</h1><h2 id="集合的定义">集合的定义</h2><p><strong>与列表、字典一样都属于可变类型的序列，集合是没有value的字典</strong></p><h2 id="集合的创建">集合的创建</h2><p><strong>直接使用大括号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="string">&#x27;python&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>使用内置函数set()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(<span class="string">&#x27;python&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>())</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;0, 1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">&#123;&#x27;o&#x27;, &#x27;y&#x27;, &#x27;p&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;t&#x27;&#125;</span><br><span class="line">&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">set()</span><br></pre></td></tr></table></figure><h2 id="集合的相关操作">集合的相关操作</h2><h3 id="1-判断操作">1.判断操作</h3><p><strong>in</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">in</span> s)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">60</span> <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>not in</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> s)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">60</span> <span class="keyword">not</span> <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="2-新增操作">2.新增操作</h3><p><strong>通过add()方法，一次添加一个元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.add&#123;<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;50, 20, 40, 10, 60, 30&#125;</span><br></pre></td></tr></table></figure><p><strong>通过update()方法，至少添加一个元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.update(&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;50, 20, 100, 40, 10, 300, 30, 200&#125;</span><br></pre></td></tr></table></figure><h3 id="3-删除操作">3.删除操作</h3><p><strong>通过remove()方法，一次删除一个指定元素，如果指定的元素不存在就抛出KeyError</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.remove(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 133, in &lt;module&gt;</span><br><span class="line">    s.remove(100)</span><br><span class="line">KeyError: 100</span><br></pre></td></tr></table></figure><p><strong>通过discard()方法，一次删除一个指定元素，如果指定的元素不存在不抛异常</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.discard(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;50, 20, 40, 10, 30&#125;</span><br></pre></td></tr></table></figure><p><strong>通过pop()方法，一次只删除一个任意元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.pop()</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;20, 40, 10, 30&#125;</span><br></pre></td></tr></table></figure><p><strong>通过clear()方法，清空集合</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s.clear()</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set()</span><br></pre></td></tr></table></figure><h2 id="集合间的关系">集合间的关系</h2><p><strong>可以用运算符==或!=来判断两个集合是否相等</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">30</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1==s2)</span><br><span class="line"><span class="built_in">print</span>(s1!=s2)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>通过issubset方法判断一个集合是否是另一个集合的子集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>&#125;</span><br><span class="line">s3=&#123;<span class="number">10</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2.issubset(s1))</span><br><span class="line"><span class="built_in">print</span>(s3.issubset(s1))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>通过issuperset方法判断一个集合是否是另一个集合的超集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>&#125;</span><br><span class="line">s3=&#123;<span class="number">10</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.issuperset(s2))</span><br><span class="line"><span class="built_in">print</span>(s1.issuperset(s3))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>通过isdisjoint判断两个集合是否有交集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line">s3=&#123;<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.isdisjoint(s2))<span class="comment">#有交集返回False</span></span><br><span class="line"><span class="built_in">print</span>(s1.isdisjoint(s3))<span class="comment">#无交集返回True</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="集合的数学操作">集合的数学操作</h2><h3 id="1-交集">1.交集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.intersection(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2)<span class="comment">#intersection()与 &amp; 等价，交集操作</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;20, 30&#125;</span><br><span class="line">&#123;20, 30&#125;</span><br></pre></td></tr></table></figure><h3 id="2-并集">2.并集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.union(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 | s2)<span class="comment">#union与 | 等价，并集操作</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;40, 10, 50, 20, 60, 30&#125;</span><br><span class="line">&#123;40, 10, 50, 20, 60, 30&#125;</span><br></pre></td></tr></table></figure><h3 id="3-差集">3.差集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.difference(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 - s2)<span class="comment">#difference与 - 等价，差集操作</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;10&#125;</span><br><span class="line">&#123;10&#125;</span><br></pre></td></tr></table></figure><h3 id="4-对称差集">4.对称差集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_difference(s2))</span><br><span class="line"><span class="built_in">print</span>(s1^s2)<span class="comment">#symmetric_difference与 ^ 等价，对称差集操作</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;50, 40, 10, 60&#125;</span><br><span class="line">&#123;50, 40, 10, 60&#125;</span><br></pre></td></tr></table></figure><h2 id="集合生成式">集合生成式</h2><p><strong>{i*i for i in range(num)}</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s=&#123;i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0, 1, 4, 9, 16, 25&#125;</span><br></pre></td></tr></table></figure><h1 id="九、列表、字典、元组、集合总结">九、列表、字典、元组、集合总结</h1><table><tr><th>数据结构</th><th>是否可变</th><th>是否重复</th><th>是否有序</th><th>定义符号</th></tr><tr><td bgcolor="white" align="center">列表（list）</td><td bgcolor="white" align="center">可变</td><td bgcolor="white" align="center">可重复</td><td bgcolor="white" align="center">有序</td><td bgcolor="white" align="center">[]</td></tr><tr><td align="center">元组（tuple）</td><td align="center">不可变</td><td align="center">可重复</td><td align="center">有序</td><td align="center">()</td></tr><tr><td rowspan="2" bgcolor="white" align="center">字典（dict）</td><td rowspan="2" bgcolor="white" align="center">可变</td><td bgcolor="white" align="center">key不可重复</td><td rowspan="2" bgcolor="white" align="center">无序</td><td rowspan="2" bgcolor="white" align="center">{key:value}</td></tr><tr><td align="center">value可重复</td></tr><tr><td bgcolor="white" align="center">集合（set）</td><td bgcolor="white" align="center">可变</td><td bgcolor="white" align="center">不可重复</td><td bgcolor="white" align="center">无序</td><td bgcolor="white" align="center">{}</td></tr></table><h1 id="十、字符串（进阶）">十、字符串（进阶）</h1><p><strong>Python中字符串是基本数据类型，是一个不可变的字符序列</strong></p><h2 id="字符串驻留机制">字符串驻留机制</h2><p><strong>仅保留一份相同且不可变字符串的方法，不同的值被存放在字符串的驻留池中，Python的驻留机制对相同的字符串只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;python&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;python&#x27;</span></span><br><span class="line">c=<span class="string">&#x27;python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a,<span class="built_in">id</span>(a))</span><br><span class="line"><span class="built_in">print</span>(b,<span class="built_in">id</span>(b))</span><br><span class="line"><span class="built_in">print</span>(c,<span class="built_in">id</span>(c))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python 2785734751984</span><br><span class="line">python 2785734751984</span><br><span class="line">python 2785734751984</span><br></pre></td></tr></table></figure><h2 id="驻留模式的几种情况（交互模式）">驻留模式的几种情况（交互模式）</h2><ul><li><strong>字符串的长度为0或1时</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0</span></span><br><span class="line">b=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line">a1=<span class="string">&#x27;%&#x27;</span></span><br><span class="line">b1=<span class="string">&#x27;%&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> b1)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure><ul><li><strong>符合标识符的字符串</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;abc%&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;abc%&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a==b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line">a1=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">b1=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> b1)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><ul><li><strong>字符串只在编译时进行驻留，而非运行时</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;ab&#x27;</span> + <span class="string">&#x27;c&#x27;</span></span><br><span class="line">c=<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> c)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><ul><li><strong>[-5,256]之间的整数数字</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=-<span class="number">5</span></span><br><span class="line">b=-<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line">a1 = -<span class="number">6</span></span><br><span class="line">b1 = -<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(a1 <span class="keyword">is</span> b1)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>可以通过sys.intern方法强制驻留</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = -<span class="number">6</span></span><br><span class="line">b = -<span class="number">6</span></span><br><span class="line">a = sys.intern(b)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure><p><font color=red><strong>注：</strong></font><strong>PyCharm对字符串进行了优化处理，所以上面的效果在PyCharm中无法演示</strong></p><h2 id="驻留机制的优缺点">驻留机制的优缺点</h2><ul><li><strong>当需要值相同的字符串时，可以直接从字符串池里拿来使用，避免频繁的创建和销毁，提升效率和节约内存，因此拼接字符串和修改字符串是会比较影响性能的</strong></li><li><strong>在需要进行字符串拼接时建议使用str类型的join方法，而非“+”，因为json()方法是先计算出所有字符中的长度，然后再拷贝，只new一次对象，效率要比“+”效率高</strong></li></ul><h2 id="字符串的常用操作">字符串的常用操作</h2><h3 id="1-查询操作">1.查询操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="4" bgcolor="white">查询方法</td><td bgcolor="white">index()</td><td bgcolor="white" align="left">查找子串substr第一次出现的位置，如果查找的子串不存在时，则抛出ValueError</td></tr><tr align="center"><td>rindex()</td><td align="left">查找子串substr最后一次出现的位置，如果查找的子串不存在时，则抛出ValueError</td></tr><tr align="center"><td bgcolor="white">find()</td><td bgcolor="white" align="left">查找子串substr第一次出现的位置，如果查找的子串不存在时，则返回-1</td></tr><tr align="center"><td>rfind()</td><td align="left">查找子串substr最后一次出现的位置，如果查找的子串不存在时，则返回-1</td></tr></table><h3 id="2-大小写转换">2.大小写转换</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="5" bgcolor="white">大小写转换</td><td bgcolor="white">upper()</td><td bgcolor="white" align="left">把字符串中所有字符都转成大写字符</td></tr><tr align="center"><td>lower()</td><td align="left">把字符串中所有字符都转成小写字符</td></tr><tr align="center"><td bgcolor="white">swapcase()</td><td bgcolor="white" align="left">把字符串中所有大写字母转成小写字母，把所有小写字母都转成大写字母</td></tr><tr align="center"><td>capitalize()</td><td align="left">把第一个字符转换为大写，其余字符转换为小写</td></tr><tr align="center"><td bgcolor="white">title()</td><td bgcolor="white" align="left">把每个单词的第一个字符转换为大写，把每个单词的剩余字符转换为小写</td></tr></table><h3 id="3-内容对齐操作">3.内容对齐操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="4" bgcolor="white">字符串对齐</td><td bgcolor="white">center()</td><td bgcolor="white" align="left">居中对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串</td></tr><tr align="center"><td>ljust()</td><td align="left">左对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串</td></tr><tr align="center"><td bgcolor="white">rjust()</td><td bgcolor="white" align="left">右对齐，第1个参数指定宽度，第2个参数指定填充符，第2个参数是可选的，默认是空格，如果设置宽度小于实际宽度则返回原字符串</td></tr><tr align="center"><td>zfill()</td><td align="left">右对齐，左边用0填充，该方法只接收一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串的长度，返回字符串本身</td></tr></table><h3 id="4-劈分操作">4.劈分操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="6" bgcolor="white">字符串的劈分</td><td rowspan="3" bgcolor="white">split()</td><td bgcolor="white" align="left">从字符串的左边开始劈分，默认的劈分字符是空格字符串，返回的值都是一个列表</td></tr><tr align="center"><td align="left">以通过参数sep指定劈分字符串的劈分符</td></tr><tr align="center"><td bgcolor="white" align="left">通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分之后，剩余的子串会单独做为一部分</td></tr><tr align="center"><td rowspan="3">rsplit()</td><td align="left">从字符串的右边开始劈分，默认的劈分字符是空格字符串，返回的值都是一个列表</td></tr><tr align="center"><td bgcolor="white" align="left">以通过参数sep指定劈分字符串的劈分符</td></tr><tr align="center"><td align="left">通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分之后，剩余的子串会单独做为一部分</td></tr></table><h3 id="5-判断字符串操作">5.判断字符串操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td rowspan="6" bgcolor="white">判断字符串的方法</td><td bgcolor="white">isidentifier()</td><td bgcolor="white" align="left">判断指定的字符串是不是合法的标识符</td></tr><tr align="center"><td>isspace()</td><td align="left">判断指定的字符串是否全部由空白字符组成（回车、换行、水平制表符）</td></tr><tr align="center"><td bgcolor="white">isalpha()</td><td bgcolor="white" align="left">判断指定的字符串是否全部由字母组成</td></tr><tr align="center"><td>isdecimal()</td><td align="left">判断指定字符串是否全部由十进制的数字组成</td></tr><tr align="center"><td bgcolor="white">isnumeric()</td><td bgcolor="white" align="left">判断指定的字符串是否全部由数字组成</td></tr><tr align="center"><td>isalnum()</td><td align="left">判断指定字符串是否全部由字母和数字组成</td></tr></table><h3 id="6-替换与合并操作">6.替换与合并操作</h3><table><tr><th>功能</th><th>方法名称</th><th>作用</th></tr><tr align="center"><td bgcolor="white">字符串替换</td><td bgcolor="white">replace()</td><td bgcolor="white" align="left">第1个参数指定被替换的子串，第2个参数指定替换子串的字符串，该方法返回替换后得到的字符串，替换前的字符串不发生变化，调用该方法时可以通过第3个参数指定最大替换次数</td></tr><tr align="center"><td>字符串的合并</td><td>join()</td><td align="left">将列表或元组中的字符串合并成一个字符串</td></tr></table><h3 id="7-比较操作">7.比较操作</h3><ul><li><strong>运算符：</strong>&gt;、&gt;=、&lt;、&lt;=、==、!=</li><li><strong>比较规则：</strong> 首先比较两个字符串中的第一个字符串，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较</li><li><strong>比较原理：</strong> 两个字符进行比较时，比较的是其ordinal value（原始值），调用内置函数ord可以得到指定字符的ordinal value。与内置函数ord对应的是内置函数chr，调用内置函数chr时指定的ordinal value可以得到其对应的字符</li></ul><h3 id="8-切片操作">8.切片操作</h3><ul><li><strong>字符串是不可变类型</strong></li><li>不具备增、删、改等操作</li><li>切片操作将产生新的对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;python,hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>:<span class="number">1</span>])   <span class="comment">#从1开始截到5（不包含5），步长为1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::<span class="number">2</span>])     <span class="comment">#默认从0开始，没有写结束，默认到字符串的最后一个元素，步长为2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[::-<span class="number">1</span>])    <span class="comment">#默认从字符串的最后一个元素开始，到字符串的第一个元素结束，因为步长为负数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[-<span class="number">6</span>::<span class="number">1</span>])   <span class="comment">#从索引为-6开始，到字符串的最后一个元素，步长为1</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ytho</span><br><span class="line">pto,el</span><br><span class="line">olleh,nohtyp</span><br><span class="line">,hello</span><br></pre></td></tr></table></figure><h3 id="9-格式化字符串">9.格式化字符串</h3><ul><li><strong>%作占位符</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫：%s，今年66岁了&quot;</span>%name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫：%s，今年%d岁了&quot;</span>%(name,age))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的名字叫：张三，今年66岁了</span><br><span class="line">我的名字叫：张三，今年66岁了</span><br></pre></td></tr></table></figure><ul><li><strong>{}作占位符</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">age = <span class="number">66</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字叫：&#123;0&#125;，今年&#123;1&#125;岁了，&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(name,age))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的名字叫：张三，今年66岁了，张三</span><br></pre></td></tr></table></figure><h3 id="10-字符串的编码与解码">10.字符串的编码与解码</h3><ul><li><strong>编码：</strong> 将字符串转换为二进制数据（bytes）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;海内存知己&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;GBK&#x27;</span>))   <span class="comment">#在GBK这种编码格式中，一个中文占两个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)) <span class="comment">#在UTF-8这种编码格式中，一个中文占三个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;\xba\xa3\xc4\xda\xb4\xe6\xd6\xaa\xbc\xba&#x27;</span><br><span class="line">b&#x27;\xe6\xb5\xb7\xe5\x86\x85\xe5\xad\x98\xe7\x9f\xa5\xe5\xb7\xb1&#x27;</span><br></pre></td></tr></table></figure><ul><li><strong>解码：</strong> 将bytes类型的数据转换成字符串类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;海内存知己&#x27;</span></span><br><span class="line">byte = <span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(byte.decode(encoding=<span class="string">&#x27;GBK&#x27;</span>))</span><br><span class="line"></span><br><span class="line">byte = <span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(byte.decode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">海内存知己</span><br><span class="line">海内存知己</span><br></pre></td></tr></table></figure><h1 id="十一、函数">十一、函数</h1><h2 id="函数的创建和调用">函数的创建和调用</h2><p><strong>函数就是执行特定任务以完成特定功能一段代码</strong></p><ul><li><strong>为什么要使用函数</strong><ul><li>复用代码</li><li>隐藏实现细节</li><li>提高可维护性</li><li>提高可读性便于调试</li></ul></li></ul><p><strong>函数的创建及调用:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数的创建</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------人生苦短-------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#函数的调用</span></span><br><span class="line">printinfo()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-------人生苦短-------</span><br></pre></td></tr></table></figure><h2 id="函数的参数传递">函数的参数传递</h2><ul><li><strong>位置实参</strong><ul><li><strong>根据形参对应的位置进行实参传递</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b</span>):<span class="comment">#a，b称为形式参数，简称形参，形参的位置是在函数的定义处</span></span><br><span class="line">    c=a+b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">result=calc(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">#1,2称为实际参数，简称实参，实参的位置在函数的调用处</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><ul><li><strong>关键字实参</strong><ul><li><strong>根据形参名称进行实参传递</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b</span>):<span class="comment">#a，b称为形式参数，简称形参，形参的位置是在函数的定义处</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    c=a+b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">result=calc(b=<span class="number">1</span>,a=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><ul><li><strong>个数可变的位置形参</strong><ul><li><strong>定义函数时，可能无法事先确定传递的位置实参的个数时，使用可变的位置参数</strong></li><li><strong>使用*定义个数可变的位置形参</strong></li><li><strong>结果为一个元组</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">fun(<span class="number">10</span>)</span><br><span class="line">fun(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(10,)</span><br><span class="line">(10, 20, 30)</span><br></pre></td></tr></table></figure><ul><li><strong>个数可变的关键字形参</strong><ul><li><strong>定义函数时，无法事先确定传递的关键字实参的个数时，使用可变的关键字形参</strong></li><li><strong>使用**定义个数可变的关键字形参</strong></li><li><strong>结果为一个字典</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">**args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">fun(a=<span class="number">10</span>)</span><br><span class="line">fun(a=<span class="number">10</span>,b=<span class="number">20</span>,c=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;a&#x27;: 10&#125;</span><br><span class="line">&#123;&#x27;a&#x27;: 10, &#x27;b&#x27;: 20, &#x27;c&#x27;: 30&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的返回值">函数的返回值</h2><ul><li><strong>如果函数没有返回值，return可以省略不写</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li><strong>函数的返回值如果是一个，只返回一个类型</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fun())</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure><ul><li><strong>函数的返回值如果是多个，返回的结果为元组</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">num</span>):</span><br><span class="line">    odd=[]      <span class="comment">#存奇数</span></span><br><span class="line">    even=[]     <span class="comment">#存偶数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span>:</span><br><span class="line">            odd.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            even.append(i)</span><br><span class="line">    <span class="keyword">return</span> odd,even</span><br><span class="line">lst=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(fun(lst))</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([1, 3, 5, 7, 9], [2, 4, 6, 8, 0])</span><br></pre></td></tr></table></figure><p><strong>函数定义默认值传参</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a,b=<span class="number">10</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a,b)</span><br><span class="line">fun(<span class="number">100</span>)<span class="comment">#只传一个参数，b采用默认值</span></span><br><span class="line">fun(<span class="number">10</span>,<span class="number">20</span>)<span class="comment">#20将替换10</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 10</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure><h2 id="函数的参数总结">函数的参数总结</h2><table><tr><th>序号</th><th>参数的类型</th><th>函数的定义</th><th>函数的调用</th><th>备注</th></tr><tr align="center"><td rowspan="2" bgcolor="white">1</td><td bgcolor="white">位置实参</td><td bgcolor="white"></td><td bgcolor="white">√</td><td bgcolor="white"></td></tr><tr align="center"><td>将序列的每个元素都转换为位置实参</td><td></td><td>√</td><td>使用*</td></tr><tr align="center"><td rowspan="2" bgcolor="white">2</td><td bgcolor="white">关键字实参</td><td bgcolor="white"></td><td bgcolor="white">√</td><td bgcolor="white"></td></tr><tr align="center"><td>将字典中的每个键值对都转换为关键字实参</td><td></td><td>√</td><td>使用**</td></tr><tr align="center"><td bgcolor="white">3</td><td bgcolor="white">默认值形参</td><td bgcolor="white">√</td><td bgcolor="white"></td><td bgcolor="white"></td></tr><tr align="center"><td>4</td><td>关键字形参</td><td>√</td><td></td><td>使用*</td></tr><tr align="center"><td bgcolor="white">5</td><td bgcolor="white">个数可变的位置形参</td><td bgcolor="white">√</td><td bgcolor="white"></td><td bgcolor="white">使用*</td></tr><tr align="center"><td>6</td><td>个数可变的关键字形参</td><td>√</td><td></td><td>使用**</td></tr></table><h2 id="变量的作用域">变量的作用域</h2><ul><li><strong>程序代码能访问该变量的区域</strong></li><li><strong>根据变量的有效范围可分为</strong><ul><li><strong>局部变量</strong><ul><li>在函数内定义并使用的变量，只在函数内部有效，局部变量使用global声明，这个变量就会成全局变量</li></ul></li><li><strong>全局变量</strong><ul><li>函数体外定义的变量，可做用于函数体外</li></ul></li></ul></li></ul><h2 id="递归函数">递归函数</h2><ul><li><strong>递归函数</strong><ul><li>如果在一个函数的函数体颞部调用了该函数本身，这个函数就称为递归函数</li></ul></li><li><strong>递归的组成</strong><ul><li>递归调用与递归终止条件</li></ul></li><li><strong>递归的调用过程</strong><ul><li>每递归调用一次函数，都会在栈内存分配一个栈帧</li><li>每执行完一次函数，都会释放相应的空间</li></ul></li><li><strong>递归的优缺点</strong><ul><li>缺点：占用内存多，效率低下</li><li>优点：思路和代码简单</li></ul></li></ul><h1 id="十二、异常处理">十二、异常处理</h1><h2 id="捕获异常">捕获异常</h2><ul><li><strong>try…except…结构捕获异常</strong><ul><li>Python提供的异常处理机制，可以在异常出现时及时捕获，然后内部“消化”，让程序继续运行</li></ul></li></ul><p><strong>发生异常：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">result=n1/n2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：2</span><br><span class="line">请输入另一个整数：jkl</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 133, in &lt;module&gt;</span><br><span class="line">    n2=int(input(&#x27;请输入另一个整数：&#x27;))</span><br><span class="line">ValueError: invalid literal for int() with base 10: &#x27;jkl&#x27;</span><br></pre></td></tr></table></figure><p><strong>捕获异常：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">    n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">    result=n1/n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：5</span><br><span class="line">请输入另一个整数：dsf</span><br><span class="line">输入错误</span><br></pre></td></tr></table></figure><ul><li><strong>多个except结构</strong><ul><li>捕获异常的顺序按照先子类后父类的顺序</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">    n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">    result=n1/n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">except</span> (ValueError,Exception):<span class="comment">#将可能产生的素有异常类型，都放到下面的小括号里</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：6</span><br><span class="line">请输入另一个整数：rew</span><br><span class="line">输入错误</span><br></pre></td></tr></table></figure><p><strong>打印异常：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">    n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">    result=n1/n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">except</span> (ValueError,Exception) <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：3</span><br><span class="line">请输入另一个整数：bfg</span><br><span class="line">输入错误</span><br><span class="line">invalid literal for int() with base 10: &#x27;bfg&#x27;</span><br></pre></td></tr></table></figure><ul><li><strong>try…except…else结构</strong><ul><li>如果try块中没有抛出异常，则执行else块，如果try中抛出异常，则执行except块</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">   n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">   result=n1/n2</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;产生错误了&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br></pre></td></tr></table></figure><ul><li><strong>try…except…else…finally结构</strong><ul><li>finally块无论是否发生异常都会被执行，能常用来释放try块中申请的资源</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">   n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">   result=n1/n2</span><br><span class="line"><span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;产生错误了&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;程序结束&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>使用Exception捕获异常：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    n1=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line">    n2=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入另一个整数：&#x27;</span>))</span><br><span class="line">    result=n1/n2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果为：&#x27;</span>,result)</span><br><span class="line"><span class="keyword">except</span> Exception:<span class="comment">#Exception可以承接任何异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一个整数：5</span><br><span class="line">请输入另一个整数：dsf</span><br><span class="line">输入错误</span><br></pre></td></tr></table></figure><h2 id="Python中常见的异常类型">Python中常见的异常类型</h2><table><tr><th>序号</th><th>异常类型</th><th>描述</th></tr><tr align="center"><td>1</td><td>ZeroDivisionError</td><td>除（或取模）零（所有数据类型）</td></tr><tr align="center"><td>2</td><td>IndexError</td><td>序列中没有此索引</td></tr><tr align="center"><td>3</td><td>KeyError</td><td>映射中没有这个键</td></tr><tr align="center"><td>4</td><td>NameError</td><td>未声明/初始化对象（没有属性）</td></tr><tr align="center"><td>5</td><td>SyntaxError</td><td>Python语法错误</td></tr><tr align="center"><td>6</td><td>ValueError</td><td>传入无效的参数</td></tr></table><h2 id="traceback模块">traceback模块</h2><ul><li><strong>使用traceback模块打印异常信息</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------&#x27;</span>)</span><br><span class="line">    num = <span class="number">10</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 135, in &lt;module&gt;</span><br><span class="line">    num = 10/0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><h1 id="十三、类、对象、方法">十三、类、对象、方法</h1><h2 id="编程的两大思想">编程的两大思想</h2><table><tr><th></th><th>面向过程</th><th>面向对象</th></tr><tr align="center"><td>区别</td><td align='left'>事物比较简单，可以用线性的思维去解决</td><td align='left'>事物比较复杂，使用简单的线性思维无法解决</td></tr><tr align="center"><td>共同点</td><td colspan="2" align='left'>面向过程和面向对象都是解决实际问题的一种思维方式</td></tr><tr align="center"><td></td><td colspan="2" align='left'>二者相辅相成，并不是对立<br>解决复杂问题，通过面向对象方式便于我们从宏观上把握事物之间复杂的关系、方便我们分析整个系统；具体到微观操作，仍然使用面向过程方式来处理</td></tr></table><h2 id="类与对象">类与对象</h2><ul><li><strong>类</strong><ul><li>类是多个类似事物组成的群体的统称。能够帮助我们快速理解和判断事物的性质</li></ul></li><li><strong>对象</strong><ul><li>100、99、520都是int类之下包含的相似的不同个例，这个个例专业术语称为实例或对象</li></ul></li></ul><h3 id="1-类的创建">1.类的创建</h3><ul><li><strong>类的组成</strong><ul><li>类属性：类中方法外的变量称为类属性，被该类的所有对象所共享</li><li>实例方法</li><li>静态方法：使用@staticmethod修饰的方法，可以通过类名直接访问</li><li>类方法：使用@classmethod修饰的方法，可以通过类名直接访问</li></ul></li><li><strong>类的语法</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):  <span class="comment">#name，age为实例属性</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    native_place = <span class="string">&quot;吉林&quot;</span>     <span class="comment">#类属性</span></span><br><span class="line">    <span class="comment">#实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我的名字叫：&#x27;</span>,self.name,<span class="string">&#x27;年龄是：&#x27;</span>,self.age)</span><br><span class="line">    <span class="comment">#类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cm</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类方法&#x27;</span>)</span><br><span class="line">    <span class="comment">#静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-对象的创建">2.对象的创建</h3><ul><li><strong>对象的创建又称为类的实例化，有了实例就可以调用类中的内容</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stu1 = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">26</span>)</span><br><span class="line">stu1.info()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的名字叫： 张三 年龄是： 26</span><br><span class="line">张三</span><br></pre></td></tr></table></figure><h3 id="3-类属性、类方法、静态方法的使用">3.类属性、类方法、静态方法的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Student.native_place)</span><br><span class="line">Student.native_place = <span class="string">&#x27;北京&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Student.native_place)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">吉林</span><br><span class="line">北京</span><br></pre></td></tr></table></figure><h3 id="4-动态绑定属性和方法">4.动态绑定属性和方法</h3><ul><li><strong>Python是动态语言，在创建对象之后，可以动态地绑定属性和方法</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是一个函数&#x27;</span>)</span><br><span class="line">stu1 = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">24</span>)</span><br><span class="line">stu1.gender=<span class="string">&#x27;男&#x27;</span>     <span class="comment">#动态绑定属性</span></span><br><span class="line"><span class="built_in">print</span>(stu1.name,stu1.age,stu1.gender)</span><br><span class="line">stu1.show = show()   <span class="comment">#动态绑定方法</span></span><br><span class="line">stu1.show</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">张三 24 男</span><br><span class="line">我是一个函数</span><br></pre></td></tr></table></figure><h2 id="面向对象的三大特征">面向对象的三大特征</h2><h3 id="1-封装">1.封装</h3><ul><li><strong>封装：</strong> 提高程序的安全性<ul><li>将数据（属性）和行为（方法）包装到类对象中。在方法内部对属性进行操作，在类对象的外部调用方法。这样，无需关心方法内部的具体实现细节，从而隔离了复杂度</li><li>在Python中没有专门修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个“_”</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.__age)</span><br><span class="line">stu1 = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">24</span>)</span><br><span class="line">stu1.show()</span><br><span class="line"><span class="built_in">print</span>(stu1.name)</span><br><span class="line"><span class="built_in">print</span>(stu1.__age)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">张三 24</span><br><span class="line">张三</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Software\PycharmProjects\demo1\demo2.py&quot;, line 143, in &lt;module&gt;</span><br><span class="line">    print(stu1.__age)</span><br><span class="line">AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__age&#x27;</span><br></pre></td></tr></table></figure><h3 id="2-继承">2.继承</h3><ul><li><strong>继承：</strong> 提高代码的复用性<ul><li>如果一个类没有继承任何类，则默认继承object</li><li>Python支持多继承</li><li>定义子类时，必须在其构造函数中调用父类的构造函数</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"><span class="comment">#定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,score</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.score=score</span><br><span class="line">stu = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;1000&#x27;</span>)</span><br><span class="line">stu.info()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">张三 21</span><br></pre></td></tr></table></figure><h4 id="（1）方法重写">（1）方法重写</h4><ul><li><strong>方法重写</strong><ul><li>如果子类对继承自父类的某个属性或方法不满意，可以在子类中对其（方法体）进行重新编写</li><li>子类重写后的方法中可以通过super().xxx()调用父类中被重写的方法</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.age)</span><br><span class="line"><span class="comment">#定义子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,score</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name,age)</span><br><span class="line">        self.score=score</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().info()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;学号：&#x27;</span>,self.score)</span><br><span class="line">stu = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;1000&#x27;</span>)</span><br><span class="line">stu.info()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">张三 21</span><br><span class="line">学号： 1000</span><br></pre></td></tr></table></figure><h4 id="（2）object类">（2）object类</h4><ul><li><strong>object类</strong><ul><li>object类是所有类的父类，因此所有类都有object类的属性和方法。</li><li>内置函数dir()可以查看指定对象所有属性</li><li>Object有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数str()经常用于print()方法，帮我们查看对象的信息，所以我们经常会对__str__()进行重写</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我的名字是&#123;0&#125;,今年&#123;1&#125;岁&#x27;</span>.<span class="built_in">format</span>(self.name,self.age)</span><br><span class="line">stu = Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(stu)      <span class="comment">#默认调用__str__()这样的方法</span></span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的名字是张三,今年21岁</span><br></pre></td></tr></table></figure><h3 id="3-多态">3.多态</h3><ul><li><strong>多态：</strong> 提高程序的可扩展性和可维护性<ul><li>多态就是“具有多种形态”，即便不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用方法，在运行过程中根据变量所引用对象的类型，动态决定调用哪个对象中的方法</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;动物要吃东西&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;狗吃肉&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猫吃鱼&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;人吃五谷杂粮&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.eat()</span><br><span class="line">fun(Dog())</span><br><span class="line">fun(Cat())</span><br><span class="line">fun(Person())</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">狗吃肉</span><br><span class="line">猫吃鱼</span><br><span class="line">人吃五谷杂粮</span><br></pre></td></tr></table></figure><h4 id="静态语言和动态语言关于多态的区别">静态语言和动态语言关于多态的区别</h4><ul><li>静态语言实现多态的三个必要条件<ul><li>继承</li><li>方法重写</li><li>父类引用指向子类对象</li></ul></li><li>动态语言的多态崇尚“鸭子类型”，当看到一只鸟走起来像鸭子、游泳起来像鸭子、收起来也像鸭子，那么这只鸟就可以被称为鸭子。在鸭子类型中，不需要关心对象是什么类型，到底是不是鸭子，只关心对象的行为。</li></ul><h2 id="特殊方法和特殊属性">特殊方法和特殊属性</h2><table><tr><th></th><th>名称</th><th>描述</th></tr><tr align="center"><td bgcolor="white">特殊属性</td><td bgcolor="white">__dict__</td><td bgcolor="white">获得类对象或实例对象所绑定的所有属性和方法的字典</td></tr><tr align="center"><td rowspan="4">特殊方法</td><td>__len__()</td><td>通过重写__len__()方法，让内置函数len()的参数可以是自定义类型</td></tr><tr align="center"><td bgcolor="white">__add__()</td><td bgcolor="white">通过重写__add__()方法，可使用自定义对象具有“+”功能</td></tr><tr align="center"><td>__new__()</td><td>用于创建对象</td></tr><tr align="center"><td bgcolor="white">__init__()</td><td bgcolor="white">对创建的对象进行初始化</td></tr></table><h2 id="类的浅拷贝和深拷贝">类的浅拷贝和深拷贝</h2><ul><li><strong>变量的赋值操作</strong><ul><li>只是形成两个变量，实际上还是指向同一个对象</li></ul></li><li><strong>浅拷贝</strong><ul><li>Python拷贝一般都是浅拷贝，拷贝时，对象包含的子对象内容不拷贝，因此，源对象与拷贝对象会引用同一个子对象</li></ul></li><li><strong>深拷贝</strong><ul><li>使用copy模块的deepcopy函数，递归拷贝对象中包含的子对象，源对象和拷贝对象所有的子对象也不相同</li></ul></li></ul><h1 id="十四、模块、包">十四、模块、包</h1><h2 id="模块的定义">模块的定义</h2><ul><li><strong>模块英文为Modules</strong></li><li><strong>模块与函数的关系</strong><ul><li>一个模块中可以包含N多个函数</li></ul></li><li><strong>在Python中一个扩展名为.py的文件就是一个模块</strong></li><li><strong>使用模块的好处</strong><ul><li>方便其他程序和脚本的导入并使用</li><li>避免函数名和变量名冲突</li><li>提高代码的可维护性</li><li>提高代码的可重用性</li></ul></li></ul><h3 id="1-导入模块">1.导入模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名称 [<span class="keyword">as</span> 别名]</span><br><span class="line"><span class="keyword">from</span> 模块名称 <span class="keyword">import</span> 函数/变量/类</span><br></pre></td></tr></table></figure><h3 id="2-以主程序方式运行">2.以主程序方式运行</h3><ul><li>在每个模块的定义中都包括一个记录模块名称的变量__name__，程序可以检查该变量，以确定他们在哪个模块中执行。如果一个模块不是被导入到其他程序中执行，那么它可能在解释器的顶级模块中执行。顶级模块的__name__变量的值为__main__</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ = <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="包的定义">包的定义</h2><ul><li><strong>包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下</strong></li><li><strong>作用：</strong><ul><li>代码规避</li><li>避免模块名称冲突</li></ul></li><li><strong>包与目录的区别</strong><ul><li>包含__init__.py文件的目录称为包</li><li>目录里通常不包含__init__.py文件</li></ul></li><li><strong>包的导入</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br></pre></td></tr></table></figure><h2 id="常用的内置模块">常用的内置模块</h2><table><tr><th>模块名</th><th>描述</th></tr><tr align="center"><td>sys</td><td align="left">与Pthon解释器及其环境操作相关的标准库</td></tr><tr align="center"><td>time</td><td align="left">提供与时间相关的各种函数的标准库</td></tr><tr align="center"><td>os</td><td align="left">提供了访问操作系统服务功能的标准库</td></tr><tr align="center"><td>calendar</td><td align="left">提供与日期相关的各种函数的标准库</td></tr><tr align="center"><td>urllib</td><td align="left">用于读取来自网上（服务器）的数据标准库</td></tr><tr align="center"><td>json</td><td align="left">用于使用JSON序列化和反序列化对象</td></tr><tr align="center"><td>re</td><td align="left">用于在字符串中执行正则表达式匹配和替换</td></tr><tr align="center"><td>math</td><td align="left">提供标准算术运算函数的标准库</td></tr><tr align="center"><td>decimal</td><td align="left">用于进行精确控制运算精度、有效数位和四舍五入操作的十进制运算</td></tr><tr align="center"><td>logging</td><td align="left">提供了灵活的记录事件、错误、警告和调试信息等目录信息的功能</td></tr></table><h1 id="十五、文件的操作">十五、文件的操作</h1><h2 id="编码格式">编码格式</h2><ul><li><strong>常见的编码格式</strong><ul><li>Python的解释器使用的是Unicode（内存）</li><li>.py文件在磁盘上使用UTF-8存储（外存）</li></ul></li></ul><h2 id="文件的读写">文件的读写</h2><ul><li><strong>文件的读写俗称“IO操作”</strong></li><li><strong>内置函数open()创建文件对象</strong></li><li><strong>语法规则</strong><ul><li>file：被创建的文件对象</li><li>open()：创建文件对象的函数</li><li>filename：要创建或打开的文件名称</li><li>mode：打开模式默认为只读</li><li>encoding：默认文本文件中字符的编写格式为gbk</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(filename [,mode,encoding])</span><br></pre></td></tr></table></figure><p><strong>打开文件：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开文件   w模式（写模式，文件不存在会新建）</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.write(<span class="string">&quot;hello python&quot;</span>)</span><br><span class="line"></span><br><span class="line">f.close()   <span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure><p><strong>读文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读文件    read方法读取指定的字符，开始时定位在文件头部，每执行一次向后移动指定字符数</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">5</span>))    <span class="comment">#hello</span></span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">5</span>))    <span class="comment"># pyth</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p><strong>一次性读取全部文件内容为列表并遍历：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">content = f.readlines()     <span class="comment">#一次性读取全部文件为列表，每行一个字符串元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(content)    <span class="comment">#[&#x27;hello python\n&#x27;, &#x27;hello python\n&#x27;, &#x27;hello python&#x27;]</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> content:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%d:%s&quot;</span>%(i,temp))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;hello python--1\n&#x27;, &#x27;hello python--2\n&#x27;, &#x27;hello python--3&#x27;]</span><br><span class="line">1:hello python--1</span><br><span class="line"></span><br><span class="line">2:hello python--2</span><br><span class="line"></span><br><span class="line">3:hello python--3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-常用的文件打开模式">1.常用的文件打开模式</h3><table><tr><th>打开模式</th><th>描述</th></tr><tr align="center"><td>r</td><td align="left">以只读模式打开文件，文件的指针将会放在文件开头</td></tr><tr align="center"><td>w</td><td align="left">以只写模式打开文件，如果文件不存在则创建，如果文件存在，则覆盖原有内容，文件指针在文件的开头</td></tr><tr align="center"><td>a</td><td align="left">以追加模式打开文件，如果文件不存在则创建，文件指针在文件开头，如果文件存在，则在文件末尾追加内容，文件指针在原文件末尾</td></tr><tr align="center"><td>b</td><td align="left">以二进制方式打开文件，不能单独使用，需要与其它模式一起使用，如rb或wb</td></tr><tr align="center"><td>+</td><td align="left">以读写模式打开文件，不能单独使用，需要与其他模式一起使用，如a+</td></tr></table><h3 id="2-文件对象的常用方法">2.文件对象的常用方法</h3><table><tr><th>方法名</th><th>说明</th></tr><tr align="center"><td>read([size])</td><td align="left">从文件中读取size个字节或字符的内容返回。若省略[size]，则读取到文件末尾，即一次读取文件所有内容</td></tr><tr align="center"><td>redline()</td><td align="left">从文本中读取一行内容</td></tr><tr align="center"><td>readlines()</td><td align="left">把文本文件中每一行都作为独立的字符串对象，并将这些对象放入列表返回</td></tr><tr align="center"><td>write(str)</td><td align="left">将字符串str内容写入文件</td></tr><tr align="center"><td>writelines(s_list)</td><td align="left">将字符串列表s_list写入文本文件，不添加换行符</td></tr><tr align="center"><td>seek(offset[,whence])</td><td align="left">把文件指针移动到新的位置，offset表示相对于whence的位置：<br>offset：为正往结束方向移动，为负往开始方向移动<br>whence不同的值代表不同含义：<br>0：从文件头开始计算（默认值）<br>1：从当前位置开始计算<br>2：从文件末尾开始计算</td></tr><tr align="center"><td>tell()</td><td align="left">返回文件指针的当前位置</td></tr><tr align="center"><td>flush()</td><td align="left">把缓冲区的内容写入文件，但不关闭文件</td></tr><tr align="center"><td>close()</td><td align="left">把缓冲区的内容写入文件，同时关闭文件，释放文件对象相关资源</td></tr></table><h3 id="3-案例">3.案例</h3><p><strong>间隔两秒打印文件一行内容：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            content = f.readline()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(content) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件关闭&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello python--1</span><br><span class="line"></span><br><span class="line">hello python--2</span><br><span class="line"></span><br><span class="line">hello python--3</span><br><span class="line">文件关闭</span><br></pre></td></tr></table></figure><p><strong>案例：复制文件内容到另一文件并捕获可能出现的异常</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    inputfile = <span class="built_in">open</span>(<span class="string">&quot;test1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    outputfile = <span class="built_in">open</span>(<span class="string">&quot;copy.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            content = inputfile.readline()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(content) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            outputfile.write(content)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;复制完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;写入文件失败&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        outputfile.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读取文件失败&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    inputfile.close()</span><br></pre></td></tr></table></figure><h2 id="with语句（上下文管理器）">with语句（上下文管理器）</h2><ul><li><strong>with语句可以自动管理上下文资源，不论什么原因挑出with块，都能确保文件正常的关闭，以此来达到释放资源的目的</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test1.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        content = file.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(content) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello python--1</span><br><span class="line"></span><br><span class="line">hello python--2</span><br><span class="line"></span><br><span class="line">hello python--3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="目录的操作">目录的操作</h2><ul><li><strong>os模块是Python内置的与操作系统功能和文件系统相关的模块，该模块中的语句的执行结果通常与操作系统有关，在不同的操作系统上运行，得到的结果可能不一样</strong></li><li><strong>os模块与os.path模块用于对目录或文件进行操作</strong></li></ul><p><strong>可以直接调用可执行文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#打开QQ</span></span><br><span class="line">os.startfile(<span class="string">&#x27;C:\Software\Tencent\QQ\Bin\QQScLauncher.exe&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-os模块操作目录相关函数">1.os模块操作目录相关函数</h3><table><tr><th>函数</th><th>说明</th></tr><tr align="center"><td align="left">getcwd()</td><td align="left">返回当前的工作目录</td></tr><tr align="center"><td align="left">listdir(path)</td><td align="left">返回指定路径下的文件和目录信息</td></tr><tr align="center"><td align="left">mkdir(path[,mode])</td><td align="left">创建目录</td></tr><tr align="center"><td align="left">makedirs(path1/path2...[,mode])</td><td align="left">创建多级目录</td></tr><tr align="center"><td align="left">rmdir(path)</td><td align="left">删除目录</td></tr><tr align="center"><td align="left">removedirs(path1/path2......)</td><td align="left">删除多级目录</td></tr><tr align="center"><td align="left">chdir(path)</td><td align="left">将path设置为当前工作目录</td></tr></table><h3 id="2-os-path模块操作目录相关函数">2.os.path模块操作目录相关函数</h3><table><tr><th>函数</th><th>说明</th></tr><tr><td align="left">abspath(path)</td><td align="left">用于获取文件或目录的绝对路径</td></tr><tr><td align="left">exists(path)</td><td align="left">用于判断文件或目录是否存在，如果存在返回True，否则返回False</td></tr><tr><td align="left">join(path,name)</td><td align="left">将目录与目录或者文件名拼接起来</td></tr><tr><td align="left">splitext()</td><td align="left">分离文件名和扩展名</td></tr><tr><td align="left">basename(path)</td><td align="left">从一个目录中提取文件名</td></tr><tr><td align="left">dirname(path)</td><td align="left">从一个路径中提取文件路径，不包括文件名</td></tr><tr><td align="left">isdir(path)</td><td align="left">用于判断是否为路径</td></tr></table><br>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 磁盘 mount 普通挂载及 lvm 挂载、lvm 磁盘扩容</title>
      <link href="/2021/03/16/linux_1/"/>
      <url>/2021/03/16/linux_1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-mount普通挂载">1. mount普通挂载</h1><p><strong>fdisk -l查看当前硬盘信息</strong><br><img src="https://img-blog.csdnimg.cn/20210316103131901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>fdisk /dev/sdb为硬盘创建分区，依次输入n，p，1，w，其中n分别表示创建一个新分区，p表示分区类型为主分区，1表示分区编号是1，w表示保存</strong><br><img src="https://img-blog.csdnimg.cn/20210316104230199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>mkfs.ext4 /dev/sdb1格式化分区，1为上一步的分区编号</strong><br><img src="https://img-blog.csdnimg.cn/2021031610474375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>mount /dev/sdb1 /data，将分区挂载到/data目录下，通过df -h可以看到挂载成功</strong><br><img src="https://img-blog.csdnimg.cn/20210316104920917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>目前挂载只是临时的，系统重启后需要重新挂载，如果希望下次启动时能自动挂载，输入vim /etc/fstab，增加下面的配置，/dev/sdb1是分区，/data是挂载此分区的目录，ext4是磁盘格式</strong><br><img src="https://img-blog.csdnimg.cn/20210316105414418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-lvm磁盘挂载">2. lvm磁盘挂载</h1><p><strong>fdisk -l查看当前硬盘信息</strong><br><img src="https://img-blog.csdnimg.cn/20210316134022383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>fdisk /dev/sdb为硬盘创建分区，依次输入n，p，1，t，8e，w，其中n分别表示创建一个新分区，p表示分区类型为主分区，1表示分区编号是1，t表示修改id标记，8e表示改为lvm，w表示保存</strong><br><img src="https://img-blog.csdnimg.cn/20210316134522282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>yum install lvm2安装lvm所需命令</strong><br><strong>pvcreate /dev/sdb1创建物理卷（PV），pvdisplay查看所有物理卷</strong><br><img src="https://img-blog.csdnimg.cn/2021031613511437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>vgcreate myvg1 /dev/sdb1创建卷组（VG），vgdisplay查看所有卷组</strong><br><img src="https://img-blog.csdnimg.cn/20210316135335597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>lvcreate -l +100%VG -n mylv1 myvg1创建逻辑卷（LV），将vg所有空间分配给lv，也可用lvcreate -L 2G -n mylv1 myvg1分配指定大小空间，lvdisplay查看所有逻辑卷</strong><br><img src="https://img-blog.csdnimg.cn/20210316135843568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>mkfs.xfs /dev/myvg1/mylv1格式化逻辑分区</strong><br><img src="https://img-blog.csdnimg.cn/20210316135950788.png" alt="在这里插入图片描述"><br><strong>mount /dev/myvg1/mylv1 /data挂载到/data目录下，通过df -h查看挂载成功</strong><br><img src="https://img-blog.csdnimg.cn/20210316140210353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>vim /etc/fstab添加/dev/myvg1/mylv1 /data xfs defaults 0 0实现自动挂载</strong><br><img src="https://img-blog.csdnimg.cn/20210316140448472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="3-lvm磁盘扩容">3. lvm磁盘扩容</h1><p><strong>fdisk -l查看新添加的磁盘</strong><br><img src="https://img-blog.csdnimg.cn/2021031614092251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>fdisk /dev/sdc为硬盘创建分区，依次输入n，p，1，t，8e，w，其中n分别表示创建一个新分区，p表示分区类型为主分区，1表示分区编号是1，t表示修改id标记，8e表示改为lvm，w表示保存</strong><br><img src="https://img-blog.csdnimg.cn/20210316141041484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>pvcreate /dev/sdc1创建物理卷（PV），pvdisplay查看所有物理卷</strong><br><img src="https://img-blog.csdnimg.cn/20210316141212838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>vgextend myvg1 /dev/sdc1将/dev/sdc1加入到myvg1，vgdisplay查看所有卷组</strong><br><img src="https://img-blog.csdnimg.cn/20210316141504685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>lvextend -l +100%FREE /dev/myvg1/mylv1将卷组剩余所有空间都给mylv1使用（也可以使用lvextend -L +1G -n /dev/myvg1/mylv1分配指定大小空间），xfs_growfs /dev/myvg1/mylv1使扩容生效，df -h查看成功扩容</strong><br><img src="https://img-blog.csdnimg.cn/20210316142416781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之将 mysql 数据转发给第三方 udp 网络端口</title>
      <link href="/2021/03/12/python_2/"/>
      <url>/2021/03/12/python_2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><font color=#999AAA ><strong>最近客户要把所有安全厂商的系统日志统一收录监管，我们的系统日志存放在mysql中，所以得写个脚本取数据发送到他们的网络端口</strong></font></p><h1 id="代码实现">代码实现</h1><p><strong>大体思路为取前五分钟的数据发送到第三方udp端口，每五分钟发送一次，代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql,socket,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立数据库的连接信息</span></span><br><span class="line">host = <span class="string">&quot;10.7.2.20&quot;</span>  <span class="comment"># 数据库的ip地址</span></span><br><span class="line">user = <span class="string">&quot;root&quot;</span>  <span class="comment"># 数据库的账号</span></span><br><span class="line">password = <span class="string">&quot;123456&quot;</span>  <span class="comment"># 数据库的密码</span></span><br><span class="line">port = <span class="number">3306</span>  <span class="comment"># mysql数据库通用端口号</span></span><br><span class="line">OUTPUTIP = <span class="string">&quot;192.168.44.111&quot;</span> <span class="comment">#目的ip</span></span><br><span class="line">OUTPUTPORT = <span class="number">6666</span>    <span class="comment">#目的端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    mysql = pymysql.connect(host=host, user=user, password=password, port=port)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#新建查询页面</span></span><br><span class="line">    cursor = mysql.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#sql</span></span><br><span class="line">    sql =  <span class="string">&#x27;select * from rs_datainsight.rs_admin_log where from_unixtime(createtime,\&#x27;%Y-%m-%d %H:%i:%s\&#x27;) between date_format(date_add(now(), interval - 5 minute),\&#x27;%Y-%m-%d %H:%i:%s\&#x27;) and date_format(now(),\&#x27;%Y-%m-%d %H:%i:%s\&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#执行sql</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#返回结果</span></span><br><span class="line">    <span class="comment"># result = cursor.fetchone() #返回单条数据</span></span><br><span class="line">    results = cursor.fetchall() <span class="comment">#返回多条数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="comment">#print(result)</span></span><br><span class="line">        <span class="comment">#发送到第三方端口</span></span><br><span class="line">        s.sendto(<span class="built_in">str</span>(result).encode(<span class="string">&quot;utf-8&quot;</span>),(OUTPUTIP,OUTPUTPORT))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#关闭查询</span></span><br><span class="line">    cursor.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#关闭数据库</span></span><br><span class="line">    mysql.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        main()</span><br><span class="line">        time.sleep(<span class="number">300</span>)     <span class="comment">#睡眠五分钟</span></span><br><span class="line">    s.close()</span><br></pre></td></tr></table></figure><p><strong>代码比较简单，就不多做叙述了，同时将脚本加入到任务执行计划里</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * /data/python3/bin/python3 /data/mysql2udp.py</span><br></pre></td></tr></table></figure><p><strong>每五分钟执行一次，保证脚本因为外界因素挂掉之后能够重启</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UDP </tag>
            
            <tag> Python </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 脚本之将 logstash 数据按天保存在本地服务器并加密压缩</title>
      <link href="/2021/03/12/python_1/"/>
      <url>/2021/03/12/python_1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>  最近客户方提出了要将日志另外备份一份并进行加密压缩，今天用这篇文章来总结一下。原本的架构是logstash通过udp端口将数据发送到我们的系统，现在客户想在中间将数据取出来做一份备份，并把每天的数据加密压缩。<br>功能分两个脚本来实现，话不多说，直接进入正题。</p><h1 id="脚本一：接收数据并按天保存在本地">脚本一：接收数据并按天保存在本地</h1><p>  先把数据取出来，在logstash中添加output插件，发送到本地888端口，数据为json格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">udp &#123;</span><br><span class="line">            host =&gt; &quot;10.7.2.20&quot;</span><br><span class="line">            port =&gt; &quot;888&quot;</span><br><span class="line">            codec =&gt; json</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>  可以在本地用nc监听888端口查看网络是否阻塞，这里就不做演示了。<br>  之后先编写接收udp端口数据的代码，一步一步来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br></pre></td></tr></table></figure><p>  收到数据后，发现来一条数据后就断开连接，就在前面加一个循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br></pre></td></tr></table></figure><p>  这样就能一直收到发送方的数据了，然后把数据存在本地文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,os</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line"><span class="comment">#print(data.decode(&quot;utf-8&quot;))</span></span><br><span class="line"><span class="comment">#/data/test.txt为存放日志的文件路径，a+表示追加内容</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/data/test.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"><span class="comment">#收到的数据没有换行，在每一条数据后面添加换行符</span></span><br><span class="line">        f.write(data.decode(<span class="string">&quot;utf-8&quot;</span>)+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.close()</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br></pre></td></tr></table></figure><p>  测试之后，完美运行，下面就是完善代码了，前面说过日志要按天来存储，并且日志还分为不同的类型，所以存放路径就分为每种类型日志下面有各自每天的日志备份，日志样例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@timestamp&quot;:&quot;2021-03-11T09:24:03.668Z&quot;,&quot;hostipv6&quot;:&quot;fe80::c360:92ba:aede:5c36&quot;,&quot;hostipv4&quot;:&quot;192.168.44.111&quot;,&quot;ecs&quot;:&#123;&quot;version&quot;:&quot;1.0.0&quot;&#125;,&quot;@version&quot;:&quot;1&quot;,&quot;message&quot;:&quot;Mar 11 17:24:01 localhost CROND[104204]: (root) CMD (/usr/local/bin/php /data/rdiweb/public/di_admin.php Autotask &gt;&gt; /tmp/111.log 2&gt;&amp;1 &amp;)&quot;,&quot;host&quot;:&#123;&quot;name&quot;:&quot;localhost.localdomain&quot;,&quot;containerized&quot;:false,&quot;os&quot;:&#123;&quot;kernel&quot;:&quot;3.10.0-693.el7.x86_64&quot;,&quot;family&quot;:&quot;redhat&quot;,&quot;name&quot;:&quot;CentOS Linux&quot;,&quot;codename&quot;:&quot;Core&quot;,&quot;version&quot;:&quot;7 (Core)&quot;,&quot;platform&quot;:&quot;centos&quot;&#125;,&quot;ip&quot;:[&quot;192.168.44.111&quot;,&quot;fe80::c360:92ba:aede:5c36&quot;],&quot;id&quot;:&quot;251f075008fe4214825ef8910e29bf29&quot;,&quot;mac&quot;:[&quot;00:0c:29:64:b2:af&quot;],&quot;hostname&quot;:&quot;localhost.localdomain&quot;,&quot;architecture&quot;:&quot;x86_64&quot;&#125;,&quot;input&quot;:&#123;&quot;type&quot;:&quot;log&quot;&#125;,&quot;agent&quot;:&#123;&quot;ephemeral_id&quot;:&quot;25d88d8c-994c-49c9-afa3-78867740c45a&quot;,&quot;version&quot;:&quot;7.2.0&quot;,&quot;type&quot;:&quot;filebeat&quot;,&quot;hostname&quot;:&quot;localhost.localdomain&quot;,&quot;id&quot;:&quot;7936b07b-99db-458a-b7ed-3df7e348ef96&quot;&#125;,&quot;log&quot;:&#123;&quot;file&quot;:&#123;&quot;path&quot;:&quot;/var/log/cron&quot;&#125;,&quot;offset&quot;:111834&#125;,&quot;appname&quot;:&quot;cron&quot;,&quot;tags&quot;:[&quot;cron&quot;,&quot;beats_input_codec_plain_applied&quot;]&#125;</span><br></pre></td></tr></table></figure><p>  可以看到从logstash收到的json日志是由tags字段来分日志类型的，比如bashhistory、cron、secure等等日志，而message为原始日志，所以我们只需要取得tags字段来分类型，并把message存在文件里即可，这里我是用正则来提取的值，因为数据的格式不规则，用json解析可能会报错，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,os,re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">path</span>):</span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取原始日志</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getmessage</span>(<span class="params">data</span>):</span><br><span class="line">        rule = <span class="string">&quot;\&quot;message\&quot;:\&quot;(.*?)\&quot;,\&quot;&quot;</span></span><br><span class="line">        message = re.findall(rule, data)</span><br><span class="line">        <span class="keyword">return</span> message[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取日志类型</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gettype</span>(<span class="params">data</span>):</span><br><span class="line">        rule = <span class="string">&quot;\&quot;tags\&quot;:\[\&quot;(.*?)\&quot;,&quot;</span></span><br><span class="line">        message = re.findall(rule, data)</span><br><span class="line">        <span class="keyword">return</span> message[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line"><span class="comment">#print(data.decode(&quot;utf-8&quot;))</span></span><br><span class="line"><span class="comment">#获取当前日期</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        time = time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="comment">#提取日志类型</span></span><br><span class="line">        <span class="built_in">type</span> = gettype(data)</span><br><span class="line">        <span class="comment">#提取日志</span></span><br><span class="line">        message = getmessage(data)</span><br><span class="line"><span class="comment">#path为存放日志的文件路径，type为日志类型，time为当天日期，a+表示追加内容</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;%s/%s/%s.txt&quot;</span>%(path,<span class="built_in">type</span>,time),<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"><span class="comment">#收到的数据没有换行，在每一条数据后面添加换行符</span></span><br><span class="line">        f.write(data.decode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.close()</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 日志存放目录</span></span><br><span class="line">    path = <span class="string">&quot;/data/data&quot;</span></span><br><span class="line">    main(path)</span><br></pre></td></tr></table></figure><p>  运行效果如图：<br><img src="https://img-blog.csdnimg.cn/2021031215392113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>  可以看到日志按照类型放在不同文件夹下，并按日期分为不同的文件，代码到这里就差不多了，但是还差一些需要完善的地方，比如来的是空数据，列表会下标越界，包括后续如果客户方要接入新的日志，找不到对应的路径也会报错，总不能每次都能手动创建日志类型的文件夹吧，话不多说，完整的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,os,re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">path</span>):</span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment">#绑定本地信息</span></span><br><span class="line">    localaddr = (<span class="string">&quot;192.168.44.112&quot;</span>,<span class="number">8888</span>)</span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取原始日志</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getmessage</span>(<span class="params">data</span>):</span><br><span class="line">        rule = <span class="string">&quot;\&quot;message\&quot;:\&quot;(.*?)\&quot;,\&quot;&quot;</span></span><br><span class="line">        message = re.findall(rule, data)</span><br><span class="line">        <span class="keyword">return</span> message[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取日志类型</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gettype</span>(<span class="params">data</span>):</span><br><span class="line">        rule = <span class="string">&quot;\&quot;tags\&quot;:\[\&quot;(.*?)\&quot;,&quot;</span></span><br><span class="line">        message = re.findall(rule, data)</span><br><span class="line">        <span class="keyword">return</span> message[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment">#data为接收到的数据，client是发送方的ip，port</span></span><br><span class="line">    data,client = udp_socket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    <span class="comment"># 判断数据是否为空，为空跳过当前循环，防止下标越界</span></span><br><span class="line">        <span class="keyword">if</span> data.isspace():</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"><span class="comment">#打印到控制台，查看是否有数据过来</span></span><br><span class="line"><span class="comment">#print(data.decode(&quot;utf-8&quot;))</span></span><br><span class="line"><span class="comment">#获取当前日期</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        time = time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="comment">#提取日志类型</span></span><br><span class="line">        <span class="built_in">type</span> = gettype(data)</span><br><span class="line">        <span class="comment">#提取日志</span></span><br><span class="line">        message = getmessage(data)</span><br><span class="line">        <span class="comment"># 判断子目录是否存在，如果不存在即创建</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(<span class="string">&quot;%s/%s&quot;</span>%(path,<span class="built_in">type</span>)) == <span class="literal">False</span>:</span><br><span class="line">            os.makedirs(<span class="string">&quot;%s/%s&quot;</span>%(path,<span class="built_in">type</span>))</span><br><span class="line"><span class="comment">#path为存放日志的文件路径，type为日志类型，time为当天日期，a+表示追加内容</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;%s/%s/%s.txt&quot;</span>%(path,<span class="built_in">type</span>,time),<span class="string">&quot;a+&quot;</span>)</span><br><span class="line"><span class="comment">#收到的数据没有换行，在每一条数据后面添加换行符</span></span><br><span class="line">        f.write(data.decode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.close()</span><br><span class="line"><span class="comment">#退出套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 日志存放目录</span></span><br><span class="line">    path = <span class="string">&quot;/data/data&quot;</span></span><br><span class="line">    main(path)</span><br></pre></td></tr></table></figure><h1 id="脚本二：将本地文件进行加密压缩">脚本二：将本地文件进行加密压缩</h1><p>  上一个脚本已经完美的把日志备份在了本地服务器，那么接下来就是将日志进行加密压缩，这个脚本相对上一个来说还是很简单的。<br>  用python压缩文件还是很简单的，比较费事的是如何加密压缩，因为pyhon自带的zipfile库不支持加密，所以这里只能使用linux压缩文件的命令行来进行处理了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zipDir</span>(<span class="params">path,outpath,password</span>):</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="comment"># 一定要有返回值，否则压缩失败；</span></span><br><span class="line">    status = os.popen(<span class="string">&quot;zip -jP %s %s %s&quot;</span>%(password,outpath,path))</span><br><span class="line">    <span class="comment"># 等待子进程完成</span></span><br><span class="line">    os.wait()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 日志存放路径</span></span><br><span class="line">    path = <span class="string">&quot;/data/secure&quot;</span></span><br><span class="line">    <span class="comment"># 压缩密码</span></span><br><span class="line">    password = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    <span class="comment"># 获取昨天日期</span></span><br><span class="line">    yesterday = (date.today() + timedelta(days=-<span class="number">1</span>)).strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">    zipDir(<span class="string">&quot;%s/%s.txt&quot;</span> %(path[<span class="number">0</span>],yesterday), <span class="string">&quot;%s/%s.zip&quot;</span> %(path,yesterday), password)</span><br></pre></td></tr></table></figure><p>  到这里文件就完美加密压缩了，可是现在的代码只能压缩一种日志类型下的文件，不能将所有日志类型全部压缩，并且压缩后的日志文件没有删除，浪费了服务器的磁盘空间，于是又花费了一些时间将代码完善，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zipDir</span>(<span class="params">path,outpath,password</span>):</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="comment"># 一定要有返回值，否则压缩失败；</span></span><br><span class="line">    status = os.popen(<span class="string">&quot;zip -jP %s %s %s&quot;</span>%(password,outpath,path))</span><br><span class="line">    <span class="comment"># 等待子进程完成</span></span><br><span class="line">    os.wait()</span><br><span class="line">    <span class="comment"># 删除压缩后的文件</span></span><br><span class="line">    os.remove(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 日志存放路径</span></span><br><span class="line">    paths = <span class="string">&quot;/data/data&quot;</span></span><br><span class="line">    <span class="comment"># 压缩密码</span></span><br><span class="line">    password = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    num = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 循环不同类型日志目录</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> os.walk(paths):</span><br><span class="line">        <span class="comment"># 跳过主目录</span></span><br><span class="line">        <span class="keyword">if</span> num:</span><br><span class="line">            num = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 获取昨天日期</span></span><br><span class="line">        yesterday = (date.today() + timedelta(days=-<span class="number">1</span>)).strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">        zipDir(<span class="string">&quot;%s/%s.txt&quot;</span> %(path[<span class="number">0</span>],yesterday), <span class="string">&quot;%s/%s.zip&quot;</span> %(path[<span class="number">0</span>],yesterday), password)</span><br></pre></td></tr></table></figure><p>  可以看到上面的代码遍历了目录，并且删除了压缩后的日志文件，和上一个脚本一样，哪怕后续加入了新的日志类型，脚本也不需要再改动了，运行效果如下：<br><img src="https://img-blog.csdnimg.cn/20210312160228444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc1ODg3Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>  之后把脚本加入到linux任务执行计划里，每天晚上2点压缩前一天的文件即可。<br>  root用户下执行ctontab -e命令，将下面执行脚本的命令添加在文件末尾即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 2 * * * /data/python3/bin/python3 /data/file2zip.py</span><br></pre></td></tr></table></figure><p>  /data/python3/bin/python3是python安装的路径，注意这里一定要写绝对路径，否则可能会执行失败，/data/file2zip.py是脚本的路径和文件名，00 2 * * *是指每天2:00运行脚本<br>  同样上一个脚本也要加入到任务执行计划中，这样服务器挂掉或者重启之后脚本也能重启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * /data/python3/bin/python3 /data/logstash2file.py</span><br></pre></td></tr></table></figure><p>  这里每五分钟执行一次即可。</p><h1 id="总结">总结</h1><p>  这个需求相对来说没到很难的程度，只是要全面考虑到怎么应对不同的生产环境。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Logstash </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
